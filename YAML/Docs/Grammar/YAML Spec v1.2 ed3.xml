YAML Ain't Markup Language Version 1.2
3rd Edition, Patched at 2009-10-01


Chapter 2. Preview

This section provides a quick glimpse into the expressive power of YAML.
It is not expected that the first-time reader grok all of the examples.
Rather, these selections are used as motivation for the remainder of the
specification.

2.1. Collections

YAML's block collections use indentation for scope and begin each entry on its own line.
Block sequences indicate each entry with a dash and space (- ).
Mappings use a colon andspace (: ) to mark each key: value pair.
Comments begin with an octothorpe (alsocalled a hash, sharp, pound, or number sign - #).

YAML also has flow styles, using explicit indicators rather than indentation to denote
scope. The flow sequence is written as a comma separated list within square brackets.
In a similar manner, the flow mapping uses curly braces.

2.2. Structures

YAML uses three dashes (---) to separate directives from document content. This
also serves to signal the start of a document if no directives are present.
Three dots (...) indicate the end of a document without starting a new one, for
use in communication channels.

Repeated nodes (objects) are first identified by an anchor (marked with
the ampersand - &amp;), and are then aliased (referenced with an asterisk - *)
thereafter.

A question mark and space (? ) indicate a complex mapping key. Within a block
collection, key: value pairs can start immediately following the dash, colon, or
question mark.

2.3. Scalars

Scalar content can be written in block notation, using a literal style
(indicated by |) where all line breaks are significant. Alternatively, they can
be written with the folded style (denoted by &gt;) where each line break is
folded to a space unless it ends an empty or amore-indented line.

In the folded scalars, newlines become spaces

Folded newlines are preserved for "more indented" and blank lines
Indentation determines scope

YAML's flow scalars include the plain style (most examples thus far) and two
quoted styles. The double-quoted style provides escape sequences.
The single-quoted style is useful when escaping is not needed. All flow scalars
can span multiple lines; line breaks are always folded.

2.4. Tags

In YAML, untagged nodes are given a type depending on the application.
The examples in this specification generally use the seq, map and str types
from the fail safe schema. A few examples also use the int, float, and null
types from the JSON schema. The repository includes additional types such as
binary, omap, set and others.

Explicit typing is denoted with a tag using the exclamation point (!) symbol.
Global tags are URIs and may be specified in a tag shorthand notation using a
handle. Application-specific local tags may also be used.

2.5. Full Length Example

Below are two full-length examples of YAML.

Example 2.27. Invoice

    --- !&lt;tag:clarkevans.com,2002:invoice&gt;
    invoice: 34843
    date   : 2001-01-23
    bill-to: &amp;id001
    given  : Chris
    family : Dumars
    address:
    lines: |
    458 Walkman Dr.
    Suite #292
    city    : Royal Oak
    state   : MI
    postal  : 48046
    ship-to: *id001
    product:
    - sku         : BL394D
    quantity    : 4
    description : Basketball
    price       : 450.00
    - sku         : BL4438H
    quantity    : 1
    description : Super Hoop
    price       : 2392.00
    tax  : 251.42
    total: 4443.52
    comments:
    Late afternoon is best.
    Backup contact is Nancy
    Billsmer @ 338-4338.

Example 2.28. Log File

    ---Time: 2001-11-23 15:01:42 -5
    User: ed
    Warning:
    This is an error message
    for the log file
    ---
    Time: 2001-11-23 15:02:31 -5
    User: ed
    Warning:
    A slightly different error
    message.
    ---
    Date: 2001-11-23 15:03:17 -5
    User: ed
    Fatal:
    Unknown variable "bar"
    Stack:
    - file: TopClass.py
    line: 23
    code: |
    x = MoreObject("345\n")
    - file: MoreClass.py
    line: 58
    code: |-
    foo = bar


Chapter 4. Syntax Conventions

The following chapters formally define the syntax of YAML character streams,
using parameterized BNF productions. Each BNF production is both named and
numbered for easy reference. Whenever possible, basic structures are specified
before the more complex structures using them in a bottom up fashion.
The order of alternatives inside a production is significant. Subsequent
alternatives are only considered when previous ones fails. See for example
the b-break production.
In addition, production matching is expected to be greedy. Optional (?),
zero-or-more (*) and one-or-more (+) patterns are always expected to match as
much of the input as possible. The productions are accompanied by examples,
which are given side-by-side next to equivalent YAML text in an explanatory
format. This format uses only flow collections, double-quoted scalars, and
explicit tags for each node.
A reference implementation using the productions is available as the Yaml
Reference Haskell package. This reference implementation is also available as
an interactive web application at http://dev.yaml.org/ypaste.


4.1. Production Parameters

YAML's syntax is designed for maximal human readability. This requires parsing
to depend on the surrounding text. For notational compactness, this dependency
is expressed using parameterized BNF productions.
This context sensitivity is the cause of most of the complexity of the YAML
syntax definition. It is further complicated by struggling with the human
tendency to look ahead when interpreting text. These complications are of
course the source of most of YAML's power to present data in a very human
readable way.

Productions use any of the following parameters:

Indentation: n or m

    Many productions use an explicit indentation level parameter. This is less
    elegant than Python's indent and undent conceptual tokens. However it is
    required to formally express YAML's indentation rules.

Context: c

    This parameter allows productions to tweak their behavior according to their
    surrounding. YAML supports two groups of contexts, distinguishing between block
    styles and flow styles.

    In block styles, indentation is used to delineate structure. To capture human
    perception of indentation the rules require special treatment of the -
    character, used in block sequences. Hence in some cases productions need to
    behave differently inside block sequences (block-in context) and outside them
    (block-out context).

    In flow styles, explicit indicators are used to delineate structure. These
    styles can be viewed as the natural extension of JSON to cover tagged,
    single-quoted and plain scalars. Since the latter have no delineating
    indicators, they are subject to some restrictions to avoid ambiguities. These
    restrictions depend on where they appear: as implicit keys directly inside
    a block mapping (block-key); as implicit keysinside a flow mapping (flow-
    key); as values inside a flow collection (flow-in); or as values outside
    one (flow-out).

(Block) Chomping: t

    Block scalars offer three possible mechanisms for chomping any trailing line
    breaks: strip, clip and keep. Unlike the previous parameters, this only
    controls interpretation; the line breaks are valid inall cases.


4.2. Production Naming Conventions

To make it easier to follow production combinations, production names use
a Hungarian-style naming convention. Each production is given a prefix based
on the type of characters it begins and ends with.

e-          A production matching no characters.
c-          A production starting and ending with a special character.
b-          A production matching a single line break.
nb-         A production starting and ending with a non-break character.
s-          A production starting and ending with a white space character.
ns-         A production starting and ending with a non-space character.
l-          A production matching complete line(s).
X-Y-        A production starting with an X- character and ending with a Y-
            character, where X- andY- are any of the aboveprefixes.
X+,X-Y+     A production as above, with the additional property that the
            matched content indentation level is greater than the specified n
            parameter.


Chapter 5. Characters

[1]    c-printable          ::= #x9 | #xA | #xD | [#x20-#x7E]           /*  8 bit */
                              | #x85 | [#xA0-#xD7FF] | [#xE000-#xFFFD]  /* 16 bit */
                              | [#x10000-#x10FFFF]                      /* 32 bit */

[2]    nb-json              ::=#x9 | [#x20-#x10FFFF]

[3]    c-byte-order-mark    ::=#xFEFF

[4]    c-sequence-entry     ::= -       A - (#x2D, hyphen) denotes a block sequence entry.
[5]    c-mapping-key        ::= ?       A ? (#x3F, question mark) denotes a mapping key.
[6]    c-mapping-value      ::= :       A : (#x3A, colon) denotes a mapping value.
[7]    c-collect-entry      ::= ,       A , (#x2C, comma) ends a flow collectionentry.
[8]    c-sequence-start     ::= [       A [ (#x5B, left bracket) starts a flow sequence.
[9]    c-sequence-end       ::= ]       A ] (#x5D, right bracket) ends a flow sequence.
[10]   c-mapping-start      ::= {       A { (#x7B, left brace) starts a flow mapping.
[11]   c-mapping-end        ::= }       A } (#x7D, right brace) ends a flow mapping.
[12]   c-comment            ::= #       An # (#x23, octothorpe, hash, sharp, pound, number sign) denotes a comment.
[13]   c-anchor             ::= &amp;   An &amp; (#x26, ampersand) denotes a node's anchor property.
[14]   c-alias              ::= *       An * (#x2A, asterisk) denotes an alias node.
[15]   c-tag                ::= !       The ! (#x21, exclamation) is heavily overloaded for specifying node tags. It is used to denote tag handles used in tag directives and tag properties; to denote local tags; and as the non-specifictag for non-plain scalars.
[16]   c-literal            ::= |       A | (#x7C, vertical bar) denotes a literal block scalar.
[17]   c-folded             ::= &gt;    A &gt; (#x3E, greater than) denotes a folded block scalar.
[18]   c-single-quote       ::= '       An ' (#x27, apostrophe, single quote) surrounds a single-quoted flow scalar.
[19]   c-double-quote       ::= "       A " (#x22, double quote) surrounds a double-quoted flow scalar.
[20]   c-directive          ::= %       A % (#x25, percent) denotes a directive line.
[21]   c-reserved           ::= @ | `   The @ (#x40, at) and ` (#x60, grave accent) are reserved for future use.
[22]   c-indicator          ::= `-` | `?` | `:` | `,` | `[` | `]` | `{` | `}`
                              | `#` | `&` | `*` | `!` | `|` | `>` | `'` | `"`
                              | `%` | `@` | '`'
[23]   c-flow-indicator     ::= `,` | `[` | `]` | `{` | `}`
[24]   b-line-feed          ::= #xA    /* LF */
[25]   b-carriage-return    ::= #xD    /* CR */
[26]   b-char               ::= b-line-feed | b-carriage-return
[27]   nb-char              ::= c-printable - b-char - c-byte-order-mark
[28]   b-break              ::= ( b-carriage-return b-line-feed )   /* DOS, Windows */
                              | b-carriage-return                   /* MacOS upto 9.x */
                              | b-line-feed
[29]   b-as-line-feed       ::= b-break
[30]   b-non-content        ::= b-break
[31]   s-space              ::= #x20 /* SP */
[32]   s-tab                ::= #x9  /* TAB */
[33]   s-white              ::= s-space | s-tab

[34]   ns-char              ::= nb-char - s-white

[35]   ns-dec-digit         ::= [#x30-#x39] /* 0-9 */

[36]   ns-hex-digit         ::= ns-dec-digit
                              | [#x41-#x46] /* A-F */ | [#x61-#x66] /* a-f */

[37]   ns-ascii-letter      ::= [#x41-#x5A] /* A-Z */ | [#x61-#x7A] /* a-z */

[38]   ns-word-char         ::= ns-dec-digit |  ns-ascii-letter | -

[39]   ns-uri-char          ::= % ns-hex-digit ns-hex-digit | ns-word-char | #
                              | ; | / | ? | : | @ | & | = | + | $ | ,
                              | _ | . | ! | ~ | * | ' | ( | ) | [ | ]


[40]   ns-tag-char          ::= ns-uri-char - ! - c-flow-indicator
[41]   c-escape             ::= \
[42]   ns-esc-null          ::= 0           Escaped ASCII null (#x0) character.
[43]   ns-esc-bell          ::= a           Escaped ASCII bell (#x7) character.
[44]   ns-esc-backspace     ::= b           Escaped ASCII backspace (#x8) character.
[45]   ns-esc-horizontal-tab::= t | #x9     Escaped ASCII horizontal tab (#x9) character. This is useful at the start or the end of a line to force a leading or trailing tab to become part of the content.
[46]   ns-esc-line-feed     ::= n           Escaped ASCII line feed (#xA) character.
[47]   ns-esc-vertical-tab  ::= v           Escaped ASCII vertical tab (#xB) character.
[48]   ns-esc-form-feed     ::= f           Escaped ASCII form feed (#xC) character.
[49]   ns-esc-carriage-return   ::= r       Escaped ASCII carriage return (#xD) character.
[50]   ns-esc-escape            ::= e       Escaped ASCII escape (#x1B) character.
[51]   ns-esc-space             ::= #x20    Escaped ASCII space (#x20) character. This isuseful at the start or the end of a line to force a leading ortrailing space to become part of the content.
[52]   ns-esc-double-quote      ::= "       Escaped ASCII double quote (#x22).
[53]   ns-esc-slash             ::= /       Escaped ASCII slash (#x2F),for JSONcompatibility.
[54]   ns-esc-backslash         ::= \       Escaped ASCII back slash (#x5C).
[55]   ns-esc-next-line         ::= N       Escaped Unicode next line (#x85) character.
[56]   ns-esc-non-breaking-space::= _       Escaped Unicode non-breaking space (#xA0)character.
[57]   ns-esc-line-separator    ::= L       Escaped Unicode line separator (#x2028)character.
[58]   ns-esc-paragraph-separator
                                ::= P   Escaped Unicode paragraph separator (#x2029)character.
[59]   ns-esc-8-bit             ::= x ( ns-hex-digit × 2 )
                                            Escaped 8-bit Unicode character.
[60]   ns-esc-16-bit            ::= u ( ns-hex-digit × 4 )
                                            Escaped 16-bit Unicode character.
[61]   ns-esc-32-bit            ::= U ( ns-hex-digit × 8 )
                                            Escaped 32-bit Unicode character.
[62]   c-ns-esc-char            ::= \
                                  ( ns-esc-null | ns-esc-bell | ns-esc-backspace
                                  | ns-esc-horizontal-tab | ns-esc-line-feed
                                  | ns-esc-vertical-tab | ns-esc-form-feed
                                  | ns-esc-carriage-return | ns-esc-escape
                                  | ns-esc-space | ns-esc-double-quote
                                  | ns-esc-slash | ns-esc-backslash
                                  | ns-esc-next-line | ns-esc-non-breaking-space
                                  | ns-esc-line-separator | ns-esc-paragraph-separator
                                  | ns-esc-8-bit | ns-esc-16-bit | ns-esc-32-bit
                                  )
[63]   s-indent(n)              ::= s-space × n
[64]   s-indent(<n)             ::= s-space × m /* Where m <  n */
[65]   s-indent(<=n)            ::= s-space × m /* Where m <= n */

[66]   s-separate-in-line       ::= s-white+ | /* Start of line */

[67]   s-line-prefix(n,c)       ::= c = block-out &#8658; s-block-line-prefix(n)
                                    c = block-in  &#8658; s-block-line-prefix(n)
                                    c = flow-out  &#8658; s-flow-line-prefix(n)
                                    c = flow-in   &#8658; s-flow-line-prefix(n)
[68]   s-block-line-prefix(n)   ::= s-indent(n)
[69]   s-flow-line-prefix(n)    ::= s-indent(n)s-separate-in-line?

[70]   l-empty(n,c)             ::= ( s-line-prefix(n,c) | s-indent(<n) )
                                    b-as-line-feed

[71]   b-l-trimmed(n,c)         ::= b-non-content l-empty(n,c)+
[72]   b-as-space               ::= b-break
[73]   b-l-folded(n,c)          ::= b-l-trimmed(n,c) | b-as-space

[74]   s-flow-folded(n)         ::= s-separate-in-line? b-l-folded(n,flow-in)
                                    s-flow-line-prefix(n)
[75]   c-nb-comment-text        ::= # nb-char*
[76]   b-comment                ::= b-non-content | /* End of file */

[77]   s-b-comment              ::= ( s-separate-in-line c-nb-comment-text? )?
                                    b-comment

[78]   l-comment                ::= s-separate-in-line c-nb-comment-text?
                                    b-comment

[79]   s-l-comments             ::= ( s-b-comment | /* Start of line */ )
                                    l-comment*

[80]   s-separate(n,c)          ::= c = block-out &#8658; s-separate-lines(n)
                                    c = block-in  &#8658; s-separate-lines(n)
                                    c = flow-out  &#8658; s-separate-lines(n)
                                    c = flow-in   &#8658; s-separate-lines(n)
                                    c = block-key &#8658; s-separate-in-line
                                    c = flow-key  &#8658; s-separate-in-line

[81]   s-separate-lines(n)      ::= ( s-l-comments s-flow-line-prefix(n) )
                                  | s-separate-in-line

[82]   l-directive              ::= %
                                  ( ns-yaml-directive
                                  | ns-tag-directive
                                  | ns-reserved-directive
                                  ) s-l-comments

[83]   ns-reserved-directive    ::= ns-directive-name
                                    ( s-separate-in-line ns-directive-parameter )*

[84]   ns-directive-name
::=ns-char
+

[85]   ns-directive-parameter
::=ns-char
+

Example 6.13. Reserved Directives
%FOO

bar

baz
 # Should be ignored
               # with a warning.
--- "foo"
%YAML 1.2
--- !!str
"foo"
Legend:
ns-reserved-directive

ns-directive-name

ns-directive-parameter


6.8.1.

YAML
 Directives
The

YAML
 directive
 specifies
the version of YAML the
document
 conforms to. This specification
defines version
1.2
, including recommendations for
YAML 1.1 processing
.
A version 1.2 YAML
processor
must accept
documents
 with an
explicit
%YAML 1.2
 directive, as well as
documents
 lacking a

YAML
 directive. Such
documents
 are assumed to conform to the
1.2 version specification.
Documents
 with a
YAML

directive specifying a higher minor version (e.g.

%YAML 1.3
) should be processed with an
appropriate warning.
Documents
with a
YAML
 directive specifying a higher major
version (e.g.
%YAML 2.0
) should be rejected
with an appropriate error message.
A version 1.2 YAML
processor
must also accept
documents
 with
an explicit
%YAML 1.1
 directive. Note that version
1.2 is mostly a superset of version 1.1, defined for the purpose of
ensuring
JSON
compatibility
. Hence a version 1.2
processor
 should process version 1.1
documents
 as if they were
version 1.2, giving a warning on points of incompatibility (handling
of
non-ASCII line
breaks
, as described
above
).
[86]   ns-yaml-directive
::=
Y

A


M

L

s-separate-in-line
ns-yaml-version

[87]   ns-yaml-version
::=ns-dec-digit
+

.
ns-dec-digit
+

Example 6.14.
YAML
 directive
%YAML
1.3
 # Attempt parsing
           # with a warning
---
"foo"
%YAML 1.2
---
!!str "foo"
 Legend:
ns-yaml-directive

ns-yaml-version
It is an error to specify more than one
YAML

directive for the same document, even if both occurrences give the
same version number.
Example 6.15. Invalid Repeated YAML directive
%YAML 1.2
%YAML
 1.1
foo
ERROR:The
YAML
 directive must only be
given at most once per document.


6.8.2.

TAG
 Directives
The

TAG

directive
 establishes a
tag shorthand
 notation for specifying
node tags
. Each
TAG

directive associates a
handle
 with a
prefix
. This allows for compact and
readable
tag
 notation.
[88]   ns-tag-directive
::=
T

A

G

s-separate-in-line
c-tag-handle
s-separate-in-line
ns-tag-prefix

Example 6.16.
TAG
 directive
%TAG
!yaml!
tag:yaml.org,2002:---
!yaml!str "foo"
%YAML 1.2
---
!!str "foo"
Legend:
ns-tag-directive

c-tag-handle

ns-tag-prefix
It is an error to specify more than one
TAG

directive for the same
handle
 in the same document, even if
both occurrences give the same
prefix
.
Example 6.17. Invalid Repeated TAG directive
%TAG ! !foo
%TAG
! !foo
bar
ERROR:The TAG directive must only
be given at most once per
handle
 in the same document.


6.8.2.1. Tag Handles

The
tag handle
exactly matches the prefix of the affected
tag shorthand
. There are three tag
handle variants:
[89]   c-tag-handle
::=c-named-tag-handle
|
c-secondary-tag-handle
|
c-primary-tag-handle

Primary Handle
The
primary tag handle
 is a single

!
 character. This allows
using the most compact possible notation for a single

primary
 name space. By default, the prefix
associated with this handle is

!
. Thus, by default,
shorthands
using this handle are interpreted as
local tags
.
It is possible to override the default behavior by providing
an explicit
TAG
 directive, associating a
different prefix for this handle. This provides smooth
migration from using
local tags
 to using
global tags
, by
the simple addition of a single
TAG

directive.
[90]   c-primary-tag-handle
::=
!

Example 6.18. Primary Tag Handle
# Private
!foo "bar"
...
# Global
%TAG
! tag:example.com,2000:app/
---
!foo "bar"
%YAML 1.2
---
!&lt;!foo&gt; "bar"
...
---
!&lt;tag:example.com,2000:app/foo&gt; "bar"
Legend:
c-primary-tag-handle
Secondary Handle
The
secondary tag handle
 is
written as

!!
. This
allows using a compact notation for a single

secondary
 name space. By default, the prefix
associated with this handle is

tag:yaml.org,2002:. This prefix is used by
the
YAML tag
repository
.
It is possible to override this default behavior by providing
an explicit
TAG
 directive associating a
different prefix for this handle.
[91]   c-secondary-tag-handle
::=
!

!

Example 6.19. Secondary Tag Handle
%TAG
!! tag:example.com,2000:app/---
!!int 1 - 3 # Interval, not integer
Legend:
c-secondary-tag-handle
%YAML 1.2
---
!&lt;tag:example.com,2000:app/int&gt; "1 - 3"
Named Handles
A
named tag handle
 surrounds a
non-empty name with

!
 characters. A handle
name must not be used in a
tag shorthand
 unless an
explicit
TAG
 directive has associated some
prefix with it.
The name of the handle is a
presentation detail
 and must not
be used to convey
content
 information. In
particular, the YAML
processor
 need not preserve the
handle name once
parsing
is completed.
[92]   c-named-tag-handle
::=
!
ns-word-char
+

!

Example 6.20. Tag Handles
%TAG
!e! tag:example.com,2000:app/---
!e!foo "bar"
Legend:
c-named-tag-handle
%YAML 1.2
---
!&lt;tag:example.com,2000:app/foo&gt; "bar"


6.8.2.2. Tag Prefixes

There are two
tag
prefix
 variants:
[93]   ns-tag-prefix
::=c-ns-local-tag-prefix
|
ns-global-tag-prefix

Local Tag Prefix
If the prefix begins with a

!
 character,
shorthands
 using the
handle
 are expanded
to a
local
tag
. Note that such a
tag
 is intentionally not a valid URI,
and its semantics are specific to the
application
. In particular, two
documents
 in the same
stream
 may assign different
semantics to the same
local tag
.
[94]   c-ns-local-tag-prefix
::=
!
ns-uri-char
*

Example 6.21. Local Tag Prefix
%TAG !m!
!my---- # Bulb here
!m!light fluorescent
...
%TAG !m!
!my---- # Color here
!m!light green
Legend:
c-ns-local-tag-prefix
%YAML 1.2
---
!&lt;!my-light&gt; "fluorescent"
...
%YAML 1.2
---
!&lt;!my-light&gt; "green"
Global Tag Prefix
If the prefix begins with a character other than

!
, it must to be a valid URI
prefix, and should contain at least the scheme and the
authority.
Shorthands
 using the associated
handle
 are
expanded to globally unique URI tags, and their semantics is
consistent across
applications
. In particular,
every
documents
 in every
stream
 must assign the same
semantics to the same
global tag
.
[95]   ns-global-tag-prefix
::=ns-tag-char
ns-uri-char
*

Example 6.22. Global Tag Prefix
%TAG !e!
tag:example.com,2000:app/---
- !e!foo "bar"
Legend:
ns-global-tag-prefix
%YAML 1.2
---
!&lt;tag:example.com,2000:app/foo&gt; "bar"


6.9. Node Properties

Each
node
 may have two optional
properties
,
anchor
 and
tag
, in addition to its
content
. Node properties may be specified
in any order before the
node's
content
. Either or both may be omitted.
[96]   c-ns-properties(n,c)::=(
c-ns-tag-property
(
s-separate(n,c)c-ns-anchor-property
 )? )| (
c-ns-anchor-property
(
s-separate(n,c)c-ns-tag-property
 )? )

Example 6.23. Node Properties
!!str

&amp;a1
 "foo":
!!str
 bar
&amp;a2
 baz : *a1
Legend:
c-ns-properties(n,c)c-ns-anchor-property
c-ns-tag-property
%YAML 1.2
---
!!map {
? &amp;B1 !!str "foo"
: !!str "bar",
? !!str "baz"
: *B1,
}


6.9.1. Node Tags

The
tag
property
 identifies the type of the
native data structure
presented
 by the
node
. A tag is denoted by the

! indicator
.
[97]   c-ns-tag-property
::=c-verbatim-tag
|
c-ns-shorthand-tag
|
c-non-specific-tag

Verbatim Tags
A tag may be written
verbatim
 by surrounding it with
the

&lt;
 and
&gt;

characters. In this case, the YAML
processor
 must deliver the verbatim
tag as-is to the
application
. In particular,
verbatim tags are not subject to
tag resolution
. A verbatim tag
must either begin with a

!
 (a
local tag
) or be a
valid URI (a
global
tag
).
[98]   c-verbatim-tag
::=
!

&lt;

ns-uri-char
+

&gt;


Example 6.24. Verbatim Tags
!&lt;tag:yaml.org,2002:str&gt;
 foo :
!&lt;!bar&gt;
 baz
Legend:
c-verbatim-tag
%YAML 1.2
---
!!map {
? !&lt;tag:yaml.org,2002:str&gt; "foo"
: !&lt;!bar&gt; "baz",
}
Example 6.25. Invalid Verbatim Tags
- !&lt;
!&gt; foo
- !&lt;
$:?&gt; bar
ERROR:- Verbatim tags aren't resolved,
so
! is invalid.
- The
$:? tag is neither a global
URI tag nor a local tag starting
with
!.
Tag Shorthands
A
tag
shorthand
 consists of a valid
tag handle
 followed by a non-empty
suffix. The
tag
handle
 must be associated with a
prefix
, either by
default or by using a

TAG
 directive
. The
resulting
parsed

tag
 is the concatenation of the
prefix
 and
the suffix, and must either begin with

!
(a
local
tag
) or be a valid URI (a
global tag
).
The choice of
tag
handle
 is a
presentation detail
 and must not
be used to convey
content
information. In particular, the
tag handle
 may be discarded once
parsing
 is completed.
The suffix must not contain any

!
 character. This would
cause the tag shorthand to be interpreted as having a
named tag
handle
. In addition, the suffix must not contain the

[
,

]
,

{
,

}
 and

,
 characters. These
characters would cause ambiguity with
flow
collection
 structures. If the suffix needs to specify
any of the above restricted characters, they must be
escaped
 using the

%
 character. This behavior is
consistent with the URI character escaping rules (specifically,
section 2.3 of
RFC2396
).
[99]   c-ns-shorthand-tag
::=c-tag-handle
ns-tag-char
+

Example 6.26. Tag Shorthands
%TAG !e! tag:example.com,2000:app/---
-
!local
 foo
-
!!str
 bar
-
!e!tag%21
 baz
Legend:
c-ns-shorthand-tag
%YAML 1.2
---
!!seq [
!&lt;!local&gt; "foo",
!&lt;tag:yaml.org,2002:str&gt; "bar",
!&lt;tag:example.com,2000:app/tag!&gt; "baz"
]
Example 6.27. Invalid Tag Shorthands
%TAG !e! tag:example,2000:app/---
-
!e! foo
-
!h!bar baz
ERROR:- The
!o! handle has no suffix.
- The
!h! handle wasn't declared.
Non-Specific Tags
If a
node
 has no tag
property, it is assigned a
non-specific tag
 that needs
to be
resolved
 to a
specific
 one. This
non-specific
tag
 is

!
 for
non-plain scalars
 and

?
 for
all other
nodes
. This is the
only case where the
node
style
 has any effect on the
content
 information.
It is possible for the tag property to be explicitly set to the

! non-specific tag
. By
convention
, this

disables

tag resolution
, forcing the
node
 to be interpreted as

tag:yaml.org,2002:seq
,

tag:yaml.org,2002:map
, or

tag:yaml.org,2002:str
, according to its
kind
.
There is no way to explicitly specify the

? non-specific
tag. This is intentional.
[100]  c-non-specific-tag
::=
!

Example 6.28. Non-Specific Tags
# Assuming conventional resolution:- "12"
- 12
-
! 12
Legend:
c-non-specific-tag
%YAML 1.2
---
!!seq [
!&lt;tag:yaml.org,2002:str&gt; "12",
!&lt;tag:yaml.org,2002:int&gt; "12",
!&lt;tag:yaml.org,2002:str&gt; "12",
]


6.9.2. Node Anchors

An anchor is denoted by the

&amp;
 indicator
. It marks a
node
 for future reference. An
alias node
 can then be used to
indicate additional inclusions of the anchored
node
. An anchored
node
 need not be referenced by any
alias nodes
; in particular, it is valid for
all
nodes
 to be anchored.
[101]  c-ns-anchor-property
::=
&amp;

ns-anchor-name

Note that as a
serialization detail
, the anchor name is
preserved in the
serialization
tree
. However, it is not reflected in the
representation
 graph and must not
be used to convey
content
information. In particular, the YAML
processor
 need not preserve the anchor
name once the
representation
 is
composed
.
Anchor names must not contain the

[
,

]
,

{
,

}
 and

,
 characters. These
characters would cause ambiguity with
flow collection
structures.
[102]  ns-anchor-char
::=ns-char
-
c-flow-indicator

[103]  ns-anchor-name
::=ns-anchor-char
+

Example 6.29. Node Anchors
First occurrence:
&amp;
anchor
 Value
Second occurrence: *anchor
Legend:
c-ns-anchor-property

ns-anchor-name
%YAML 1.2
---
!!map {
? !!str "First occurrence"
: &amp;A !!str "Value",
? !!str "Second occurrence"
: *A,
}


Chapter 7. Flow Styles

YAML's
flow styles
can be thought of as the natural extension of JSON to cover
folding
 long content lines for
readability,
tagging
 nodes to control
construction
 of
native data structures
, and
using
anchors
 and
aliases
 to reuse
constructed
 object instances.


7.1. Alias Nodes

Subsequent occurrences of a previously
serialized
 node are
presented
 as
alias
nodes
. The first occurrence of the
node
 must be marked by an
anchor
 to allow subsequent occurrences to be
presented
 as alias nodes.
An alias node is denoted by the

* indicator
. The alias refers to the
most recent preceding
node
 having the
same
anchor
. It is an error for an
alias node to use an
anchor
 that
does not previously occur in the
document
. It is not an error to specify an
anchor
 that is not used by any
alias node.
Note that an alias node must not specify any
properties
 or
content
, as these were already specified at the first
occurrence of the
node
.
[104]  c-ns-alias-node
::=
*
ns-anchor-name

Example 7.1. Alias Nodes
First occurrence: &amp;
anchor
 Foo
Second occurrence:
*anchor
Override anchor: &amp;
anchor
 Bar
Reuse anchor:
*anchor
Legend:
c-ns-alias-node

ns-anchor-name
%YAML 1.2
---
!!map {
? !!str "First occurrence"
: &amp;A !!str "Foo",
? !!str "Override anchor"
: &amp;B !!str "Bar",
? !!str "Second occurrence"
: *A,
? !!str "Reuse anchor"
: *B,
}


7.2. Empty Nodes

YAML allows the
node content
 to be
omitted in many cases.
Nodes
 with
empty
content
 are interpreted as
if they were
plain scalars
 with an empty value. Such
nodes
 are commonly resolved to a

null

 value.
[105]  e-scalar
::=/* Empty */

In the examples, empty
scalars
 are
sometimes displayed as the glyph
° for clarity.
Note that this glyph corresponds to a position in the characters
stream
 rather than to an actual
character.
Example 7.2. Empty Content
{  foo : !!str
°,
!!str
° : bar,
}
Legend:
e-scalar
%YAML 1.2
---
!!map {
? !!str "foo" : !!str "",
? !!str ""    : !!str "bar",
}
Both the
node's
properties
 and
node
content
 are optional. This allows for a
completely empty
node
. Completely empty nodes are only valid when following
some explicit indication for their existence.
[106]  e-node
::=e-scalar

Example 7.3. Completely Empty Flow Nodes
{  ? foo :°,
°: bar,
}
Legend:
e-node
%YAML 1.2
---
!!map {
? !!str "foo" : !!null "",
? !!null ""   : !!str "bar",
}


7.3. Flow Scalar Styles

YAML provides three
flow scalar styles
:
double-quoted
,
single-quoted
 and
plain
(unquoted). Each provides a different trade-off between readability and
expressive power.
The
scalar style
is a
presentation
detail
 and must not be used to convey
content
 information, with the exception
that
plain
scalars
 are distinguished for the purpose of
tag resolution
.


7.3.1. Double-Quoted Style

The
double-quoted style
 is specified
by surrounding

" indicators
. This is the only
style
 capable of expressing
arbitrary strings, by using

\

escape
sequences
. This comes at the cost of having to escape the

\
 and
"
characters.
[107]  nb-double-char
::=c-ns-esc-char
| (
nb-json
-

\
-

"
 )

[108]  ns-double-char
::=nb-double-char
-
s-white

Double-quoted scalars are restricted to a single line when contained
inside an
implicit
key
.
[109]  c-double-quoted(n,c)::=
"
nb-double-text(n,c)
"

[110]  nb-double-text(n,c)::=c
 = flow-out  &#8658;
nb-double-multi-line(n)c
 = flow-in   &#8658;
nb-double-multi-line(n)c
 = block-key &#8658;
nb-double-one-line
c
 = flow-key  &#8658;
nb-double-one-line

[111]  nb-double-one-line
::=nb-double-char
*

Example 7.4. Double Quoted Implicit Keys
"implicit block key
" : [
"implicit flow key
" : value,
]
Legend:
nb-double-one-line
c-double-quoted(n,c)%YAML 1.2
---
!!map {
? !!str "implicit block key"
: !!seq [
!!map {
? !!str "implicit flow key"
: !!str "value",
}
]
}
In a multi-line double-quoted scalar,
line breaks
 are are subject to
flow line folding
,
which discards any trailing
white space
 characters. It is also
possible to
escape
 the
line
break
 character. In this case, the
line break
 is excluded from the
content
, and the trailing
white space
 characters
are preserved. Combined with the ability to
escape

white space
 characters, this allows
double-quoted lines to be broken at arbitrary positions.
[112]  s-double-escaped(n)::=s-white
*

\
b-non-content
l-empty(n,flow-in)*
s-flow-line-prefix(n)
[113]  s-double-break(n)::=s-double-escaped(n)|
s-flow-folded(n)
Example 7.5. Double Quoted Line Breaks
"folded
·&#8595;
to a space,&#8594;&#8595;
·&#8595;
to a line feed, or
·&#8594;\&#8595;
·\·&#8594;non-content"
%YAML 1.2
---
!!str "folded to a space,\n\
to a line feed, \
or \t \tnon-content"
Legend:
s-flow-folded(n)
s-double-escaped(n)All leading and trailing
white space
 characters are excluded from
the
content
. Each continuation
line must therefore contain at least one non-space
 character. Empty lines, if any, are
consumed as part of the
line
folding
.
[114]  nb-ns-double-in-line
::=(
s-white
*
ns-double-char
 )*

[115]  s-double-next-line(n)::=s-double-break(n)(
ns-double-char
nb-ns-double-in-line
(
s-double-next-line(n)|
s-white
* ) )?

[116]  nb-double-multi-line(n)::=nb-ns-double-in-line
(
s-double-next-line(n)|
s-white
* )

Example 7.6. Double Quoted Lines
"·1st non-empty
&#8595;
&#8595;
·2nd non-empty
·
&#8594;
3rd non-empty
·"
%YAML 1.2
---
!!str " 1st non-empty\n\
2nd non-empty \
3rd non-empty "
Legend:
nb-ns-double-in-line

s-double-next-line(n)7.3.2. Single-Quoted Style
The
single-quoted style
 is specified
by surrounding

' indicators
. Therefore, within a
single-quoted scalar, such characters need to be repeated. This is
the only form of
escaping
 performed in single-quoted
scalars. In particular, the
\ and
"
characters may be freely used. This restricts single-quoted scalars
to
printable
characters. In addition, it is only possible to break a long
single-quoted line where a
space
character is surrounded by non-spaces
.
[117]  c-quoted-quote
::=
'

'

[118]  nb-single-char
::=c-quoted-quote
| (
nb-json
-

'
 )

[119]  ns-single-char
::=nb-single-char
-
s-white

Example 7.7. Single Quoted Characters
 'here
''s to "quotes"'Legend:
c-quoted-quote
%YAML 1.2
---
!!str "here's to \"quotes\""
Single-quoted scalars are restricted to a single line when contained
inside a
implicit
key
.
[120]  c-single-quoted(n,c)::=
'
nb-single-text(n,c)
'

[121]  nb-single-text(n,c)::=c
 = flow-out  &#8658;
nb-single-multi-line(n)c
 = flow-in   &#8658;
nb-single-multi-line(n)c
 = block-key &#8658;
nb-single-one-line
c
 = flow-key  &#8658;
nb-single-one-line

[122]  nb-single-one-line
::=nb-single-char
*

Example 7.8. Single Quoted Implicit Keys
'implicit block key
' : [
'implicit flow key
' : value,
]
Legend:
nb-single-one-line
c-single-quoted(n,c)%YAML 1.2
---
!!map {
? !!str "implicit block key"
: !!seq [
!!map {
? !!str "implicit flow key"
: !!str "value",
}
]
}
All leading and trailing
white space
 characters are excluded from
the
content
. Each continuation
line must therefore contain at least one non-space
 character. Empty lines, if any, are
consumed as part of the
line
folding
.
[123]  nb-ns-single-in-line
::=(
s-white
*
ns-single-char
 )*

[124]  s-single-next-line(n)::=s-flow-folded(n)(
ns-single-char
nb-ns-single-in-line
(
s-single-next-line(n) |
s-white
* ) )?

[125]  nb-single-multi-line(n)::=nb-ns-single-in-line
(
s-single-next-line(n)|
s-white
* )

Example 7.9. Single Quoted Lines
'·1st non-empty
&#8595;
&#8595;
·2nd non-empty
·
&#8594;
3rd non-empty
·'
%YAML 1.2
---
!!str " 1st non-empty\n\
2nd non-empty \
3rd non-empty "
Legend:
nb-ns-single-in-line(n)
s-single-next-line(n)7.3.3. Plain Style
The
plain
 (unquoted) style has no identifying
indicators
 and provides no
form of escaping. It is therefore the most readable, most limited and
most
context
 sensitive
style
. In addition to a restricted
character set, a plain scalar must not be empty, or contain leading
or trailing
white
space
 characters. It is only possible to break a long plain
line where a
space
 character is
surrounded by non-spaces
.
Plain scalars must not begin with most
indicators
, as this would cause
ambiguity with other YAML constructs. However, the

:
,

?
 and

-
indicators
 may be used as the
first character if followed by a non-space

safe
 character, as
this causes no ambiguity.
[126]  ns-plain-first(c)::=(
ns-char
-
c-indicator
 )| ( (

?
|

:
|

-
 )/* Followed by an
ns-plain-safe(c)) */ )

Plain scalars must never contain the

:

 and

 #
 character combinations.
Such combinations would cause ambiguity with
mapping

key: value pairs
 and
comments
. In addition, inside
flow
collections
, or when used as
implicit keys
, plain scalars must not
contain the

[
,

]
,

{
,

}
 and

,
 characters. These
characters would cause ambiguity with
flow collection
structures.
[127]  ns-plain-safe(c)::=c
 = flow-out  &#8658;
ns-plain-safe-out
c
 = flow-in   &#8658;
ns-plain-safe-in
c
 = block-key &#8658;
ns-plain-safe-out
c
 = flow-key  &#8658;
ns-plain-safe-in

[128]  ns-plain-safe-out
::=ns-char

[129]  ns-plain-safe-in
::=ns-char
-
c-flow-indicator

[130]  ns-plain-char(c)::=(
ns-plain-safe(c)-

:
-

#
 )| ( /* An
ns-char
 preceding */

#
 )| (

:
/* Followed by an
ns-plain-safe(c) */ )

Example 7.10. Plain Characters
# Outside flow collection:-
::vector
- ": - ()"
- Up
, up, and away!
-
-123
- http
://example.com/foo
#bar
# Inside flow collection:
- [
::vector,
": - ()",
"Up
, up and away!",
-123,
http
://example.com/foo
#bar ]
%YAML 1.2
---
!!seq [
!!str "::vector",
!!str ": - ()",
!!str "Up, up, and away!",
!!int "-123",
!!str "http://example.com/foo#bar",
!!seq [
!!str "::vector",
!!str ": - ()",
!!str "Up, up, and away!",
!!int "-123",
!!str "http://example.com/foo#bar",
],
]
Legend:
ns-plain-first(c)
Not ns-plain-first(c)
ns-plain-char(c)
Not ns-plain-char(c)Plain scalars are further restricted to a single line when contained
inside an
implicit
key
.
[131]  ns-plain(n,c)::=c
 = flow-out  &#8658;
ns-plain-multi-line(n,c)c
 = flow-in   &#8658;
ns-plain-multi-line(n,c)c
 = block-key &#8658;
ns-plain-one-line(c)c
 = flow-key  &#8658;
ns-plain-one-line(c)
[132]  nb-ns-plain-in-line(c)::=(
s-white
*
ns-plain-char(c) )*

[133]  ns-plain-one-line(c)::=ns-plain-first(c)nb-ns-plain-in-line(c)
Example 7.11. Plain Implicit Keys
implicit block key
 : [
implicit flow key
 : value,
]
Legend:
ns-plain-one-line(c)%YAML 1.2
---
!!map {
? !!str "implicit block key"
: !!seq [
!!map {
? !!str "implicit flow key"
: !!str "value",
}
]
}
All leading and trailing
white space
 characters are excluded from
the
content
. Each continuation
line must therefore contain at least one non-space
 character. Empty lines, if any, are
consumed as part of the
line
folding
.
[134]  s-ns-plain-next-line(n,c)::=s-flow-folded(n)ns-plain-char(c)nb-ns-plain-in-line(c)
[135]  ns-plain-multi-line(n,c)::=ns-plain-one-line(c)s-ns-plain-next-line(n,c)*

Example 7.12. Plain Lines
1st non-empty
&#8595;
&#8595;
·2nd non-empty
·
&#8594;
3rd non-empty
%YAML 1.2
---
!!str "1st non-empty\n\
2nd non-empty \
3rd non-empty"
Legend:
nb-ns-plain-in-line(c)
s-ns-plain-next-line(n,c)7.4. Flow Collection Styles
A
flow
collection
 may be nested within a
block collection
(flow-out
context
), nested within another flow collection (flow-in
context
), or be a part of an
implicit key
 (flow-key
 context
or
block-key
context
). Flow collection entries are terminated by the

,
indicator
. The final
, may be omitted. This
does not cause ambiguity because flow collection entries can never be
completely
empty
.
[136]  in-flow(c)::=c
 = flow-out  &#8658; flow-in
c
 = flow-in   &#8658; flow-in
c
 = block-key &#8658; flow-key
c
 = flow-key  &#8658; flow-key


7.4.1. Flow Sequences

Flow
sequence content
 is denoted by surrounding

[
 and

]
characters.
[137]  c-flow-sequence(n,c)::=
[
s-separate(n,c)?ns-s-flow-seq-entries(n,in-flow(c))?

]

Sequence entries are separated by a

,
 character.
[138]  ns-s-flow-seq-entries(n,c)::=ns-flow-seq-entry(n,c)s-separate(n,c)?(

,
s-separate(n,c)?ns-s-flow-seq-entries(n,c)? )?

Example 7.13. Flow Sequence
-
[
one
,
two
,
]-
[three
 ,four
]Legend:
c-sequence-start

c-sequence-end
ns-flow-seq-entry(n,c)%YAML 1.2
---
!!seq [
!!seq [
!!str "one",
!!str "two",
],
!!seq [
!!str "three",
!!str "four",
],
]
Any
flow node
 may
be used as a flow sequence entry. In addition, YAML provides a
compact notation
 for the case where a flow
sequence entry is a
mapping
 with
a
single key: value pair
.
[139]  ns-flow-seq-entry(n,c)::=ns-flow-pair(n,c)|
ns-flow-node(n,c)
Example 7.14. Flow Sequence Entries
["double
quoted",
'single
quoted',
plain
text
,
[ nested ],
single: pair
,
]
Legend:
ns-flow-node(n,c)
ns-flow-pair(n,c)%YAML 1.2
---
!!seq [
!!str "double quoted",
!!str "single quoted",
!!str "plain text",
!!seq [
!!str "nested",
],
!!map {
? !!str "single"
: !!str "pair",
},
]


7.4.2. Flow Mappings

Flow
mappings
 are denoted by surrounding

{
 and

}
 characters.
[140]  c-flow-mapping(n,c)::=
{
s-separate(n,c)?ns-s-flow-map-entries(n,in-flow(c))?

}

Mapping entries are separated by a

,
 character.
[141]  ns-s-flow-map-entries(n,c)::=ns-flow-map-entry(n,c)s-separate(n,c)?(

,
s-separate(n,c)?ns-s-flow-map-entries(n,c)? )?

Example 7.15. Flow Mappings
-
{
one : two
 ,
three: four
 ,
}-
{five: six
,seven : eight
}Legend:
c-mapping-start

c-mapping-end
ns-flow-map-entry(n,c)%YAML 1.2
---
!!seq [
!!map {
? !!str "one"   : !!str "two",
? !!str "three" : !!str "four",
},
!!map {
? !!str "five"  : !!str "six",
? !!str "seven" : !!str "eight",
},
]
If the optional

?
mapping key indicator
 is specified, the rest of the entry
may be
completely empty
.
[142]  ns-flow-map-entry(n,c)::=(

?
s-separate(n,c)ns-flow-map-explicit-entry(n,c) )|
ns-flow-map-implicit-entry(n,c)
[143]  ns-flow-map-explicit-entry(n,c)::=ns-flow-map-implicit-entry(n,c)| (
e-node
 /* Key */e-node
 /* Value */ )

Example 7.16. Flow Mapping Entries
{?
explicit: entry
,
implicit: entry
,
?°°}
Legend:
ns-flow-map-explicit-entry(n,c)ns-flow-map-implicit-entry(n,c)e-node
%YAML 1.2
---
!!map {
? !!str "explicit" : !!str "entry",
? !!str "implicit" : !!str "entry",
? !!null "" : !!null "",
}
Normally, YAML insists the

: mapping value indicator
 be
separated
from the
value
 by
white space
. A benefit of
this restriction is that the
: character can be used
inside
plain scalars
, as long as it is not
followed by
white
space
. This allows for unquoted URLs and timestamps. It is
also a potential source for confusion as
a:1
 is a
plain
scalar
 and not a
key: value pair
.
Note that the
value
 may be
completely
empty
 since its existence is indicated by the

:.
[144]  ns-flow-map-implicit-entry(n,c)::=ns-flow-map-yaml-key-entry(n,c)|
c-ns-flow-map-empty-key-entry(n,c)|
c-ns-flow-map-json-key-entry(n,c)
[145]  ns-flow-map-yaml-key-entry(n,c)::=ns-flow-yaml-node(n,c)( (
s-separate(n,c)?c-ns-flow-map-separate-value(n,c) )|
e-node
 )

[146]  c-ns-flow-map-empty-key-entry(n,c)::=e-node
 /* Key */c-ns-flow-map-separate-value(n,c)
[147]  c-ns-flow-map-separate-value(n,c)::=
:
/* Not followed by an
ns-plain-safe(c) */( (
s-separate(n,c)ns-flow-node(n,c) )|
e-node
 /* Value */ )

Example 7.17. Flow Mapping Separate Values
{unquoted
·:·"separate",
http://foo.com
,
omitted value
:°,
°:·omitted key
,
}
Legend:
ns-flow-yaml-node(n,c)
e-node
c-ns-flow-map-separate-value(n,c)%YAML 1.2
---
!!map {
? !!str "unquoted" : !!str "separate",
? !!str "http://foo.com" : !!null "",
? !!str "omitted value" : !!null "",
? !!null "" : !!str "omitted key",
}
To ensure
JSON
compatibility
, if a
key
inside a flow mapping is
JSON-like
, YAML allows the following
value
 to be specified adjacent to
the
:. This causes no ambiguity, as all
JSON-like

keys
 are surrounded by
indicators
. However, as this greatly
reduces readability, YAML
processors
 should
separate
 the
value
 from the
:
on output, even in this case.
[148]  c-ns-flow-map-json-key-entry(n,c)::=c-flow-json-node(n,c)( (
s-separate(n,c)?c-ns-flow-map-adjacent-value(n,c) )|
e-node
 )

[149]  c-ns-flow-map-adjacent-value(n,c)::=
:
( (
s-separate(n,c)?ns-flow-node(n,c) )|
e-node
 ) /* Value */

Example 7.18. Flow Mapping Adjacent Values
{"adjacent":value
,
"readable":·value
,
"empty":°}
Legend:
c-flow-json-node(n,c)
e-node
c-ns-flow-map-adjacent-value(n,c)%YAML 1.2
---
!!map {
? !!str "adjacent" : !!str "value",
? !!str "readable" : !!str "value",
? !!str "empty"    : !!null "",
}
A more compact notation is usable inside
flow sequences
, if the
mapping
 contains a
single
key: value pair
. This notation does not require the
surrounding
{ and
} characters.
Note that it is not possible to specify any
node properties
 for the
mapping
 in this case.
Example 7.19. Single Pair Flow Mappings
[foo: bar
]
Legend:
ns-flow-pair(n,c)%YAML 1.2
---
!!seq [
!!map { ? !!str "foo" : !!str "bar" }
]
If the
? indicator is explicitly specified,
parsing
 is unambiguous, and the syntax is
identical to the general case.
[150]  ns-flow-pair(n,c)::=(

?
s-separate(n,c)ns-flow-map-explicit-entry(n,c) )|
ns-flow-pair-entry(n,c)
Example 7.20. Single Pair Explicit Entry
[?
foo
bar : baz
]
Legend:
ns-flow-map-explicit-entry(n,c)%YAML 1.2
---
!!seq [
!!map {
? !!str "foo bar"
: !!str "baz",
},
]
If the
? indicator is omitted,
parsing
 needs to see past the
implicit key
 to
recognize it as such. To limit the amount of lookahead required, the

: indicator must appear at most 1024 Unicode
characters beyond the start of the
key
. In addition, the
key
 is restricted to a single line.
Note that YAML allows arbitrary
nodes
 to be used as
keys
. In particular, a
key
 may be a
sequence
 or a
mapping
. Thus, without the above
restrictions, practical one-pass
parsing
 would have been impossible to
implement.
[151]  ns-flow-pair-entry(n,c)::=ns-flow-pair-yaml-key-entry(n,c)|
c-ns-flow-map-empty-key-entry(n,c)|
c-ns-flow-pair-json-key-entry(n,c)
[152]  ns-flow-pair-yaml-key-entry(n,c)::=ns-s-implicit-yaml-key(flow-key)c-ns-flow-map-separate-value(n,c)
[153]  c-ns-flow-pair-json-key-entry(n,c)::=c-s-implicit-json-key(flow-key)c-ns-flow-map-adjacent-value(n,c)
[154]  ns-s-implicit-yaml-key(c)::=ns-flow-yaml-node(n/a,c)s-separate-in-line
?/* At most 1024 characters altogether */

[155]  c-s-implicit-json-key(c)::=c-flow-json-node(n/a,c)s-separate-in-line
?/* At most 1024 characters altogether */

Example 7.21. Single Pair Implicit Entries
- [
YAML·: separate
 ]- [
°: empty key entry
 ]
- [
{JSON: like}:adjacent
 ]
Legend:
ns-s-implicit-yaml-key
c-s-implicit-json-key
e-node

Value
%YAML 1.2
---
!!seq [
!!seq [
!!map {
? !!str "YAML"
: !!str "separate"
},
],
!!seq [
!!map {
? !!null ""
: !!str "empty key entry"
},
],
!!seq [
!!map {
? !!map {
? !!str "JSON"
: !!str "like"
} : "adjacent",
},
],
]
Example 7.22. Invalid Implicit Keys
[
foo
 bar
: invalid,
"foo
...&gt;1K characters...bar": invalid ]
ERROR:- The
foo bar
 key spans multiple lines
- The
foo...bar
 key is too long


7.5. Flow Nodes

JSON-like

flow styles
 all have
explicit start and end
indicators
. The only
flow style
 that does not
have this property is the
plain scalar
. Note that none of the

JSON-like
 styles is actually acceptable by JSON. Even
the
double-quoted style
 is a superset of
the JSON string format.
[156]  ns-flow-yaml-content(n,c)::=ns-plain(n,c)
[157]  c-flow-json-content(n,c)::=c-flow-sequence(n,c)|
c-flow-mapping(n,c)|
c-single-quoted(n,c)|
c-double-quoted(n,c)
[158]  ns-flow-content(n,c)::=ns-flow-yaml-content(n,c)|
c-flow-json-content(n,c)
Example 7.23. Flow Content
-
[ a, b ]-
{ a: b }-
"a"-
'b'-
c
Legend:
c-flow-json-content(n,c)ns-flow-yaml-content(n,c)%YAML 1.2
---
!!seq [
!!seq [ !!str "a", !!str "b" ],
!!map { ? !!str "a" : !!str "b" },
!!str "a",
!!str "b",
!!str "c",
]
A complete
flow
node
 also has optional
node properties
, except
for
alias nodes
 which refer to the
anchored

node properties
.
[159]  ns-flow-yaml-node(n,c)::=c-ns-alias-node
|
ns-flow-yaml-content(n,c)| (
c-ns-properties(n,c)( (
s-separate(n,c)ns-flow-yaml-content(n,c) )|
e-scalar
 ) )

[160]  c-flow-json-node(n,c)::=(
c-ns-properties(n,c)s-separate(n,c) )?c-flow-json-content(n,c)
[161]  ns-flow-node(n,c)::=c-ns-alias-node
|
ns-flow-content(n,c)| (
c-ns-properties(n,c)( (
s-separate(n,c)ns-flow-content(n,c) )|
e-scalar
 ) )

Example 7.24. Flow Nodes
-
!!str "a"-
'b'-
&amp;anchor "c"-
*anchor
-
!!str°Legend:
c-flow-json-node(n,c)ns-flow-yaml-node(n,c)%YAML 1.2
---
!!seq [
!!str "a",
!!str "b",
&amp;A !!str "c",
*A,
!!str "",
]


Chapter 8. Block Styles

YAML's
block
styles
 employ
indentation
 rather than
indicators
 to denote structure. This
results in a more human readable (though less compact) notation.


8.1. Block Scalar Styles

YAML provides two
block scalar styles
,
literal
and
folded
. Each provides a different trade-off
between readability and expressive power.


8.1.1. Block Scalar Headers

Block
scalars
 are controlled by a few
indicators
 given in a
header
 preceding the
content
 itself. This header is followed
by a non-content
line break
with an optional
comment
. This
is the only case where a
comment
must not be followed by additional
comment
 lines.
[162]  c-b-block-header(m,t)::=( (
c-indentation-indicator(m)c-chomping-indicator(t) )| (
c-chomping-indicator(t)c-indentation-indicator(m) ) )s-b-comment

Example 8.1. Block Scalar Header
- | # Empty header&#8595;
 literal
- &gt;
1 # Indentation indicator&#8595;
·folded
- |+ # Chomping indicator&#8595;
keep

- &gt;
1- # Both indicators&#8595;
·strip

%YAML 1.2
---
!!seq [
!!str "literal\n",
!!str "·folded\n",
!!str "keep\n\n",
!!str "·strip",
]
 Legend:
c-b-block-header(m,t)8.1.1.1. Block Indentation Indicator
Typically, the
indentation
 level of a
block
scalar
 is detected from its first non-empty
 line. It is an error for any
of the leading
empty lines
to contain more
spaces
 than the
first non-empty line
.
Detection fails when the first non-empty line
 contains leading content
space
 characters.
Content
 may safely start with a
tab
 or a

#
 character.
When detection would fail, YAML requires that the
indentation
 level
for the
content
 be given using
an explicit
indentation indicator
. This level
is specified as the integer number of the additional
indentation
spaces used for the
content
,
relative to its parent
node
.
It is always valid to specify an indentation indicator for a
block
scalar
 node, though a YAML
processor
 should only emit an
explicit indentation indicator for cases where detection will fail.
[163]  c-indentation-indicator(m)::=ns-dec-digit
&#8658; m =
ns-dec-digit
 - #x30
/* Empty */  &#8658; m = auto-detect()

Example 8.2. Block Indentation Indicator
- |°·detected
- &gt;
°·····# detected
- |1
··explicit
- &gt;
°·&#8594;
·detected
%YAML 1.2
---
!!seq [
!!str "detected\n",
!!str "\n\n# detected\n",
!!str "·explicit\n",
!!str "\t·detected\n",
]
 Legend:
c-indentation-indicator(m)s-indent(n)Example 8.3. Invalid Block Scalar Indentation Indicators
- |···text
- &gt;
··text
·text
- |2
·text
ERROR:- A leading all-space line must
not have too many
spaces
.
- A following text line must
not be
less indented
.
- The text is
less indented
than the indicated level.


8.1.1.2. Block Chomping Indicator

Chomping
 controls how final
line breaks
 and trailing
empty lines
 are
interpreted. YAML provides three chomping methods:
Strip
Stripping
 is specified by the

-
chomping indicator
. In this case, the final
line break
 and any
trailing
empty lines
are excluded from the
scalar's
content
.
Clip
Clipping
 is the default behavior
used if no explicit chomping indicator is specified. In this
case, the final
line
break
 character is preserved in the
scalar's content
. However, any
trailing
empty lines
are excluded from the
scalar's
content
.
Keep
Keeping
is specified by the

+ chomping indicator
. In
this case, the final
line
break
 and any trailing
empty lines
 are considered to be part of the
scalar's content
. These
additional lines are not subject to
folding
.
The chomping method used is a
presentation detail
 and must not be
used to convey
content
information.
[164]  c-chomping-indicator(t)::=
-         &#8658;
t
 = strip

+         &#8658;
t
 = keep
/* Empty */ &#8658;
t
 = clip

The interpretation of the final
line
break
 of a
block scalar
 is controlled by the
chomping indicator specified in the
block scalar header
.
[165]  b-chomped-last(t)::=t
 = strip &#8658;
b-non-content
 | /* End of file */t
 = clip  &#8658;
b-as-line-feed
 | /* End of file */t
 = keep  &#8658;
b-as-line-feed
 | /* End of file */

Example 8.4. Chomping Final Line Break
strip: |-  text
&#8595;
clip: |
text
&#8595;
keep: |+
text
&#8595;
Legend:
b-non-content

b-as-line-feed
%YAML 1.2
---
!!map {
? !!str "strip"
: !!str "text",
? !!str "clip"
: !!str "text\n",
? !!str "keep"
: !!str "text\n",
}
The interpretation of the trailing
empty lines
 following a
block scalar
 is also
controlled by the chomping indicator specified in the
block scalar header
.
[166]  l-chomped-empty(n,t)::=t
 = strip &#8658;
l-strip-empty(n)t
 = clip  &#8658;
l-strip-empty(n)t
 = keep  &#8658;
l-keep-empty(n)
[167]  l-strip-empty(n)::=(
s-indent(&#8804;n)b-non-content
 )*l-trail-comments(n)?

[168]  l-keep-empty(n)::=l-empty(n,block-in)*l-trail-comments(n)?

Explicit
comment
 lines may
follow the trailing
empty
lines
. To prevent ambiguity, the first such
comment
 line must be less
indented
 than the
block
scalar content
. Additional
comment
 lines, if any, are not so
restricted. This is the only case where the
indentation
 of
comment
 lines is constrained.
[169]  l-trail-comments(n)::=s-indent(&lt;n)c-nb-comment-text
b-comment
l-comment
*

Example 8.5. Chomping Trailing Lines
 # Strip
  # Comments:
strip: |-
# text&#8595;
··&#8659;
·# Clip
··# comments:
&#8595;
clip: |
# text&#8595;
·&#8595;
·# Keep
··# comments:
&#8595;
keep: |+
# text&#8595;
&#8595;
·# Trail
··# comments.%YAML 1.2
---
!!map {
? !!str "strip"
: !!str "# text",
? !!str "clip"
: !!str "# text\n",
? !!str "keep"
: !!str "# text\n",
}
 Legend:
l-strip-empty(n)l-keep-empty(n)l-trail-comments(n)If a
block scalar
 consists only of
empty lines
, then these lines are
considered as trailing lines and hence are affected by chomping.
Example 8.6. Empty Scalar Chomping
strip: &gt;-&#8595;
clip: &gt;
&#8595;
keep: |+
&#8595;
Legend:
l-strip-empty(n)
l-keep-empty(n)%YAML 1.2
---
!!map {
? !!str "strip"
: !!str "",
? !!str "clip"
: !!str "",
? !!str "keep"
: !!str "\n",
}


8.1.2. Literal Style

The
literal style
 is denoted by the

| indicator
. It
is the simplest, most restricted, and most readable
scalar style
.
[170]  c-l+literal(n)::=
|
c-b-block-header(m,t)l-literal-content(n+m,t)
Example 8.7. Literal Scalar
|&#8595;
·literal&#8595;
·&#8594;text&#8595;
&#8595;
Legend:
c-l+literal(n)%YAML 1.2
---
!!str "literal\n\ttext\n"
Inside literal scalars, all (indented
) characters are considered
to be
content
, including
white space
characters. Note that all
line
break
 characters are
normalized
. In addition,
empty lines
 are not
folded
,
though final
line breaks
 and
trailing
empty lines
 are
chomped
.
There is no way to escape characters inside literal scalars. This
restricts them to
printable
 characters. In addition, there is no
way to break a long literal line.
[171]  l-nb-literal-text(n)::=l-empty(n,block-in)*s-indent(n)nb-char
+

[172]  b-nb-literal-next(n)::=b-as-line-feed
l-nb-literal-text(n)
[173]  l-literal-content(n,t)::=(
l-nb-literal-text(n)b-nb-literal-next(n)*b-chomped-last(t) )?l-chomped-empty(n,t)
Example 8.8. Literal Content
|·
··
··literal
&#8595;
···&#8595;
··
··text
&#8595;
&#8595;
·# Comment
%YAML 1.2
---
!!str "\n\nliteral\n·\n\ntext\n"
 Legend:
l-nb-literal-text(n)b-nb-literal-next(n)b-chomped-last(t)l-chomped-empty(n,t)8.1.3. Folded Style
The
folded style
 is denoted by the

&gt;
 indicator
.
It is similar to the
literal style
; however, folded scalars
are subject to
line
folding
.
[174]  c-l+folded(n)::=
&gt;

c-b-block-header(m,t)l-folded-content(n+m,t)
Example 8.9. Folded Scalar
&gt;&#8595;
·folded&#8595;
·text&#8595;
&#8595;
%YAML 1.2
---
!!str "folded text\n"
Legend:
c-l+folded(n)Folding
 allows long lines
to be broken anywhere a single
space
 character separates two non-space
 characters.
[175]  s-nb-folded-text(n)::=s-indent(n)ns-char
nb-char
*

[176]  l-nb-folded-lines(n)::=s-nb-folded-text(n)(
b-l-folded(n,block-in)s-nb-folded-text(n) )*

Example 8.10. Folded Lines
&gt;
·folded
&#8595;
·line
&#8595;
&#8595;
·next
·line
&#8595;
* bullet

* list
* lines

·last
&#8595;
·line
&#8595;

# Comment
%YAML 1.2
---
!!str "\n\
folded line\n\
next line\n\
\  * bullet\n
\n\
\  * list\n\
\  * lines\n\
\n\
last line\n"
 Legend:
s-nb-folded-text(n)l-nb-folded-lines(n)(The following three examples duplicate this example, each
highlighting different productions.)
Lines starting with
white
space
 characters (more-indented
 lines) are not
folded
.
[177]  s-nb-spaced-text(n)::=s-indent(n)s-white
nb-char
*

[178]  b-l-spaced(n)::=b-as-line-feed
l-empty(n,block-in)*

[179]  l-nb-spaced-lines(n)::=s-nb-spaced-text(n)(
b-l-spaced(n)s-nb-spaced-text(n) )*
Example 8.11. More Indented Lines
&gt;
folded
line

next
line
···* bullet
&#8595;
&#8595;
···* list
&#8595;
···* lines
&#8595;

last
line

# Comment
%YAML 1.2
---
!!str "\n\
folded line\n\
next line\n\
\  * bullet\n
\n\
\  * list\n\
\  * lines\n\
\n\
last line\n"
 Legend:
s-nb-spaced-text(n)l-nb-spaced-lines(n)Line breaks
 and
empty lines
 separating folded and
more-indented lines are also not
folded
.
[180]  l-nb-same-lines(n)::=l-empty(n,block-in)*(
l-nb-folded-lines(n)|
l-nb-spaced-lines(n) )

[181]  l-nb-diff-lines(n)::=l-nb-same-lines(n)(
b-as-line-feed
l-nb-same-lines(n) )*

Example 8.12. Empty Separation Lines
&gt;
&#8595;
folded
line
&#8595;
&#8595;
next
line
&#8595;
* bullet

* list
* line
&#8595;
&#8595;
last
line

# Comment
%YAML 1.2
---
!!str "\n\
folded line\n\
next line\n\
\  * bullet\n
\n\
\  * list\n\
\  * lines\n\
\n\
last line\n"
 Legend:
b-as-line-feed
(separation)
l-empty(n,c)The final
line break
, and
trailing
empty lines
 if any,
are subject to
chomping
 and are
never
folded
.
[182]  l-folded-content(n,t)::=(
l-nb-diff-lines(n)b-chomped-last(t) )?l-chomped-empty(n,t)
Example 8.13. Final Empty Lines
&gt;
 folded
line

next
line
* bullet

* list
* line

last
line
&#8595;
&#8595;
# Comment
%YAML 1.2
---
!!str "\n\
folded line\n\
next line\n\
\  * bullet\n
\n\
\  * list\n\
\  * lines\n\
\n\
last line\n"
 Legend:
b-chomped-last(t)
l-chomped-empty(n,t)8.2. Block Collection Styles
For readability,
block collections styles
 are not
denoted by any
indicator
.
Instead, YAML uses a lookahead method, where a block collection is
distinguished from a
plain scalar
 only when a
key: value pair
 or a
sequence entry
 is seen.


8.2.1. Block Sequences

A block sequence
 is simply a series of
nodes
, each denoted by a leading

-
indicator
. The
- indicator must be
separated
from the
node
 by
white space
. This allows

- to be used as the first character in a
plain
scalar
 if followed by a non-space character (e.g.

-1
).
[183]  l+block-sequence(n)::=(
s-indent(n+m)c-l-block-seq-entry(n+m) )+/* For some fixed auto-detected
m
 &gt; 0 */

[184]  c-l-block-seq-entry(n)::=
-
 /* Not followed by an
ns-char
 */s-l+block-indented(n,block-in)
Example 8.14. Block Sequence
block sequence:··- one&#8595;
- two : three&#8595;
Legend:
c-l-block-seq-entry(n)auto-detected
s-indent(n)%YAML 1.2
---
!!map {
? !!str "block sequence"
: !!seq [
!!str "one",
!!map {
? !!str "two"
: !!str "three"
},
],
}
The entry
node
 may be either
completely
empty
, be a nested
block node
, or use a
compact in-line
notation
. The compact notation may be used when the entry
is itself a nested
block collection
. In this case, both
the
- indicator and the following
spaces
 are considered to be part of the
indentation
 of the nested
collection
. Note that it is not
possible to specify
node
properties
 for such a
collection
.
[185]  s-l+block-indented(n,c)::=(
s-indent(m)(
ns-l-compact-sequence(n+1+m)|
ns-l-compact-mapping(n+1+m) ) )|
s-l+block-node(n,c)| (
e-node
s-l-comments
 )

[186]  ns-l-compact-sequence(n)::=c-l-block-seq-entry(n)(
s-indent(n)c-l-block-seq-entry(n) )*

Example 8.15. Block Sequence Entry Types
-° # Empty
- |
block node
-·- one # Compact
··- two # sequence
- one: two # Compact mapping
Legend:
Empty
s-l+block-node(n,c)ns-l-compact-sequence(n)ns-l-compact-mapping(n)%YAML 1.2
---
!!seq [
!!null "",
!!str "block node\n",
!!seq [
!!str "one"
!!str "two",
],
!!map {
? !!str "one"
: !!str "two",
},
]


8.2.2. Block Mappings

A
Block
mapping
 is a series of entries, each
presenting
 a
key: value pair
.
[187]  l+block-mapping(n)::=(
s-indent(n+m)ns-l-block-map-entry(n+m) )+/* For some fixed auto-detected
m
 &gt; 0 */

Example 8.16. Block Mappings
block mapping:·key: value&#8595;
Legend:
ns-l-block-map-entry(n)auto-detected
s-indent(n)%YAML 1.2
---
!!map {
? !!str "block mapping"
: !!map {
? !!str "key"
: !!str "value",
},
}
If the

?
indicator is specified, the optional value node must be specified on
a separate line, denoted by the

:
 indicator. Note that YAML allows
here the same
compact in-line notation
 described above for
block
sequence
 entries.
[188]  ns-l-block-map-entry(n)::=c-l-block-map-explicit-entry(n)|
ns-l-block-map-implicit-entry(n)
[189]  c-l-block-map-explicit-entry(n)::=c-l-block-map-explicit-key(n)(
l-block-map-explicit-value(n)|
e-node
 )

[190]  c-l-block-map-explicit-key(n)::=
?
s-l+block-indented(n,block-out)
[191]  l-block-map-explicit-value(n)::=s-indent(n)
:
s-l+block-indented(n,block-out)
Example 8.17. Explicit Block Mapping Entries
? explicit key # Empty value&#8595;
°? |
block key&#8595;
:·- one # Explicit compact
··- two # block value&#8595;
Legend:
c-l-block-map-explicit-key(n)l-block-map-explicit-value(n)e-node
%YAML 1.2
---
!!map {
? !!str "explicit key"
: !!str "",
? !!str "block key\n"
: !!seq [
!!str "one",
!!str "two",
],
}
If the
? indicator is omitted,
parsing
 needs to see past the
implicit key
, in the
same way as in the
single key: value pair
flow
mapping
. Hence, such
keys
are subject to the same restrictions; they are limited to a single
line and must not span more than 1024 Unicode characters.
[192]  ns-l-block-map-implicit-entry(n)::=(
ns-s-block-map-implicit-key
|
e-node
 )c-l-block-map-implicit-value(n)
[193]  ns-s-block-map-implicit-key
::=c-s-implicit-json-key(block-key)|
ns-s-implicit-yaml-key(block-key)
In this case, the
value
 may be
specified on the same line as the
implicit key
. Note however that in
block mappings the
value
 must
never be adjacent to the
:, as this greatly reduces
readability and is not required for
JSON compatibility
 (unlike the case in
flow
mappings
).
There is no compact notation for in-line
values
. Also, while both the
implicit key
 and the
value
 following it may be empty,
the

:
indicator is mandatory. This prevents a potential ambiguity with
multi-line
plain scalars
.
[194]  c-l-block-map-implicit-value(n)::=
:
(
s-l+block-node(n,block-out)| (
e-node
s-l-comments
 ) )

Example 8.18. Implicit Block Mapping Entries
plain key
: in-line value
°:° # Both empty
"quoted key":
- entry
Legend:
ns-s-block-map-implicit-key
c-l-block-map-implicit-value(n)%YAML 1.2
---
!!map {
? !!str "plain key"
: !!str "in-line value",
? !!null ""
: !!null "",
? !!str "quoted key"
: !!seq [ !!str "entry" ],
}
A
compact in-line notation
 is also available.
This compact notation may be nested inside
block sequences
 and
explicit block mapping entries. Note that it is not possible to
specify
node
properties
 for such a nested mapping.
[195]  ns-l-compact-mapping(n)::=ns-l-block-map-entry(n)(
s-indent(n)ns-l-block-map-entry(n) )*

Example 8.19. Compact Block Mappings
-
sun: yellow&#8595;
-
?
earth: blue&#8595;
:
moon: white&#8595;
Legend:
ns-l-compact-mapping(n)%YAML 1.2
---
!!seq [
!!map {
!!str "sun" : !!str "yellow",
},
!!map {
? !!map {
? !!str "earth"
: !!str "blue"
},
: !!map {
? !!str "moon"
: !!str "white"
},
}
]


8.2.3. Block Nodes

YAML allows
flow
nodes
 to be embedded inside
block collections
(but not vice-versa).
Flow
nodes
 must be
indented
 by at least one more
space
 than the parent
block
collection
. Note that
flow nodes
 may begin on a following line.
It is at this point that
parsing
needs to distinguish between a
plain scalar
 and an
implicit key
starting a nested
block mapping
.
[196]  s-l+block-node(n,c)::=s-l+block-in-block(n,c)|
s-l+flow-in-block(n)
[197]  s-l+flow-in-block(n)::=s-separate(n+1,flow-out)ns-flow-node(n+1,flow-out)s-l-comments

Example 8.20. Block Node Types
-&#8595;
··"flow in block"&#8595;
-·&gt;
Block scalar&#8595;
-·!!map # Block collection
foo : bar&#8595;
Legend:
s-l+flow-in-block(n)s-l+block-in-block(n,c)%YAML 1.2
---
!!seq [
!!str "flow in block",
!!str "Block scalar\n",
!!map {
? !!str "foo"
: !!str "bar",
},
]
The block
node's
properties
 may span across several lines. In this case,
they must be
indented
 by at least one more
space
 than the
block
collection
, regardless of the
indentation
 of the
block
collection
 entries.
[198]  s-l+block-in-block(n,c)::=s-l+block-scalar(n,c)|
s-l+block-collection(n,c)
[199]  s-l+block-scalar(n,c)::=s-separate(n+1,c)(
c-ns-properties(n+1,c)s-separate(n+1,c) )?(
c-l+literal(n)|
c-l+folded(n) )

Example 8.21. Block Scalar Nodes
literal:
|2
··value
folded:&#8595;
···!foo
··&gt;1
·value
Legend:
c-l+literal(n)
c-l+folded(n)%YAML 1.2
---
!!map {
? !!str "literal"
: !!str "value",
? !!str "folded"
: !&lt;!foo&gt; "value",
}
Since people perceive the

- indicator
 as
indentation
, nested
block
sequences
 may be
indented
 by one less
space
 to compensate, except, of course, if
nested inside another
block sequence
 (block-out
context
 vs.
block-in
context
).
[200]  s-l+block-collection(n,c)::=(
s-separate(n+1,c)c-ns-properties(n+1,c) )?s-l-comments
(
l+block-sequence(seq-spaces(n,c))|
l+block-mapping(n) )

[201]  seq-spaces(n,c)::=c
 = block-out &#8658; n-1
c
 = block-in  &#8658; n

Example 8.22. Block Collection Nodes
sequence: !!seq
- entry
- !!seq
- nested
mapping: !!map
 foo: bar
Legend:
l+block-sequence(n)l+block-mapping(n)s-l+block-collection(n,c)%YAML 1.2
---
!!map {
? !!str "sequence"
: !!seq [
!!str "entry",
!!seq [ !!str "nested" ],
],
? !!str "mapping"
: !!map {
? !!str "foo" : !!str "bar",
},
}


Chapter 9. YAML Character Stream

9.1. Documents

A YAML character
stream
 may contain
several
documents
. Each document
is completely independent from the rest.


9.1.1. Document Prefix

A document may be preceded by a
prefix
 specifying the
character encoding
, and
optional
comment
 lines. Note
that all
documents
 in a stream
must use the same
character
encoding
. However it is valid to re-specify the
encoding
 using a
byte order mark
 for each
document
 in the stream. This makes it
easier to concatenate streams.
The existence of the optional prefix does not necessarily indicate
the existence of an actual
document
.
[202]  l-document-prefix
::=c-byte-order-mark
?
l-comment
*

Example 9.1. Document Prefix
&#8660;# Comment
# lines
Document
Legend:
l-document-prefix
%YAML 1.2
---
!!str "Document"


9.1.2. Document Markers

Using
directives
 creates a
potential ambiguity. It is valid to have a

%
 character at the start of a
line (e.g. as the first character of the second line of a
plain
scalar
). How, then, to distinguish between an actual
directive
 and a
content
 line that happens to start with a

%
character?
The solution is the use of two special
marker
 lines to control the processing of
directives
, one at the start
of a
document
 and one at the
end.
At the start of a
document
,
lines beginning with a

%
 character are assumed to be
directives
. The (possibly
empty) list of
directives
 is
terminated by a
directives end marker
 line. Lines following this
marker can safely use

%
 as the first character.
At the end of a
document
, a
document end
marker
 line is used to signal the
parser
 to begin scanning for
directives
 again.
The existence of this optional
document suffix
 does not necessarily
indicate the existence of an actual following
document
.
Obviously, the actual
content
lines are therefore forbidden to begin with either of these markers.
[203]  c-directives-end
::=
-
-
-

[204]  c-document-end
::=
.
.
.

[205]  l-document-suffix
::=c-document-end
s-l-comments

[206]  c-forbidden
::=/* Start of line */(
c-directives-end
|
c-document-end
 )(
b-char
|
s-white
| /* End of file */ )

Example 9.2. Document Markers
%YAML 1.2
---Document
... # Suffix
%YAML 1.2
---
!!str "Document"
Legend:
c-directives-end

c-document-end
l-document-suffix


9.1.3. Bare Documents

A
bare
document
 does not begin with any
directives
 or
marker
 lines. Such documents are very

clean
 as they contain nothing other than the
content
. In this case, the first
non-comment line may not start with a

%
 first character.
Document
nodes
 are
indented
 as if they
have a parent
indented
 at -1
spaces
. Since a
node
 must be more
indented
 than its parent
node
, this allows the document's
node
 to be
indented
 at zero or more
spaces
.
[207]  l-bare-document
::=s-l+block-node(-1,block-in)/* Excluding
c-forbidden
 content */

Example 9.3. Bare Documents
Bare
document
...
# No document
...
|
%!PS-Adobe-2.0 # Not the first line
%YAML 1.2
---
!!str "Bare document"
%YAML 1.2
---
!!str "%!PS-Adobe-2.0\n"
 Legend:
l-bare-document


9.1.4. Explicit Documents

An
explicit
document
 begins with an explicit
directives end marker
 line but
no
directives
. Since the
existence of the
document
 is
indicated by this
marker
, the
document
 itself may be
completely
empty
.
[208]  l-explicit-document
::=c-directives-end
(
l-bare-document
| (
e-node
s-l-comments
 ) )

Example 9.4. Explicit Documents
---{ matches
% : 20 }...
---
# Empty
...
 Legend:
l-explicit-document
%YAML 1.2
---
!!map {
!!str "matches %": !!int "20"
}
...
%YAML 1.2
---
!!null ""


9.1.5. Directives Documents

A
directives
document
 begins with some
directives
 followed by an explicit
directives end
marker
 line.
[209]  l-directive-document
::=l-directive
+l-explicit-document

Example 9.5. Directives Documents
%YAML 1.2
--- |
%!PS-Adobe-2.0
...
%YAML1.2
---
# Empty
...
 Legend:
l-explicit-document
%YAML 1.2
---
!!str "%!PS-Adobe-2.0\n"
...
%YAML 1.2
---
!!null ""


9.2. Streams

A YAML
stream
 consists of zero or
more
documents
. Subsequent
documents
 require some sort of
separation
marker
 line. If a
document
 is not terminated by a
document end
marker
 line, then the following
document
 must begin with a
directives end
marker
 line.
The stream format is intentionally
sloppy
 to better
support common use cases, such as stream concatenation.
[210]  l-any-document
::=l-directive-document
|
l-explicit-document
|
l-bare-document

[211]  l-yaml-stream
::=l-document-prefix
*
l-any-document
?(
l-document-suffix
+
l-document-prefix
*
l-any-document
?|
l-document-prefix
*
l-explicit-document
? )*

Example 9.6. Stream
Document
---
# Empty
...
%YAML 1.2
---
matches %: 20
 Legend:
l-any-document
l-document-suffix
l-explicit-document
%YAML 1.2
---
!!str "Document"
...
%YAML 1.2
---
!!null ""
...
%YAML 1.2
---
!!map {
!!str "matches %": !!int "20"
}
A sequence of bytes is a
well-formed stream
 if, taken as a
whole, it complies with the above
l-yaml-stream
production.
Some common use case that can take advantage of the YAML stream
structure are:
Appending to Streams
Allowing multiple
documents
in a single stream makes YAML suitable for log files and similar
applications
. Note that
each
document
 is independent
of the rest, allowing for heterogeneous log file entries.
Concatenating Streams
Concatenating two YAML streams requires both to use the same
character
encoding
. In addition, it is necessary to separate the
last
document
 of the first
stream and the first
document
 of the second stream. This
is easily ensured by inserting a
document end marker
 between
the two streams. Note that this is safe regardless of the content
of either stream. In particular, either or both may be empty, and
the first stream may or may not already contain such a marker.
Communication Streams
The
document
end marker
 allows signaling the end of a
document
 without closing the stream
or starting the next
document
. This allows the receiver
to complete processing a
document
 without having to wait for
the next one to arrive. The sender may also transmit "keep-alive"
messages in the form of
comment
 lines or repeated
document end
markers
 without signalling the start of the next
document
.


Chapter 10. Recommended Schemas

A YAML
schema
 is a combination of a
set of
tags
 and a mechanism for
resolving

non-specific tags
.
10.1. Failsafe Schema
The
failsafe
schema
 is guaranteed to work with any YAML
document
. It is therefore the recommended
schema
 for generic YAML tools. A
YAML
processor
 should therefore
support this
schema
, at least as an
option.
10.1.1. Tags
10.1.1.1.
Generic Mapping
URI:
tag:yaml.org,2002:map
Kind:
Mapping
.
Definition:
Represents
 an
associative container, where each
key
 is unique in the association and
mapped to exactly one
value
.  YAML places no restrictions
on the type of
keys
; in
particular, they are not restricted to being
scalars
. Example
bindings
 to
native
 types
include Perl's hash, Python's dictionary, and Java's
Hashtable.
Example 10.1.
!!map
 Examples
Block style: !!map
  Clark : Evans
Ingy  : döt Net
Oren  : Ben-Kiki

Flow style: !!map { Clark: Evans, Ingy: döt Net, Oren: Ben-Kiki }
10.1.1.2.
Generic Sequence
URI:
tag:yaml.org,2002:seq
Kind:
Sequence
.
Definition:
Represents
 a
collection indexed by sequential integers starting with zero.
Example
bindings
 to
native
types include Perl's array, Python's list or tuple, and
Java's array or Vector.
Example 10.2.
!!seq
 Examples
Block style: !!seq
- Clark Evans
- Ingy döt Net
- Oren Ben-Kiki

Flow style: !!seq [ Clark Evans, Ingy döt Net, Oren Ben-Kiki ]
10.1.1.3.
Generic String
URI:
tag:yaml.org,2002:str
Kind:
Scalar
.
Definition:
Represents
 a Unicode
string, a sequence of zero or more Unicode characters. This
type is usually
bound
to the
native
 language's string type, or,
for languages lacking one (such as C), to a character array.
Canonical Form:
The obvious.
Example 10.3.
!!str
 Examples
Block style: !!str |-  String: just a theory.

Flow style: !!str "String: just a theory."
10.1.2. Tag Resolution
All
nodes
 with the

! non-specific tag
 are
resolved
, by the
standard
convention
, to

tag:yaml.org,2002:seq
,

tag:yaml.org,2002:map
, or

tag:yaml.org,2002:str
, according to their
kind
.
All
nodes
 with the

? non-specific
tag
 are left
unresolved
. This constrains the
application
 to deal with  a
partial
representation
.
10.2. JSON Schema
The
JSON schema
 is
the lowest common denominator of most modern computer languages, and
allows
parsing
 JSON files. A YAML
processor
 should therefore
support this
schema
, at least as an
option. It is also strongly recommended that other
schemas
 should be based on it.
10.2.1. Tags
The JSON
schema
 uses the
following
tags
 in addition to those
defined by the
failsafe
 schema:
10.2.1.1.
Null
URI:
tag:yaml.org,2002:null
Kind:
Scalar
.
Definition:
Represents
 the lack
of a value. This is typically
bound
 to a
native
 null-like
value (e.g.,
undef
 in Perl,
None
 in Python). Note that a null is
different from an empty string. Also, a
mapping
 entry with some
key
 and a null
value
 is valid, and different
from not having that
key
in the
mapping
.
Canonical Form:
null
.
Example 10.4.
!!null
 Examples
!!null null: value for null key
key with null value: !!null null
10.2.1.2.
Boolean
URI:
tag:yaml.org,2002:bool
Kind:
Scalar
.
Definition:
Represents
 a
true/false value. In languages without a
native
 Boolean type
(such as C), is usually
bound
 to a native integer
type, using one for true and zero for false.
Canonical Form:
Either
true
 or
false
.
Example 10.5.
!!bool
 Examples
YAML is a superset of JSON: !!bool true
Pluto is a planet: !!bool false
10.2.1.3.
Integer
URI:
tag:yaml.org,2002:int
Kind:
Scalar
.
Definition:
Represents
 arbitrary
sized finite mathematical integers. Scalars of this type
should be
bound
 to a
native
integer data type, if possible.
Some languages (such as Perl) provide only a

number
 type that allows for both integer and
floating-point values. A YAML
processor
 may use such a type
for integers, as long as they round-trip properly.
In some languages (such as C), an integer may overflow the
native
type's storage capability. A YAML
processor
 may reject such a
value as an error, truncate it with a warning, or find some
other manner to round-trip it. In general, integers
representable using 32 binary digits should safely round-trip
through most systems.
Canonical Form:
Decimal integer notation, with a leading
-
character for negative values, matching the regular expression
0 | -? [1-9] [0-9]*Example 10.6.
!!int
 Examples
negative: !!int -12
zero: !!int 0
positive: !!int 34
10.2.1.4.
Floating Point
URI:
tag:yaml.org,2002:float
Kind:
Scalar
.
Definition:
Represents
 an
approximation to real numbers, including three special values
(positive and negative infinity, and
not a
number
).
Some languages (such as Perl) provide only a

number
 type that allows for both integer and
floating-point values. A YAML
processor
 may use such a type
for floating-point numbers, as long as they round-trip
properly.
Not all floating-point values can be stored exactly in any
given
native
 type. Hence a float value may
change by
a small amount
 when round-tripped.
The supported range and accuracy depends on the
implementation, though 32 bit IEEE floats should be safe.
Since YAML does not specify a particular accuracy, using
floating-point
mapping keys
requires great care and is not recommended.
Canonical Form:
Either
0
,
.inf
,
-.inf
,
.nan
, or
scientific notation matching the regular expression
-? [1-9] ( \. [0-9]* [1-9] )? ( e [-+] [1-9] [0-9]* )?.
Example 10.7.
!!float
 Examples
negative: !!float -1
zero: !!float 0
positive: !!float 2.3e4
infinity: !!float .inf
not a number: !!float .nan
10.2.2. Tag Resolution
The
JSON schema
tag
resolution
 is an extension of the
failsafe schema

tag resolution
.
All
nodes
 with the

! non-specific tag
 are
resolved
, by the
standard
convention
, to

tag:yaml.org,2002:seq
,

tag:yaml.org,2002:map
, or

tag:yaml.org,2002:str
, according to their
kind
.
Collections
 with the

? non-specific
tag
 (that is,
untagged

collections
) are
resolved
 to

tag:yaml.org,2002:seq
 or

tag:yaml.org,2002:map
 according to their
kind
.

Scalars
 with the

? non-specific
tag
 (that is,
plain scalars
) are matched with a list of
regular expressions (first match wins, e.g.
0
is resolved as
!!int
). In principle, JSON
files should not contain any
scalars
 that do not match at least one of
these. Hence the YAML
processor
 should consider them to be an
error.

Regular expression

 Resolved to tag

null

tag:yaml.org,2002:null

true | false

tag:yaml.org,2002:bool

-? ( 0 | [1-9] [0-9]* )
tag:yaml.org,2002:int

-? ( 0 | [1-9] [0-9]* ) ( \. [0-9]* )? ( [eE] [-+]? [0-9]+ )?
tag:yaml.org,2002:float

* Error
Example 10.8. JSON Tag Resolution
A null: null
Booleans: [ true, false ]
Integers: [ 0, -0, 3, -19 ]
Floats: [ 0., -0.0, 12e03, -2E+05 ]
Invalid: [ True, Null, 0o7, 0x3A, +12.3 ]
%YAML 1.2
---
!!map {
!!str "A null" : !!null "null",
!!str "Booleans: !!seq [
!!bool "true", !!bool "false"
],
!!str "Integers": !!seq [
!!int "0", !!int "-0",
!!int "3", !!int "-19"
],
!!str "Floats": !!seq [
!!float "0.", !!float "-0.0",
!!float "12e03", !!float "-2E+05"
],
!!str "Invalid": !!seq [
# Rejected by the schema
True, Null, 0o7, 0x3A, +12.3,
],
}
...
10.3. Core Schema
The
Core schema
 is
an extension of the
JSON
schema
, allowing for more human-readable
presentation
 of the same types. This is the
recommended default
schema
 that
YAML
processor
 should use unless
instructed otherwise. It is also strongly recommended that other
schemas
 should be based on it.
10.3.1. Tags
The core
schema
 uses the same
tags
 as the
JSON schema
.
10.3.2. Tag Resolution
The
core schema
tag
resolution
 is an extension of the
JSON schema

tag resolution
.
All
nodes
 with the

! non-specific tag
 are
resolved
, by the
standard
convention
, to

tag:yaml.org,2002:seq
,

tag:yaml.org,2002:map
, or

tag:yaml.org,2002:str
, according to their
kind
.
Collections
 with the

? non-specific
tag
 (that is,
untagged

collections
) are
resolved
 to

tag:yaml.org,2002:seq
 or

tag:yaml.org,2002:map
 according to their
kind
.
Scalars
 with the

? non-specific
tag
 (that is,
plain scalars
) are matched with an
extended list of regular expressions. However, in this case, if none
of the regular expressions matches, the
scalar
 is
resolved
 to
tag:yaml.org,2002:str
 (that is, considered to
be a string).

Regular expression

 Resolved to tag

null | Null | NULL | ~
tag:yaml.org,2002:null

/* Empty */
tag:yaml.org,2002:null

true | True | TRUE | false | False | FALSE

tag:yaml.org,2002:bool

[-+]? [0-9]+
tag:yaml.org,2002:int

(Base 10)
0o [0-7]+
tag:yaml.org,2002:int

(Base 8)
0x [0-9a-fA-F]+
tag:yaml.org,2002:int

(Base 16)
[-+]? ( \. [0-9]+ | [0-9]+ ( \. [0-9]* )? ) ( [eE] [-+]? [0-9]+ )?
tag:yaml.org,2002:float

(Number)
[-+]? ( \.inf | \.Inf | \.INF )
tag:yaml.org,2002:float

(Infinity)
\.nan | \.NaN | \.NAN

tag:yaml.org,2002:float

(Not a number)
*
tag:yaml.org,2002:str

(Default)Example 10.9. Core Tag Resolution
A null: null
Also a null: # Empty
Not a null: ""
Booleans: [ true, True, false, FALSE ]
Integers: [ 0, 0o7, 0x3A, -19 ]
Floats: [ 0., -0.0, .5, +12e03, -2E+05 ]
Also floats: [ .inf, -.Inf, +.INF, .NAN ]
%YAML 1.2
---
!!map {
!!str "A null" : !!null "null",
!!str "Also a null" : !!null "",
!!str "Not a null" : !!str "",
!!str "Booleans: !!seq [
!!bool "true", !!bool "True",
!!bool "false", !!bool "FALSE",
],
!!str "Integers": !!seq [
!!int "0", !!int "0o7",
!!int "0x3A", !!int "-19",
],
!!str "Floats": !!seq [
!!float "0.", !!float "-0.0", !!float ".5",
!!float "+12e03", !!float "-2E+05"
],
!!str "Also floats": !!seq [
!!float ".inf", !!float "-.Inf",
!!float "+.INF", !!float ".NAN",
],
}
...
10.4. Other Schemas
None of the above recommended
schemas
 preclude the use of arbitrary
explicit
tags
. Hence YAML
processors
 for a particular programming
language typically provide some form of
local tags
 that map directly to the
language's
native data
structures
 (e.g.,
!ruby/object:Set
).
While such
local
tags
 are useful for ad-hoc
applications
, they do not suffice for
stable, interoperable cross-application
 or cross-platform data
exchange.
Interoperable
schemas
 make use of
global tags
 (URIs)
that
represent
 the same data
across different programming languages. In addition, an interoperable
schema
 may provide additional
tag resolution
rules. Such rules may provide additional regular expressions, as well
as consider the path to the
node
.
This allows interoperable
schemas
to use
untagged

nodes
.
It is strongly recommended that such
schemas
 be based on the
core schema
 defined above.
In addition, it is strongly recommended that such
schemas
 make as much use as possible of the
the
YAML tag
repository
 at
http://yaml.org/type/. This
repository provides recommended
global tags
 for increasing the portability
of YAML
documents
 between
different
applications
.
The tag repository is intentionally left out of the scope of this
specification. This allows it to evolve to better support YAML
applications
. Hence, developers are
encouraged to submit new
universal
 types to the
repository. The yaml-core mailing list at
http://lists.sourceforge.net/lists/listinfo/yaml-core
 is the
preferred method for such submissions, as well as raising any questions
regarding this draft.
Index
Indicators
! tag         indicator,
Tags
,
Indicator Characters
,
Node Tags
! local tag,
Tags
,
Tag Handles
,
Tag Prefixes
,
Node Tags
! non-specific           tag,
Resolved Tags
,
Node Tags
,
Tag Resolution
,
Tag Resolution
,
Tag Resolution
! primary tag                   handle,
Tag Handles
!!                   secondary tag handle,
Tag Handles
!&#8230;! named                   handle,
Tag Handles
,
Node Tags
" double-quoted           style,
Indicator Characters
,
Double-Quoted Style
# comment,
Collections
,
Indicator Characters
,
Comments
,
Plain Style
,
Block Indentation Indicator
% directive,
Indicator Characters
,
Directives
,
Document Markers
,
Bare Documents
% escaping in URI,
Tags
,
Miscellaneous Characters
,
Node Tags
&amp;         anchor,
Structures
,
Indicator Characters
,
Node Anchors
' reserved           indicator,
Indicator Characters
' single-quoted           style,
Indicator Characters
,
Single-Quoted Style
*         alias,
Structures
,
Indicator Characters
,
Alias Nodes
+ keep                 chomping,
Block Chomping Indicator
, end flow entry,
Collections
,
Indicator Characters
,
Miscellaneous Characters
,
Node Tags
,
Node Anchors
,
Plain Style
,
Flow Collection Styles
,
Flow Sequences
,
Flow Mappings
- block sequence entry,
Introduction
,
Collections
,
Structures
,
Production Parameters
,
Indicator Characters
,
Indentation Spaces
,
Plain Style
,
Block Collection Styles
,
Block Sequences
,
Block Nodes
- strip chomping,
Block Chomping Indicator
: mapping value,
Introduction
,
Collections
,
Structures
,
Indicator Characters
,
Indentation Spaces
,
Plain Style
,
Flow Mappings
,
Block Mappings
&lt;&#8230;&gt; verbatim               tag,
Node Tags
&gt; folded style,
Scalars
,
Indicator Characters
,
Folded Style
? mapping         key,
Structures
,
Indicator Characters
,
Indentation Spaces
,
Plain Style
,
Flow Mappings
,
Block Mappings
? non-specific tag,
Resolved Tags
,
Node Tags
,
Tag Resolution
,
Tag Resolution
,
Tag Resolution
@ reserved           indicator,
Indicator Characters
[ start flow sequence,
Collections
,
Indicator Characters
,
Miscellaneous Characters
,
Node Tags
,
Node Anchors
,
Plain Style
,
Flow Sequences
\ escaping in double-quoted         scalars,
Escaped Characters
,
Double-Quoted Style
] end flow sequence,
Collections
,
Indicator Characters
,
Miscellaneous Characters
,
Node Tags
,
Node Anchors
,
Plain Style
,
Flow Sequences
{ start flow         mapping,
Collections
,
Indicator Characters
,
Miscellaneous Characters
,
Node Tags
,
Node Anchors
,
Plain Style
,
Flow Mappings
| literal style,
Scalars
,
Indicator Characters
,
Literal Style
} end flow         mapping,
Collections
,
Indicator Characters
,
Miscellaneous Characters
,
Node Tags
,
Node Anchors
,
Plain Style
,
Flow Mappings
prefix,
Document Prefix
A
alias,
Introduction
,
Prior Art
,
Structures
,
Dump
,
Serialization Tree
,
Anchors and Aliases
,
Loading Failure Points
,
Well-Formed Streams and Identified Aliases
,
Resolved Tags
,
Indicator Characters
,
Node Anchors
,
Flow Styles
,
Alias Nodes
,
Flow Nodes
identified,
Structures
,
Anchors and Aliases
,
Well-Formed Streams and Identified Aliases
unidentified,
Loading Failure Points
,
Well-Formed Streams and Identified Aliases
anchor,
Structures
,
Dump
,
Serialization Tree
,
Anchors and Aliases
,
Well-Formed Streams and Identified Aliases
,
Resolved Tags
,
Indicator Characters
,
Node Properties
,
Flow Styles
,
Alias Nodes
,
Flow Nodes
application,
Introduction
,
Prior Art
,
Tags
,
Processing YAML Information
,
Dump
,
Information Models
,
Tags
,
Serialization Tree
,
Keys Order
,
Resolved Tags
,
Available Tags
,
Tag Prefixes
,
Node Tags
,
Streams
,
Tag Resolution
,
Other Schemas
B
block scalar header,
Comments
,
Block Scalar Headers
,
Block Chomping Indicator
byte order mark,
Character Encodings
,
Document Prefix
C
character encoding,
Character Encodings
,
Document Prefix
,
Streams
in URI,
Miscellaneous Characters
chomping,
Production Parameters
,
Line Folding
,
Block Chomping Indicator
,
Literal Style
,
Folded Style
clip,
Production Parameters
,
Block Chomping Indicator
keep,
Production Parameters
,
Block Chomping Indicator
strip,
Production Parameters
,
Block Chomping Indicator
collection,
Prior Art
,
Representation Graph
,
Nodes
,
Node Comparison
,
Anchors and Aliases
,
Node Styles
,
Comments
,
Resolved Tags
,
Recognized and Valid Tags
,
Tag Resolution
,
Tag Resolution
comment,
Collections
,
Processes
,
Dump
,
Load
,
Presentation Stream
,
Comments
,
Resolved Tags
,
Indicator Characters
,
Comments
,
Separation Lines
,
Plain Style
,
Block Scalar Headers
,
Block Chomping Indicator
,
Document Prefix
,
Streams
compose,
Processes
,
Load
,
Keys Order
,
Anchors and Aliases
,
Resolved Tags
,
Recognized and Valid Tags
,
Available Tags
,
Node Anchors
construct,
Processes
,
Load
,
Serialization Tree
,
Loading Failure Points
,
Recognized and Valid Tags
,
Available Tags
,
Flow Styles
,
Generic Mapping
,
Generic Sequence
,
Generic String
,
Null
,
Boolean
,
Integer
content,
Structures
,
Dump
,
Nodes
,
Tags
,
Node Comparison
,
Loading Failure Points
,
Resolved Tags
,
Recognized and Valid Tags
,
Character Encodings
,
Line Break Characters
,
Escaped Characters
,
Indentation Spaces
,
Separation Spaces
,
Line Prefixes
,
Empty Lines
,
Line Folding
,
Comments
,
Directives
,
Tag Handles
,
Node Properties
,
Node Tags
,
Node Anchors
,
Alias Nodes
,
Empty Nodes
,
Flow Scalar Styles
,
Double-Quoted Style
,
Single-Quoted Style
,
Plain Style
,
Block Scalar Headers
,
Block Indentation Indicator
,
Block Chomping Indicator
,
Literal Style
,
Document Markers
,
Bare Documents
valid,
Recognized and Valid Tags
context,
Production Parameters
,
Plain Style
block-in,
Production Parameters
,
Block Nodes
block-key,
Production Parameters
,
Flow Collection Styles
block-out,
Production Parameters
,
Block Nodes
flow-in,
Production Parameters
,
Flow Collection Styles
flow-key,
Production Parameters
,
Flow Collection Styles
flow-out,
Production Parameters
,
Flow Collection Styles
D
directive,
Structures
,
Dump
,
Load
,
Presentation Stream
,
Directives
,
Indicator Characters
,
Directives
,
Document Markers
,
Bare Documents
,
Explicit Documents
,
Directives Documents
reserved,
Directives
,
Directives
TAG,
Tags
,
Directives
,
Indicator Characters
,
Directives
,
TAG Directives
,
Node Tags
YAML,
Directives
,
Directives
,
YAML Directives
document,
Prior Art
,
Structures
,
Presentation Stream
,
Directives
,
Loading Failure Points
,
Resolved Tags
,
Recognized and Valid Tags
,
Character Encodings
,
Line Break Characters
,
YAML Directives
,
Tag Prefixes
,
Alias Nodes
,
Documents
,
Document Prefix
,
Document Markers
,
Explicit Documents
,
Streams
,
Failsafe Schema
,
Other Schemas
bare,
Bare Documents
directives,
Directives Documents
explicit,
Explicit Documents
suffix,
Document Markers
dump,
Processes
,
Dump
E
empty         line,
Prior Art
,
Scalars
,
Empty Lines
,
Line Folding
,
Block Indentation Indicator
,
Block Chomping Indicator
,
Literal Style
,
Folded Style
equality,
Relation to JSON
,
Dump
,
Representation Graph
,
Nodes
,
Tags
,
Node Comparison
,
Scalar Formats
,
Loading Failure Points
,
Recognized and Valid Tags
escaping
in         double-quoted scalars,
Prior Art
,
Scalars
,
Character Set
,
Character Encodings
,
Miscellaneous Characters
,
Escaped Characters
,
Double-Quoted Style
in           single-quoted scalars,
Single-Quoted Style
in             URIs,
Miscellaneous Characters
non-content line           break,
Double-Quoted Style
I
identity,
Node Comparison
indicator,
Introduction
,
Prior Art
,
Collections
,
Node Styles
,
Production Parameters
,
Indicator Characters
,
Line Folding
,
Plain Style
,
Flow Mappings
,
Flow Nodes
,
Block Styles
,
Block Scalar Headers
,
Block Collection Styles
indentation,
Block Indentation Indicator
reserved,
Indicator Characters
information model,
Information Models
invalid         content,
Loading Failure Points
,
Recognized and Valid Tags
J
JSON compatibility,
Character Set
,
Character Encodings
,
Line Break Characters
,
Escaped Characters
,
Comments
,
YAML Directives
,
Flow Mappings
,
Block Mappings
JSON-like,
Flow Mappings
,
Flow Nodes
K
key,
Relation to JSON
,
Structures
,
Dump
,
Information Models
,
Representation Graph
,
Nodes
,
Node Comparison
,
Serialization Tree
,
Keys Order
,
Resolved Tags
,
Indicator Characters
,
Flow Mappings
,
Block Mappings
,
Generic Mapping
,
Null
,
Floating Point
implicit,
Separation Lines
,
Double-Quoted Style
,
Single-Quoted Style
,
Plain Style
,
Flow Collection Styles
,
Flow Mappings
,
Block Mappings
,
Block Nodes
order,
Processes
,
Dump
,
Load
,
Information Models
,
Serialization Tree
,
Keys Order
key: value pair,
Introduction
,
Collections
,
Structures
,
Nodes
,
Keys Order
,
Node Styles
,
Plain Style
,
Flow Mappings
,
Block Collection Styles
,
Block Mappings
kind,
Dump
,
Representation Graph
,
Nodes
,
Tags
,
Node Comparison
,
Node Styles
,
Resolved Tags
,
Node Tags
,
Tag Resolution
,
Tag Resolution
,
Tag Resolution
L
line break,
Prior Art
,
Scalars
,
Production Parameters
,
Production Naming Conventions
,
Line Break Characters
,
White Space Characters
,
Empty Lines
,
Line Folding
,
Comments
,
Double-Quoted Style
,
Block Scalar Headers
,
Block Chomping Indicator
,
Literal Style
,
Folded Style
non-ASCII,
Line Break Characters
,
YAML Directives
normalization,
Line Break Characters
,
Literal Style
line folding,
Prior Art
,
Scalars
,
Line Folding
,
Flow Styles
,
Double-Quoted Style
,
Single-Quoted Style
,
Plain Style
,
Block Chomping Indicator
,
Folded Style
block,
Line Folding
,
Folded Style
flow,
Line Folding
,
Double-Quoted Style
line prefix,
Line Prefixes
,
Empty Lines
load,
Processes
,
Load
,
Loading Failure Points
failure               point,
Load
,
Loading Failure Points
M
mapping,
Introduction
,
Prior Art
,
Relation to JSON
,
Collections
,
Structures
,
Dump
,
Representation Graph
,
Nodes
,
Tags
,
Node Comparison
,
Keys Order
,
Resolved Tags
,
Plain Style
,
Flow Sequences
,
Flow Mappings
,
Generic Mapping
,
Null
marker,
Presentation Stream
,
Document Markers
,
Bare Documents
,
Explicit Documents
,
Streams
directives end,
Structures
,
Document Markers
,
Explicit Documents
,
Directives Documents
,
Streams
document         end,
Structures
,
Document Markers
,
Streams
more-indented,
Scalars
,
Line Folding
,
Folded Style
N
native data structure,
Introduction
,
Goals
,
Prior Art
,
Relation to JSON
,
Processing YAML Information
,
Processes
,
Dump
,
Load
,
Representation Graph
,
Nodes
,
Tags
,
Node Comparison
,
Serialization Tree
,
Loading Failure Points
,
Recognized and Valid Tags
,
Available Tags
,
Node Tags
,
Flow Styles
,
Generic Mapping
,
Generic Sequence
,
Generic String
,
Null
,
Boolean
,
Integer
,
Floating Point
,
Other Schemas
need not,
Terminology
node,
Structures
,
Dump
,
Representation Graph
,
Nodes
,
Tags
,
Node Comparison
,
Serialization Tree
,
Keys Order
,
Anchors and Aliases
,
Presentation Stream
,
Node Styles
,
Comments
,
Loading Failure Points
,
Well-Formed Streams and Identified Aliases
,
Resolved Tags
,
Recognized and Valid Tags
,
Syntax Conventions
,
Indentation Spaces
,
Node Properties
,
Node Tags
,
Node Anchors
,
Alias Nodes
,
Empty Nodes
,
Flow Mappings
,
Flow Nodes
,
Block Indentation Indicator
,
Block Sequences
,
Bare Documents
,
Tag Resolution
,
Tag Resolution
,
Tag Resolution
,
Other Schemas
completely empty,
Empty Nodes
,
Flow Collection Styles
,
Flow Mappings
,
Block Sequences
,
Explicit Documents
property,
Node Properties
,
Alias Nodes
,
Empty Nodes
,
Flow Mappings
,
Flow Nodes
,
Block Sequences
,
Block Mappings
,
Block Nodes
root,
Representation Graph
,
Resolved Tags
P
parse,
Load
,
Presentation Stream
,
Resolved Tags
,
Production Parameters
,
Line Break Characters
,
Escaped Characters
,
Tag Handles
,
Node Tags
,
Flow Mappings
,
Block Mappings
,
Block Nodes
,
Document Markers
,
JSON Schema
present,
Processing YAML Information
,
Dump
,
Load
,
Nodes
,
Node Comparison
,
Presentation Stream
,
Scalar Formats
,
Character Set
,
Miscellaneous Characters
,
Node Tags
,
Alias Nodes
,
Block Mappings
,
Core Schema
presentation,
Processing YAML Information
,
Information Models
,
Presentation Stream
,
Production Parameters
detail,
Dump
,
Load
,
Information Models
,
Presentation Stream
,
Node Styles
,
Scalar Formats
,
Comments
,
Directives
,
Resolved Tags
,
Character Encodings
,
Line Break Characters
,
Escaped Characters
,
Indentation Spaces
,
Separation Spaces
,
Line Prefixes
,
Line Folding
,
Comments
,
Directives
,
Tag Handles
,
Node Tags
,
Flow Scalar Styles
,
Block Chomping Indicator
printable character,
Introduction
,
Prior Art
,
Character Set
,
White Space Characters
,
Escaped Characters
,
Single-Quoted Style
,
Literal Style
processor,
Terminology
,
Processing YAML Information
,
Dump
,
Node Comparison
,
Presentation Stream
,
Directives
,
Well-Formed Streams and Identified Aliases
,
Resolved Tags
,
Recognized and Valid Tags
,
Available Tags
,
Character Set
,
Character Encodings
,
Line Break Characters
,
Miscellaneous Characters
,
Comments
,
Directives
,
YAML Directives
,
Tag Handles
,
Node Tags
,
Node Anchors
,
Flow Mappings
,
Block Indentation Indicator
,
Failsafe Schema
,
JSON Schema
,
Integer
,
Floating Point
,
Tag Resolution
,
Core Schema
,
Other Schemas
R
represent,
Introduction
,
Prior Art
,
Dump
,
Tags
,
Node Comparison
,
Keys Order
,
Generic Mapping
,
Generic Sequence
,
Generic String
,
Null
,
Boolean
,
Integer
,
Floating Point
,
Other Schemas
representation,
Processing YAML Information
,
Processes
,
Dump
,
Load
,
Information Models
,
Representation Graph
,
Nodes
,
Node Comparison
,
Serialization Tree
,
Keys Order
,
Anchors and Aliases
,
Presentation Stream
,
Node Styles
,
Scalar Formats
,
Comments
,
Directives
,
Available Tags
,
Node Anchors
complete,
Loading Failure Points
,
Resolved Tags
,
Recognized and Valid Tags
,
Available Tags
partial,
Loading Failure Points
,
Resolved Tags
,
Recognized and Valid Tags
,
Tag Resolution
required,
Terminology
S
scalar,
Introduction
,
Prior Art
,
Scalars
,
Dump
,
Representation Graph
,
Nodes
,
Tags
,
Node Comparison
,
Scalar Formats
,
Comments
,
Recognized and Valid Tags
,
Line Break Characters
,
Separation Spaces
,
Line Prefixes
,
Comments
,
Empty Nodes
,
Block Chomping Indicator
,
Generic Mapping
,
Generic String
,
Null
,
Boolean
,
Integer
,
Floating Point
,
Tag Resolution
,
Tag Resolution
canonical form,
Prior Art
,
Tags
,
Node Comparison
,
Scalar Formats
,
Loading Failure Points
content format,
Dump
,
Load
,
Tags
,
Node Comparison
,
Presentation Stream
,
Scalar Formats
,
Loading Failure Points
schema,
Recommended Schemas
,
Failsafe Schema
,
JSON Schema
,
Tags
,
Core Schema
,
Tags
,
Other Schemas
core,
Core Schema
,
Tag Resolution
,
Other Schemas
failsafe,
Tags
,
Failsafe Schema
,
Tags
,
Tag Resolution
JSON,
Tags
,
JSON Schema
,
Tag Resolution
,
Core Schema
,
Tags
,
Tag Resolution
sequence,
Introduction
,
Prior Art
,
Dump
,
Representation Graph
,
Nodes
,
Tags
,
Node Comparison
,
Keys Order
,
Resolved Tags
,
Flow Mappings
,
Generic Sequence
serialization,
Processing YAML Information
,
Processes
,
Dump
,
Load
,
Information Models
,
Serialization Tree
,
Anchors and Aliases
,
Presentation Stream
,
Node Styles
,
Scalar Formats
,
Comments
,
Directives
,
Node Anchors
detail,
Dump
,
Load
,
Information Models
,
Keys Order
,
Anchors and Aliases
,
Node Anchors
serialize,
Introduction
,
Prior Art
,
Relation to JSON
,
Dump
,
Load
,
Keys Order
,
Anchors and Aliases
,
Alias Nodes
shall,
Terminology
space,
Prior Art
,
Scalars
,
White Space Characters
,
Indentation Spaces
,
Line Folding
,
Single-Quoted Style
,
Plain Style
,
Block Indentation Indicator
,
Folded Style
,
Block Sequences
,
Block Nodes
,
Bare Documents
indentation,
Introduction
,
Prior Art
,
Collections
,
Dump
,
Load
,
Information Models
,
Node Styles
,
Resolved Tags
,
Production Parameters
,
Production Naming Conventions
,
Indentation Spaces
,
Separation Spaces
,
Line Prefixes
,
Line Folding
,
Comments
,
Separation Lines
,
Directives
,
Block Styles
,
Block Indentation Indicator
,
Block Chomping Indicator
,
Literal Style
,
Block Sequences
,
Block Nodes
,
Bare Documents
separation,
Separation Spaces
,
Comments
,
Flow Mappings
,
Block Sequences
white,
Production Naming Conventions
,
White Space Characters
,
Separation Spaces
,
Line Prefixes
,
Line Folding
,
Comments
,
Double-Quoted Style
,
Single-Quoted Style
,
Plain Style
,
Flow Mappings
,
Literal Style
,
Folded Style
,
Block Sequences
stream,
Prior Art
,
Processing YAML Information
,
Processes
,
Dump
,
Load
,
Presentation Stream
,
Loading Failure Points
,
Well-Formed Streams and Identified Aliases
,
Resolved Tags
,
Syntax Conventions
,
Character Set
,
Character Encodings
,
Miscellaneous Characters
,
Comments
,
Tag Prefixes
,
Empty Nodes
,
Documents
,
Streams
ill-formed,
Load
,
Loading Failure Points
,
Well-Formed Streams and Identified Aliases
well-formed,
Well-Formed Streams and Identified Aliases
,
Streams
style,
Dump
,
Load
,
Information Models
,
Presentation Stream
,
Node Styles
,
Scalar Formats
,
Resolved Tags
,
Node Tags
,
Double-Quoted Style
,
Plain Style
block,
Prior Art
,
Scalars
,
Node Styles
,
Production Parameters
,
Indentation Spaces
,
Block Styles
,
Block Sequences
collection,
Collections
,
Structures
,
Indentation Spaces
,
Flow Collection Styles
,
Block Collection Styles
,
Block Sequences
,
Block Nodes
folded,
Scalars
,
Node Styles
,
Indicator Characters
,
Line Folding
,
Block Scalar Styles
,
Literal Style
,
Folded Style
literal,
Prior Art
,
Scalars
,
Node Styles
,
Indicator Characters
,
Block Scalar Styles
,
Literal Style
,
Folded Style
mapping,
Node Styles
,
Production Parameters
,
Block Mappings
,
Block Nodes
scalar,
Node Styles
,
Block Scalar Styles
,
Block Scalar Headers
,
Block Indentation Indicator
,
Block Chomping Indicator
sequence,
Collections
,
Node Styles
,
Production Parameters
,
Indicator Characters
,
Block Sequences
,
Block Mappings
,
Block Nodes
compact block collection,
Node Styles
,
Block Sequences
,
Block Mappings
flow,
Prior Art
,
Collections
,
Scalars
,
Node Styles
,
Production Parameters
,
Line Folding
,
Flow Styles
,
Flow Sequences
,
Flow Nodes
,
Block Nodes
collection,
Syntax Conventions
,
Production Parameters
,
Indicator Characters
,
Miscellaneous Characters
,
Node Tags
,
Node Anchors
,
Plain Style
,
Flow Collection Styles
double-quoted,
Prior Art
,
Scalars
,
Node Styles
,
Syntax Conventions
,
Character Set
,
Character Encodings
,
Indicator Characters
,
Escaped Characters
,
Flow Scalar Styles
,
Double-Quoted Style
,
Flow Nodes
mapping,
Collections
,
Node Styles
,
Production Parameters
,
Indicator Characters
,
Flow Mappings
,
Block Mappings
plain,
Scalars
,
Node Styles
,
Resolved Tags
,
Production Parameters
,
Indicator Characters
,
Node Tags
,
Empty Nodes
,
Flow Scalar Styles
,
Plain Style
,
Flow Mappings
,
Flow Nodes
,
Block Collection Styles
,
Block Sequences
,
Block Mappings
,
Block Nodes
,
Document Markers
,
Tag Resolution
,
Tag Resolution
scalar,
Scalars
,
Node Styles
,
Line Prefixes
,
Line Folding
,
Flow Scalar Styles
sequence,
Collections
,
Node Styles
,
Indicator Characters
,
Flow Sequences
,
Flow Mappings
single-quoted,
Node Styles
,
Production Parameters
,
Indicator Characters
,
Flow Scalar Styles
,
Single-Quoted Style
scalar,
Node Styles
,
Escaped Characters
,
Empty Lines
,
Flow Scalar Styles
,
Literal Style
single key:value pair mapping,
Keys Order
,
Node Styles
,
Flow Sequences
,
Flow Mappings
,
Block Mappings
T
tab,
Prior Art
,
Character Set
,
White Space Characters
,
Indentation Spaces
,
Separation Spaces
,
Line Prefixes
,
Block Indentation Indicator
tag,
Prior Art
,
Tags
,
Dump
,
Representation Graph
,
Nodes
,
Tags
,
Node Comparison
,
Scalar Formats
,
Loading Failure Points
,
Resolved Tags
,
Recognized and Valid Tags
,
Available Tags
,
Syntax Conventions
,
Production Parameters
,
Indicator Characters
,
Miscellaneous Characters
,
TAG Directives
,
Tag Prefixes
,
Node Properties
,
Node Tags
,
Flow Styles
,
Recommended Schemas
,
Tags
,
Tags
,
Other Schemas
available,
Available Tags
global,
Prior Art
,
Tags
,
Dump
,
Tags
,
Resolved Tags
,
Tag Handles
,
Tag Prefixes
,
Node Tags
,
Other Schemas
handle,
Tags
,
Processes
,
Dump
,
Indicator Characters
,
TAG Directives
,
Tag Handles
,
Tag Prefixes
,
Node Tags
named,
Miscellaneous Characters
,
Tag Handles
,
Node Tags
primary,
Tag Handles
secondary,
Tag Handles
local,
Prior Art
,
Tags
,
Dump
,
Tags
,
Resolved Tags
,
Indicator Characters
,
Tag Handles
,
Tag Prefixes
,
Node Tags
,
Other Schemas
non-specific,
Tags
,
Dump
,
Loading Failure Points
,
Resolved Tags
,
Indicator Characters
,
Node Tags
,
Recommended Schemas
,
Tag Resolution
,
Tag Resolution
,
Other Schemas
prefix,
TAG Directives
,
Tag Prefixes
,
Node Tags
property,
Resolved Tags
,
Indicator Characters
,
Node Tags
recognized,
Recognized and Valid Tags
repository,
Tags
,
Tag Handles
,
Other Schemas
bool,
Boolean
float,
Tags
,
Floating Point
int,
Tags
,
Integer
map,
Tags
,
Generic Mapping
null,
Tags
,
Empty Nodes
,
Null
seq,
Tags
,
Generic Sequence
str,
Tags
,
Generic String
resolution,
Tags
,
Loading Failure Points
,
Resolved Tags
,
Node Tags
,
Flow Scalar Styles
,
Recommended Schemas
,
Tag Resolution
,
Tag Resolution
,
Tag Resolution
,
Other Schemas
convention,
Resolved Tags
,
Node Tags
,
Tag Resolution
,
Tag Resolution
,
Tag Resolution
shorthand,
Tags
,
Miscellaneous Characters
,
TAG Directives
,
Tag Handles
,
Tag Prefixes
,
Node Tags
specific,
Resolved Tags
,
Node Tags
unavailable,
Load
,
Loading Failure Points
,
Available Tags
unrecognized,
Loading Failure Points
,
Recognized and Valid Tags
unresolved,
Loading Failure Points
,
Resolved Tags
verbatim,
Node Tags
trimming,
Line Folding
V
value,
Dump
,
Nodes
,
Node Comparison
,
Resolved Tags
,
Indicator Characters
,
Flow Mappings
,
Block Mappings
,
Generic Mapping
,
Null
Y
YAML 1.1         processing,
Line Break Characters
,
YAML Directives
