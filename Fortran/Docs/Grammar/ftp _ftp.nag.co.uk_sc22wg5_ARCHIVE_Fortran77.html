<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type" content="text/html; charset=windows-1252"><title>ftp://ftp.nag.co.uk/sc22wg5/ARCHIVE/Fortran77.html</title><link rel="stylesheet" type="text/css" href="ftp%20_ftp.nag.co.uk_sc22wg5_ARCHIVE_Fortran77_files/viewsource.css"></head><body id="viewsource" class="highlight" style="-moz-tab-size: 4" contextmenu="actions"><pre id="line1"><span></span><span class="error" title="Start tag seen without seeing a doctype first. Expected “&lt;!DOCTYPE html&gt;”.">&lt;<span class="start-tag">html</span>&gt;</span><span></span><span>&lt;<span class="start-tag">head</span>&gt;</span><span></span><span>&lt;<span class="start-tag">title</span>&gt;</span><span>Fortran 77 Standard</span><span>&lt;/<span class="end-tag">title</span>&gt;</span><span></span><span>&lt;/<span class="end-tag">head</span>&gt;</span><span></span><span>&lt;<span class="start-tag">body</span>&gt;</span><span>
<span id="line2"></span></span><span>&lt;<span class="start-tag">pre</span>&gt;</span><span>
<span id="line3"></span>                                                   ANSI X3J3/90.4
<span id="line4"></span>
<span id="line5"></span>
<span id="line6"></span>
<span id="line7"></span>                             1.  INTRODUCTION
<span id="line8"></span>
<span id="line9"></span>          1.1  Purpose
<span id="line10"></span>
<span id="line11"></span>          This standard specifies the form  and  establishes  the
<span id="line12"></span>          interpretation  of  programs  expressed  in the FORTRAN
<span id="line13"></span>          language.  The purpose of this standard is  to  promote
<span id="line14"></span>          portability of FORTRAN programs for use on a variety of
<span id="line15"></span>          data processing systems.
<span id="line16"></span>
<span id="line17"></span>          1.2  Processor
<span id="line18"></span>
<span id="line19"></span>          The combination of a data  processing  system  and  the
<span id="line20"></span>          mechanism  by which programs are transformed for use on
<span id="line21"></span>          that data processing system is called  a  processor  in
<span id="line22"></span>          this standard.
<span id="line23"></span>
<span id="line24"></span>          1.3  Scope
<span id="line25"></span>
<span id="line26"></span>          1.3.1  Inclusions.  This standard specifies:
<span id="line27"></span>
<span id="line28"></span>             (1) The form of a program  written  in  the  FORTRAN
<span id="line29"></span>                 language
<span id="line30"></span>
<span id="line31"></span>             (2) Rules for interpreting the  meaning  of  such  a
<span id="line32"></span>                 program and its data
<span id="line33"></span>
<span id="line34"></span>             (3) The form of writing input data to  be  processed
<span id="line35"></span>                 by  such  a program operating on data processing
<span id="line36"></span>                 systems
<span id="line37"></span>
<span id="line38"></span>             (4) The form of the output data resulting  from  the
<span id="line39"></span>                 use of such a program on data processing systems
<span id="line40"></span>
<span id="line41"></span>          1.3.2  Exclusions.  This standard does not specify:
<span id="line42"></span>
<span id="line43"></span>             (1) The mechanism by which programs are  transformed
<span id="line44"></span>                 for use on a data processing system
<span id="line45"></span>
<span id="line46"></span>             (2) The method of transcription of programs or their
<span id="line47"></span>                 input   or   output  data  to  or  from  a  data
<span id="line48"></span>                 processing medium
<span id="line49"></span>
<span id="line50"></span>             (3) The operations required for setup and control of
<span id="line51"></span>                 the use of programs on data processing systems
<span id="line52"></span>
<span id="line53"></span>             (4) The results when the rules of this standard fail
<span id="line54"></span>                 to establish an interpretation
<span id="line55"></span>
<span id="line56"></span>             (5) The size or complexity of a program and its data
<span id="line57"></span>                 that  will  exceed  the capacity of any specific
<span id="line58"></span>
<span id="line59"></span>
<span id="line60"></span>
<span id="line61"></span>          FORTRAN 77 Full Language                       Page 1-1
<span id="line62"></span>
<span id="line63"></span>
<span id="line64"></span>
<span id="line65"></span>
<span id="line66"></span>
<span id="line67"></span>
<span id="line68"></span>
<span id="line69"></span>          INTRODUCTION                             ANSI X3J3/90.4
<span id="line70"></span>
<span id="line71"></span>
<span id="line72"></span>
<span id="line73"></span>                 data processing system or the  capability  of  a
<span id="line74"></span>                 particular processor
<span id="line75"></span>
<span id="line76"></span>             (6) The range or precision of numeric quantities and
<span id="line77"></span>                 the method of rounding of numeric results
<span id="line78"></span>
<span id="line79"></span>             (7) The physical properties of input/output records,
<span id="line80"></span>                 files, and units
<span id="line81"></span>
<span id="line82"></span>             (8) The physical properties  and  implementation  of
<span id="line83"></span>                 storage
<span id="line84"></span>
<span id="line85"></span>          1.4  Conformance
<span id="line86"></span>
<span id="line87"></span>          The  requirements, prohibitions, and options  specified
<span id="line88"></span>          in  this  standard generally refer to permissible forms
<span id="line89"></span>          and  relationships  for  standard-conforming   programs
<span id="line90"></span>          rather than for processors.  The obvious exceptions are
<span id="line91"></span>          the optional output  forms  produced  by  a  processor,
<span id="line92"></span>          which  are  not  under  the  control of a program.  The
<span id="line93"></span>          requirements,   prohibitions,   and   options   for   a
<span id="line94"></span>          standard-conforming  processor usually must be inferred
<span id="line95"></span>          from those given for programs.
<span id="line96"></span>
<span id="line97"></span>          An executable program (2.4.2) conforms to this standard
<span id="line98"></span>          if it uses only those forms and relationships described
<span id="line99"></span>          herein  and  if   the   executable   program   has   an
<span id="line100"></span>          interpretation  according  to this standard.  A program
<span id="line101"></span>          unit (2.4) conforms to  this  standard  if  it  can  be
<span id="line102"></span>          included  in  an  executable  program  in a manner that
<span id="line103"></span>          allows  the   executable   program   to   be   standard
<span id="line104"></span>          conforming.
<span id="line105"></span>
<span id="line106"></span>          A processor conforms to this standard  if  it  executes
<span id="line107"></span>          standard-conforming  programs in a manner that fulfills
<span id="line108"></span>          the interpretations  prescribed  herein.   A  standard-
<span id="line109"></span>          conforming  processor  may  allow  additional forms and
<span id="line110"></span>          relationships  provided  that  such  additions  do  not
<span id="line111"></span>          conflict  with  the  standard  forms and relationships.
<span id="line112"></span>          However,  a  standard-conforming  processor  may  allow
<span id="line113"></span>          additional intrinsic functions (15.10) even though this
<span id="line114"></span>          could cause a conflict with the  name  of  an  external
<span id="line115"></span>          function  in  a standard-conforming program.  If such a
<span id="line116"></span>          conflict occurs, the processor is permitted to use  the
<span id="line117"></span>          intrinsic  function  unless  the  name  appears  in  an
<span id="line118"></span>          EXTERNAL  statement  within  the   program   unit.    A
<span id="line119"></span>          standard-conforming  program  must  not  use  intrinsic
<span id="line120"></span>          functions that have been added by the processor.   Note
<span id="line121"></span>          that  a  standard-conforming  program  must not use any
<span id="line122"></span>          forms or relationships  that  are  prohibited  by  this
<span id="line123"></span>          standard, but a standard-conforming processor may allow
<span id="line124"></span>
<span id="line125"></span>
<span id="line126"></span>
<span id="line127"></span>          FORTRAN 77 Full Language                       Page 1-2
<span id="line128"></span>
<span id="line129"></span>
<span id="line130"></span>
<span id="line131"></span>
<span id="line132"></span>
<span id="line133"></span>
<span id="line134"></span>
<span id="line135"></span>          INTRODUCTION                             ANSI X3J3/90.4
<span id="line136"></span>
<span id="line137"></span>
<span id="line138"></span>
<span id="line139"></span>          such forms and relationships if they do not change  the
<span id="line140"></span>          proper interpretation of a standard-conforming program.
<span id="line141"></span>
<span id="line142"></span>          Because a standard-conforming program may place demands
<span id="line143"></span>          on  the processor that are not within the scope of this
<span id="line144"></span>          standard or may include standard  items  that  are  not
<span id="line145"></span>          portable,  such as external procedures defined by means
<span id="line146"></span>          other than FORTRAN, conformance to this  standard  does
<span id="line147"></span>          not  ensure  that  a  standard-conforming  program will
<span id="line148"></span>          execute consistently on all or any  standard-conforming
<span id="line149"></span>          processors.
<span id="line150"></span>
<span id="line151"></span>          1.4.1  Subset_Conformance.  This standard describes two
<span id="line152"></span>          levels  of the FORTRAN language, referred to as FORTRAN
<span id="line153"></span>          and subset FORTRAN.   FORTRAN  is  the  full  language.
<span id="line154"></span>          Subset FORTRAN is a subset of the full language.
<span id="line155"></span>
<span id="line156"></span>          An executable program conforms to the subset  level  of
<span id="line157"></span>          this   standard   if  it  uses  only  those  forms  and
<span id="line158"></span>          relationships described herein for that  level  and  if
<span id="line159"></span>          the  executable program has an interpretation according
<span id="line160"></span>          to this standard at that level and would have the  same
<span id="line161"></span>          interpretation  in  the  full language.  A program unit
<span id="line162"></span>          conforms to the subset level of this standard if it can
<span id="line163"></span>          be  included  in an executable program in a manner that
<span id="line164"></span>          allows the executable program to be standard conforming
<span id="line165"></span>          at that level.
<span id="line166"></span>
<span id="line167"></span>          A subset level processor conforms to the  subset  level
<span id="line168"></span>          of  this standard if it executes subset level standard-
<span id="line169"></span>          conforming programs  in  a  manner  that  fulfills  the
<span id="line170"></span>          interpretations  prescribed  herein for subset FORTRAN.
<span id="line171"></span>          A subset level processor may include an extension  that
<span id="line172"></span>          has a form and would have an interpretation at the full
<span id="line173"></span>          level only if  the  extension  has  the  interpretation
<span id="line174"></span>          provided  by  the full level.  A subset level processor
<span id="line175"></span>          may also include extensions that do not have forms  and
<span id="line176"></span>          interpretations in the full language.
<span id="line177"></span>
<span id="line178"></span>          1.5  Notation_Used_in_This_Standard
<span id="line179"></span>
<span id="line180"></span>          In this standard, "must" is. to  be  interpreted  as  a
<span id="line181"></span>          requirement;   conversely,   "must   not"   is   to  be
<span id="line182"></span>          interpreted as a prohibition.
<span id="line183"></span>
<span id="line184"></span>          In  describing  the  form  of  FORTRAN  statements   or
<span id="line185"></span>          constructs,  the following metalanguage conventions and
<span id="line186"></span>          symbols are used:
<span id="line187"></span>
<span id="line188"></span>             (1) Special characters from  the  FORTRAN  character
<span id="line189"></span>                 set,  uppercase letters, and uppercase words are
<span id="line190"></span>
<span id="line191"></span>
<span id="line192"></span>
<span id="line193"></span>          FORTRAN 77 Full Language                       Page 1-3
<span id="line194"></span>
<span id="line195"></span>
<span id="line196"></span>
<span id="line197"></span>
<span id="line198"></span>
<span id="line199"></span>
<span id="line200"></span>
<span id="line201"></span>          INTRODUCTION                             ANSI X3J3/90.4
<span id="line202"></span>
<span id="line203"></span>
<span id="line204"></span>
<span id="line205"></span>                 to be written as shown, except  where  otherwise
<span id="line206"></span>                 noted.
<span id="line207"></span>
<span id="line208"></span>             (2) Lowercase letters and lowercase  words  indicate
<span id="line209"></span>                 general  entities  for  which  specific entities
<span id="line210"></span>                 must be substituted in actual statements.   Once
<span id="line211"></span>                 a  given  lowercase  letter or word is used in a
<span id="line212"></span>                 syntactic specification to represent an  entity,
<span id="line213"></span>                 all  subsequent  occurrences  of  that letter or
<span id="line214"></span>                 word represent the same entity until that letter
<span id="line215"></span>                 or  word  is  used  in  a  subsequent  syntactic
<span id="line216"></span>                 specification to represent a different entity.
<span id="line217"></span>
<span id="line218"></span>             (3) Brackets, [ ], are  used  to  indicate  optional
<span id="line219"></span>                 items.
<span id="line220"></span>
<span id="line221"></span>             (4) An ellipsis, ...  , indicates that the preceding
<span id="line222"></span>                 optional  items  may appear one or more times in
<span id="line223"></span>                 succession.
<span id="line224"></span>
<span id="line225"></span>             (5) Blanks are  used  to  improve  readability,  but
<span id="line226"></span>                 unless otherwise noted have no significance.
<span id="line227"></span>
<span id="line228"></span>             (6) Words or  groups  of  words  that  have  special
<span id="line229"></span>                 significance  are underlined where their meaning
<span id="line230"></span>                 is  described.   Titles  and  the   metalanguage
<span id="line231"></span>                 symbols described in 1.5(2) are also underlined.
<span id="line232"></span>
<span id="line233"></span>          An  example  illustrates  the  metalanguage.   Given  a
<span id="line234"></span>          description of the form of a statement as:
<span id="line235"></span>
<span id="line236"></span>                               CALL sub___ [( [a_ [,a_]...] )]
<span id="line237"></span>
<span id="line238"></span>          the following forms are allowed:
<span id="line239"></span>
<span id="line240"></span>                     CALL sub___
<span id="line241"></span>                     CALL sub___ ()
<span id="line242"></span>                     CALL sub___ (a_)
<span id="line243"></span>                     CALL sub___ (a_, a_)
<span id="line244"></span>                     CALL sub___ (a_, a_, a_)
<span id="line245"></span>                     etc
<span id="line246"></span>
<span id="line247"></span>          When an actual statement is written, specific  entities
<span id="line248"></span>          are substituted for sub and each a_; for example:
<span id="line249"></span>
<span id="line250"></span>                               CALL ABCD (X,1.0)
<span id="line251"></span>
<span id="line252"></span>
<span id="line253"></span>
<span id="line254"></span>
<span id="line255"></span>
<span id="line256"></span>
<span id="line257"></span>
<span id="line258"></span>
<span id="line259"></span>          FORTRAN 77 Full Language                       Page 1-4
<span id="line260"></span>
<span id="line261"></span>
<span id="line262"></span>
<span id="line263"></span>
<span id="line264"></span>
<span id="line265"></span>
<span id="line266"></span>
<span id="line267"></span>          INTRODUCTION                             ANSI X3J3/90.4
<span id="line268"></span>
<span id="line269"></span>
<span id="line270"></span>
<span id="line271"></span>          1.6  Subset_Text
<span id="line272"></span>
<span id="line273"></span>          The  section  titles  in  the  subset  description  are
<span id="line274"></span>          identical  to  the  section titles in the full language
<span id="line275"></span>          description.
<span id="line276"></span>
<span id="line277"></span>          There are some instances in which a  general  situation
<span id="line278"></span>          occurs  in the full language but only a restricted case
<span id="line279"></span>          applies to  the  subset.   For  example,  in  3.6,  the
<span id="line280"></span>          "nonexecutable  statements"  that  may  appear  between
<span id="line281"></span>          executable statements may only be FORMAT statements  in
<span id="line282"></span>          the  subset.   In  most  of  these  instances, the more
<span id="line283"></span>          general text of the full language description has  been
<span id="line284"></span>          retained  in  the subset description, even though it is
<span id="line285"></span>          to be interpreted as covering only the restricted case.
<span id="line286"></span>
<span id="line287"></span>          To help find differences between the  full  and  subset
<span id="line288"></span>          languages, vertical bars have been added in the margins
<span id="line289"></span>          where the text of the full and subset languages differ.
<span id="line290"></span>          For  example,  this  sentence  does  not  appear in the
<span id="line291"></span>          subset language text.
<span id="line292"></span>
<span id="line293"></span>
<span id="line294"></span>
<span id="line295"></span>
<span id="line296"></span>
<span id="line297"></span>
<span id="line298"></span>
<span id="line299"></span>
<span id="line300"></span>
<span id="line301"></span>
<span id="line302"></span>
<span id="line303"></span>
<span id="line304"></span>
<span id="line305"></span>
<span id="line306"></span>
<span id="line307"></span>
<span id="line308"></span>
<span id="line309"></span>
<span id="line310"></span>
<span id="line311"></span>
<span id="line312"></span>
<span id="line313"></span>
<span id="line314"></span>
<span id="line315"></span>
<span id="line316"></span>
<span id="line317"></span>
<span id="line318"></span>
<span id="line319"></span>
<span id="line320"></span>
<span id="line321"></span>
<span id="line322"></span>
<span id="line323"></span>
<span id="line324"></span>
<span id="line325"></span>          FORTRAN 77 Full Language                       Page 1-5
<span id="line326"></span>
<span id="line327"></span>
<span id="line328"></span>
<span id="line329"></span>
<span id="line330"></span>
<span id="line331"></span>
<span id="line332"></span>
<span id="line333"></span>
<span id="line334"></span>
<span id="line335"></span>
<span id="line336"></span>
<span id="line337"></span>                                 CONTENTS
<span id="line338"></span>
<span id="line339"></span>
<span id="line340"></span>          1.  INTRODUCTION..................................  1-1
<span id="line341"></span>              1.1  Purpose..................................  1-1
<span id="line342"></span>              1.2  Processor................................  1-1
<span id="line343"></span>              1.3  Scope....................................  1-1
<span id="line344"></span>                   1.3.1  Inclusions........................  1-1
<span id="line345"></span>                   1.3.2  Exclusions........................  1-1
<span id="line346"></span>              1.4  Conformance..............................  1-2
<span id="line347"></span>                   1.4.1  Subset Conformance................  1-3
<span id="line348"></span>              1.5  Notation Used in This Standard...........  1-3
<span id="line349"></span>              1.6  Subset Text..............................  1-5
<span id="line350"></span>
<span id="line351"></span>
<span id="line352"></span>
<span id="line353"></span>
<span id="line354"></span>
<span id="line355"></span>
<span id="line356"></span>
<span id="line357"></span>
<span id="line358"></span>
<span id="line359"></span>
<span id="line360"></span>
<span id="line361"></span>
<span id="line362"></span>
<span id="line363"></span>
<span id="line364"></span>
<span id="line365"></span>
<span id="line366"></span>
<span id="line367"></span>
<span id="line368"></span>
<span id="line369"></span>
<span id="line370"></span>
<span id="line371"></span>
<span id="line372"></span>
<span id="line373"></span>
<span id="line374"></span>
<span id="line375"></span>
<span id="line376"></span>
<span id="line377"></span>
<span id="line378"></span>
<span id="line379"></span>
<span id="line380"></span>
<span id="line381"></span>
<span id="line382"></span>
<span id="line383"></span>
<span id="line384"></span>
<span id="line385"></span>
<span id="line386"></span>
<span id="line387"></span>
<span id="line388"></span>
<span id="line389"></span>
<span id="line390"></span>
<span id="line391"></span>                                   - i -
<span id="line392"></span>
<span id="line393"></span>
<span id="line394"></span>
<span id="line395"></span>
<span id="line396"></span>
<span id="line397"></span>
<span id="line398"></span>
<span id="line399"></span>                                                   ANSI X3J3/90.4
<span id="line400"></span>
<span id="line401"></span>
<span id="line402"></span>
<span id="line403"></span>                      2.  FORTRAN_TERMS_AND_CONCEPTS
<span id="line404"></span>
<span id="line405"></span>          This section introduces basic terminology and concepts,
<span id="line406"></span>          some  of which are clarified further in later sections.
<span id="line407"></span>          Many terms and concepts of more specialized meaning are
<span id="line408"></span>          also  introduced  in  later  sections.   The underlined
<span id="line409"></span>          words are  described  here  and  used  throughout  this
<span id="line410"></span>          standard.
<span id="line411"></span>
<span id="line412"></span>          2.1  Sequence
<span id="line413"></span>
<span id="line414"></span>          A  sequence  is  a  set   ordered   by   a   one-to-one
<span id="line415"></span>          correspondence  with  the  numbers 1, 2, through n_. The
<span id="line416"></span>          number of elements in the sequence is n_. A sequence may
<span id="line417"></span>          be empty, in which case it contains no elements.
<span id="line418"></span>
<span id="line419"></span>          The elements of a nonempty sequence are referred to  as
<span id="line420"></span>          the  first  element,  second  element,  etc.   The  n_th
<span id="line421"></span>          element, where n_ is  the  number  of  elements  in  the
<span id="line422"></span>          sequence,   is  called  the  last  element.   An  empty
<span id="line423"></span>          sequence has no first or last element.
<span id="line424"></span>
<span id="line425"></span>          2.2  Syntactic_Items
<span id="line426"></span>
<span id="line427"></span>          Letters, digits, and special characters of the  FORTRAN
<span id="line428"></span>          character  set  (3.1)  are  used  to form the syntactic
<span id="line429"></span>          items of the FORTRAN  language.   The  basic  syntactic
<span id="line430"></span>          items  of  the FORTRAN language are constants, symbolic
<span id="line431"></span>          names,  statement  labels,  keywords,  operators,   and
<span id="line432"></span>          special characters.
<span id="line433"></span>
<span id="line434"></span>          The form of a constant is described in Section 4.
<span id="line435"></span>
<span id="line436"></span>          A symbolic name takes the form of a sequence of one  to
<span id="line437"></span>          six  letters  or  digits,  the first of which must be a
<span id="line438"></span>          letter.    Classification   of   symbolic   names   and
<span id="line439"></span>          restrictions on their use are described in Section 18.
<span id="line440"></span>
<span id="line441"></span>          A statement label takes the form of a sequence  of  one
<span id="line442"></span>          to  five  digits,  one of which must be nonzero, and is
<span id="line443"></span>          used to identify a statement (3.4).
<span id="line444"></span>
<span id="line445"></span>          A keyword takes the form of  a  specified  sequence  of
<span id="line446"></span>          letters.   The  keywords  that  are  significant in the
<span id="line447"></span>          FORTRAN language are described in  Sections  7  through
<span id="line448"></span>          16.   In  many  instances,  a keyword or a portion of a
<span id="line449"></span>          keyword also meets  the  requirements  for  a  symbolic
<span id="line450"></span>          name.   Whether  a  particular  sequence  of characters
<span id="line451"></span>          identifies a keyword or a symbolic name is  implied  by
<span id="line452"></span>          context.   There  is  no sequence of characters that is
<span id="line453"></span>          reserved in all contexts in FORTRAN.
<span id="line454"></span>
<span id="line455"></span>
<span id="line456"></span>
<span id="line457"></span>          FORTRAN 77 Full Language                       Page 2-1
<span id="line458"></span>
<span id="line459"></span>
<span id="line460"></span>
<span id="line461"></span>
<span id="line462"></span>
<span id="line463"></span>
<span id="line464"></span>
<span id="line465"></span>          FORTRAN TERMS AND CONCEPTS               ANSI X3J3/90.4
<span id="line466"></span>
<span id="line467"></span>
<span id="line468"></span>
<span id="line469"></span>          The set of special characters is described in 3.1.4.  A
<span id="line470"></span>          special  character  may  be  an  operator  or part of a
<span id="line471"></span>          constant or  have  some  other  special  meaning.   The
<span id="line472"></span>          interpretation is implied by context.
<span id="line473"></span>
<span id="line474"></span>          2.3  Statements,_Comments,_and_Lines
<span id="line475"></span>
<span id="line476"></span>          A FORTRAN statement is a sequence of  syntactic  items,
<span id="line477"></span>          as  described  in  Sections  7  through 16.  Except for
<span id="line478"></span>          assignment  and  statement  function  statements,  each
<span id="line479"></span>          statement begins with a keyword.  In this standard, the
<span id="line480"></span>          keyword or keywords that begin the statement  are  used
<span id="line481"></span>          to  identify  that    statement.   For  example, a DATA
<span id="line482"></span>          statement begins with the keyword DATA.
<span id="line483"></span>
<span id="line484"></span>          A statement is written in one or more lines, the  first
<span id="line485"></span>          of  which is called an initial line (3.2.2); succeeding
<span id="line486"></span>          lines, if any, are called continuation lines (3.2.3).
<span id="line487"></span>
<span id="line488"></span>          There is also a line called  a  comment  line  (3.2.1),
<span id="line489"></span>          which  is  not part of any statement and is intended to
<span id="line490"></span>          provide documentation.
<span id="line491"></span>
<span id="line492"></span>          2.3.1  Classes_of_Statements.    Each   statement    is
<span id="line493"></span>          classified  as executable or nonexecutable (Section 7).
<span id="line494"></span>          Executable statements specify  actions.   Nonexecutable
<span id="line495"></span>          statements  describe  the characteristics, arrangement,
<span id="line496"></span>          and   initial   values   of   data;   contain   editing
<span id="line497"></span>          information;   specify  statement  functions;  classify
<span id="line498"></span>          program  units;  and  specify   entry   points   within
<span id="line499"></span>          subprograms.
<span id="line500"></span>
<span id="line501"></span>          2.4  Program_Units_and_Procedures
<span id="line502"></span>
<span id="line503"></span>          A program unit consists of a sequence of statements and
<span id="line504"></span>          optional  comment  lines.   A  program unit is either a
<span id="line505"></span>          main program or a subprogram.
<span id="line506"></span>
<span id="line507"></span>          A main program is a program unit that does not  have  a
<span id="line508"></span>          FUNCTION,  SUBROUTINE,  or  BLOCK DATA statement as its
<span id="line509"></span>          first statement; it may have a PROGRAM statement as its
<span id="line510"></span>          first statement.
<span id="line511"></span>
<span id="line512"></span>          A subprogram is a program unit  that  has  a  FUNCTION,
<span id="line513"></span>          SUBROUTINE,  or  BLOCK  DATA  statement  as  its  first
<span id="line514"></span>          statement.  A subprogram whose  first  statement  is  a
<span id="line515"></span>          FUNCTION  statement is called a function subprogram.  A
<span id="line516"></span>          subprogram  whose  first  statement  is  a   SUBROUTINE
<span id="line517"></span>          statement  is called a subroutine subprogram.  Function
<span id="line518"></span>          subprograms  and  subroutine  subprograms  are   called
<span id="line519"></span>          procedure   subprograms.   A  subprogram  whose   first
<span id="line520"></span>
<span id="line521"></span>
<span id="line522"></span>
<span id="line523"></span>          FORTRAN 77 Full Language                       Page 2-2
<span id="line524"></span>
<span id="line525"></span>
<span id="line526"></span>
<span id="line527"></span>
<span id="line528"></span>
<span id="line529"></span>
<span id="line530"></span>
<span id="line531"></span>          FORTRAN TERMS AND CONCEPTS               ANSI X3J3/90.4
<span id="line532"></span>
<span id="line533"></span>
<span id="line534"></span>
<span id="line535"></span>          statement is a BLOCK DATA statement is called  a  block
<span id="line536"></span>          data subprogram.
<span id="line537"></span>
<span id="line538"></span>          2.4.1  Procedures.    Subroutines   (15.6),    external
<span id="line539"></span>          functions  (15.5),  statement functions (15.4), and the
<span id="line540"></span>          intrinsic  functions  (15.3)  are  called   procedures.
<span id="line541"></span>          Subroutines  and external functions are called external
<span id="line542"></span>          procedures.   Function   subprograms   and   subroutine
<span id="line543"></span>          subprograms  may specify one or more external functions
<span id="line544"></span>          and   subroutines,   respectively   (15.7).    External
<span id="line545"></span>          procedures  may  also  be specified by means other than
<span id="line546"></span>          FORTRAN subprograms.
<span id="line547"></span>
<span id="line548"></span>          2.4.2  Executable_Program.  An executable program is  a
<span id="line549"></span>          collection  of  program  units that consists of exactly
<span id="line550"></span>          one main program and any  number,  including  none,  of
<span id="line551"></span>          subprograms and external procedures.
<span id="line552"></span>
<span id="line553"></span>          2.5  Variable
<span id="line554"></span>
<span id="line555"></span>          A variable is an entity that has  both  a  name  and  a
<span id="line556"></span>          type.   A  variable name is a symbolic name of a datum.
<span id="line557"></span>          Such a datum may be  identified,  defined  (2.11),  and
<span id="line558"></span>          referenced   (2.12).   Note  that  the  usage  in  this
<span id="line559"></span>          standard of the word "variable" is more restricted than
<span id="line560"></span>          its  normal  usage,  in  that it does not include array
<span id="line561"></span>          elements.
<span id="line562"></span>
<span id="line563"></span>          The type of a variable is optionally specified  by  the
<span id="line564"></span>          appearance  of  the  variable  name in a type-statement
<span id="line565"></span>          (8.4).  If it is  not  so  specified,  the  type  of  a
<span id="line566"></span>          variable is implied by the first letter of the variable
<span id="line567"></span>          name to be integer or real (4.1.2), unless the  initial
<span id="line568"></span>          letter  type  implication  is  changed by the use of an
<span id="line569"></span>          IMPLICIT statement (8.5).
<span id="line570"></span>
<span id="line571"></span>          At any given time during the execution of an executable
<span id="line572"></span>          program,  a  variable  is  either  defined or undefined
<span id="line573"></span>          (2.11).
<span id="line574"></span>
<span id="line575"></span>          2.6  Array
<span id="line576"></span>
<span id="line577"></span>          An array is a nonempty sequence of data that has a name
<span id="line578"></span>          and a type.  The name of an array is a symbolic name.
<span id="line579"></span>
<span id="line580"></span>          2.6.1  Array_Elements.  Each  of  the  elements  of  an
<span id="line581"></span>          array  is  called  an  array  element.   An  array name
<span id="line582"></span>          qualified by a subscript is an array element  name  and
<span id="line583"></span>          identifies  a  particular  element  of the array (5.3).
<span id="line584"></span>          Such a datum may be  identified,  defined  (2.11),  and
<span id="line585"></span>          referenced  (2.12).  The number of array elements in an
<span id="line586"></span>
<span id="line587"></span>
<span id="line588"></span>
<span id="line589"></span>          FORTRAN 77 Full Language                       Page 2-3
<span id="line590"></span>
<span id="line591"></span>
<span id="line592"></span>
<span id="line593"></span>
<span id="line594"></span>
<span id="line595"></span>
<span id="line596"></span>
<span id="line597"></span>          FORTRAN TERMS AND CONCEPTS               ANSI X3J3/90.4
<span id="line598"></span>
<span id="line599"></span>
<span id="line600"></span>
<span id="line601"></span>          array  is specified by an array declarator (5.1).
<span id="line602"></span>
<span id="line603"></span>          An array element has a type.  The  type  of  all  array
<span id="line604"></span>          elements within an array is the same, and is optionally
<span id="line605"></span>          specified by the appearance of  the  array  name  in  a
<span id="line606"></span>          type-statement  (8.4).   If it is not so specified, the
<span id="line607"></span>          type of an array element is implied by the first letter
<span id="line608"></span>          of the array name to be integer or real (4.1.2), unless
<span id="line609"></span>          the initial letter type implication is changed  by  the
<span id="line610"></span>          use of an IMPLICIT statement (8.5).
<span id="line611"></span>
<span id="line612"></span>          At any given time during the execution of an executable
<span id="line613"></span>          program,   an   array  element  is  either  defined  or
<span id="line614"></span>          undefined (2.11).
<span id="line615"></span>
<span id="line616"></span>          2.7  Substring
<span id="line617"></span>
<span id="line618"></span>          A character datum is a nonempty sequence of characters.
<span id="line619"></span>          A  substring  is  a  contiguous  portion of a character
<span id="line620"></span>          datum.  The form of a substring name used to  identify,
<span id="line621"></span>          define  (2.11),  or  reference  (2.12)  a  substring is
<span id="line622"></span>          described in 5.7.1.
<span id="line623"></span>
<span id="line624"></span>          At any given time during the execution of an executable
<span id="line625"></span>          program,  a  substring  is  either defined or undefined
<span id="line626"></span>          (2.11).
<span id="line627"></span>
<span id="line628"></span>          2.8  Dummy_Argument
<span id="line629"></span>
<span id="line630"></span>          A dummy argument in a procedure is  either  a  symbolic
<span id="line631"></span>          name  or  an  asterisk.  A symbolic name dummy argument
<span id="line632"></span>          identifies a variable, array, or procedure that becomes
<span id="line633"></span>          associated  (2.14)  with  an  actual  argument  of each
<span id="line634"></span>          reference  (2.12)  to  the  procedure  (15.2,   15.4.2,
<span id="line635"></span>          15.5.2,   and  15.6.2).   An  asterisk  dummy  argument
<span id="line636"></span>          indicates that the corresponding actual argument is  an
<span id="line637"></span>          alternate   return  specifier  (15.6.2.3,  15.8.3,  and
<span id="line638"></span>          15.9.3.5).
<span id="line639"></span>
<span id="line640"></span>          Each dummy  argument  name  that  is  classified  as  a
<span id="line641"></span>          variable, array, or dummy procedure may appear wherever
<span id="line642"></span>          an actual name of the same class (Section 18) and  type
<span id="line643"></span>          may appear, except where explicitly prohibited.
<span id="line644"></span>
<span id="line645"></span>          2.9  Scope_of_Symbolic_Names_and_Statement_Labels
<span id="line646"></span>
<span id="line647"></span>          The scope of a symbolic name (18.1)  is  an  executable
<span id="line648"></span>          program,   a   program   unit,   a  statement  function
<span id="line649"></span>          statement, or an implied-DO list in a DATA statement.
<span id="line650"></span>
<span id="line651"></span>
<span id="line652"></span>
<span id="line653"></span>
<span id="line654"></span>
<span id="line655"></span>          FORTRAN 77 Full Language                       Page 2-4
<span id="line656"></span>
<span id="line657"></span>
<span id="line658"></span>
<span id="line659"></span>
<span id="line660"></span>
<span id="line661"></span>
<span id="line662"></span>
<span id="line663"></span>          FORTRAN TERMS AND CONCEPTS               ANSI X3J3/90.4
<span id="line664"></span>
<span id="line665"></span>
<span id="line666"></span>
<span id="line667"></span>          The name of the main program and  the  names  of  block
<span id="line668"></span>          data  subprograms, external functions, subroutines, and
<span id="line669"></span>          common blocks have a scope of an executable program.
<span id="line670"></span>
<span id="line671"></span>          The names of variables,  arrays,  constants,  statement
<span id="line672"></span>          functions,  intrinsic  functions,  and dummy procedures
<span id="line673"></span>          have a scope of a program unit.
<span id="line674"></span>
<span id="line675"></span>          The names of variables that appear as  dummy  arguments
<span id="line676"></span>          in  a statement function statement have a scope of that
<span id="line677"></span>          statement.
<span id="line678"></span>
<span id="line679"></span>          The names of variables that appear as  the  DO-variable
<span id="line680"></span>          of  an  implied-DO  in a DATA statement have a scope of
<span id="line681"></span>          the implied-DO list.
<span id="line682"></span>
<span id="line683"></span>          Statement labels have a scope of a program unit.
<span id="line684"></span>
<span id="line685"></span>          2.10  List
<span id="line686"></span>
<span id="line687"></span>          A list  is  a  nonempty  sequence  (2.1)  of  syntactic
<span id="line688"></span>          entities separated by commas.  The entities in the list
<span id="line689"></span>          are called list items.
<span id="line690"></span>
<span id="line691"></span>          2.11  Definition_Status
<span id="line692"></span>
<span id="line693"></span>          At  any  gi  ven  time  during  the  execution  of   an
<span id="line694"></span>          executable  program,  the  definition  status  of  each
<span id="line695"></span>          variable, array element, or substring is either defined
<span id="line696"></span>          or undefined (Section 17).
<span id="line697"></span>
<span id="line698"></span>          A defined entity has a value.  The value of  a  defined
<span id="line699"></span>          !entity  does  not  change  until  the  entity  becomes
<span id="line700"></span>          undefined or is redefined with a different value.
<span id="line701"></span>
<span id="line702"></span>          If  a  variable,  array  element,   or   substring   is
<span id="line703"></span>          undefined, it does not have a predictable value.
<span id="line704"></span>
<span id="line705"></span>          A previously defined  variable  or  array  element  may
<span id="line706"></span>          become  undefined.   Subsequent definition of a defined
<span id="line707"></span>          variable or array element is permitted, except where it
<span id="line708"></span>          is explicitly prohibited.
<span id="line709"></span>
<span id="line710"></span>          A  character  variable,  character  array  element,  or
<span id="line711"></span>          character  substring  is  defined if every substring of
<span id="line712"></span>          length one of the entity is defined.  Note  that  if  a
<span id="line713"></span>          string  is  defined,  every  substring of the string is
<span id="line714"></span>          defined,  and  if  any  substring  of  the  string   is
<span id="line715"></span>          undefined,  the  string  is  undefined.   Defining  any
<span id="line716"></span>          substring does not cause any other string or  substring
<span id="line717"></span>          to become undefined.
<span id="line718"></span>
<span id="line719"></span>
<span id="line720"></span>
<span id="line721"></span>          FORTRAN 77 Full Language                       Page 2-5
<span id="line722"></span>
<span id="line723"></span>
<span id="line724"></span>
<span id="line725"></span>
<span id="line726"></span>
<span id="line727"></span>
<span id="line728"></span>
<span id="line729"></span>          FORTRAN TERMS AND CONCEPTS               ANSI X3J3/90.4
<span id="line730"></span>
<span id="line731"></span>
<span id="line732"></span>
<span id="line733"></span>          An entity is initially defined  if  it  is  assigned  a
<span id="line734"></span>          value  in  a  DATA  statement  (Section  9).  Initially
<span id="line735"></span>          defined entities  are  in  the  defined  state  at  the
<span id="line736"></span>          beginning  of  execution of an executable program.  All
<span id="line737"></span>          variables and array elements not initially defined,  or
<span id="line738"></span>          associated (2.14) with an initially defined entity, are
<span id="line739"></span>          undefined  at  the  beginning  of   execution   of   an
<span id="line740"></span>          executable program.
<span id="line741"></span>
<span id="line742"></span>          An entity must be defined at the time a reference to it
<span id="line743"></span>          is executed.
<span id="line744"></span>
<span id="line745"></span>          2.12  Reference
<span id="line746"></span>
<span id="line747"></span>          A variable, array element, or  substring  reference  is
<span id="line748"></span>          the   appearance  of  a  variable,  array  element,  or
<span id="line749"></span>          substring name,  respectively,  in  a  statement  in  a
<span id="line750"></span>          context  requiring  the value of that entity to be used
<span id="line751"></span>          during the execution of the executable program.  When a
<span id="line752"></span>          reference  to  an entity is executed, its current value
<span id="line753"></span>          is available.  In this standard, the act of defining an
<span id="line754"></span>          entity is not considered a reference to that entity.
<span id="line755"></span>
<span id="line756"></span>          A procedure reference is the appearance of a  procedure
<span id="line757"></span>          name  in  a  statement  in  a context that requires the
<span id="line758"></span>          actions specified  by  the  procedure  to  be  executed
<span id="line759"></span>          during the execution of the executable program.  When a
<span id="line760"></span>          procedure reference is executed, the procedure must  be
<span id="line761"></span>          available.
<span id="line762"></span>
<span id="line763"></span>          2.13  Storage
<span id="line764"></span>
<span id="line765"></span>          A storage sequence is a sequence of storage  units.   A
<span id="line766"></span>          storage  unit  is  either  a  numeric storage unit or a
<span id="line767"></span>          character storage unit.
<span id="line768"></span>
<span id="line769"></span>          An integer, real, or  logical  datum  has  one  numeric
<span id="line770"></span>          storage  unit in a storage sequence. A double precision
<span id="line771"></span>          or complex datum has two numeric  storage  units  in  a
<span id="line772"></span>          storage  sequence.  A character datum has one character
<span id="line773"></span>          storage unit in a storage sequence for  each  character
<span id="line774"></span>          in  the  datum.   This  standard  does  not  specify  a
<span id="line775"></span>          relationship between  a  numeric  storage  unit  and  a
<span id="line776"></span>          character storage unit.
<span id="line777"></span>
<span id="line778"></span>          If a datum requires more than one  storage  unit  in  a
<span id="line779"></span>          storage sequence, those storage units are consecutive.
<span id="line780"></span>
<span id="line781"></span>          The concept of a storage sequence is used  to  describe
<span id="line782"></span>          relationships   that   exist   among  variables,  array
<span id="line783"></span>          elements, arrays, substrings, and common blocks.   This
<span id="line784"></span>
<span id="line785"></span>
<span id="line786"></span>
<span id="line787"></span>          FORTRAN 77 Full Language                       Page 2-6
<span id="line788"></span>
<span id="line789"></span>
<span id="line790"></span>
<span id="line791"></span>
<span id="line792"></span>
<span id="line793"></span>
<span id="line794"></span>
<span id="line795"></span>          FORTRAN TERMS AND CONCEPTS               ANSI X3J3/90.4
<span id="line796"></span>
<span id="line797"></span>
<span id="line798"></span>
<span id="line799"></span>          standard  does  not  specify a relationship between the
<span id="line800"></span>          storage sequence concept and the physical properties or
<span id="line801"></span>          implementation of storage.
<span id="line802"></span>
<span id="line803"></span>          2.14  Association
<span id="line804"></span>
<span id="line805"></span>          Association of entities exists if the same datum may be
<span id="line806"></span>          identified  by  different  symbolic  names  in the same
<span id="line807"></span>          program unit, or by the same name or a  different  name
<span id="line808"></span>          in  different  program  units  of  the  same executable
<span id="line809"></span>          program (17.1).
<span id="line810"></span>
<span id="line811"></span>          Entities may become associated by the following:
<span id="line812"></span>
<span id="line813"></span>             (1) Common association (8.3.4)
<span id="line814"></span>
<span id="line815"></span>             (2) Equivalence association (8.2.2)
<span id="line816"></span>
<span id="line817"></span>             (3) Argument association (15.9.3)
<span id="line818"></span>
<span id="line819"></span>             (4) Entry association (15.7.3)
<span id="line820"></span>
<span id="line821"></span>
<span id="line822"></span>
<span id="line823"></span>
<span id="line824"></span>
<span id="line825"></span>
<span id="line826"></span>
<span id="line827"></span>
<span id="line828"></span>
<span id="line829"></span>
<span id="line830"></span>
<span id="line831"></span>
<span id="line832"></span>
<span id="line833"></span>
<span id="line834"></span>
<span id="line835"></span>
<span id="line836"></span>
<span id="line837"></span>
<span id="line838"></span>
<span id="line839"></span>
<span id="line840"></span>
<span id="line841"></span>
<span id="line842"></span>
<span id="line843"></span>
<span id="line844"></span>
<span id="line845"></span>
<span id="line846"></span>
<span id="line847"></span>
<span id="line848"></span>
<span id="line849"></span>
<span id="line850"></span>
<span id="line851"></span>
<span id="line852"></span>
<span id="line853"></span>          FORTRAN 77 Full Language                       Page 2-7
<span id="line854"></span>
<span id="line855"></span>
<span id="line856"></span>
<span id="line857"></span>
<span id="line858"></span>
<span id="line859"></span>
<span id="line860"></span>
<span id="line861"></span>
<span id="line862"></span>
<span id="line863"></span>
<span id="line864"></span>
<span id="line865"></span>                                 CONTENTS
<span id="line866"></span>
<span id="line867"></span>
<span id="line868"></span>          2.  FORTRAN TERMS AND CONCEPTS....................  2-1
<span id="line869"></span>              2.1   Sequence................................  2-1
<span id="line870"></span>              2.2   Syntactic Items.........................  2-1
<span id="line871"></span>              2.3   Statements, Comments, and Lines.........  2-2
<span id="line872"></span>                    2.3.1  Classes of Statements............  2-2
<span id="line873"></span>              2.4   Program Units and Procedures............  2-2
<span id="line874"></span>                    2.4.1  Procedures.......................  2-3
<span id="line875"></span>                    2.4.2  Executable Program...............  2-3
<span id="line876"></span>              2.5   Variable................................  2-3
<span id="line877"></span>              2.6   Array...................................  2-3
<span id="line878"></span>                    2.6.1  Array Elements...................  2-3
<span id="line879"></span>              2.7   Substring...............................  2-4
<span id="line880"></span>              2.8   Dummy Argument..........................  2-4
<span id="line881"></span>              2.9   Scope of Symbolic Names and Statement
<span id="line882"></span>                    Labels..................................  2-4
<span id="line883"></span>              2.10  List....................................  2-5
<span id="line884"></span>              2.11  Definition Status.......................  2-5
<span id="line885"></span>              2.12  Reference...............................  2-6
<span id="line886"></span>              2.13  Storage.................................  2-6
<span id="line887"></span>              2.14  Association.............................  2-7
<span id="line888"></span>
<span id="line889"></span>
<span id="line890"></span>
<span id="line891"></span>
<span id="line892"></span>
<span id="line893"></span>
<span id="line894"></span>
<span id="line895"></span>
<span id="line896"></span>
<span id="line897"></span>
<span id="line898"></span>
<span id="line899"></span>
<span id="line900"></span>
<span id="line901"></span>
<span id="line902"></span>
<span id="line903"></span>
<span id="line904"></span>
<span id="line905"></span>
<span id="line906"></span>
<span id="line907"></span>
<span id="line908"></span>
<span id="line909"></span>
<span id="line910"></span>
<span id="line911"></span>
<span id="line912"></span>
<span id="line913"></span>
<span id="line914"></span>
<span id="line915"></span>
<span id="line916"></span>
<span id="line917"></span>
<span id="line918"></span>
<span id="line919"></span>                                   - i -
<span id="line920"></span>
<span id="line921"></span>
<span id="line922"></span>
<span id="line923"></span>
<span id="line924"></span>
<span id="line925"></span>
<span id="line926"></span>
<span id="line927"></span>                                                   ANSI X3J3/90.4
<span id="line928"></span>
<span id="line929"></span>
<span id="line930"></span>
<span id="line931"></span>               3.  CHARACTERS,_LINES,_AND_EXECUTION_SEQUENCE
<span id="line932"></span>
<span id="line933"></span>          3.1  FORTRAN_Character_Set
<span id="line934"></span>
<span id="line935"></span>          The  FORTRAN  character  set  consists  of   twenty-six
<span id="line936"></span>          letters, ten digits, and thirteen special characters.
<span id="line937"></span>
<span id="line938"></span>          3.1.1  Letters.  A letter  is  one  of  the  twenty-six
<span id="line939"></span>          characters:
<span id="line940"></span>
<span id="line941"></span>            A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
<span id="line942"></span>
<span id="line943"></span>          3.1.2  Digits.  A digit is one of the ten characters:
<span id="line944"></span>
<span id="line945"></span>                            0 1 2 3 4 5 6 7 8 9
<span id="line946"></span>
<span id="line947"></span>          A string of digits is interpreted in the  decimal  base
<span id="line948"></span>          number   system   when   a  numeric  interpretation  is
<span id="line949"></span>          appropriate.
<span id="line950"></span>
<span id="line951"></span>          3.1.3  Alphanumeric_Characters.     An     alphanumeric
<span id="line952"></span>          character is a letter or a digit.
<span id="line953"></span>
<span id="line954"></span>          3.1.4  Special_Characters.  A special character is  one
<span id="line955"></span>          of the thirteen characters:
<span id="line956"></span>
<span id="line957"></span>8                    __________________________________
<span id="line958"></span>
<span id="line959"></span>                     Character   Name of Character
<span id="line960"></span>8                    __________________________________
<span id="line961"></span>
<span id="line962"></span>                                    Blank
<span id="line963"></span>8                     _________________9      Equals
<span id="line964"></span>                         +          Plus
<span id="line965"></span>                         -          Minus
<span id="line966"></span>                         *          Asterisk
<span id="line967"></span>                         /          Slash
<span id="line968"></span>                         (          Left Parenthesis
<span id="line969"></span>                         )          Right Parenthesis
<span id="line970"></span>                         ,          Comma
<span id="line971"></span>                         $          Currency Symbol
<span id="line972"></span>                         '          Apostrophe
<span id="line973"></span>                         :          Colon
<span id="line974"></span>8                    __________________________________
<span id="line975"></span>7                   |7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|
<span id="line976"></span>
<span id="line977"></span>
<span id="line978"></span>
<span id="line979"></span>
<span id="line980"></span>
<span id="line981"></span>
<span id="line982"></span>
<span id="line983"></span>
<span id="line984"></span>
<span id="line985"></span>
<span id="line986"></span>
<span id="line987"></span>
<span id="line988"></span>
<span id="line989"></span>
<span id="line990"></span>                              |7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|
<span id="line991"></span>
<span id="line992"></span>
<span id="line993"></span>
<span id="line994"></span>
<span id="line995"></span>
<span id="line996"></span>
<span id="line997"></span>
<span id="line998"></span>
<span id="line999"></span>
<span id="line1000"></span>
<span id="line1001"></span>
<span id="line1002"></span>
<span id="line1003"></span>
<span id="line1004"></span>
<span id="line1005"></span>                                                     |7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|
<span id="line1006"></span>
<span id="line1007"></span>
<span id="line1008"></span>
<span id="line1009"></span>
<span id="line1010"></span>
<span id="line1011"></span>
<span id="line1012"></span>
<span id="line1013"></span>
<span id="line1014"></span>
<span id="line1015"></span>
<span id="line1016"></span>
<span id="line1017"></span>
<span id="line1018"></span>
<span id="line1019"></span>
<span id="line1020"></span>
<span id="line1021"></span>
<span id="line1022"></span>          3.1.5  Collating_Sequence_and_Graphics.  The  order  in
<span id="line1023"></span>          which  the  letters  are  listed in 3.1.1 specifies the
<span id="line1024"></span>          collating sequence for the letters; A is less  than  Z.
<span id="line1025"></span>          The  order  in  which  the  digits  are listed in 3.1.2
<span id="line1026"></span>          specifies the collating sequence for the digits;  0  is
<span id="line1027"></span>          less  than  9.   The  digits  and  letters  must not be
<span id="line1028"></span>          intermixed in the collating sequence; all of the digits
<span id="line1029"></span>          must  precede A or all of the digits must follow Z. The
<span id="line1030"></span>
<span id="line1031"></span>9
<span id="line1032"></span>          FORTRAN 77 Full Language                       Page 3-1
<span id="line1033"></span>
<span id="line1034"></span>
<span id="line1035"></span>
<span id="line1036"></span>
<span id="line1037"></span>
<span id="line1038"></span>
<span id="line1039"></span>
<span id="line1040"></span>          CHARACTERS, LINES, AND EXECUTION SEQUENCEANSI X3J3/90.4
<span id="line1041"></span>
<span id="line1042"></span>
<span id="line1043"></span>
<span id="line1044"></span>          character blank is less than the letter A and less than
<span id="line1045"></span>          the digit 0.  The order in which the special characters
<span id="line1046"></span>          are  listed  in  3.1.4  does  not  imply  a   collating
<span id="line1047"></span>          sequence.
<span id="line1048"></span>
<span id="line1049"></span>          Except for the currency symbol, the graphics  used  for
<span id="line1050"></span>          the  forty-nine  characters  must be as given in 3.1.1,
<span id="line1051"></span>          3.1.2, and 3.1.4.  However, the style of any graphic is
<span id="line1052"></span>          not specified.
<span id="line1053"></span>
<span id="line1054"></span>          3.1.6  Blank_Character.  With the exception of the uses
<span id="line1055"></span>          specified  (3.2.2,  3.2.3, 3.3, 4.8, 4.8.1, 13.5.1, and
<span id="line1056"></span>          13.5.2), a blank character within a program unit has no
<span id="line1057"></span>          meaning  and  may  be used to improve the appearance of
<span id="line1058"></span>          the program unit, subject to  the  restriction  on  the
<span id="line1059"></span>          number of consecutive continuation lines (3.3).
<span id="line1060"></span>
<span id="line1061"></span>          3.2  Lines
<span id="line1062"></span>
<span id="line1063"></span>          A  line  in  a  program  unit  is  a  sequence  of   72
<span id="line1064"></span>          characters.   All  characters  must be from the FORTRAN
<span id="line1065"></span>          character set,  except  as  described  in  3.2.1,  4.8,
<span id="line1066"></span>          12.2.2, and 13.2.1.
<span id="line1067"></span>
<span id="line1068"></span>          The character positions in a line  are  called  columns
<span id="line1069"></span>          and  are  numbered consecutively 1, 2, through 72.  The
<span id="line1070"></span>          number indicates the sequential position of a character
<span id="line1071"></span>          in  the  line,  beginning at the left and proceeding to
<span id="line1072"></span>          the right.  Lines are ordered by the sequence in  which
<span id="line1073"></span>          they  are  presented to the processor.  Thus, a program
<span id="line1074"></span>          unit consists of a totally ordered set of characters.
<span id="line1075"></span>
<span id="line1076"></span>          3.2.1  Comment_Line.  A comment line is any  line  that
<span id="line1077"></span>          contains  a  C  or an asterisk in column 1, or contains
<span id="line1078"></span>          only blank characters  in  columns  1  through  72.   A
<span id="line1079"></span>          comment line that contains a C or an asterisk in column
<span id="line1080"></span>          1 may contain any character capable  of  representation
<span id="line1081"></span>          in the processor in columns 2 through 72.
<span id="line1082"></span>
<span id="line1083"></span>          A comment line does not affect the  executable  program
<span id="line1084"></span>          in any way and may be used to provide documentation.
<span id="line1085"></span>
<span id="line1086"></span>          Comment lines may appear anywhere in the program  unit.
<span id="line1087"></span>          Comment lines may precede the initial line of the first
<span id="line1088"></span>          statement of  any  program  unit.   Comment  lines  may
<span id="line1089"></span>          appear   between   an   initial   line  and  its  first
<span id="line1090"></span>          continuation line or between two continuation lines.
<span id="line1091"></span>
<span id="line1092"></span>          3.2.2  Initial_Line.  An initial line is any line  that
<span id="line1093"></span>          is  not a comment line and contains the character blank
<span id="line1094"></span>          or the digit 0 in column 6.  Columns 1  through  5  may
<span id="line1095"></span>
<span id="line1096"></span>
<span id="line1097"></span>
<span id="line1098"></span>          FORTRAN 77 Full Language                       Page 3-2
<span id="line1099"></span>
<span id="line1100"></span>
<span id="line1101"></span>
<span id="line1102"></span>
<span id="line1103"></span>
<span id="line1104"></span>
<span id="line1105"></span>
<span id="line1106"></span>          CHARACTERS, LINES, AND EXECUTION SEQUENCEANSI X3J3/90.4
<span id="line1107"></span>
<span id="line1108"></span>
<span id="line1109"></span>
<span id="line1110"></span>          contain a statement label (3.4), or each of the columns
<span id="line1111"></span>          1 through 5 must contain the character blank.
<span id="line1112"></span>
<span id="line1113"></span>          3.2.3  Continuation_Line.  A continuation line  is  any
<span id="line1114"></span>          line   that  contains  any  character  of  the  FORTRAN
<span id="line1115"></span>          character set other than the  character  blank  or  the
<span id="line1116"></span>          digit  0 in column 6 and contains only blank characters
<span id="line1117"></span>          in columns 1 through 5.  A statement must not have more
<span id="line1118"></span>          than nineteen continuation lines.
<span id="line1119"></span>
<span id="line1120"></span>          3.3  Statements
<span id="line1121"></span>
<span id="line1122"></span>          The statements of the FORTRAN language are described in
<span id="line1123"></span>          Sections  7  through  16  and  are used to form program
<span id="line1124"></span>          units.  Each statement is written in columns 7  through
<span id="line1125"></span>          72   of  an  initial  line  and  as  many  as  nineteen
<span id="line1126"></span>          continuation lines.  An END statement is  written  only
<span id="line1127"></span>          in  columns  7 through 72 of an initial line.  No other
<span id="line1128"></span>          statement in a program unit may have  an  initial  line
<span id="line1129"></span>          that  appears  to  be  an  END  statement.  Note that a
<span id="line1130"></span>          statement must contain no more  than  1320  characters.
<span id="line1131"></span>          Except  as  part  of  a logical IF statement (11.5), no
<span id="line1132"></span>          statement may begin on a line that contains any part of
<span id="line1133"></span>          the previous statement.
<span id="line1134"></span>
<span id="line1135"></span>          Blank characters  preceding,  within,  or  following  a
<span id="line1136"></span>          statement  do  not  change  the  interpretation  of the
<span id="line1137"></span>          statement, except when they  appear  within  the  datum
<span id="line1138"></span>          strings  of  character constants or the H or apostrophe
<span id="line1139"></span>          edit descriptors in FORMAT statements.  However,  blank
<span id="line1140"></span>          characters do count as characters in the limit of total
<span id="line1141"></span>          characters allowed in any one statement.
<span id="line1142"></span>
<span id="line1143"></span>          3.4  Statement_Labels
<span id="line1144"></span>
<span id="line1145"></span>          Statement  labels  provide  a  means  of  referring  to
<span id="line1146"></span>          individual  statements.   Any statement may be labeled,
<span id="line1147"></span>          but  only  labeled  executable  statements  and  FORMAT
<span id="line1148"></span>          statements  may  be referred to by the use of statement
<span id="line1149"></span>          labels.  The form of a statement label is a sequence of
<span id="line1150"></span>          one  to five digits, one of which must be nonzero.  The
<span id="line1151"></span>          statement label may be placed  anywhere  in  columns  1
<span id="line1152"></span>          through  5  of  the initial line of the statement.  The
<span id="line1153"></span>          same statement label must not be given to more than one
<span id="line1154"></span>          statement  in a program unit.  Blanks and leading zeros
<span id="line1155"></span>          are not significant in distinguishing between statement
<span id="line1156"></span>          labels.
<span id="line1157"></span>
<span id="line1158"></span>
<span id="line1159"></span>
<span id="line1160"></span>
<span id="line1161"></span>
<span id="line1162"></span>
<span id="line1163"></span>
<span id="line1164"></span>          FORTRAN 77 Full Language                       Page 3-3
<span id="line1165"></span>
<span id="line1166"></span>
<span id="line1167"></span>
<span id="line1168"></span>
<span id="line1169"></span>
<span id="line1170"></span>
<span id="line1171"></span>
<span id="line1172"></span>          CHARACTERS, LINES, AND EXECUTION SEQUENCEANSI X3J3/90.4
<span id="line1173"></span>
<span id="line1174"></span>
<span id="line1175"></span>
<span id="line1176"></span>          3.5  Order_of_Statements_and_Lines
<span id="line1177"></span>
<span id="line1178"></span>          A PROGRAM  statement  may  appear  only  as  the  first
<span id="line1179"></span>          statement  of a main program.  The first statement of a
<span id="line1180"></span>          subprogram must be either a  FUNCTION,  SUBROUTINE,  or
<span id="line1181"></span>          BLOCK DATA statement.
<span id="line1182"></span>
<span id="line1183"></span>          Within a program unit that permits the statements:
<span id="line1184"></span>
<span id="line1185"></span>             (1) FORMAT statements may appear anywhere;
<span id="line1186"></span>
<span id="line1187"></span>             (2) all specification statements  must  precede  all
<span id="line1188"></span>                 DATA  statements, statement function statements,
<span id="line1189"></span>                 and executable statements;
<span id="line1190"></span>
<span id="line1191"></span>             (3) all statement function statements  must  precede
<span id="line1192"></span>                 all executable statements;
<span id="line1193"></span>
<span id="line1194"></span>             (4) DATA statements may appear  anywhere  after  the
<span id="line1195"></span>                 specification statements; and
<span id="line1196"></span>
<span id="line1197"></span>             (5) ENTRY  statements  may  appear  anywhere  except
<span id="line1198"></span>                 between   a   block   IF   statement   and   its
<span id="line1199"></span>                 corresponding END IF statement, or between a  DO
<span id="line1200"></span>                 statement  and the terminal statement of its DO-
<span id="line1201"></span>                 loop.
<span id="line1202"></span>
<span id="line1203"></span>          Within the specification statements of a program  unit,
<span id="line1204"></span>          IMPLICIT    statements    must    precede   all   other
<span id="line1205"></span>          specification statements except  PARAMETER  statements.
<span id="line1206"></span>          Any  specification statement that specifies the type of
<span id="line1207"></span>          a  symbolic  name  of  a  constant  must  precede   the
<span id="line1208"></span>          PARAMETER   statement   that  defines  that  particular
<span id="line1209"></span>          symbolic name of a constant;  the  PARAMETER  statement
<span id="line1210"></span>          must   precede  all  other  statements  containing  the
<span id="line1211"></span>          symbolic names of constants that  are  defined  in  the
<span id="line1212"></span>          PARAMETER statement.
<span id="line1213"></span>
<span id="line1214"></span>          The last  line  of  a  program  unit  must  be  an  END
<span id="line1215"></span>          statement.
<span id="line1216"></span>
<span id="line1217"></span>
<span id="line1218"></span>
<span id="line1219"></span>
<span id="line1220"></span>
<span id="line1221"></span>
<span id="line1222"></span>
<span id="line1223"></span>
<span id="line1224"></span>
<span id="line1225"></span>
<span id="line1226"></span>
<span id="line1227"></span>
<span id="line1228"></span>
<span id="line1229"></span>
<span id="line1230"></span>          FORTRAN 77 Full Language                       Page 3-4
<span id="line1231"></span>
<span id="line1232"></span>
<span id="line1233"></span>
<span id="line1234"></span>
<span id="line1235"></span>
<span id="line1236"></span>
<span id="line1237"></span>
<span id="line1238"></span>          CHARACTERS, LINES, AND EXECUTION SEQUENCEANSI X3J3/90.4
<span id="line1239"></span>
<span id="line1240"></span>
<span id="line1241"></span>
<span id="line1242"></span>                                 Figure 1
<span id="line1243"></span>
<span id="line1244"></span>              Required Order of Statements and Comment Lines
<span id="line1245"></span>
<span id="line1246"></span>8          _______________________________________________________
<span id="line1247"></span>
<span id="line1248"></span>                          PROGRAM, FUNCTION, SUBROUTINE, or
<span id="line1249"></span>                                BLOCK DATA Statement
<span id="line1250"></span>8                    _____________________________________________
<span id="line1251"></span>
<span id="line1252"></span>                                                    IMPLICIT
<span id="line1253"></span>                                                   Statements
<span id="line1254"></span>                                    PARAMETER8   _________________
<span id="line1255"></span>9           Comment      FORMAT      Statements        Other
<span id="line1256"></span>            Lines        and                      Specification
<span id="line1257"></span>                        ENTRY                      Statements
<span id="line1258"></span>                      Statements8  _______________________________
<span id="line1259"></span>9                                                    Statement
<span id="line1260"></span>                                                    Function
<span id="line1261"></span>                                       DATA        Statements
<span id="line1262"></span>                                    Statements8  _________________
<span id="line1263"></span>9                                                   Executable
<span id="line1264"></span>                   |8|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|999999999999999999999999999999999             |7|7|7|7|7|7|7|7|7|7|7|7|7|99999999999999999999999999             |7|7|7|7|7|7|7|7|7|7|7|7|7|99999999999999999999999999   Statements
<span id="line1265"></span>8          _______________________________________________________
<span id="line1266"></span>
<span id="line1267"></span>                              END Statement
<span id="line1268"></span>8          _______________________________________________________
<span id="line1269"></span>7         |8|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|
<span id="line1270"></span>
<span id="line1271"></span>
<span id="line1272"></span>
<span id="line1273"></span>
<span id="line1274"></span>
<span id="line1275"></span>
<span id="line1276"></span>
<span id="line1277"></span>
<span id="line1278"></span>
<span id="line1279"></span>
<span id="line1280"></span>
<span id="line1281"></span>
<span id="line1282"></span>
<span id="line1283"></span>
<span id="line1284"></span>
<span id="line1285"></span>
<span id="line1286"></span>
<span id="line1287"></span>
<span id="line1288"></span>9                                                                |8|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|
<span id="line1289"></span>
<span id="line1290"></span>
<span id="line1291"></span>
<span id="line1292"></span>
<span id="line1293"></span>
<span id="line1294"></span>
<span id="line1295"></span>
<span id="line1296"></span>
<span id="line1297"></span>
<span id="line1298"></span>
<span id="line1299"></span>
<span id="line1300"></span>
<span id="line1301"></span>
<span id="line1302"></span>
<span id="line1303"></span>
<span id="line1304"></span>
<span id="line1305"></span>
<span id="line1306"></span>
<span id="line1307"></span>
<span id="line1308"></span>
<span id="line1309"></span>9          Figure  1  is  a  diagram  of  the  required  order  of
<span id="line1310"></span>          statements  and  comment  lines  for  a  program  unit.
<span id="line1311"></span>          Vertical lines delineate varieties of  statements  that
<span id="line1312"></span>          may  be  interspersed.   For example, FORMAT statements
<span id="line1313"></span>          may be interspersed with statement function  statements
<span id="line1314"></span>          and  executable statements.  Horizontal lines delineate
<span id="line1315"></span>          varieties of statements that must not be  interspersed.
<span id="line1316"></span>          For  example, statement function statements must not be
<span id="line1317"></span>          interspersed with executable statements.  Note that  an
<span id="line1318"></span>          END  statement is also an executable statement and must
<span id="line1319"></span>          appear only as the last statement of a program unit.
<span id="line1320"></span>
<span id="line1321"></span>          3.6  Normal_Execution_Sequence_and_Transfer_of_Control
<span id="line1322"></span>
<span id="line1323"></span>          Normal  execution  sequence   is   the   execution   of
<span id="line1324"></span>          executable statements in the order in which they appear
<span id="line1325"></span>          in a program unit.  Execution of an executable  program
<span id="line1326"></span>          begins  with  the  execution  of  the  first executable
<span id="line1327"></span>          statement  of  the  main  program.   When  an  external
<span id="line1328"></span>          procedure  specified  in  a  subprogram  is referenced,
<span id="line1329"></span>          execution begins with the  first  executable  statement
<span id="line1330"></span>          that   follows   the  FUNCTION,  SUBROUTINE,  or  ENTRY
<span id="line1331"></span>          statement that specifies the  referenced  procedure  as
<span id="line1332"></span>          the name of a procedure.
<span id="line1333"></span>
<span id="line1334"></span>
<span id="line1335"></span>
<span id="line1336"></span>
<span id="line1337"></span>          FORTRAN 77 Full Language                       Page 3-5
<span id="line1338"></span>
<span id="line1339"></span>
<span id="line1340"></span>
<span id="line1341"></span>
<span id="line1342"></span>
<span id="line1343"></span>
<span id="line1344"></span>
<span id="line1345"></span>          CHARACTERS, LINES, AND EXECUTION SEQUENCEANSI X3J3/90.4
<span id="line1346"></span>
<span id="line1347"></span>
<span id="line1348"></span>
<span id="line1349"></span>          A transfer of control is an alteration  of  the  normal
<span id="line1350"></span>          execution   sequence.   Statements  that  may  cause  a
<span id="line1351"></span>          transfer of control are:
<span id="line1352"></span>
<span id="line1353"></span>             (1) GO TO
<span id="line1354"></span>
<span id="line1355"></span>             (2) Arithmetic IF
<span id="line1356"></span>
<span id="line1357"></span>             (3) RETURN
<span id="line1358"></span>
<span id="line1359"></span>             (4) STOP
<span id="line1360"></span>
<span id="line1361"></span>             (5) An input/output statement  containing  an  error
<span id="line1362"></span>                 specifier or end-of-file specifier
<span id="line1363"></span>
<span id="line1364"></span>             (6) CALL with an alternate return specifier
<span id="line1365"></span>
<span id="line1366"></span>             (7) A logical IF statement  containing  any  of  the
<span id="line1367"></span>                 above forms
<span id="line1368"></span>
<span id="line1369"></span>             (8) Block IF and ELSE IF
<span id="line1370"></span>
<span id="line1371"></span>             (9) The last statement, if any, of  an  IF-block  or
<span id="line1372"></span>                 ELSE IF-block
<span id="line1373"></span>
<span id="line1374"></span>            (10) DO
<span id="line1375"></span>
<span id="line1376"></span>            (11) The terminal statement of a DO-loop
<span id="line1377"></span>
<span id="line1378"></span>            (12) END
<span id="line1379"></span>
<span id="line1380"></span>          The  effect  of  these  statements  on  the   execution
<span id="line1381"></span>          sequence is described in Sections 11, 12, and 15.
<span id="line1382"></span>
<span id="line1383"></span>          The normal execution sequence is not  affected  by  the
<span id="line1384"></span>          appearance of nonexecutable statements or comment lines
<span id="line1385"></span>          between executable statements.  Execution of a function
<span id="line1386"></span>          reference  or  a  CALL  statement  is  not considered a
<span id="line1387"></span>          transfer of control in the program unit  that  contains
<span id="line1388"></span>          the  reference,  except  when  control is returned to a
<span id="line1389"></span>          statement identified by an alternate  return  specifier
<span id="line1390"></span>          in  a  CALL  statement.   Execution  of a RETURN or END
<span id="line1391"></span>          statement in a referenced procedure, or execution of  a
<span id="line1392"></span>          transfer  of  control within a referenced procedure, is
<span id="line1393"></span>          not considered a transfer of  control  in  the  program
<span id="line1394"></span>          unit that contains the reference.
<span id="line1395"></span>
<span id="line1396"></span>          In the execution of an executable program, a  procedure
<span id="line1397"></span>          subprogram must not be referenced a second time without
<span id="line1398"></span>          the prior execution of a RETURN  or  END  statement  in
<span id="line1399"></span>          that procedure.
<span id="line1400"></span>
<span id="line1401"></span>
<span id="line1402"></span>
<span id="line1403"></span>          FORTRAN 77 Full Language                       Page 3-6
<span id="line1404"></span>
<span id="line1405"></span>
<span id="line1406"></span>
<span id="line1407"></span>
<span id="line1408"></span>
<span id="line1409"></span>
<span id="line1410"></span>
<span id="line1411"></span>          CHARACTERS, LINES, AND EXECUTION SEQUENCEANSI X3J3/90.4
<span id="line1412"></span>
<span id="line1413"></span>
<span id="line1414"></span>
<span id="line1415"></span>
<span id="line1416"></span>
<span id="line1417"></span>
<span id="line1418"></span>
<span id="line1419"></span>
<span id="line1420"></span>
<span id="line1421"></span>
<span id="line1422"></span>
<span id="line1423"></span>
<span id="line1424"></span>
<span id="line1425"></span>
<span id="line1426"></span>
<span id="line1427"></span>
<span id="line1428"></span>
<span id="line1429"></span>
<span id="line1430"></span>
<span id="line1431"></span>
<span id="line1432"></span>
<span id="line1433"></span>
<span id="line1434"></span>
<span id="line1435"></span>
<span id="line1436"></span>
<span id="line1437"></span>
<span id="line1438"></span>
<span id="line1439"></span>
<span id="line1440"></span>
<span id="line1441"></span>
<span id="line1442"></span>
<span id="line1443"></span>
<span id="line1444"></span>
<span id="line1445"></span>
<span id="line1446"></span>
<span id="line1447"></span>
<span id="line1448"></span>
<span id="line1449"></span>
<span id="line1450"></span>
<span id="line1451"></span>
<span id="line1452"></span>
<span id="line1453"></span>
<span id="line1454"></span>
<span id="line1455"></span>
<span id="line1456"></span>
<span id="line1457"></span>
<span id="line1458"></span>
<span id="line1459"></span>
<span id="line1460"></span>
<span id="line1461"></span>
<span id="line1462"></span>
<span id="line1463"></span>
<span id="line1464"></span>
<span id="line1465"></span>
<span id="line1466"></span>
<span id="line1467"></span>
<span id="line1468"></span>
<span id="line1469"></span>          FORTRAN 77 Full Language                       Page 3-7
<span id="line1470"></span>
<span id="line1471"></span>
<span id="line1472"></span>
<span id="line1473"></span>
<span id="line1474"></span>
<span id="line1475"></span>
<span id="line1476"></span>
<span id="line1477"></span>
<span id="line1478"></span>
<span id="line1479"></span>
<span id="line1480"></span>
<span id="line1481"></span>                                 CONTENTS
<span id="line1482"></span>
<span id="line1483"></span>
<span id="line1484"></span>          3.  CHARACTERS, LINES, AND EXECUTION SEQUENCE.....  3-
<span id="line1485"></span>              1
<span id="line1486"></span>              3.1  FORTRAN Character Set....................  3-1
<span id="line1487"></span>                   3.1.1  Letters...........................  3-1
<span id="line1488"></span>                   3.1.2  Digits............................  3-1
<span id="line1489"></span>                   3.1.3  Alphanumeric Characters...........  3-1
<span id="line1490"></span>                   3.1.4  Special Characters................  3-1
<span id="line1491"></span>                   3.1.5  Collating Sequence and
<span id="line1492"></span>                          Graphics..........................  3-1
<span id="line1493"></span>                   3.1.6  Blank Character...................  3-2
<span id="line1494"></span>              3.2  Lines....................................  3-2
<span id="line1495"></span>                   3.2.1  Comment Line......................  3-2
<span id="line1496"></span>                   3.2.2  Initial Line......................  3-2
<span id="line1497"></span>                   3.2.3  Continuation Line.................  3-3
<span id="line1498"></span>              3.3  Statements...............................  3-3
<span id="line1499"></span>              3.4  Statement Labels.........................  3-3
<span id="line1500"></span>              3.5  Order of Statements and Lines............  3-4
<span id="line1501"></span>              3.6  Normal Execution Sequence and Transfer
<span id="line1502"></span>                   of Control...............................  3-5
<span id="line1503"></span>
<span id="line1504"></span>
<span id="line1505"></span>
<span id="line1506"></span>
<span id="line1507"></span>
<span id="line1508"></span>
<span id="line1509"></span>
<span id="line1510"></span>
<span id="line1511"></span>
<span id="line1512"></span>
<span id="line1513"></span>
<span id="line1514"></span>
<span id="line1515"></span>
<span id="line1516"></span>
<span id="line1517"></span>
<span id="line1518"></span>
<span id="line1519"></span>
<span id="line1520"></span>
<span id="line1521"></span>
<span id="line1522"></span>
<span id="line1523"></span>
<span id="line1524"></span>
<span id="line1525"></span>
<span id="line1526"></span>
<span id="line1527"></span>
<span id="line1528"></span>
<span id="line1529"></span>
<span id="line1530"></span>
<span id="line1531"></span>
<span id="line1532"></span>
<span id="line1533"></span>
<span id="line1534"></span>
<span id="line1535"></span>                                   - i -
<span id="line1536"></span>
<span id="line1537"></span>
<span id="line1538"></span>
<span id="line1539"></span>
<span id="line1540"></span>
<span id="line1541"></span>
<span id="line1542"></span>
<span id="line1543"></span>                                                   ANSI X3J3/90.4
<span id="line1544"></span>
<span id="line1545"></span>
<span id="line1546"></span>
<span id="line1547"></span>                       4.  DATA_TYPES_AND_CONSTANTS
<span id="line1548"></span>
<span id="line1549"></span>          4.1  Data_Types
<span id="line1550"></span>
<span id="line1551"></span>          The six types of data are:
<span id="line1552"></span>
<span id="line1553"></span>             (1) Integer
<span id="line1554"></span>
<span id="line1555"></span>             (2) Real
<span id="line1556"></span>
<span id="line1557"></span>             (3) Double precision
<span id="line1558"></span>
<span id="line1559"></span>             (4) Complex
<span id="line1560"></span>
<span id="line1561"></span>             (5) Logical
<span id="line1562"></span>
<span id="line1563"></span>             (6) Character
<span id="line1564"></span>
<span id="line1565"></span>          Each  type  is  different  and  may  have  a  different
<span id="line1566"></span>          internal  representation.   The  type  may  affect  the
<span id="line1567"></span>          interpretation of the operations involving the datum.
<span id="line1568"></span>
<span id="line1569"></span>          4.1.1  Data_Type_of_a_Name.   The  name   employed   to
<span id="line1570"></span>          identify a datum or a function also identifies its data
<span id="line1571"></span>          type.   A  symbolic  name  representing   a   constant,
<span id="line1572"></span>          variable,   array,   or   function  (except  a  generic
<span id="line1573"></span>          function) must have only  one  type  for  each  program
<span id="line1574"></span>          unit.   Once  a  particular  name  is identified with a
<span id="line1575"></span>          particular type in a program unit, that type is implied
<span id="line1576"></span>          for  any  usage  of  the  name in the program unit that
<span id="line1577"></span>          requires a type.
<span id="line1578"></span>
<span id="line1579"></span>          4.1.2  Type_Rules_for_Data_and_Procedure_Identifiers.
<span id="line1580"></span>          A  symbolic  name that identifies a constant, variable,
<span id="line1581"></span>          array, external function,  or  statement  function  may
<span id="line1582"></span>          have  its  type  specified in a type-statement (8.4) as
<span id="line1583"></span>          integer, real, double precision, complex,  logical,  or
<span id="line1584"></span>          character.   In  the absence of an explicit declaration
<span id="line1585"></span>          in a type-statement, the type is implied by  the  first
<span id="line1586"></span>          letter  of  the name.  A first letter of I, J, K, L, M,
<span id="line1587"></span>          or N implies type integer and any other letter  implies
<span id="line1588"></span>          type  real,  unless an IMPLICIT statement (8.5) is used
<span id="line1589"></span>          to change the default implied type.
<span id="line1590"></span>
<span id="line1591"></span>          The data type of an array element name is the  same  as
<span id="line1592"></span>          the type of its array name.
<span id="line1593"></span>
<span id="line1594"></span>          The data type of a function name specifies the type  of
<span id="line1595"></span>          the  datum  supplied  by  the  function reference in an
<span id="line1596"></span>          expression.
<span id="line1597"></span>
<span id="line1598"></span>
<span id="line1599"></span>
<span id="line1600"></span>
<span id="line1601"></span>          FORTRAN 77 Full Language                       Page 4-1
<span id="line1602"></span>
<span id="line1603"></span>
<span id="line1604"></span>
<span id="line1605"></span>
<span id="line1606"></span>
<span id="line1607"></span>
<span id="line1608"></span>
<span id="line1609"></span>          DATA TYPES AND CONSTANTS                 ANSI X3J3/90.4
<span id="line1610"></span>
<span id="line1611"></span>
<span id="line1612"></span>
<span id="line1613"></span>          A symbolic name that identifies  a  specific  intrinsic
<span id="line1614"></span>          function  in  a program unit has a type as specified in
<span id="line1615"></span>          15.10.  An explicit  type-statement  is  not  required;
<span id="line1616"></span>          however, it is permitted.  A generic function name does
<span id="line1617"></span>          not have a predetermined type; the result of a  generic
<span id="line1618"></span>          function  reference  assumes a type that depends on the
<span id="line1619"></span>          type of the argument, as  specified  in  15.10.   If  a
<span id="line1620"></span>          generic function name appears in a type-statement, such
<span id="line1621"></span>          an appearance is not sufficient by itself to remove the
<span id="line1622"></span>          generic properties from that function.
<span id="line1623"></span>
<span id="line1624"></span>          In a program unit that contains  an  external  function
<span id="line1625"></span>          reference,  the  type  of the function is determined in
<span id="line1626"></span>          the same manner as for variables and arrays.
<span id="line1627"></span>
<span id="line1628"></span>          The  type  of  an  external   function   is   specified
<span id="line1629"></span>          implicitly  by  its  name,  explicitly  in  a  FUNCTION
<span id="line1630"></span>          statement, or explicitly  in  a  type-statement.   Note
<span id="line1631"></span>          that an IMPLICIT statement within a function subprogram
<span id="line1632"></span>          may affect the type of the external function  specified
<span id="line1633"></span>          in the subprogram.
<span id="line1634"></span>
<span id="line1635"></span>          A  symbolic  name  that  identifies  a  main   program,
<span id="line1636"></span>          subroutine,  common block, or block data subprogram has
<span id="line1637"></span>          no data type.
<span id="line1638"></span>
<span id="line1639"></span>          4.1.3  Data_Type_Properties.   The   mathematical   and
<span id="line1640"></span>          representation  properties  for  each of the data types
<span id="line1641"></span>          are specified in the  following  sections.   For  real,
<span id="line1642"></span>          double  precision,  and integer data, the value zero is
<span id="line1643"></span>          considered neither positive nor negative.  The value of
<span id="line1644"></span>          a  signed  zero is the same as the value of an unsigned
<span id="line1645"></span>          zero.
<span id="line1646"></span>
<span id="line1647"></span>          4.2  Constants
<span id="line1648"></span>
<span id="line1649"></span>          A constant is an arithmetic constant, logical constant,
<span id="line1650"></span>          or  character  constant.   The value of a constant does
<span id="line1651"></span>          not  change.   Within  an   executable   program,   all
<span id="line1652"></span>          constants that have the same form have the same value.
<span id="line1653"></span>
<span id="line1654"></span>          4.2.1  Data_Type_of_a_Constant.  The form of the string
<span id="line1655"></span>          representing  a  constant  specifies both its value and
<span id="line1656"></span>          data  type.   A  PARAMETER  statement  (8.6)  allows  a
<span id="line1657"></span>          constant  to  be  given  a symbolic name.  The symbolic
<span id="line1658"></span>          name of a constant must not be used  to  form  part  of
<span id="line1659"></span>          another constant.
<span id="line1660"></span>
<span id="line1661"></span>          4.2.2  Blanks_in_Constants.  Blank characters occurring
<span id="line1662"></span>          in  a constant, except in a character constant, have no
<span id="line1663"></span>          effect on the value of the constant.
<span id="line1664"></span>
<span id="line1665"></span>
<span id="line1666"></span>
<span id="line1667"></span>          FORTRAN 77 Full Language                       Page 4-2
<span id="line1668"></span>
<span id="line1669"></span>
<span id="line1670"></span>
<span id="line1671"></span>
<span id="line1672"></span>
<span id="line1673"></span>
<span id="line1674"></span>
<span id="line1675"></span>          DATA TYPES AND CONSTANTS                 ANSI X3J3/90.4
<span id="line1676"></span>
<span id="line1677"></span>
<span id="line1678"></span>
<span id="line1679"></span>          4.2.3  Arithmetic_Constants.   Integer,  real,   double
<span id="line1680"></span>          precision,   and   complex   constants  are  arithmetic
<span id="line1681"></span>          constants.
<span id="line1682"></span>
<span id="line1683"></span>          4.2.3.1  Signs_of_Constants.  An unsigned constant is a
<span id="line1684"></span>          constant  without a leading sign.  A signed constant is
<span id="line1685"></span>          a constant with a  leading  plus  or  minus  sign.   An
<span id="line1686"></span>          optionally  signed  constant  is a constant that may be
<span id="line1687"></span>          either signed or unsigned.  Integer, real,  and  double
<span id="line1688"></span>          precision constants may be optionally signed constants,
<span id="line1689"></span>          except where specified otherwise.
<span id="line1690"></span>
<span id="line1691"></span>          4.3  Integer_Type
<span id="line1692"></span>
<span id="line1693"></span>          An integer datum is always an exact  representation  of
<span id="line1694"></span>          an  integer value.  It may assume a positive, negative,
<span id="line1695"></span>          or zero value.  It may assume only an  integral  value.
<span id="line1696"></span>          An  integer  datum  has  one  numeric storage unit in a
<span id="line1697"></span>          storage sequence.
<span id="line1698"></span>
<span id="line1699"></span>          4.3.1  Integer_Constant.   The  form  of   an   integer
<span id="line1700"></span>          constant  is  an  optional  sign followed by a nonempty
<span id="line1701"></span>          string of digits.  The digit string is interpreted as a
<span id="line1702"></span>          decimal number.
<span id="line1703"></span>
<span id="line1704"></span>          4.4  Real_Type
<span id="line1705"></span>
<span id="line1706"></span>          A real datum is a processor approximation to the  value
<span id="line1707"></span>          of  a real number.  It may assume a positive, negative,
<span id="line1708"></span>          or zero value.  A real datum has  one  numeric  storage
<span id="line1709"></span>          unit in a storage sequence.
<span id="line1710"></span>
<span id="line1711"></span>          4.4.1  Basic_Real_Constant.  The form of a  basic  real
<span id="line1712"></span>          constant  is  an  optional  sign,  an  integer  part, a
<span id="line1713"></span>          decimal point, and a fractional part,  in  that  order.
<span id="line1714"></span>          Both  the  integer  part  and  the  fractional part are
<span id="line1715"></span>          strings of digits; either of these parts may be omitted
<span id="line1716"></span>          but  not  both.   A  basic real constant may be written
<span id="line1717"></span>          with  more  digits  than  a  processor  will   use   to
<span id="line1718"></span>          approximate  the  value  of the constant.  A basic real
<span id="line1719"></span>          constant is interpreted as a decimal number.
<span id="line1720"></span>
<span id="line1721"></span>          4.4.2  Real_Exponent.  The form of a real  exponent  is
<span id="line1722"></span>          the  letter  E followed by an optionally signed integer
<span id="line1723"></span>          constant.  A real exponent denotes a power of ten.
<span id="line1724"></span>
<span id="line1725"></span>          4.4.3  Real_Constant.  The forms  of  a  real  constant
<span id="line1726"></span>          are:
<span id="line1727"></span>
<span id="line1728"></span>             (1) Basic real constant
<span id="line1729"></span>
<span id="line1730"></span>
<span id="line1731"></span>
<span id="line1732"></span>
<span id="line1733"></span>          FORTRAN 77 Full Language                       Page 4-3
<span id="line1734"></span>
<span id="line1735"></span>
<span id="line1736"></span>
<span id="line1737"></span>
<span id="line1738"></span>
<span id="line1739"></span>
<span id="line1740"></span>
<span id="line1741"></span>          DATA TYPES AND CONSTANTS                 ANSI X3J3/90.4
<span id="line1742"></span>
<span id="line1743"></span>
<span id="line1744"></span>
<span id="line1745"></span>             (2) Basic real constant followed by a real exponent
<span id="line1746"></span>
<span id="line1747"></span>             (3) Integer constant followed by a real exponent
<span id="line1748"></span>
<span id="line1749"></span>          The value of a  real  constant  that  contains  a  real
<span id="line1750"></span>          exponent  is  the product of the constant that precedes
<span id="line1751"></span>          the E and the power of ten  indicated  by  the  integer
<span id="line1752"></span>          following the E.  The integer constant part of form (3)
<span id="line1753"></span>          may be written with more digits than a  processor  will
<span id="line1754"></span>          use to approximate the value of the constant.
<span id="line1755"></span>
<span id="line1756"></span>          4.5  Double_Precision_Type
<span id="line1757"></span>
<span id="line1758"></span>          A double precision datum is a  processor  approximation
<span id="line1759"></span>          to the value of a real number.  The precision, although
<span id="line1760"></span>          not specified, must be greater than that of type  real.
<span id="line1761"></span>          A   double  precision  datum  may  assume  a  positive,
<span id="line1762"></span>          negative, or zero value.  A double precision datum  has
<span id="line1763"></span>          two  consecutive  numeric  storage  units  in a storage
<span id="line1764"></span>          sequence.
<span id="line1765"></span>
<span id="line1766"></span>          4.5.1  Double_Precision_Exponent.  The form of a double
<span id="line1767"></span>          precision  exponent  is  the  letter  D  followed by an
<span id="line1768"></span>          optionally signed integer constant.  A double precision
<span id="line1769"></span>          exponent  denotes  a  power of ten.  Note that the form
<span id="line1770"></span>          and interpretation of a double precision  exponent  are
<span id="line1771"></span>          identical  to those of a real exponent, except that the
<span id="line1772"></span>          letter D is used instead of the letter E.
<span id="line1773"></span>
<span id="line1774"></span>          4.5.2  Double_Precision_Constant.   The  forms   of   a
<span id="line1775"></span>          double precision constant are:
<span id="line1776"></span>
<span id="line1777"></span>             (1) Basic  real  constant  followed  by   a   double
<span id="line1778"></span>                 precision exponent
<span id="line1779"></span>
<span id="line1780"></span>             (2) Integer constant followed by a double  precision
<span id="line1781"></span>                 exponent
<span id="line1782"></span>
<span id="line1783"></span>          The value of a double precision constant is the product
<span id="line1784"></span>          of  the  constant  that precedes the D and the power of
<span id="line1785"></span>          ten indicated by the  integer  following  the  D.   The
<span id="line1786"></span>          integer  constant  part of form (2) may be written with
<span id="line1787"></span>          more digits than a processor will  use  to  approximate
<span id="line1788"></span>          the value of the constant.
<span id="line1789"></span>
<span id="line1790"></span>          4.6  Complex_Type
<span id="line1791"></span>
<span id="line1792"></span>          A complex datum is a  processor  approximation  to  the
<span id="line1793"></span>          value  of  a  complex  number.  The representation of a
<span id="line1794"></span>          complex datum is in the form of an ordered pair of real
<span id="line1795"></span>          data.   The  first of the pair represents the real part
<span id="line1796"></span>
<span id="line1797"></span>
<span id="line1798"></span>
<span id="line1799"></span>          FORTRAN 77 Full Language                       Page 4-4
<span id="line1800"></span>
<span id="line1801"></span>
<span id="line1802"></span>
<span id="line1803"></span>
<span id="line1804"></span>
<span id="line1805"></span>
<span id="line1806"></span>
<span id="line1807"></span>          DATA TYPES AND CONSTANTS                 ANSI X3J3/90.4
<span id="line1808"></span>
<span id="line1809"></span>
<span id="line1810"></span>
<span id="line1811"></span>          of the complex datum  and  the  second  represents  the
<span id="line1812"></span>          imaginary  part.   Each  part  has  the  same degree of
<span id="line1813"></span>          approximation as for a real datum.  A complex datum has
<span id="line1814"></span>          two  consecutive  numeric  storage  units  in a storage
<span id="line1815"></span>          sequence; the first storage unit is the real  part  and
<span id="line1816"></span>          the second storage unit is the imaginary part.
<span id="line1817"></span>
<span id="line1818"></span>          4.6.1  Complex_Constant.   The  form   of   a   complex
<span id="line1819"></span>          constant  is  a left parenthesis followed by an ordered
<span id="line1820"></span>          pair of real or integer constants separated by a comma,
<span id="line1821"></span>          and   followed  by  a  right  parenthesis.   The  first
<span id="line1822"></span>          constant of the pair is the real part  of  the  complex
<span id="line1823"></span>          constant and the second is the imaginary part.
<span id="line1824"></span>
<span id="line1825"></span>          4.7  Logical_Type
<span id="line1826"></span>
<span id="line1827"></span>          A logical datum may assume  only  the  values  true  or
<span id="line1828"></span>          false.  A logical datum has one numeric storage unit in
<span id="line1829"></span>          a storage sequence.
<span id="line1830"></span>
<span id="line1831"></span>          4.7.1  Logical_Constant.  The forms  and  values  of  a
<span id="line1832"></span>          logical constant are:
<span id="line1833"></span>
<span id="line1834"></span>8                             _________________
<span id="line1835"></span>
<span id="line1836"></span>                               Form     Value
<span id="line1837"></span>8                             _________________
<span id="line1838"></span>
<span id="line1839"></span>                              .TRUE.    true
<span id="line1840"></span>
<span id="line1841"></span>                              .FALSE.   false
<span id="line1842"></span>
<span id="line1843"></span>8                             _________________
<span id="line1844"></span>7                            |7|7|7|7|7|7|7|
<span id="line1845"></span>
<span id="line1846"></span>
<span id="line1847"></span>
<span id="line1848"></span>
<span id="line1849"></span>
<span id="line1850"></span>
<span id="line1851"></span>                                     |7|7|7|7|7|7|7|
<span id="line1852"></span>
<span id="line1853"></span>
<span id="line1854"></span>
<span id="line1855"></span>
<span id="line1856"></span>
<span id="line1857"></span>
<span id="line1858"></span>                                             |7|7|7|7|7|7|7|
<span id="line1859"></span>
<span id="line1860"></span>
<span id="line1861"></span>
<span id="line1862"></span>
<span id="line1863"></span>
<span id="line1864"></span>
<span id="line1865"></span>
<span id="line1866"></span>
<span id="line1867"></span>          4.8  Character_Type
<span id="line1868"></span>
<span id="line1869"></span>          A character datum  is  a  string  of  characters.   The
<span id="line1870"></span>          string   may  consist  of  any  characters  capable  of
<span id="line1871"></span>          representation in the processor.  The  blank  character
<span id="line1872"></span>          is  valid  and  significant  in a character datum.  The
<span id="line1873"></span>          length of a character datum is the number of characters
<span id="line1874"></span>          in  the  string.   A  character datum has one character
<span id="line1875"></span>          storage unit in a storage sequence for  each  character
<span id="line1876"></span>          in the string.
<span id="line1877"></span>
<span id="line1878"></span>          Each character in the string has a  character  position
<span id="line1879"></span>          that  is  numbered  consecutively  1,  2,  3, etc.  The
<span id="line1880"></span>          number indicates the sequential position of a character
<span id="line1881"></span>          in  the string, beginning at the left and proceeding to
<span id="line1882"></span>          the right.
<span id="line1883"></span>
<span id="line1884"></span>
<span id="line1885"></span>9
<span id="line1886"></span>
<span id="line1887"></span>
<span id="line1888"></span>          FORTRAN 77 Full Language                       Page 4-5
<span id="line1889"></span>
<span id="line1890"></span>
<span id="line1891"></span>
<span id="line1892"></span>
<span id="line1893"></span>
<span id="line1894"></span>
<span id="line1895"></span>
<span id="line1896"></span>          DATA TYPES AND CONSTANTS                 ANSI X3J3/90.4
<span id="line1897"></span>
<span id="line1898"></span>
<span id="line1899"></span>
<span id="line1900"></span>          4.8.1  Character_Constant.  The  form  of  a  character
<span id="line1901"></span>          constant is an apostrophe followed by a nonempty string
<span id="line1902"></span>          of characters followed by an  apostrophe.   The  string
<span id="line1903"></span>          may consist of any characters capable of representation
<span id="line1904"></span>          in the processor.  Note that the delimiting apostrophes
<span id="line1905"></span>          are  not part of the datum represented by the constant.
<span id="line1906"></span>          An apostrophe within the datum string is represented by
<span id="line1907"></span>          two consecutive apostrophes with no intervening blanks.
<span id="line1908"></span>          In a character constant, blanks  embedded  between  the
<span id="line1909"></span>          delimiting apostrophes are significant.
<span id="line1910"></span>
<span id="line1911"></span>          The length of a character constant  is  the  number  of
<span id="line1912"></span>          characters  between  the delimiting apostrophes, except
<span id="line1913"></span>          that each pair of consecutive apostrophes counts  as  a
<span id="line1914"></span>          single  character.   The delimiting apostrophes are not
<span id="line1915"></span>          counted.  The length of a character  constant  must  be
<span id="line1916"></span>          greater than zero.
<span id="line1917"></span>
<span id="line1918"></span>
<span id="line1919"></span>
<span id="line1920"></span>
<span id="line1921"></span>
<span id="line1922"></span>
<span id="line1923"></span>
<span id="line1924"></span>
<span id="line1925"></span>
<span id="line1926"></span>
<span id="line1927"></span>
<span id="line1928"></span>
<span id="line1929"></span>
<span id="line1930"></span>
<span id="line1931"></span>
<span id="line1932"></span>
<span id="line1933"></span>
<span id="line1934"></span>
<span id="line1935"></span>
<span id="line1936"></span>
<span id="line1937"></span>
<span id="line1938"></span>
<span id="line1939"></span>
<span id="line1940"></span>
<span id="line1941"></span>
<span id="line1942"></span>
<span id="line1943"></span>
<span id="line1944"></span>
<span id="line1945"></span>
<span id="line1946"></span>
<span id="line1947"></span>
<span id="line1948"></span>
<span id="line1949"></span>
<span id="line1950"></span>
<span id="line1951"></span>
<span id="line1952"></span>
<span id="line1953"></span>
<span id="line1954"></span>          FORTRAN 77 Full Language                       Page 4-6
<span id="line1955"></span>
<span id="line1956"></span>
<span id="line1957"></span>
<span id="line1958"></span>
<span id="line1959"></span>
<span id="line1960"></span>
<span id="line1961"></span>
<span id="line1962"></span>
<span id="line1963"></span>
<span id="line1964"></span>
<span id="line1965"></span>
<span id="line1966"></span>                                 CONTENTS
<span id="line1967"></span>
<span id="line1968"></span>
<span id="line1969"></span>          4.  DATA TYPES AND CONSTANTS......................  4-1
<span id="line1970"></span>              4.1  Data Types...............................  4-1
<span id="line1971"></span>                   4.1.1  Data Type of a Name...............  4-1
<span id="line1972"></span>                   4.1.2  Type Rules for Data and Procedure
<span id="line1973"></span>                          Identifiers.......................  4-1
<span id="line1974"></span>                   4.1.3  Data Type Properties..............  4-2
<span id="line1975"></span>              4.2  Constants................................  4-2
<span id="line1976"></span>                   4.2.1  Data Type of a Constant...........  4-2
<span id="line1977"></span>                   4.2.2  Blanks in Constants...............  4-2
<span id="line1978"></span>                   4.2.3  Arithmetic Constants..............  4-3
<span id="line1979"></span>              4.3  Integer Type.............................  4-3
<span id="line1980"></span>                   4.3.1  Integer Constant..................  4-3
<span id="line1981"></span>              4.4  Real Type................................  4-3
<span id="line1982"></span>                   4.4.1  Basic Real Constant...............  4-3
<span id="line1983"></span>                   4.4.2  Real Exponent.....................  4-3
<span id="line1984"></span>                   4.4.3  Real Constant.....................  4-3
<span id="line1985"></span>              4.5  Double Precision Type....................  4-4
<span id="line1986"></span>                   4.5.1  Double Precision Exponent.........  4-4
<span id="line1987"></span>                   4.5.2  Double Precision Constant.........  4-4
<span id="line1988"></span>              4.6  Complex Type.............................  4-4
<span id="line1989"></span>                   4.6.1  Complex Constant..................  4-5
<span id="line1990"></span>              4.7  Logical Type.............................  4-5
<span id="line1991"></span>                   4.7.1  Logical Constant..................  4-5
<span id="line1992"></span>              4.8  Character Type...........................  4-5
<span id="line1993"></span>                   4.8.1  Character Constant................  4-6
<span id="line1994"></span>
<span id="line1995"></span>
<span id="line1996"></span>
<span id="line1997"></span>
<span id="line1998"></span>
<span id="line1999"></span>
<span id="line2000"></span>
<span id="line2001"></span>
<span id="line2002"></span>
<span id="line2003"></span>
<span id="line2004"></span>
<span id="line2005"></span>
<span id="line2006"></span>
<span id="line2007"></span>
<span id="line2008"></span>
<span id="line2009"></span>
<span id="line2010"></span>
<span id="line2011"></span>
<span id="line2012"></span>
<span id="line2013"></span>
<span id="line2014"></span>
<span id="line2015"></span>
<span id="line2016"></span>
<span id="line2017"></span>
<span id="line2018"></span>
<span id="line2019"></span>
<span id="line2020"></span>                                   - i -
<span id="line2021"></span>
<span id="line2022"></span>
<span id="line2023"></span>
<span id="line2024"></span>
<span id="line2025"></span>
<span id="line2026"></span>
<span id="line2027"></span>
<span id="line2028"></span>                                                   ANSI X3J3/90.4
<span id="line2029"></span>
<span id="line2030"></span>
<span id="line2031"></span>
<span id="line2032"></span>                         5.  ARRAYS_AND_SUBSTRINGS
<span id="line2033"></span>
<span id="line2034"></span>          An array is a nonempty  sequence  of  data.   An  array
<span id="line2035"></span>          element  is  one  member  of  the sequence of data.  An
<span id="line2036"></span>          array name is the symbolic name of an array.  An  array
<span id="line2037"></span>          element name is an array name qualified by  a subscript
<span id="line2038"></span>          (5.3).
<span id="line2039"></span>
<span id="line2040"></span>          An array name not qualified by a  subscript  identifies
<span id="line2041"></span>          the entire sequence of elements of the array in certain
<span id="line2042"></span>          forms where such use is permitted (5.6); however, in an
<span id="line2043"></span>          EQUIVALENCE statement, an array name not qualified by a
<span id="line2044"></span>          subscript identifies the first  element  of  the  array
<span id="line2045"></span>          (8.2.4).
<span id="line2046"></span>
<span id="line2047"></span>          An array element name identifies  one  element  of  the
<span id="line2048"></span>          sequence.   The subscript value (Table 1) specifies the
<span id="line2049"></span>          element of the array  being  identified.   A  different
<span id="line2050"></span>          array   element  may  be  identified  by  changing  the
<span id="line2051"></span>          subscript value of the array element name.
<span id="line2052"></span>
<span id="line2053"></span>          An array name is local to a program unit (18.1.2).
<span id="line2054"></span>
<span id="line2055"></span>          A substring is a  contiguous  portion  of  a  character
<span id="line2056"></span>          datum.
<span id="line2057"></span>
<span id="line2058"></span>          5.1  Array_Declarator
<span id="line2059"></span>
<span id="line2060"></span>          An array declarator  specifies  a  symbolic  name  that
<span id="line2061"></span>          identifies an array within a program unit and specifies
<span id="line2062"></span>          certain  properties  of  the  array.   Only  one  array
<span id="line2063"></span>          declarator  for an array name is permitted in a program
<span id="line2064"></span>          unit.
<span id="line2065"></span>
<span id="line2066"></span>          5.1.1  Form_of_an_Array_Declarator.   The  form  of  an
<span id="line2067"></span>          array declarator is:
<span id="line2068"></span>
<span id="line2069"></span>                               a_ (d_ [,d_]...)
<span id="line2070"></span>
<span id="line2071"></span>          where: a_   is the symbolic name of the array
<span id="line2072"></span>
<span id="line2073"></span>                 d_   is a dimension declarator
<span id="line2074"></span>
<span id="line2075"></span>          The number of dimensions of the array is the number  of
<span id="line2076"></span>          dimension  declarators  in  the  array declarator.  The
<span id="line2077"></span>          minimum number of dimensions is one and the maximum  is
<span id="line2078"></span>          seven.
<span id="line2079"></span>
<span id="line2080"></span>          5.1.1.1  Form_of_a_Dimension_Declarator.  The form of a
<span id="line2081"></span>          dimension declarator is:
<span id="line2082"></span>
<span id="line2083"></span>
<span id="line2084"></span>
<span id="line2085"></span>
<span id="line2086"></span>          FORTRAN 77 Full Language                       Page 5-1
<span id="line2087"></span>
<span id="line2088"></span>
<span id="line2089"></span>
<span id="line2090"></span>
<span id="line2091"></span>
<span id="line2092"></span>
<span id="line2093"></span>
<span id="line2094"></span>          ARRAYS AND SUBSTRINGS                    ANSI X3J3/90.4
<span id="line2095"></span>
<span id="line2096"></span>
<span id="line2097"></span>
<span id="line2098"></span>                               [d_918:] d_92
<span id="line2099"></span>9          where: d_918  is the lower dimension bound
<span id="line2100"></span>
<span id="line2101"></span>                 d_928  is the upper dimension bound
<span id="line2102"></span>
<span id="line2103"></span>          The lower and upper  dimension  bounds  are  arithmetic
<span id="line2104"></span>          expressions,  called  dimension  bound  expressions, in
<span id="line2105"></span>          which all constants, symbolic names of  constants,  and
<span id="line2106"></span>          variables  are  of  type  integer.  The upper dimension
<span id="line2107"></span>          bound of the last  dimension  may  be  an  asterisk  in
<span id="line2108"></span>          assumed-size  array  declarators  (5.1.2).  A dimension
<span id="line2109"></span>          bound expression must not contain a function  or  array
<span id="line2110"></span>          element  reference.   Integer  variables  may appear in
<span id="line2111"></span>          dimension bound expressions only  in  adjustable  array
<span id="line2112"></span>          declarators (5.1.2).
<span id="line2113"></span>
<span id="line2114"></span>          If the symbolic name of a  constant  or  variable  that
<span id="line2115"></span>          appears  in  a  dimension  bound  expression  is not of
<span id="line2116"></span>          default  implied  integer  type  (4.1.2),  it  must  be
<span id="line2117"></span>          specified  as  integer  by  an  IMPLICIT statement or a
<span id="line2118"></span>          type-statement prior to its appearance in  a  dimension
<span id="line2119"></span>          bound expression.
<span id="line2120"></span>
<span id="line2121"></span>          5.1.1.2  Value_of_Dimension_Bounds.    The   value   of
<span id="line2122"></span>          either  dimension  bound  may be positive, negative, or
<span id="line2123"></span>          zero; however, the value of the upper  dimension  bound
<span id="line2124"></span>          must be greater than or equal to the value of the lower
<span id="line2125"></span>          dimension bound.  If only the upper dimension bound  is
<span id="line2126"></span>          specified,  the  value  of the lower dimension bound is
<span id="line2127"></span>          one.  An upper dimension bound of an asterisk is always
<span id="line2128"></span>          greater than or equal to the lower dimension bound.
<span id="line2129"></span>
<span id="line2130"></span>          5.1.2  Kinds_and_Occurrences_of_Array_Declarators.
<span id="line2131"></span>          Each  array  declarator  is  either  a  constant  array
<span id="line2132"></span>          declarator,  an  adjustable  array  declarator,  or  an
<span id="line2133"></span>          assumed-size   array   declarator.   A  constant  array
<span id="line2134"></span>          declarator is an array declarator in which each of  the
<span id="line2135"></span>          dimension  bound  expressions  is  an  integer constant
<span id="line2136"></span>          expression (6.1.3.1).  An adjustable  array  declarator
<span id="line2137"></span>          is  an  array  declarator  that  contains  one  or more
<span id="line2138"></span>          variables.   An  assumed-size  array  declarator  is  a
<span id="line2139"></span>          constant   array  declarator  or  an  adjustable  array
<span id="line2140"></span>          declarator, except that the upper  dimension  bound  of
<span id="line2141"></span>          the last dimension is an asterisk.
<span id="line2142"></span>
<span id="line2143"></span>          Each  array  declarator  is  either  an  actual   array
<span id="line2144"></span>          declarator or a dummy array declarator.
<span id="line2145"></span>
<span id="line2146"></span>
<span id="line2147"></span>
<span id="line2148"></span>
<span id="line2149"></span>
<span id="line2150"></span>
<span id="line2151"></span>          FORTRAN 77 Full Language                       Page 5-2
<span id="line2152"></span>
<span id="line2153"></span>
<span id="line2154"></span>
<span id="line2155"></span>
<span id="line2156"></span>
<span id="line2157"></span>
<span id="line2158"></span>
<span id="line2159"></span>          ARRAYS AND SUBSTRINGS                    ANSI X3J3/90.4
<span id="line2160"></span>
<span id="line2161"></span>
<span id="line2162"></span>
<span id="line2163"></span>          5.1.2.1  Actual_Array_Declarator.   An   actual   array
<span id="line2164"></span>          declarator  is  an  array declarator in which the array
<span id="line2165"></span>          name is  not  a  dummy  argument.   Each  actual  array
<span id="line2166"></span>          declarator  must  be  a  constant array declarator.  An
<span id="line2167"></span>          actual array declarator is  permitted  in  a  DIMENSION
<span id="line2168"></span>          statement, type-statement, or COMMON statement (Section
<span id="line2169"></span>          8).
<span id="line2170"></span>
<span id="line2171"></span>          5.1.2.2  Dummy_Array_Declarator.    A    dummy    array
<span id="line2172"></span>          declarator  is  an  array declarator in which the array
<span id="line2173"></span>          name is a dummy argument.  A dummy array declarator may
<span id="line2174"></span>          be  either  a  constant array declarator, an adjustable
<span id="line2175"></span>          array declarator, or an assumed-size array  declarator.
<span id="line2176"></span>          A  dummy  array  declarator is permitted in a DIMENSION
<span id="line2177"></span>          statement or a  type-statement  but  not  in  a  COMMON
<span id="line2178"></span>          statement.  A dummy array declarator may appear only in
<span id="line2179"></span>          a function or subroutine subprogram.
<span id="line2180"></span>
<span id="line2181"></span>          5.2  Properties_of_an_Array
<span id="line2182"></span>
<span id="line2183"></span>          The following properties of an array are  specified  by
<span id="line2184"></span>          the  array  declarator: the number of dimensions of the
<span id="line2185"></span>          array, the size  and  bounds  of  each  dimension,  and
<span id="line2186"></span>          therefore the number of array elements.
<span id="line2187"></span>
<span id="line2188"></span>          The properties of  an  array  in  a  program  unit  are
<span id="line2189"></span>          specified by the array declarator for the array in that
<span id="line2190"></span>          program unit.
<span id="line2191"></span>
<span id="line2192"></span>          5.2.1  Data_Type_of_an_Array_and_an_Array_Element.   An
<span id="line2193"></span>          array  name  has a data type (4.1.1).  An array element
<span id="line2194"></span>          name has the same data type as the array name.
<span id="line2195"></span>
<span id="line2196"></span>          5.2.2  Dimensions_of_an_Array.     The    number     of
<span id="line2197"></span>          dimensions  of  an  array  is  equal  to  the number of
<span id="line2198"></span>          dimension declarators in the array declarator.
<span id="line2199"></span>
<span id="line2200"></span>          The size of a dimension is the value:
<span id="line2201"></span>
<span id="line2202"></span>                               d_928 - d_918 + 1
<span id="line2203"></span>
<span id="line2204"></span>          where: d_918  is the value of the lower dimension bound
<span id="line2205"></span>
<span id="line2206"></span>                 d_928  is the value of the upper dimension bound
<span id="line2207"></span>
<span id="line2208"></span>          Note that if the value of the lower dimension bound  is
<span id="line2209"></span>          one, the size of the dimension is d_928.
<span id="line2210"></span>
<span id="line2211"></span>          The size  of  a  dimension  whose  upper  bound  is  an
<span id="line2212"></span>          asterisk is not specified.
<span id="line2213"></span>
<span id="line2214"></span>
<span id="line2215"></span>
<span id="line2216"></span>
<span id="line2217"></span>          FORTRAN 77 Full Language                       Page 5-3
<span id="line2218"></span>
<span id="line2219"></span>
<span id="line2220"></span>
<span id="line2221"></span>
<span id="line2222"></span>
<span id="line2223"></span>
<span id="line2224"></span>
<span id="line2225"></span>          ARRAYS AND SUBSTRINGS                    ANSI X3J3/90.4
<span id="line2226"></span>
<span id="line2227"></span>
<span id="line2228"></span>
<span id="line2229"></span>          The  number  and  size  of  dimensions  in  one   array
<span id="line2230"></span>          declarator may be different from the number and size of
<span id="line2231"></span>          dimensions  in  another  array   declarator   that   is
<span id="line2232"></span>          associated   by   common,   equivalence,   or  argument
<span id="line2233"></span>          association.
<span id="line2234"></span>
<span id="line2235"></span>          5.2.3  Size_of_an_Array.  The size of an array is equal
<span id="line2236"></span>          to the number of elements in the array.  The size of an
<span id="line2237"></span>          array is equal to the  product  of  the  sizes  of  the
<span id="line2238"></span>          dimensions  specified  by the array declarator for that
<span id="line2239"></span>          array name.  The size of an  assumed-size  dummy  array
<span id="line2240"></span>          (5.5) is determined as follows:
<span id="line2241"></span>
<span id="line2242"></span>             (1) If the  actual  argument  corresponding  to  the
<span id="line2243"></span>                 dummy  array  is  a noncharacter array name, the
<span id="line2244"></span>                 size of the dummy  array  is  the  size  of  the
<span id="line2245"></span>                 actual argument array.
<span id="line2246"></span>
<span id="line2247"></span>             (2) If the  actual  argument  corresponding  to  the
<span id="line2248"></span>                 dummy array name is a noncharacter array element
<span id="line2249"></span>                 name with a subscript value of r_ in an array  of
<span id="line2250"></span>                 size x_, the size of the dummy array is x_ + 1 - r_
<span id="line2251"></span>                 .
<span id="line2252"></span>
<span id="line2253"></span>             (3) If the actual  argument  is  a  character  array
<span id="line2254"></span>                 name, character array element name, or character
<span id="line2255"></span>                 array  element  substring  name  and  begins  at
<span id="line2256"></span>                 character  storage  unit  t_  of an array with c_
<span id="line2257"></span>                 character storage units, then the  size  of  the
<span id="line2258"></span>                 dummy  array  is INT((c_ + 1 - t_) / ln__), where ln__
<span id="line2259"></span>                 is the length of an element of the dummy array.
<span id="line2260"></span>
<span id="line2261"></span>          If an assumed-size dummy array has n_  dimensions,  the
<span id="line2262"></span>          product of the sizes of the first n_ - 1 dimensions must
<span id="line2263"></span>          be less than or equal to the  size  of  the  array,  as
<span id="line2264"></span>          determined by one of the immediately preceding rules.
<span id="line2265"></span>
<span id="line2266"></span>          5.2.4  Array_Element_Ordering.   The  elements  of   an
<span id="line2267"></span>          array  are  ordered  in  a  sequence  (2.1).   An array
<span id="line2268"></span>          element  name  contains  a  subscript   (5.4.1)   whose
<span id="line2269"></span>          subscript value (5.4.3) determines which element of the
<span id="line2270"></span>          array is identified by the  array  element  name.   The
<span id="line2271"></span>          first  element  of  the  array has a subscript value of
<span id="line2272"></span>          one; the second element has a subscript value  of  two;
<span id="line2273"></span>          the  last  element  has  a subscript value equal to the
<span id="line2274"></span>          size of the array.
<span id="line2275"></span>
<span id="line2276"></span>          Whenever an array name unqualified by  a  subscript  is
<span id="line2277"></span>          used to designate the whole array (5.6), the appearance
<span id="line2278"></span>          of the array name implies that the number of values  to
<span id="line2279"></span>          be  processed is equal to the number of elements in the
<span id="line2280"></span>
<span id="line2281"></span>
<span id="line2282"></span>
<span id="line2283"></span>          FORTRAN 77 Full Language                       Page 5-4
<span id="line2284"></span>
<span id="line2285"></span>
<span id="line2286"></span>
<span id="line2287"></span>
<span id="line2288"></span>
<span id="line2289"></span>
<span id="line2290"></span>
<span id="line2291"></span>          ARRAYS AND SUBSTRINGS                    ANSI X3J3/90.4
<span id="line2292"></span>
<span id="line2293"></span>
<span id="line2294"></span>
<span id="line2295"></span>          array and that the elements of  the  array  are  to  be
<span id="line2296"></span>          taken in sequential order.
<span id="line2297"></span>
<span id="line2298"></span>          5.2.5  Array_Storage_Sequence.  An array has a  storage
<span id="line2299"></span>          sequence  consisting  of  the  storage sequences of the
<span id="line2300"></span>          array elements in the order  determined  by  the  array
<span id="line2301"></span>          element  ordering.   The  number of storage units in an
<span id="line2302"></span>          array is x_*z_, where x_ is the number of the elements  in
<span id="line2303"></span>          the array and z_ is the number of storage units for each
<span id="line2304"></span>          array element.
<span id="line2305"></span>
<span id="line2306"></span>          5.3  Array_Element_Name
<span id="line2307"></span>
<span id="line2308"></span>          The form of an array element name is:
<span id="line2309"></span>
<span id="line2310"></span>                               a_ (s_ [,s_]...)
<span id="line2311"></span>
<span id="line2312"></span>          where: a_   is the array name
<span id="line2313"></span>
<span id="line2314"></span>                 (s_ [,s_]...) is a subscript (5.4.1)
<span id="line2315"></span>
<span id="line2316"></span>                 s_   is a subscript expression (5.4.2)
<span id="line2317"></span>
<span id="line2318"></span>          The number of subscript expressions must  be  equal  to
<span id="line2319"></span>          the  number  of  dimensions in the array declarator for
<span id="line2320"></span>          the array name.
<span id="line2321"></span>
<span id="line2322"></span>          5.4  Subscript
<span id="line2323"></span>
<span id="line2324"></span>          5.4.1  Form_of_a_Subscript.  The form  of  a  subscript
<span id="line2325"></span>          is:
<span id="line2326"></span>
<span id="line2327"></span>                               (s_ [,s_]...)
<span id="line2328"></span>
<span id="line2329"></span>          where s_ is a subscript expression.
<span id="line2330"></span>
<span id="line2331"></span>          Note that the term "subscript" includes the parentheses
<span id="line2332"></span>          that delimit the list of subscript expressions.
<span id="line2333"></span>
<span id="line2334"></span>          5.4.2  Subscript_Expression.  A subscript expression is
<span id="line2335"></span>          an  integer  expression.   A  subscript  expression may
<span id="line2336"></span>          contain   array   element   references   and   function
<span id="line2337"></span>          references.   Note that a restriction in the evaluation
<span id="line2338"></span>          of expressions (6.6) prohibits  certain  side  effects.
<span id="line2339"></span>          In  particular, evaluation of a function must not alter
<span id="line2340"></span>          the value of any other subscript expression within  the
<span id="line2341"></span>          same subscript.
<span id="line2342"></span>
<span id="line2343"></span>          Within a program unit,  the  value  of  each  subscript
<span id="line2344"></span>          expression  must  be  greater  than  or  equal  to  the
<span id="line2345"></span>          corresponding  lower  dimension  bound  in  the   array
<span id="line2346"></span>
<span id="line2347"></span>
<span id="line2348"></span>
<span id="line2349"></span>          FORTRAN 77 Full Language                       Page 5-5
<span id="line2350"></span>
<span id="line2351"></span>
<span id="line2352"></span>
<span id="line2353"></span>
<span id="line2354"></span>
<span id="line2355"></span>
<span id="line2356"></span>
<span id="line2357"></span>          ARRAYS AND SUBSTRINGS                    ANSI X3J3/90.4
<span id="line2358"></span>
<span id="line2359"></span>
<span id="line2360"></span>
<span id="line2361"></span>          declarator  for the array.  The value of each subscript
<span id="line2362"></span>          expression must  not  exceed  the  corresponding  upper
<span id="line2363"></span>          dimension  bound  declared for the array in the program
<span id="line2364"></span>          unit.  If the upper dimension bound is an asterisk, the
<span id="line2365"></span>          value of the corresponding subscript expression must be
<span id="line2366"></span>          such that the subscript value does not exceed the  size
<span id="line2367"></span>          of the dummy array.
<span id="line2368"></span>
<span id="line2369"></span>          5.4.3  Subscript_Value.   The  subscript  value  of   a
<span id="line2370"></span>          subscript is specified in Table 1.  The subscript value
<span id="line2371"></span>          determines which array element  is  identified  by  the
<span id="line2372"></span>          array   element  name.   Within  a  program  unit,  the
<span id="line2373"></span>          subscript value depends on the values of the  subscript
<span id="line2374"></span>          expressions  in  the subscript and on the dimensions of
<span id="line2375"></span>          the array specified in the  array  declarator  for  the
<span id="line2376"></span>          array in the program unit.  If the subscript value is r_
<span id="line2377"></span>          , the r_th element of the array is identified.
<span id="line2378"></span>
<span id="line2379"></span>
<span id="line2380"></span>
<span id="line2381"></span>
<span id="line2382"></span>
<span id="line2383"></span>
<span id="line2384"></span>
<span id="line2385"></span>
<span id="line2386"></span>
<span id="line2387"></span>
<span id="line2388"></span>
<span id="line2389"></span>
<span id="line2390"></span>
<span id="line2391"></span>
<span id="line2392"></span>
<span id="line2393"></span>
<span id="line2394"></span>
<span id="line2395"></span>
<span id="line2396"></span>
<span id="line2397"></span>
<span id="line2398"></span>
<span id="line2399"></span>
<span id="line2400"></span>
<span id="line2401"></span>
<span id="line2402"></span>
<span id="line2403"></span>
<span id="line2404"></span>
<span id="line2405"></span>
<span id="line2406"></span>
<span id="line2407"></span>
<span id="line2408"></span>
<span id="line2409"></span>
<span id="line2410"></span>
<span id="line2411"></span>
<span id="line2412"></span>
<span id="line2413"></span>
<span id="line2414"></span>
<span id="line2415"></span>          FORTRAN 77 Full Language                       Page 5-6
<span id="line2416"></span>
<span id="line2417"></span>
<span id="line2418"></span>
<span id="line2419"></span>
<span id="line2420"></span>
<span id="line2421"></span>
<span id="line2422"></span>
<span id="line2423"></span>          ARRAYS AND SUBSTRINGS                    ANSI X3J3/90.4
<span id="line2424"></span>
<span id="line2425"></span>
<span id="line2426"></span>
<span id="line2427"></span>                                  Table 1_______
<span id="line2428"></span>
<span id="line2429"></span>                              Subscript Value
<span id="line2430"></span>
<span id="line2431"></span>8          _________________________________________________________
<span id="line2432"></span>
<span id="line2433"></span>           n        Dimension         Subscript       Subscript
<span id="line2434"></span>                   Declarator                           Value
<span id="line2435"></span>
<span id="line2436"></span>8          _________________________________________________________
<span id="line2437"></span>
<span id="line2438"></span>           1   (j918:k918)               (s918)          1+(s918-j918)
<span id="line2439"></span>
<span id="line2440"></span>8          _________________________________________________________
<span id="line2441"></span>
<span id="line2442"></span>           2   (j918:k918,j928:k928)         (s918,s928)       1+(s918-j918)
<span id="line2443"></span>                                                    +(s928-j928)*d91
<span id="line2444"></span>8
<span id="line2445"></span>8          _________________________________________________________
<span id="line2446"></span>
<span id="line2447"></span>           3   (j918:k918,j928:k928,j938:k938)   (s918,s928,s938)    1+(s918-j918)
<span id="line2448"></span>                                                    +(s928-j928)*d91
<span id="line2449"></span>8                                                    +(s938-j938)*d928*d91
<span id="line2450"></span>8
<span id="line2451"></span>8          _________________________________________________________
<span id="line2452"></span>
<span id="line2453"></span>
<span id="line2454"></span>8          _________________________________________________________
<span id="line2455"></span>
<span id="line2456"></span>           n   (j918:k918,...,j9n8:k9n8)     (s918,...,s9n8)   1+(s918-j918)
<span id="line2457"></span>                                                    +(s928-j928)*d91
<span id="line2458"></span>8                                                    +(s938-j938)*d928*d91
<span id="line2459"></span>8                                                    +...
<span id="line2460"></span>                                                    +(s9n8-j9n8)*d9n-1
<span id="line2461"></span>8                                                     *d9n-28*...*d91
<span id="line2462"></span>8
<span id="line2463"></span>8          _________________________________________________________
<span id="line2464"></span>7         |7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|
<span id="line2465"></span>
<span id="line2466"></span>
<span id="line2467"></span>
<span id="line2468"></span>
<span id="line2469"></span>
<span id="line2470"></span>
<span id="line2471"></span>
<span id="line2472"></span>
<span id="line2473"></span>
<span id="line2474"></span>
<span id="line2475"></span>
<span id="line2476"></span>
<span id="line2477"></span>
<span id="line2478"></span>
<span id="line2479"></span>
<span id="line2480"></span>
<span id="line2481"></span>
<span id="line2482"></span>
<span id="line2483"></span>
<span id="line2484"></span>
<span id="line2485"></span>
<span id="line2486"></span>
<span id="line2487"></span>
<span id="line2488"></span>
<span id="line2489"></span>
<span id="line2490"></span>
<span id="line2491"></span>
<span id="line2492"></span>            |7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|
<span id="line2493"></span>
<span id="line2494"></span>
<span id="line2495"></span>
<span id="line2496"></span>
<span id="line2497"></span>
<span id="line2498"></span>
<span id="line2499"></span>
<span id="line2500"></span>
<span id="line2501"></span>
<span id="line2502"></span>
<span id="line2503"></span>
<span id="line2504"></span>
<span id="line2505"></span>
<span id="line2506"></span>
<span id="line2507"></span>
<span id="line2508"></span>
<span id="line2509"></span>
<span id="line2510"></span>
<span id="line2511"></span>
<span id="line2512"></span>
<span id="line2513"></span>
<span id="line2514"></span>
<span id="line2515"></span>
<span id="line2516"></span>
<span id="line2517"></span>
<span id="line2518"></span>
<span id="line2519"></span>
<span id="line2520"></span>                                  |7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|
<span id="line2521"></span>
<span id="line2522"></span>
<span id="line2523"></span>
<span id="line2524"></span>
<span id="line2525"></span>
<span id="line2526"></span>
<span id="line2527"></span>
<span id="line2528"></span>
<span id="line2529"></span>
<span id="line2530"></span>
<span id="line2531"></span>
<span id="line2532"></span>
<span id="line2533"></span>
<span id="line2534"></span>
<span id="line2535"></span>
<span id="line2536"></span>
<span id="line2537"></span>
<span id="line2538"></span>
<span id="line2539"></span>
<span id="line2540"></span>
<span id="line2541"></span>
<span id="line2542"></span>
<span id="line2543"></span>
<span id="line2544"></span>
<span id="line2545"></span>
<span id="line2546"></span>
<span id="line2547"></span>
<span id="line2548"></span>                                                |7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|
<span id="line2549"></span>
<span id="line2550"></span>
<span id="line2551"></span>
<span id="line2552"></span>
<span id="line2553"></span>
<span id="line2554"></span>
<span id="line2555"></span>
<span id="line2556"></span>
<span id="line2557"></span>
<span id="line2558"></span>
<span id="line2559"></span>
<span id="line2560"></span>
<span id="line2561"></span>
<span id="line2562"></span>
<span id="line2563"></span>
<span id="line2564"></span>
<span id="line2565"></span>
<span id="line2566"></span>
<span id="line2567"></span>
<span id="line2568"></span>
<span id="line2569"></span>
<span id="line2570"></span>
<span id="line2571"></span>
<span id="line2572"></span>
<span id="line2573"></span>
<span id="line2574"></span>
<span id="line2575"></span>
<span id="line2576"></span>                                                                  |7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|
<span id="line2577"></span>
<span id="line2578"></span>
<span id="line2579"></span>
<span id="line2580"></span>
<span id="line2581"></span>
<span id="line2582"></span>
<span id="line2583"></span>
<span id="line2584"></span>
<span id="line2585"></span>
<span id="line2586"></span>
<span id="line2587"></span>
<span id="line2588"></span>
<span id="line2589"></span>
<span id="line2590"></span>
<span id="line2591"></span>
<span id="line2592"></span>
<span id="line2593"></span>
<span id="line2594"></span>
<span id="line2595"></span>
<span id="line2596"></span>
<span id="line2597"></span>
<span id="line2598"></span>
<span id="line2599"></span>
<span id="line2600"></span>
<span id="line2601"></span>
<span id="line2602"></span>
<span id="line2603"></span>
<span id="line2604"></span>
<span id="line2605"></span>
<span id="line2606"></span>          Notes for Table 1:
<span id="line2607"></span>
<span id="line2608"></span>             (1) n is the number of dimensions,  1 <span class="entity"><span>&amp;</span>lt;</span> n <span class="entity"><span>&amp;</span>lt;</span> 7.
<span id="line2609"></span>
<span id="line2610"></span>             (2) j9i8 is the value of the lower bound  of  the  ith
<span id="line2611"></span>                 dimension.
<span id="line2612"></span>
<span id="line2613"></span>             (3) k9i8 is the value of the upper bound  of  the  ith
<span id="line2614"></span>                 dimension.
<span id="line2615"></span>
<span id="line2616"></span>             (4) If only the upper bound is specified, then j9i8% =
<span id="line2617"></span>                  1.
<span id="line2618"></span>
<span id="line2619"></span>             (5) s9i8 is the integer value  of  the  ith  subscript
<span id="line2620"></span>                 expression.
<span id="line2621"></span>
<span id="line2622"></span>9
<span id="line2623"></span>
<span id="line2624"></span>
<span id="line2625"></span>          FORTRAN 77 Full Language                       Page 5-7
<span id="line2626"></span>
<span id="line2627"></span>
<span id="line2628"></span>
<span id="line2629"></span>
<span id="line2630"></span>
<span id="line2631"></span>
<span id="line2632"></span>
<span id="line2633"></span>          ARRAYS AND SUBSTRINGS                    ANSI X3J3/90.4
<span id="line2634"></span>
<span id="line2635"></span>
<span id="line2636"></span>
<span id="line2637"></span>             (6) d9i8 = k9i8-j9i8+1 is the size of the  ith  dimension.
<span id="line2638"></span>                 If  the value of the lower bound is 1, then d9i8 =
<span id="line2639"></span>                  k9i8.
<span id="line2640"></span>
<span id="line2641"></span>          Note that a subscript of  the  form  (j918,...j9n8)  has  a
<span id="line2642"></span>          subscript value of one and identifies the first element
<span id="line2643"></span>          of the array.  A  subscript  of  the  form  (k918,...,k9n8)
<span id="line2644"></span>          identifies the last element of the array; its subscript
<span id="line2645"></span>          value is equal to the number of elements in the array.
<span id="line2646"></span>
<span id="line2647"></span>          The subscript value and the subscript expression  value
<span id="line2648"></span>          are   not   necessarily  the  same,  even  for  a  one-
<span id="line2649"></span>          dimensional array.  In the example:
<span id="line2650"></span>
<span id="line2651"></span>                     DIMENSION A(-1:8),B(10,10)
<span id="line2652"></span>                     A(2) = B(1,2)
<span id="line2653"></span>
<span id="line2654"></span>          A(2) identifies the fourth element of A, the  subscript
<span id="line2655"></span>          is  (2)  with  a  subscript  value  of  four,  and  the
<span id="line2656"></span>          subscript expression is 2 with a value of two.   B(1,2)
<span id="line2657"></span>          identifies  the eleventh element of B, the subscript is
<span id="line2658"></span>          (1,2) with  a  subscript  value  of  eleven,   and  the
<span id="line2659"></span>          subscript  expressions  are  1 and 2 with values of one
<span id="line2660"></span>          and two.
<span id="line2661"></span>
<span id="line2662"></span>          5.5  Dummy_and_Actual_Arrays
<span id="line2663"></span>
<span id="line2664"></span>          A  dummy  array  is  an  array  for  which  the   array
<span id="line2665"></span>          declarator  is  a  dummy array declarator.  An assumed-
<span id="line2666"></span>          size dummy array is a dummy array for which  the  array
<span id="line2667"></span>          declarator  is  an  assumed-size  array  declarator.  A
<span id="line2668"></span>          dummy  array  is  permitted  only  in  a  function   or
<span id="line2669"></span>          subroutine subprogram (Section 15).
<span id="line2670"></span>
<span id="line2671"></span>          An actual  array  is  an  array  for  which  the  array
<span id="line2672"></span>          declarator  is  an actual array declarator.  Each array
<span id="line2673"></span>          in the main program is an actual array and must have  a
<span id="line2674"></span>          constant  array  declarator.  A dummy array may be used
<span id="line2675"></span>          as an actual argument.
<span id="line2676"></span>
<span id="line2677"></span>          5.5.1  Adjustable_Arrays_and_Adjustable_Dimensions.  An
<span id="line2678"></span>          adjustable  array  is  an  array  for  which  the array
<span id="line2679"></span>          declarator is an adjustable array  declarator.   In  an
<span id="line2680"></span>          adjustable    array    declarator,    those   dimension
<span id="line2681"></span>          declarators that contain a  variable  name  are  called
<span id="line2682"></span>          adjustable dimensions.
<span id="line2683"></span>
<span id="line2684"></span>          An adjustable array declarator must be  a  dummy  array
<span id="line2685"></span>          declarator.   At  least  one dummy argument list of the
<span id="line2686"></span>          subprogram must contain  the  name  of  the  adjustable
<span id="line2687"></span>          array.   A  variable  name  that appears in a dimension
<span id="line2688"></span>
<span id="line2689"></span>
<span id="line2690"></span>
<span id="line2691"></span>          FORTRAN 77 Full Language                       Page 5-8
<span id="line2692"></span>
<span id="line2693"></span>
<span id="line2694"></span>
<span id="line2695"></span>
<span id="line2696"></span>
<span id="line2697"></span>
<span id="line2698"></span>
<span id="line2699"></span>          ARRAYS AND SUBSTRINGS                    ANSI X3J3/90.4
<span id="line2700"></span>
<span id="line2701"></span>
<span id="line2702"></span>
<span id="line2703"></span>          bound expression of an array must also appear as a name
<span id="line2704"></span>          either  in  every dummy argument list that contains the
<span id="line2705"></span>          array name or in a common block in that subprogram.
<span id="line2706"></span>
<span id="line2707"></span>          At the time of execution of a reference to  a  function
<span id="line2708"></span>          or  subroutine  containing  an  adjustable array in its
<span id="line2709"></span>          dummy  argument  list,  each   actual   argument   that
<span id="line2710"></span>          corresponds   to   a  dummy  argument  appearing  in  a
<span id="line2711"></span>          dimension bound  expression  for  the  array  and  each
<span id="line2712"></span>          variable  in   common  appearing  in  a dimension bound
<span id="line2713"></span>          expression for  the  array  must  be  defined  with  an
<span id="line2714"></span>          integer  value.  The values of those dummy arguments or
<span id="line2715"></span>          variables in common, together with  any  constants  and
<span id="line2716"></span>          symbolic  names of constants appearing in the dimension
<span id="line2717"></span>          bound   expression,   determine   the   size   of   the
<span id="line2718"></span>          corresponding adjustable dimension for the execution of
<span id="line2719"></span>          the subprogram.  The sizes of the adjustable dimensions
<span id="line2720"></span>          and   of   any  constant  dimensions  appearing  in  an
<span id="line2721"></span>          adjustable array declarator  determine  the  number  of
<span id="line2722"></span>          elements   in the array and the array element ordering.
<span id="line2723"></span>          The execution of different references to  a  subprogram
<span id="line2724"></span>          or different executions of the same reference determine
<span id="line2725"></span>          possibly  different  properties  (size  of  dimensions,
<span id="line2726"></span>          dimension bounds, number of elements, and array element
<span id="line2727"></span>          ordering) for each adjustable array in the  subprogram.
<span id="line2728"></span>          These  properties  depend  on  the values of any actual
<span id="line2729"></span>          arguments and variables in common that  are  referenced
<span id="line2730"></span>          in   the   adjustable   dimension  expressions  in  the
<span id="line2731"></span>          subprogram.
<span id="line2732"></span>
<span id="line2733"></span>          During the execution of  an  external  procedure  in  a
<span id="line2734"></span>          subprogram  containing  an  adjustable array, the array
<span id="line2735"></span>          properties of dimension size, lower and upper dimension
<span id="line2736"></span>          bounds,  and  array  size  (number  of  elements in the
<span id="line2737"></span>          array) do not change.  However, the variables  involved
<span id="line2738"></span>          in  an  adjustable dimension may be redefined or become
<span id="line2739"></span>          undefined during execution of  the  external  procedure
<span id="line2740"></span>          with no effect on the above-mentioned properties.
<span id="line2741"></span>
<span id="line2742"></span>          5.6  Use_of_Array_Names
<span id="line2743"></span>
<span id="line2744"></span>          In a program unit, each appearance  of  an  array  name
<span id="line2745"></span>          must  be  in  an  array  element  name  except  in  the
<span id="line2746"></span>          following cases:
<span id="line2747"></span>
<span id="line2748"></span>             (1) In a list of dummy arguments
<span id="line2749"></span>
<span id="line2750"></span>             (2) In a COMMON statement
<span id="line2751"></span>
<span id="line2752"></span>             (3) In a type-statement
<span id="line2753"></span>
<span id="line2754"></span>
<span id="line2755"></span>
<span id="line2756"></span>
<span id="line2757"></span>          FORTRAN 77 Full Language                       Page 5-9
<span id="line2758"></span>
<span id="line2759"></span>
<span id="line2760"></span>
<span id="line2761"></span>
<span id="line2762"></span>
<span id="line2763"></span>
<span id="line2764"></span>
<span id="line2765"></span>          ARRAYS AND SUBSTRINGS                    ANSI X3J3/90.4
<span id="line2766"></span>
<span id="line2767"></span>
<span id="line2768"></span>
<span id="line2769"></span>             (4) In an array declarator.  Note that although  the
<span id="line2770"></span>                 form  of an array declarator may be identical to
<span id="line2771"></span>                 that  of  an  array  element  name,   an   array
<span id="line2772"></span>                 declarator is not an array element name.
<span id="line2773"></span>
<span id="line2774"></span>             (5) In an EQUIVALENCE statement
<span id="line2775"></span>
<span id="line2776"></span>             (6) In a DATA statement
<span id="line2777"></span>
<span id="line2778"></span>             (7) In the list of actual arguments in  a  reference
<span id="line2779"></span>                 to an external procedure
<span id="line2780"></span>
<span id="line2781"></span>             (8) In the list of an input/output statement if  the
<span id="line2782"></span>                 array is not an assumed-size dummy array
<span id="line2783"></span>
<span id="line2784"></span>             (9) As a unit identifier for an internal file in  an
<span id="line2785"></span>                 input/output  statement  if  the array is not an
<span id="line2786"></span>                 assumed-size dummy array
<span id="line2787"></span>
<span id="line2788"></span>            (10) As the  format  identifier  in  an  input/output
<span id="line2789"></span>                 statement  if  the  array is not an assumed-size
<span id="line2790"></span>                 dummy array
<span id="line2791"></span>
<span id="line2792"></span>            (11) In a SAVE statement
<span id="line2793"></span>
<span id="line2794"></span>          5.7  Character_Substring
<span id="line2795"></span>
<span id="line2796"></span>          A character substring is  a  contiguous  portion  of  a
<span id="line2797"></span>          character  datum  and is of type character. A character
<span id="line2798"></span>          substring is identified by a substring name and may  be
<span id="line2799"></span>          assigned values and referenced.
<span id="line2800"></span>
<span id="line2801"></span>          5.7.1  Substring_Name.  The forms of a  substring  name
<span id="line2802"></span>          are:
<span id="line2803"></span>
<span id="line2804"></span>                               v_ ( [e_918] : [e_928] )
<span id="line2805"></span>
<span id="line2806"></span>                               a_ (s_ [,s_]...)( [e_918] : [e_928] )
<span id="line2807"></span>
<span id="line2808"></span>          where: v_   is a character variable name
<span id="line2809"></span>
<span id="line2810"></span>                 a_ (s_ [,s_]...) is a character array element name
<span id="line2811"></span>
<span id="line2812"></span>                 e_918 and e_928 are each an integer expression and are
<span id="line2813"></span>                     called substring expressions
<span id="line2814"></span>
<span id="line2815"></span>          The value e_918 specifies the leftmost character  position
<span id="line2816"></span>          of  the  substring,  and  the  value  e_928 specifies the
<span id="line2817"></span>          rightmost  character  position.   For  example,  A(2:4)
<span id="line2818"></span>          specifies  characters  in positions two through four of
<span id="line2819"></span>          the character variable  A,  and  B(4,3)(1:6)  specifies
<span id="line2820"></span>
<span id="line2821"></span>
<span id="line2822"></span>
<span id="line2823"></span>          FORTRAN 77 Full Language                      Page 5-10
<span id="line2824"></span>
<span id="line2825"></span>
<span id="line2826"></span>
<span id="line2827"></span>
<span id="line2828"></span>
<span id="line2829"></span>
<span id="line2830"></span>
<span id="line2831"></span>          ARRAYS AND SUBSTRINGS                    ANSI X3J3/90.4
<span id="line2832"></span>
<span id="line2833"></span>
<span id="line2834"></span>
<span id="line2835"></span>          characters   in   positions  one  through  six  of  the
<span id="line2836"></span>          character array element B(4,3).
<span id="line2837"></span>
<span id="line2838"></span>          The values of e_918 and e_928 must be such that:
<span id="line2839"></span>
<span id="line2840"></span>                               1 <span class="entity"><span>&amp;</span>lt;</span> e_918 <span class="entity"><span>&amp;</span>lt;</span> e_928 <span class="entity"><span>&amp;</span>lt;</span> len___
<span id="line2841"></span>
<span id="line2842"></span>          where len is the length of the  character  variable  or
<span id="line2843"></span>          array  element  (8.4.2).   If e_918 is omitted, a value of
<span id="line2844"></span>          one is implied for e_918.  If e_928 is omitted,  a  value  of
<span id="line2845"></span>          len  is implied for e_928.  Both e_918 and e_928 may be omitted;
<span id="line2846"></span>          for example, the form v_(:) is equivalent to v_, and  the
<span id="line2847"></span>          form  a_ (s_ [,s_]...)(:) is equivalent to a_(s_  [,s_]...).
<span id="line2848"></span>          The length of a character substring is e_928 - e_918 + 1.
<span id="line2849"></span>
<span id="line2850"></span>          5.7.2  Substring_Expression.   A  substring  expression
<span id="line2851"></span>          may  be any integer expression.  A substring expression
<span id="line2852"></span>          may  contain  array  element  references  and  function
<span id="line2853"></span>          references.   Note that a restriction in the evaluation
<span id="line2854"></span>          of expressions (6.6) prohibits  certain  side  effects.
<span id="line2855"></span>          In  particular, evaluation of a function must not alter
<span id="line2856"></span>          the value of  any  other  expression  within  the  same
<span id="line2857"></span>          substring name.
<span id="line2858"></span>
<span id="line2859"></span>
<span id="line2860"></span>
<span id="line2861"></span>
<span id="line2862"></span>
<span id="line2863"></span>
<span id="line2864"></span>
<span id="line2865"></span>
<span id="line2866"></span>
<span id="line2867"></span>
<span id="line2868"></span>
<span id="line2869"></span>
<span id="line2870"></span>
<span id="line2871"></span>
<span id="line2872"></span>
<span id="line2873"></span>
<span id="line2874"></span>
<span id="line2875"></span>
<span id="line2876"></span>
<span id="line2877"></span>
<span id="line2878"></span>
<span id="line2879"></span>
<span id="line2880"></span>
<span id="line2881"></span>
<span id="line2882"></span>
<span id="line2883"></span>
<span id="line2884"></span>
<span id="line2885"></span>
<span id="line2886"></span>
<span id="line2887"></span>
<span id="line2888"></span>
<span id="line2889"></span>          FORTRAN 77 Full Language                      Page 5-11
<span id="line2890"></span>
<span id="line2891"></span>
<span id="line2892"></span>
<span id="line2893"></span>
<span id="line2894"></span>
<span id="line2895"></span>
<span id="line2896"></span>
<span id="line2897"></span>
<span id="line2898"></span>
<span id="line2899"></span>
<span id="line2900"></span>
<span id="line2901"></span>                                 CONTENTS
<span id="line2902"></span>
<span id="line2903"></span>
<span id="line2904"></span>          5.  ARRAYS AND SUBSTRINGS........................   5-1
<span id="line2905"></span>              5.1  Array Declarator........................   5-1
<span id="line2906"></span>                   5.1.1  Form of an Array
<span id="line2907"></span>                          Declarator.......................   5-1
<span id="line2908"></span>                   5.1.2  Kinds and Occurrences of Array
<span id="line2909"></span>                          Declarators......................   5-2
<span id="line2910"></span>              5.2  Properties of an Array..................   5-3
<span id="line2911"></span>                   5.2.1  Data Type of an Array and an
<span id="line2912"></span>                          Array Element....................   5-3
<span id="line2913"></span>                   5.2.2  Dimensions of an Array...........   5-3
<span id="line2914"></span>                   5.2.3  Size of an Array.................   5-4
<span id="line2915"></span>                   5.2.4  Array Element Ordering...........   5-4
<span id="line2916"></span>                   5.2.5  Array Storage Sequence...........   5-5
<span id="line2917"></span>              5.3  Array Element Name......................   5-5
<span id="line2918"></span>              5.4  Subscript...............................   5-5
<span id="line2919"></span>                   5.4.1  Form of a Subscript..............   5-5
<span id="line2920"></span>                   5.4.2  Subscript Expression.............   5-5
<span id="line2921"></span>                   5.4.3  Subscript Value..................   5-6
<span id="line2922"></span>              5.5  Dummy and Actual Arrays.................   5-8
<span id="line2923"></span>                   5.5.1  Adjustable Arrays and Adjustable
<span id="line2924"></span>                          Dimensions.......................   5-8
<span id="line2925"></span>              5.6  Use of Array Names......................   5-9
<span id="line2926"></span>              5.7  Character Substring.....................  5-10
<span id="line2927"></span>                   5.7.1  Substring Name...................  5-10
<span id="line2928"></span>                   5.7.2  Substring Expression.............  5-11
<span id="line2929"></span>
<span id="line2930"></span>
<span id="line2931"></span>
<span id="line2932"></span>
<span id="line2933"></span>
<span id="line2934"></span>
<span id="line2935"></span>
<span id="line2936"></span>
<span id="line2937"></span>
<span id="line2938"></span>
<span id="line2939"></span>
<span id="line2940"></span>
<span id="line2941"></span>
<span id="line2942"></span>
<span id="line2943"></span>
<span id="line2944"></span>
<span id="line2945"></span>
<span id="line2946"></span>
<span id="line2947"></span>
<span id="line2948"></span>
<span id="line2949"></span>
<span id="line2950"></span>
<span id="line2951"></span>
<span id="line2952"></span>
<span id="line2953"></span>
<span id="line2954"></span>
<span id="line2955"></span>                                   - i -
<span id="line2956"></span>
<span id="line2957"></span>
<span id="line2958"></span>
<span id="line2959"></span>
<span id="line2960"></span>
<span id="line2961"></span>
<span id="line2962"></span>
<span id="line2963"></span>                                                   ANSI X3J3/90.4
<span id="line2964"></span>
<span id="line2965"></span>
<span id="line2966"></span>
<span id="line2967"></span>                              6.  EXPRESSIONS
<span id="line2968"></span>
<span id="line2969"></span>          This section describes the  formation,  interpretation,
<span id="line2970"></span>          and   evaluation   rules   for  arithmetic,  character,
<span id="line2971"></span>          relational, and logical expressions.  An expression  is
<span id="line2972"></span>          formed from operands, operators, and parentheses.
<span id="line2973"></span>
<span id="line2974"></span>          6.1  Arithmetic_Expressions
<span id="line2975"></span>
<span id="line2976"></span>          An arithmetic expression is used to express  a  numeric
<span id="line2977"></span>          computation.  Evaluation  of  an  arithmetic expression
<span id="line2978"></span>          produces a numeric !value.
<span id="line2979"></span>
<span id="line2980"></span>          The simplest form of an  arithmetic  expression  is  an
<span id="line2981"></span>          unsigned  arithmetic  constant,  symbolic  name  of  an
<span id="line2982"></span>          arithmetic  constant,  arithmetic  variable  reference,
<span id="line2983"></span>          arithmetic  array  element  reference,   or  arithmetic
<span id="line2984"></span>          function  reference.    More   complicated   arithmetic
<span id="line2985"></span>          expressions   may  be  formed  by  using  one  or  more
<span id="line2986"></span>          arithmetic operands together with arithmetic  operators
<span id="line2987"></span>          and  parentheses.   Arithmetic  operands  must identify
<span id="line2988"></span>          values of type  integer,  real,  double  precision,  or
<span id="line2989"></span>          complex.
<span id="line2990"></span>
<span id="line2991"></span>          6.1.1  Arithmetic_Operators.    The   five   arithmetic
<span id="line2992"></span>          operators are:
<span id="line2993"></span>
<span id="line2994"></span>8                   ____________________________________
<span id="line2995"></span>
<span id="line2996"></span>                    Operator   Representing
<span id="line2997"></span>8                   ____________________________________
<span id="line2998"></span>
<span id="line2999"></span>                       **      Exponentiation
<span id="line3000"></span>                       /       Division
<span id="line3001"></span>                       *       Multiplication
<span id="line3002"></span>                       -       Subtraction or Negation
<span id="line3003"></span>                       +       Addition or Identity
<span id="line3004"></span>8                   ____________________________________
<span id="line3005"></span>7                  |7|7|7|7|7|7|7|7|
<span id="line3006"></span>
<span id="line3007"></span>
<span id="line3008"></span>
<span id="line3009"></span>
<span id="line3010"></span>
<span id="line3011"></span>
<span id="line3012"></span>
<span id="line3013"></span>                            |7|7|7|7|7|7|7|7|
<span id="line3014"></span>
<span id="line3015"></span>
<span id="line3016"></span>
<span id="line3017"></span>
<span id="line3018"></span>
<span id="line3019"></span>
<span id="line3020"></span>
<span id="line3021"></span>                                                      |7|7|7|7|7|7|7|7|
<span id="line3022"></span>
<span id="line3023"></span>
<span id="line3024"></span>
<span id="line3025"></span>
<span id="line3026"></span>
<span id="line3027"></span>
<span id="line3028"></span>
<span id="line3029"></span>
<span id="line3030"></span>
<span id="line3031"></span>          Each of the operators **, /, and * operates on  a  pair
<span id="line3032"></span>          of  operands  and  is written between the two operands.
<span id="line3033"></span>          Each of the operators + and - either:
<span id="line3034"></span>
<span id="line3035"></span>             (1) operates on a pair of operands  and  is  written
<span id="line3036"></span>                 between the two operands, or
<span id="line3037"></span>
<span id="line3038"></span>             (2) operates on a single  operand  and  is   written
<span id="line3039"></span>                 preceding that operand.
<span id="line3040"></span>
<span id="line3041"></span>
<span id="line3042"></span>
<span id="line3043"></span>
<span id="line3044"></span>9
<span id="line3045"></span>
<span id="line3046"></span>
<span id="line3047"></span>          FORTRAN 77 Full Language                       Page 6-1
<span id="line3048"></span>
<span id="line3049"></span>
<span id="line3050"></span>
<span id="line3051"></span>
<span id="line3052"></span>
<span id="line3053"></span>
<span id="line3054"></span>
<span id="line3055"></span>          EXPRESSIONS                              ANSI X3J3/90.4
<span id="line3056"></span>
<span id="line3057"></span>
<span id="line3058"></span>
<span id="line3059"></span>          6.1.2  Form   and    Interpretation    of    Arithmetic
<span id="line3060"></span>          Expressions.   The  interpretation  of  the  expression
<span id="line3061"></span>          formed with each of the arithmetic  operators  in  each
<span id="line3062"></span>          form of use is as follows:
<span id="line3063"></span>
<span id="line3064"></span>8            ___________________________________________________
<span id="line3065"></span>
<span id="line3066"></span>             Use of Operator   Interpretation
<span id="line3067"></span>8            ___________________________________________________
<span id="line3068"></span>
<span id="line3069"></span>                x918 ** x928       Exponentiate x918 to the power x92
<span id="line3070"></span>8
<span id="line3071"></span>                 x918 / x928       Divide x918 by x92
<span id="line3072"></span>8
<span id="line3073"></span>                 x918 * x928       Multiply x918 and x92
<span id="line3074"></span>8
<span id="line3075"></span>                 x918 - x928       Subtract x928 from x91
<span id="line3076"></span>8
<span id="line3077"></span>                    - x928       Negate x92
<span id="line3078"></span>8
<span id="line3079"></span>                 x918 + x928       Add x918 and x92
<span id="line3080"></span>8
<span id="line3081"></span>                    + x928       Same as x92
<span id="line3082"></span>7            ___________________________________________________
<span id="line3083"></span>7           |7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|
<span id="line3084"></span>
<span id="line3085"></span>
<span id="line3086"></span>
<span id="line3087"></span>
<span id="line3088"></span>
<span id="line3089"></span>
<span id="line3090"></span>
<span id="line3091"></span>
<span id="line3092"></span>
<span id="line3093"></span>
<span id="line3094"></span>
<span id="line3095"></span>
<span id="line3096"></span>
<span id="line3097"></span>
<span id="line3098"></span>
<span id="line3099"></span>                            |7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|
<span id="line3100"></span>
<span id="line3101"></span>
<span id="line3102"></span>
<span id="line3103"></span>
<span id="line3104"></span>
<span id="line3105"></span>
<span id="line3106"></span>
<span id="line3107"></span>
<span id="line3108"></span>
<span id="line3109"></span>
<span id="line3110"></span>
<span id="line3111"></span>
<span id="line3112"></span>
<span id="line3113"></span>
<span id="line3114"></span>
<span id="line3115"></span>                                                              |7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|
<span id="line3116"></span>
<span id="line3117"></span>
<span id="line3118"></span>
<span id="line3119"></span>
<span id="line3120"></span>
<span id="line3121"></span>
<span id="line3122"></span>
<span id="line3123"></span>
<span id="line3124"></span>
<span id="line3125"></span>
<span id="line3126"></span>
<span id="line3127"></span>
<span id="line3128"></span>
<span id="line3129"></span>
<span id="line3130"></span>
<span id="line3131"></span>
<span id="line3132"></span>
<span id="line3133"></span>          where: x918  denotes the  operand  to  the  left  of  the
<span id="line3134"></span>                     operator
<span id="line3135"></span>
<span id="line3136"></span>                 x928  denotes the operand  to  the  right  of  the
<span id="line3137"></span>                     operator
<span id="line3138"></span>
<span id="line3139"></span>          The interpretation of a division may depend on the data
<span id="line3140"></span>          types of the operands (6.1.5).
<span id="line3141"></span>
<span id="line3142"></span>          A set of formation  rules  is  used  to  establish  the
<span id="line3143"></span>          interpretation   of   an   arithmetic  expression  that
<span id="line3144"></span>          contains two or more operators.  There is a  precedence
<span id="line3145"></span>          among  the  arithmetic  operators, which determines the
<span id="line3146"></span>          order in which the operands are to be  combined  unless
<span id="line3147"></span>          the  order  is  changed by the use of parentheses.  The
<span id="line3148"></span>          precedence of the arithmetic operators is as follows:
<span id="line3149"></span>
<span id="line3150"></span>8                         _________________________
<span id="line3151"></span>
<span id="line3152"></span>                          Operator   Precedence
<span id="line3153"></span>8                         _________________________
<span id="line3154"></span>
<span id="line3155"></span>                             **      Highest
<span id="line3156"></span>                          * and /    Intermediate
<span id="line3157"></span>                          + and -    Lowest
<span id="line3158"></span>8                         _________________________
<span id="line3159"></span>7                        |7|7|7|7|7|7|
<span id="line3160"></span>
<span id="line3161"></span>
<span id="line3162"></span>
<span id="line3163"></span>
<span id="line3164"></span>
<span id="line3165"></span>                                  |7|7|7|7|7|7|
<span id="line3166"></span>
<span id="line3167"></span>
<span id="line3168"></span>
<span id="line3169"></span>
<span id="line3170"></span>
<span id="line3171"></span>                                                 |7|7|7|7|7|7|
<span id="line3172"></span>
<span id="line3173"></span>
<span id="line3174"></span>
<span id="line3175"></span>
<span id="line3176"></span>
<span id="line3177"></span>
<span id="line3178"></span>
<span id="line3179"></span>          For example, in the expression
<span id="line3180"></span>
<span id="line3181"></span>
<span id="line3182"></span>
<span id="line3183"></span>
<span id="line3184"></span>          FORTRAN 77 Full Language                       Page 6-2
<span id="line3185"></span>
<span id="line3186"></span>
<span id="line3187"></span>
<span id="line3188"></span>
<span id="line3189"></span>
<span id="line3190"></span>
<span id="line3191"></span>
<span id="line3192"></span>          EXPRESSIONS                              ANSI X3J3/90.4
<span id="line3193"></span>
<span id="line3194"></span>
<span id="line3195"></span>
<span id="line3196"></span>                               - A ** 2
<span id="line3197"></span>
<span id="line3198"></span>          the exponentiation operator (**)  has  precedence  over
<span id="line3199"></span>          the  negation  operator (-); therefore, the operands of
<span id="line3200"></span>          the exponentiation operator are  combined  to  form  an
<span id="line3201"></span>          expression  that is used as the operand of the negation
<span id="line3202"></span>          operator.  The interpretation of the  above  expression
<span id="line3203"></span>          is the same as the interpretation of the expression
<span id="line3204"></span>
<span id="line3205"></span>                               - (A ** 2)
<span id="line3206"></span>
<span id="line3207"></span>          The arithmetic operands are:
<span id="line3208"></span>
<span id="line3209"></span>             (1) Primary
<span id="line3210"></span>
<span id="line3211"></span>             (2) Factor
<span id="line3212"></span>
<span id="line3213"></span>             (3) Term
<span id="line3214"></span>
<span id="line3215"></span>             (4) Arithmetic expression
<span id="line3216"></span>
<span id="line3217"></span>          The formation rules to be applied in  establishing  the
<span id="line3218"></span>          interpretation of arithmetic expressions are in 6.1.2.1
<span id="line3219"></span>          through 6.1.2.4.
<span id="line3220"></span>
<span id="line3221"></span>          6.1.2.1  Primaries.  The primaries are:
<span id="line3222"></span>
<span id="line3223"></span>             (1) Unsigned arithmetic constant (4.2.3)
<span id="line3224"></span>
<span id="line3225"></span>             (2) Symbolic name of an arithmetic constant (8.6)
<span id="line3226"></span>
<span id="line3227"></span>             (3) Arithmetic variable reference (2.5)
<span id="line3228"></span>
<span id="line3229"></span>             (4) Arithmetic array element reference (5.3)
<span id="line3230"></span>
<span id="line3231"></span>             (5) Arithmetic function reference (15.2)
<span id="line3232"></span>
<span id="line3233"></span>             (6) Arithmetic expression  enclosed  in  parentheses
<span id="line3234"></span>                 (6.1.2.4)
<span id="line3235"></span>
<span id="line3236"></span>          6.1.2.2  Factor.  The forms of a factor are:
<span id="line3237"></span>
<span id="line3238"></span>             (1) Primary
<span id="line3239"></span>
<span id="line3240"></span>             (2) Primary ** factor
<span id="line3241"></span>
<span id="line3242"></span>          Thus, a factor is formed from a sequence of one or more
<span id="line3243"></span>          primaries  separated  by  the  exponentiation operator.
<span id="line3244"></span>          Form  (2)  indicates  that  in  interpreting  a  factor
<span id="line3245"></span>          containing  two  or  more exponentiation operators, the
<span id="line3246"></span>          primaries  are  combined  from  right  to  left.    For
<span id="line3247"></span>
<span id="line3248"></span>
<span id="line3249"></span>
<span id="line3250"></span>          FORTRAN 77 Full Language                       Page 6-3
<span id="line3251"></span>
<span id="line3252"></span>
<span id="line3253"></span>
<span id="line3254"></span>
<span id="line3255"></span>
<span id="line3256"></span>
<span id="line3257"></span>
<span id="line3258"></span>          EXPRESSIONS                              ANSI X3J3/90.4
<span id="line3259"></span>
<span id="line3260"></span>
<span id="line3261"></span>
<span id="line3262"></span>          example, the factor
<span id="line3263"></span>
<span id="line3264"></span>                               2**3**2
<span id="line3265"></span>
<span id="line3266"></span>          has the same interpretation as the factor
<span id="line3267"></span>
<span id="line3268"></span>                               2**(3**2)
<span id="line3269"></span>
<span id="line3270"></span>          6.1.2.3  Term.  The forms of a term are:
<span id="line3271"></span>
<span id="line3272"></span>             (1) Factor
<span id="line3273"></span>
<span id="line3274"></span>             (2) Term / factor
<span id="line3275"></span>
<span id="line3276"></span>             (3) Term * factor
<span id="line3277"></span>
<span id="line3278"></span>          Thus, a term is formed from a sequence of one  or  more
<span id="line3279"></span>          factors separated by either the multiplication operator
<span id="line3280"></span>          or the division operator.  Forms (2) and  (3)  indicate
<span id="line3281"></span>          that  in  interpreting  a  term  containing two or more
<span id="line3282"></span>          multiplication or division operators, the  factors  are
<span id="line3283"></span>          combined from left to right.
<span id="line3284"></span>
<span id="line3285"></span>          6.1.2.4  Arithmetic_Expression.   The   forms   of   an
<span id="line3286"></span>          arithmetic expression are:
<span id="line3287"></span>
<span id="line3288"></span>             (1) Term
<span id="line3289"></span>
<span id="line3290"></span>             (2) + term
<span id="line3291"></span>
<span id="line3292"></span>             (3) - term
<span id="line3293"></span>
<span id="line3294"></span>             (4) Arithmetic expression + term
<span id="line3295"></span>
<span id="line3296"></span>             (5) Arithmetic expression - term
<span id="line3297"></span>
<span id="line3298"></span>          Thus,  an  arithmetic  expression  is  formed  from   a
<span id="line3299"></span>          sequence  of  one or more terms separated by either the
<span id="line3300"></span>          addition operator or  the  subtraction  operator.   The
<span id="line3301"></span>          first  term in an arithmetic expression may be preceded
<span id="line3302"></span>          by the identity or the negation  operator.   Forms  (4)
<span id="line3303"></span>          and  (5)  indicate  that  in interpreting an arithmetic
<span id="line3304"></span>          expression  containing  two   or   more   addition   or
<span id="line3305"></span>          subtraction operators, the terms are combined from left
<span id="line3306"></span>          to right.
<span id="line3307"></span>
<span id="line3308"></span>          Note  that  these  formation  rules   do   not   permit
<span id="line3309"></span>          expressions   containing   two  consecutive  arithmetic
<span id="line3310"></span>          operators, such as A**-B or A+-B.  However, expressions
<span id="line3311"></span>          such as A**(-B) and A+(-B) are permitted.
<span id="line3312"></span>
<span id="line3313"></span>
<span id="line3314"></span>
<span id="line3315"></span>
<span id="line3316"></span>          FORTRAN 77 Full Language                       Page 6-4
<span id="line3317"></span>
<span id="line3318"></span>
<span id="line3319"></span>
<span id="line3320"></span>
<span id="line3321"></span>
<span id="line3322"></span>
<span id="line3323"></span>
<span id="line3324"></span>          EXPRESSIONS                              ANSI X3J3/90.4
<span id="line3325"></span>
<span id="line3326"></span>
<span id="line3327"></span>
<span id="line3328"></span>          6.1.3  Arithmetic_Constant_Expression.   An  arithmetic
<span id="line3329"></span>          constant  expression  is  an  arithmetic  expression in
<span id="line3330"></span>          which each  primary  is  an  arithmetic  constant,  the
<span id="line3331"></span>          symbolic   name   of  an  arithmetic  constant,  or  an
<span id="line3332"></span>          arithmetic constant expression enclosed in parentheses.
<span id="line3333"></span>          The exponentiation operator is not permitted unless the
<span id="line3334"></span>          exponent is of type integer.  Note that variable, array
<span id="line3335"></span>          element, and function references are not allowed.
<span id="line3336"></span>
<span id="line3337"></span>          6.1.3.1  Integer_Constant_Expression.     An    integer
<span id="line3338"></span>          constant   expression   is   an   arithmetic   constant
<span id="line3339"></span>          expression in which each constant or symbolic name of a
<span id="line3340"></span>          constant is of type integer.  Note that variable, array
<span id="line3341"></span>          element, and function references are not allowed.
<span id="line3342"></span>
<span id="line3343"></span>          The  following  are  examples   of   integer   constant
<span id="line3344"></span>          expressions:
<span id="line3345"></span>
<span id="line3346"></span>                     3
<span id="line3347"></span>                     -3
<span id="line3348"></span>                     -3+4
<span id="line3349"></span>
<span id="line3350"></span>          6.1.4  Type   and    Interpretation    of    Arithmetic
<span id="line3351"></span>          Expressions.  The data type of a constant is determined
<span id="line3352"></span>          by the form of the constant (4.2.1).  The data type  of
<span id="line3353"></span>          an  arithmetic  variable reference, symbolic name of an
<span id="line3354"></span>          arithmetic   constant,   arithmetic    array    element
<span id="line3355"></span>          reference,   or   arithmetic   function   reference  is
<span id="line3356"></span>          determined  by  the  name  of  the  datum  or  function
<span id="line3357"></span>          (4.1.2).   The  data  type  of an arithmetic expression
<span id="line3358"></span>          containing  one  or  more   arithmetic   operators   is
<span id="line3359"></span>          determined from the data types of the operands.
<span id="line3360"></span>
<span id="line3361"></span>          Integer expressions, real expressions, double precision
<span id="line3362"></span>          expressions,  and  complex  expressions  are arithmetic
<span id="line3363"></span>          expressions whose values are  of  type  integer,  real,
<span id="line3364"></span>          double precision, and complex, respectively.
<span id="line3365"></span>
<span id="line3366"></span>          When the operator + or - operates on a single  operand,
<span id="line3367"></span>          the  data  type of the resulting expression is the same
<span id="line3368"></span>          as the data type of the operand.
<span id="line3369"></span>
<span id="line3370"></span>          When an arithmetic  operator  operates  on  a  pair  of
<span id="line3371"></span>          operands,  the data type of the resulting expression is
<span id="line3372"></span>          given in Tables 2 and 3.  In these tables, each  letter
<span id="line3373"></span>          I,  R,  D, or C represents an operand or result of type
<span id="line3374"></span>          integer,   real,   double   precision,   or    complex,
<span id="line3375"></span>          respectively.
<span id="line3376"></span>
<span id="line3377"></span>          The type of the result is indicated by the I, R, D,  or
<span id="line3378"></span>          C  that  precedes the equals, and the interpretation is
<span id="line3379"></span>
<span id="line3380"></span>
<span id="line3381"></span>
<span id="line3382"></span>          FORTRAN 77 Full Language                       Page 6-5
<span id="line3383"></span>
<span id="line3384"></span>
<span id="line3385"></span>
<span id="line3386"></span>
<span id="line3387"></span>
<span id="line3388"></span>
<span id="line3389"></span>
<span id="line3390"></span>          EXPRESSIONS                              ANSI X3J3/90.4
<span id="line3391"></span>
<span id="line3392"></span>
<span id="line3393"></span>
<span id="line3394"></span>          indicated by the expression to the right of the equals.
<span id="line3395"></span>          REAL, DBLE, and CMPLX are the type-conversion functions
<span id="line3396"></span>          described in 15.10.
<span id="line3397"></span>
<span id="line3398"></span>                                  Table 2_______
<span id="line3399"></span>
<span id="line3400"></span>               Type and Interpretation of Result for x918 + x92
<span id="line3401"></span>7          ________________________________________________________
<span id="line3402"></span>
<span id="line3403"></span>             x928             I928                       R92
<span id="line3404"></span>8           x91
<span id="line3405"></span>7          ________________________________________________________
<span id="line3406"></span>
<span id="line3407"></span>           I918           I = I918 + I928         R = REAL(I918) + R92
<span id="line3408"></span>8
<span id="line3409"></span>           R918        R = R918 + REAL(I928)      R = R918 + R92
<span id="line3410"></span>8
<span id="line3411"></span>           D918        D = D918 + DBLE(I928)      D = D918 + DBLE(R928)
<span id="line3412"></span>
<span id="line3413"></span>           C918     C=C918+CMPLX(REAL(I928),0.)   C = C918 + CMPLX(R928,0.)
<span id="line3414"></span>8          ________________________________________________________
<span id="line3415"></span>7         |7|7|7|7|7|7|7|7|7|7|7|
<span id="line3416"></span>
<span id="line3417"></span>
<span id="line3418"></span>
<span id="line3419"></span>
<span id="line3420"></span>
<span id="line3421"></span>
<span id="line3422"></span>
<span id="line3423"></span>
<span id="line3424"></span>
<span id="line3425"></span>
<span id="line3426"></span>               |7|7|7|7|7|7|7|7|7|7|7|
<span id="line3427"></span>
<span id="line3428"></span>
<span id="line3429"></span>
<span id="line3430"></span>
<span id="line3431"></span>
<span id="line3432"></span>
<span id="line3433"></span>
<span id="line3434"></span>
<span id="line3435"></span>
<span id="line3436"></span>
<span id="line3437"></span>                                         |7|7|7|7|7|7|7|7|7|7|7|
<span id="line3438"></span>
<span id="line3439"></span>
<span id="line3440"></span>
<span id="line3441"></span>
<span id="line3442"></span>
<span id="line3443"></span>
<span id="line3444"></span>
<span id="line3445"></span>
<span id="line3446"></span>
<span id="line3447"></span>
<span id="line3448"></span>                                                                 |7|7|7|7|7|7|7|7|7|7|7|
<span id="line3449"></span>
<span id="line3450"></span>
<span id="line3451"></span>
<span id="line3452"></span>
<span id="line3453"></span>
<span id="line3454"></span>
<span id="line3455"></span>
<span id="line3456"></span>
<span id="line3457"></span>
<span id="line3458"></span>
<span id="line3459"></span>
<span id="line3460"></span>
<span id="line3461"></span>8          _______________________________________________________
<span id="line3462"></span>
<span id="line3463"></span>             x928           D928                       C92
<span id="line3464"></span>8           x91
<span id="line3465"></span>7          _______________________________________________________
<span id="line3466"></span>
<span id="line3467"></span>           I918      D = DBLE(I928) + D928     C=CMPLX(REAL(I928),0.)+C92
<span id="line3468"></span>8
<span id="line3469"></span>           R918      D = DBLE(R918) + D928     C = CMPLX(R918,0.) + C92
<span id="line3470"></span>8
<span id="line3471"></span>           D918      D = D918 + D928                 Prohibited
<span id="line3472"></span>
<span id="line3473"></span>           C918         Prohibited         C = C918 + C92
<span id="line3474"></span>7          _______________________________________________________
<span id="line3475"></span>7         |7|7|7|7|7|7|7|7|7|7|7|
<span id="line3476"></span>
<span id="line3477"></span>
<span id="line3478"></span>
<span id="line3479"></span>
<span id="line3480"></span>
<span id="line3481"></span>
<span id="line3482"></span>
<span id="line3483"></span>
<span id="line3484"></span>
<span id="line3485"></span>
<span id="line3486"></span>                |7|7|7|7|7|7|7|7|7|7|7|
<span id="line3487"></span>
<span id="line3488"></span>
<span id="line3489"></span>
<span id="line3490"></span>
<span id="line3491"></span>
<span id="line3492"></span>
<span id="line3493"></span>
<span id="line3494"></span>
<span id="line3495"></span>
<span id="line3496"></span>
<span id="line3497"></span>                                      |7|7|7|7|7|7|7|7|7|7|7|
<span id="line3498"></span>
<span id="line3499"></span>
<span id="line3500"></span>
<span id="line3501"></span>
<span id="line3502"></span>
<span id="line3503"></span>
<span id="line3504"></span>
<span id="line3505"></span>
<span id="line3506"></span>
<span id="line3507"></span>
<span id="line3508"></span>                                                                |7|7|7|7|7|7|7|7|7|7|7|
<span id="line3509"></span>
<span id="line3510"></span>
<span id="line3511"></span>
<span id="line3512"></span>
<span id="line3513"></span>
<span id="line3514"></span>
<span id="line3515"></span>
<span id="line3516"></span>
<span id="line3517"></span>
<span id="line3518"></span>
<span id="line3519"></span>
<span id="line3520"></span>
<span id="line3521"></span>          Tables  giving   the   type   and   interpretation   of
<span id="line3522"></span>          expressions  involving  -,  *, and / may be obtained by
<span id="line3523"></span>          replacing all occurrences of + in Table 2 by -,  *,  or
<span id="line3524"></span>          /, respectively.
<span id="line3525"></span>
<span id="line3526"></span>
<span id="line3527"></span>
<span id="line3528"></span>
<span id="line3529"></span>
<span id="line3530"></span>
<span id="line3531"></span>
<span id="line3532"></span>
<span id="line3533"></span>
<span id="line3534"></span>
<span id="line3535"></span>
<span id="line3536"></span>
<span id="line3537"></span>
<span id="line3538"></span>
<span id="line3539"></span>
<span id="line3540"></span>
<span id="line3541"></span>          FORTRAN 77 Full Language                       Page 6-6
<span id="line3542"></span>
<span id="line3543"></span>
<span id="line3544"></span>
<span id="line3545"></span>
<span id="line3546"></span>
<span id="line3547"></span>
<span id="line3548"></span>
<span id="line3549"></span>          EXPRESSIONS                              ANSI X3J3/90.4
<span id="line3550"></span>
<span id="line3551"></span>
<span id="line3552"></span>
<span id="line3553"></span>                                  Table 3_______
<span id="line3554"></span>
<span id="line3555"></span>               Type and Interpretation of Result for x918**x92
<span id="line3556"></span>7          _______________________________________________________
<span id="line3557"></span>
<span id="line3558"></span>               x928           I928                     R92
<span id="line3559"></span>8             x91
<span id="line3560"></span>7          _______________________________________________________
<span id="line3561"></span>
<span id="line3562"></span>             I918         I = I918**I928        R = REAL(I918)**R92
<span id="line3563"></span>8
<span id="line3564"></span>             R918         R = R918**I928        R = R918**R92
<span id="line3565"></span>8
<span id="line3566"></span>             D918         D = D918**I928        D = D918**DBLE(R928)
<span id="line3567"></span>
<span id="line3568"></span>             C918         C = C918**I928        C = C918**CMPLX(R928,0.)
<span id="line3569"></span>8          _______________________________________________________
<span id="line3570"></span>7         |7|7|7|7|7|7|7|7|7|7|7|
<span id="line3571"></span>
<span id="line3572"></span>
<span id="line3573"></span>
<span id="line3574"></span>
<span id="line3575"></span>
<span id="line3576"></span>
<span id="line3577"></span>
<span id="line3578"></span>
<span id="line3579"></span>
<span id="line3580"></span>
<span id="line3581"></span>                    |7|7|7|7|7|7|7|7|7|7|7|
<span id="line3582"></span>
<span id="line3583"></span>
<span id="line3584"></span>
<span id="line3585"></span>
<span id="line3586"></span>
<span id="line3587"></span>
<span id="line3588"></span>
<span id="line3589"></span>
<span id="line3590"></span>
<span id="line3591"></span>
<span id="line3592"></span>                                     |7|7|7|7|7|7|7|7|7|7|7|
<span id="line3593"></span>
<span id="line3594"></span>
<span id="line3595"></span>
<span id="line3596"></span>
<span id="line3597"></span>
<span id="line3598"></span>
<span id="line3599"></span>
<span id="line3600"></span>
<span id="line3601"></span>
<span id="line3602"></span>
<span id="line3603"></span>                                                                |7|7|7|7|7|7|7|7|7|7|7|
<span id="line3604"></span>
<span id="line3605"></span>
<span id="line3606"></span>
<span id="line3607"></span>
<span id="line3608"></span>
<span id="line3609"></span>
<span id="line3610"></span>
<span id="line3611"></span>
<span id="line3612"></span>
<span id="line3613"></span>
<span id="line3614"></span>
<span id="line3615"></span>
<span id="line3616"></span>8          _______________________________________________________
<span id="line3617"></span>
<span id="line3618"></span>             x928           D928                       C92
<span id="line3619"></span>8           x91
<span id="line3620"></span>7          _______________________________________________________
<span id="line3621"></span>
<span id="line3622"></span>           I928      D = DBLE(I928)**D928     C=CMPLX(REAL(I928),0.)**C92
<span id="line3623"></span>8
<span id="line3624"></span>           R918      D = DBLE(R918)**D928     C = CMPLX(R918,0.)**C92
<span id="line3625"></span>8
<span id="line3626"></span>           D918      D = D918**D928                  Prohibited
<span id="line3627"></span>
<span id="line3628"></span>           C918         Prohibited        C = C918**C92
<span id="line3629"></span>7          _______________________________________________________
<span id="line3630"></span>7         |7|7|7|7|7|7|7|7|7|7|7|
<span id="line3631"></span>
<span id="line3632"></span>
<span id="line3633"></span>
<span id="line3634"></span>
<span id="line3635"></span>
<span id="line3636"></span>
<span id="line3637"></span>
<span id="line3638"></span>
<span id="line3639"></span>
<span id="line3640"></span>
<span id="line3641"></span>                |7|7|7|7|7|7|7|7|7|7|7|
<span id="line3642"></span>
<span id="line3643"></span>
<span id="line3644"></span>
<span id="line3645"></span>
<span id="line3646"></span>
<span id="line3647"></span>
<span id="line3648"></span>
<span id="line3649"></span>
<span id="line3650"></span>
<span id="line3651"></span>
<span id="line3652"></span>                                     |7|7|7|7|7|7|7|7|7|7|7|
<span id="line3653"></span>
<span id="line3654"></span>
<span id="line3655"></span>
<span id="line3656"></span>
<span id="line3657"></span>
<span id="line3658"></span>
<span id="line3659"></span>
<span id="line3660"></span>
<span id="line3661"></span>
<span id="line3662"></span>
<span id="line3663"></span>                                                                |7|7|7|7|7|7|7|7|7|7|7|
<span id="line3664"></span>
<span id="line3665"></span>
<span id="line3666"></span>
<span id="line3667"></span>
<span id="line3668"></span>
<span id="line3669"></span>
<span id="line3670"></span>
<span id="line3671"></span>
<span id="line3672"></span>
<span id="line3673"></span>
<span id="line3674"></span>
<span id="line3675"></span>
<span id="line3676"></span>          Four entries in Table 3 specify an interpretation to be
<span id="line3677"></span>          a  complex  value  raised to a complex power.  In these
<span id="line3678"></span>          cases, the value of the expression  is  the  "principal
<span id="line3679"></span>          value"  determined  by  x918**x928 = EXP(x928*LOG(x918)), where
<span id="line3680"></span>          EXP and LOG are functions described in 15.10.
<span id="line3681"></span>
<span id="line3682"></span>          Except for a value raised to an integer power, Tables 2
<span id="line3683"></span>          and  3  specify  that  if two operands are of different
<span id="line3684"></span>          type, the operand that differs in type from the  result
<span id="line3685"></span>          of the operation is converted to the type of the result
<span id="line3686"></span>          and then the operator operates on a pair of operands of
<span id="line3687"></span>          the  same  type.   When  a primary of type real, double
<span id="line3688"></span>          precision, or complex is raised to  an  integer  power,
<span id="line3689"></span>          the  integer  operand  need  not  be converted.  If the
<span id="line3690"></span>          value of I928 is negative, the interpretation  of  I918**I92
<span id="line3691"></span>8          is  the  same as the interpretation of 1/(I918**ABS(I928)),
<span id="line3692"></span>          which is subject to  the  rules  for  integer  division
<span id="line3693"></span>          (6.1.5).    For  example,  2**(-3)  has  the  value  of
<span id="line3694"></span>          1/(2**3), which is zero.
<span id="line3695"></span>
<span id="line3696"></span>
<span id="line3697"></span>
<span id="line3698"></span>
<span id="line3699"></span>
<span id="line3700"></span>          FORTRAN 77 Full Language                       Page 6-7
<span id="line3701"></span>
<span id="line3702"></span>
<span id="line3703"></span>
<span id="line3704"></span>
<span id="line3705"></span>
<span id="line3706"></span>
<span id="line3707"></span>
<span id="line3708"></span>          EXPRESSIONS                              ANSI X3J3/90.4
<span id="line3709"></span>
<span id="line3710"></span>
<span id="line3711"></span>
<span id="line3712"></span>          The type  and  interpretation  of  an  expression  that
<span id="line3713"></span>          consists  of  an  operator operating on either a single
<span id="line3714"></span>          operand or a pair of operands are  independent  of  the
<span id="line3715"></span>          context   in   which   the   expression   appears.   In
<span id="line3716"></span>          particular, the type  and  interpretation  of  such  an
<span id="line3717"></span>          expression  are  independent  of  the type of any other
<span id="line3718"></span>          operand of any larger expression in which  it  appears.
<span id="line3719"></span>          For  example,  if  X  is  of  type  real,  J is of type
<span id="line3720"></span>          integer, and  INT  is  the  real-to-integer  conversion
<span id="line3721"></span>          function,   the   expression  INT(X+J)  is  an  integer
<span id="line3722"></span>          expression and X+J is a real expression.
<span id="line3723"></span>
<span id="line3724"></span>          6.1.5  Integer_Division.  One operand of  type  integer
<span id="line3725"></span>          may  be  divided  by  another  operand of type integer.
<span id="line3726"></span>          Although the mathematical quotient of two  integers  is
<span id="line3727"></span>          not  necessarily  an integer, Table 2 specifies that an
<span id="line3728"></span>          expression involving the  division  operator  with  two
<span id="line3729"></span>          operands   of   type   integer  is  interpreted  as  an
<span id="line3730"></span>          expression of type  integer.   The  result  of  such  a
<span id="line3731"></span>          division  is called an integer quotient and is obtained
<span id="line3732"></span>          as follows:   If  the  magnitude  of  the  mathematical
<span id="line3733"></span>          quotient  is  less  than  one,  the integer quotient is
<span id="line3734"></span>          zero.  Otherwise, the integer quotient is  the  integer
<span id="line3735"></span>          whose  magnitude  is  the largest integer that does not
<span id="line3736"></span>          exceed the magnitude of the mathematical  quotient  and
<span id="line3737"></span>          whose  sign is the same as the sign of the mathematical
<span id="line3738"></span>          quotient.  For example, the value of the expression  (-
<span id="line3739"></span>          8)/3 is (-2).
<span id="line3740"></span>
<span id="line3741"></span>          6.2  Character_Expressions
<span id="line3742"></span>
<span id="line3743"></span>          A character expression is used to express  a  character
<span id="line3744"></span>          string.   Evaluation of a character expression produces
<span id="line3745"></span>          a result of type character.
<span id="line3746"></span>
<span id="line3747"></span>          The simplest  form  of  a  character  expression  is  a
<span id="line3748"></span>          character   constant,  symbolic  name  of  a  character
<span id="line3749"></span>          constant, character variable reference, character array
<span id="line3750"></span>          element  reference,  character  substring reference, or
<span id="line3751"></span>          character   function   reference.   More    complicated
<span id="line3752"></span>          character  expressions  may  be  formed by using one or
<span id="line3753"></span>          more  character  operands   together   with   character
<span id="line3754"></span>          operators and parentheses.
<span id="line3755"></span>
<span id="line3756"></span>          6.2.1  Character_Operator.  The character operator is:
<span id="line3757"></span>
<span id="line3758"></span>
<span id="line3759"></span>
<span id="line3760"></span>
<span id="line3761"></span>
<span id="line3762"></span>
<span id="line3763"></span>
<span id="line3764"></span>
<span id="line3765"></span>
<span id="line3766"></span>          FORTRAN 77 Full Language                       Page 6-8
<span id="line3767"></span>
<span id="line3768"></span>
<span id="line3769"></span>
<span id="line3770"></span>
<span id="line3771"></span>
<span id="line3772"></span>
<span id="line3773"></span>
<span id="line3774"></span>          EXPRESSIONS                              ANSI X3J3/90.4
<span id="line3775"></span>
<span id="line3776"></span>
<span id="line3777"></span>
<span id="line3778"></span>8                        __________________________
<span id="line3779"></span>
<span id="line3780"></span>                         Operator   Representing
<span id="line3781"></span>8                        __________________________
<span id="line3782"></span>
<span id="line3783"></span>                            //      Concatenation
<span id="line3784"></span>8                        __________________________
<span id="line3785"></span>7                       |7|7|7|7|
<span id="line3786"></span>
<span id="line3787"></span>
<span id="line3788"></span>
<span id="line3789"></span>                                 |7|7|7|7|
<span id="line3790"></span>
<span id="line3791"></span>
<span id="line3792"></span>
<span id="line3793"></span>                                                 |7|7|7|7|
<span id="line3794"></span>
<span id="line3795"></span>
<span id="line3796"></span>
<span id="line3797"></span>
<span id="line3798"></span>
<span id="line3799"></span>          The interpretation of the expression  formed  with  the
<span id="line3800"></span>          character operator is:
<span id="line3801"></span>
<span id="line3802"></span>8                __________________________________________
<span id="line3803"></span>
<span id="line3804"></span>                 Use of Operator   Interpretation
<span id="line3805"></span>8                __________________________________________
<span id="line3806"></span>
<span id="line3807"></span>                    x918 // x928       Concatenate x918 with x92
<span id="line3808"></span>7                __________________________________________
<span id="line3809"></span>7               |7|7|7|7|
<span id="line3810"></span>
<span id="line3811"></span>
<span id="line3812"></span>
<span id="line3813"></span>                                |7|7|7|7|
<span id="line3814"></span>
<span id="line3815"></span>
<span id="line3816"></span>
<span id="line3817"></span>                                                         |7|7|7|7|
<span id="line3818"></span>
<span id="line3819"></span>
<span id="line3820"></span>
<span id="line3821"></span>
<span id="line3822"></span>
<span id="line3823"></span>          where: x918  denotes the  operand  to  the  left  of  the
<span id="line3824"></span>                     operator
<span id="line3825"></span>
<span id="line3826"></span>                 x928  denotes the operand  to  the  right  of  the
<span id="line3827"></span>                     operator
<span id="line3828"></span>
<span id="line3829"></span>          The result of a concatenation operation is a  character
<span id="line3830"></span>          string  whose  value is the value of x918 concatenated on
<span id="line3831"></span>          the right with the value of x928 and whose length is  the
<span id="line3832"></span>          sum  of  the  lengths  of  x918 and x928.  For example, the
<span id="line3833"></span>          value of 'AB' // 'CDE' is the string ABCDE.
<span id="line3834"></span>
<span id="line3835"></span>          6.2.2  Form    and    Interpretation    of    Character
<span id="line3836"></span>          Expressions.   A  character expression and the operands
<span id="line3837"></span>          of a character expression must identify values of  type
<span id="line3838"></span>          character.   Except in a character assignment statement
<span id="line3839"></span>          (10.4),  a  character  expression  must   not   involve
<span id="line3840"></span>          concatenation  of an operand whose length specification
<span id="line3841"></span>          is  an  asterisk  in  parentheses  (8.4.2)  unless  the
<span id="line3842"></span>          operand is the symbolic name of a constant.
<span id="line3843"></span>
<span id="line3844"></span>          6.2.2.1  Character_Primaries.  The character  primaries
<span id="line3845"></span>          are:
<span id="line3846"></span>
<span id="line3847"></span>             (1) Character constant (4.8.1)
<span id="line3848"></span>
<span id="line3849"></span>             (2) Symbolic name of a character constant (8.6)
<span id="line3850"></span>
<span id="line3851"></span>             (3) Character variable reference (2.5)
<span id="line3852"></span>
<span id="line3853"></span>             (4) Character array element reference (5.3)
<span id="line3854"></span>
<span id="line3855"></span>             (5) Character substring reference (5.7)
<span id="line3856"></span>
<span id="line3857"></span>
<span id="line3858"></span>
<span id="line3859"></span>
<span id="line3860"></span>
<span id="line3861"></span>          FORTRAN 77 Full Language                       Page 6-9
<span id="line3862"></span>
<span id="line3863"></span>
<span id="line3864"></span>
<span id="line3865"></span>
<span id="line3866"></span>
<span id="line3867"></span>
<span id="line3868"></span>
<span id="line3869"></span>          EXPRESSIONS                              ANSI X3J3/90.4
<span id="line3870"></span>
<span id="line3871"></span>
<span id="line3872"></span>
<span id="line3873"></span>             (6) Character function reference (15.2)
<span id="line3874"></span>
<span id="line3875"></span>             (7) Character  expression  enclosed  in  parentheses
<span id="line3876"></span>                 (6.2.2.2)
<span id="line3877"></span>
<span id="line3878"></span>          6.2.2.2  Character_Expression.    The   forms   of    a
<span id="line3879"></span>          character expression are:
<span id="line3880"></span>
<span id="line3881"></span>             (1) Character primary
<span id="line3882"></span>
<span id="line3883"></span>             (2) Character expression // character primary
<span id="line3884"></span>
<span id="line3885"></span>          Thus, a character expression is a sequence  of  one  or
<span id="line3886"></span>          more character primaries separated by the concatenation
<span id="line3887"></span>          operator.  Form  (2)  indicates  that  in  a  character
<span id="line3888"></span>          expression   containing   two   or  more  concatenation
<span id="line3889"></span>          operators, the primaries  are  combined  from  left  to
<span id="line3890"></span>          right   to   establish   the   interpretation   of  the
<span id="line3891"></span>          expression.  For example, the formation  rules  specify
<span id="line3892"></span>          that the interpretation of the character expression
<span id="line3893"></span>
<span id="line3894"></span>                               'AB' // 'CD' // 'EF'
<span id="line3895"></span>
<span id="line3896"></span>          is the same as  the  interpretation  of  the  character
<span id="line3897"></span>          expression
<span id="line3898"></span>
<span id="line3899"></span>                               ('AB' // 'CD') // 'EF'
<span id="line3900"></span>
<span id="line3901"></span>          The value of the character expression in  this  example
<span id="line3902"></span>          is  the  same  as  that of the constant 'ABCDEF'.  Note
<span id="line3903"></span>          that parentheses have no  effect  on  the  value  of  a
<span id="line3904"></span>          character expression.
<span id="line3905"></span>
<span id="line3906"></span>          6.2.3  Character_Constant_Expression.    A    character
<span id="line3907"></span>          constant  expression is a character expression in which
<span id="line3908"></span>          each primary is a character constant, the symbolic name
<span id="line3909"></span>          of  a  character  constant,  or  a  character  constant
<span id="line3910"></span>          expression  enclosed   in   parentheses.    Note   that
<span id="line3911"></span>          variable,   array   element,  substring,  and  function
<span id="line3912"></span>          references are not allowed.
<span id="line3913"></span>
<span id="line3914"></span>          6.3  Relational_Expressions
<span id="line3915"></span>
<span id="line3916"></span>          A relational expression is used to compare  the  values
<span id="line3917"></span>          of   two   arithmetic   expressions  or  two  character
<span id="line3918"></span>          expressions.  A relational expression may not  be  used
<span id="line3919"></span>          to  compare  the value of an arithmetic expression with
<span id="line3920"></span>          the value of a character expression.
<span id="line3921"></span>
<span id="line3922"></span>          Relational expressions may appear only  within  logical
<span id="line3923"></span>          expressions.   Evaluation  of  a  relational expression
<span id="line3924"></span>
<span id="line3925"></span>
<span id="line3926"></span>
<span id="line3927"></span>          FORTRAN 77 Full Language                      Page 6-10
<span id="line3928"></span>
<span id="line3929"></span>
<span id="line3930"></span>
<span id="line3931"></span>
<span id="line3932"></span>
<span id="line3933"></span>
<span id="line3934"></span>
<span id="line3935"></span>          EXPRESSIONS                              ANSI X3J3/90.4
<span id="line3936"></span>
<span id="line3937"></span>
<span id="line3938"></span>
<span id="line3939"></span>          produces a result of type logical, with a value of true
<span id="line3940"></span>          or false.
<span id="line3941"></span>
<span id="line3942"></span>          6.3.1  Relational_Operators.  The relational  operators
<span id="line3943"></span>          are:
<span id="line3944"></span>
<span id="line3945"></span>8                   _____________________________________
<span id="line3946"></span>
<span id="line3947"></span>                    Operator   Representing
<span id="line3948"></span>8                   _____________________________________
<span id="line3949"></span>
<span id="line3950"></span>                      .LT.     Less than
<span id="line3951"></span>                      .LE.     Less than or equal to
<span id="line3952"></span>                      .EQ.     Equal to
<span id="line3953"></span>                      .NE.     Not equal to
<span id="line3954"></span>                      .GT.     Greater than
<span id="line3955"></span>                      .GE.     Greater than or equal to
<span id="line3956"></span>8                   _____________________________________
<span id="line3957"></span>7                  |7|7|7|7|7|7|7|7|7|
<span id="line3958"></span>
<span id="line3959"></span>
<span id="line3960"></span>
<span id="line3961"></span>
<span id="line3962"></span>
<span id="line3963"></span>
<span id="line3964"></span>
<span id="line3965"></span>
<span id="line3966"></span>                            |7|7|7|7|7|7|7|7|7|
<span id="line3967"></span>
<span id="line3968"></span>
<span id="line3969"></span>
<span id="line3970"></span>
<span id="line3971"></span>
<span id="line3972"></span>
<span id="line3973"></span>
<span id="line3974"></span>
<span id="line3975"></span>                                                       |7|7|7|7|7|7|7|7|7|
<span id="line3976"></span>
<span id="line3977"></span>
<span id="line3978"></span>
<span id="line3979"></span>
<span id="line3980"></span>
<span id="line3981"></span>
<span id="line3982"></span>
<span id="line3983"></span>
<span id="line3984"></span>
<span id="line3985"></span>
<span id="line3986"></span>          6.3.2  Arithmetic_Relational_Expression.  The  form  of
<span id="line3987"></span>          an arithmetic relational expression is:
<span id="line3988"></span>
<span id="line3989"></span>                               e_918 relop_____ e_92
<span id="line3990"></span>9          where: e_918 and e_928 are  each  an  integer,  real,  double
<span id="line3991"></span>                     precision, or complex expression
<span id="line3992"></span>
<span id="line3993"></span>                 relop_____ is a relational operator
<span id="line3994"></span>
<span id="line3995"></span>          A complex operand is permitted only when the relational
<span id="line3996"></span>          operator is .EQ. or .NE.
<span id="line3997"></span>
<span id="line3998"></span>          6.3.3  Interpretation    of    Arithmetic    Relational
<span id="line3999"></span>          Expressions.   An  arithmetic  relational expression is
<span id="line4000"></span>          interpreted as having the logical  value  true  if  the
<span id="line4001"></span>          values  of  the operands satisfy the relation specified
<span id="line4002"></span>          by the operator.  An arithmetic  relational  expression
<span id="line4003"></span>          is interpreted as having the logical value false if the
<span id="line4004"></span>          values of the operands  do  not  satisfy  the  relation
<span id="line4005"></span>          specified by the operator.
<span id="line4006"></span>
<span id="line4007"></span>          If the two  arithmetic  expressions  are  of  different
<span id="line4008"></span>          types, the value of the relational expression
<span id="line4009"></span>
<span id="line4010"></span>                               e_918 relop_____ e_92
<span id="line4011"></span>9          is the value of the expression
<span id="line4012"></span>
<span id="line4013"></span>                               ((e_918) - (e_928)) relop_____ 0
<span id="line4014"></span>
<span id="line4015"></span>          where 0 (zero) is of the same type as the expression ((e
<span id="line4016"></span>          _918) (e_928)), and relop_____ is the same relational operator in
<span id="line4017"></span>          both expressions.  Note that the comparison of a double
<span id="line4018"></span>
<span id="line4019"></span>9
<span id="line4020"></span>          FORTRAN 77 Full Language                      Page 6-11
<span id="line4021"></span>
<span id="line4022"></span>
<span id="line4023"></span>
<span id="line4024"></span>
<span id="line4025"></span>
<span id="line4026"></span>
<span id="line4027"></span>
<span id="line4028"></span>          EXPRESSIONS                              ANSI X3J3/90.4
<span id="line4029"></span>
<span id="line4030"></span>
<span id="line4031"></span>
<span id="line4032"></span>          precision value and a complex value is not permitted.
<span id="line4033"></span>
<span id="line4034"></span>          6.3.4  Character_Relational_Expression.  The form of  a
<span id="line4035"></span>          character relational expression is:
<span id="line4036"></span>
<span id="line4037"></span>                               e_918 relop_____ e_92
<span id="line4038"></span>9          where: e_918 and e_928 are character expressions
<span id="line4039"></span>
<span id="line4040"></span>                 relop_____ is a relational operator
<span id="line4041"></span>
<span id="line4042"></span>          6.3.5  Interpretation    of    Character     Relational
<span id="line4043"></span>          Expressions.   A  character  relational  expression  is
<span id="line4044"></span>          interpreted as the logical value true if the values  of
<span id="line4045"></span>          the  operands  satisfy  the  relation  specified by the
<span id="line4046"></span>          operator.   A  character   relational   expression   is
<span id="line4047"></span>          interpreted as the logical value false if the values of
<span id="line4048"></span>          the operands do not satisfy the relation  specified  by
<span id="line4049"></span>          the operator.
<span id="line4050"></span>
<span id="line4051"></span>          The character expression e_918 is considered  to  be  less
<span id="line4052"></span>          than  e_928 if the value of e_918 precedes the value of e_928 in
<span id="line4053"></span>          the collating sequence; e_918 is greater than e_928  if  the
<span id="line4054"></span>          value  of  e_918 follows the value of e_928 in the collating
<span id="line4055"></span>          sequence (3.1.5).  Note  that  the  collating  sequence
<span id="line4056"></span>          depends partially on the processor; however, the result
<span id="line4057"></span>          of the use of the operators  .EQ.  and  .NE.  does  not
<span id="line4058"></span>          depend  on the collating sequence.  If the operands are
<span id="line4059"></span>          of unequal length, the shorter operand is considered as
<span id="line4060"></span>          if  it  were  extended  on the right with blanks to the
<span id="line4061"></span>          length of the longer operand.
<span id="line4062"></span>
<span id="line4063"></span>          6.4  Logical_Expressions
<span id="line4064"></span>
<span id="line4065"></span>          A logical expression  is  used  to  express  a  logical
<span id="line4066"></span>          computation.    Evaluation   of  a  logical  expression
<span id="line4067"></span>          produces a result of type logical, with a value of true
<span id="line4068"></span>          or false.
<span id="line4069"></span>
<span id="line4070"></span>          The simplest form of a logical expression is a  logical
<span id="line4071"></span>          constant,  symbolic name of a logical constant, logical
<span id="line4072"></span>          variable reference, logical  array  element  reference,
<span id="line4073"></span>          logical  function  reference, or relational expression.
<span id="line4074"></span>          More complicated logical expressions may be  formed  by
<span id="line4075"></span>          using  one  or  more  logical  operands  together  with
<span id="line4076"></span>          logical operators and parentheses.
<span id="line4077"></span>
<span id="line4078"></span>          6.4.1  Logical_Operators.  The logical operators are:
<span id="line4079"></span>
<span id="line4080"></span>
<span id="line4081"></span>
<span id="line4082"></span>
<span id="line4083"></span>
<span id="line4084"></span>
<span id="line4085"></span>          FORTRAN 77 Full Language                      Page 6-12
<span id="line4086"></span>
<span id="line4087"></span>
<span id="line4088"></span>
<span id="line4089"></span>
<span id="line4090"></span>
<span id="line4091"></span>
<span id="line4092"></span>
<span id="line4093"></span>          EXPRESSIONS                              ANSI X3J3/90.4
<span id="line4094"></span>
<span id="line4095"></span>
<span id="line4096"></span>
<span id="line4097"></span>8                __________________________________________
<span id="line4098"></span>
<span id="line4099"></span>                 Operator   Representing
<span id="line4100"></span>8                __________________________________________
<span id="line4101"></span>
<span id="line4102"></span>                  .NOT.     Logical Negation
<span id="line4103"></span>                  .AND.     Logical Conjunction
<span id="line4104"></span>                   .OR.     Logical Inclusive Disjunction
<span id="line4105"></span>                  .EQV.     Logical Equivalence
<span id="line4106"></span>                  .NEQV.    Logical Nonequivalence
<span id="line4107"></span>8                __________________________________________
<span id="line4108"></span>7               |7|7|7|7|7|7|7|7|
<span id="line4109"></span>
<span id="line4110"></span>
<span id="line4111"></span>
<span id="line4112"></span>
<span id="line4113"></span>
<span id="line4114"></span>
<span id="line4115"></span>
<span id="line4116"></span>                         |7|7|7|7|7|7|7|7|
<span id="line4117"></span>
<span id="line4118"></span>
<span id="line4119"></span>
<span id="line4120"></span>
<span id="line4121"></span>
<span id="line4122"></span>
<span id="line4123"></span>
<span id="line4124"></span>                                                         |7|7|7|7|7|7|7|7|
<span id="line4125"></span>
<span id="line4126"></span>
<span id="line4127"></span>
<span id="line4128"></span>
<span id="line4129"></span>
<span id="line4130"></span>
<span id="line4131"></span>
<span id="line4132"></span>
<span id="line4133"></span>
<span id="line4134"></span>          6.4.2  Form_and_Interpretation_of_Logical_Expressions.
<span id="line4135"></span>          A  set  of  formation  rules  is  used to establish the
<span id="line4136"></span>          interpretation of a logical  expression  that  contains
<span id="line4137"></span>          two  or  more logical operators.  There is a precedence
<span id="line4138"></span>          among the logical operators, which determines the order
<span id="line4139"></span>          in  which  the  operands  are to be combined unless the
<span id="line4140"></span>          order is  changed  by  the  use  of  parentheses.   The
<span id="line4141"></span>          precedence of the logical operators is as follows:
<span id="line4142"></span>
<span id="line4143"></span>8                      ______________________________
<span id="line4144"></span>
<span id="line4145"></span>                          Operator       Precedence
<span id="line4146"></span>8                      ______________________________
<span id="line4147"></span>
<span id="line4148"></span>                            .NOT.        Highest
<span id="line4149"></span>                            .AND.
<span id="line4150"></span>                            .OR.
<span id="line4151"></span>                       .EQV. or .NEQV.   Lowest
<span id="line4152"></span>8                      ______________________________
<span id="line4153"></span>7                     |7|7|7|7|7|7|7|
<span id="line4154"></span>
<span id="line4155"></span>
<span id="line4156"></span>
<span id="line4157"></span>
<span id="line4158"></span>
<span id="line4159"></span>
<span id="line4160"></span>                                      |7|7|7|7|7|7|7|
<span id="line4161"></span>
<span id="line4162"></span>
<span id="line4163"></span>
<span id="line4164"></span>
<span id="line4165"></span>
<span id="line4166"></span>
<span id="line4167"></span>                                                   |7|7|7|7|7|7|7|
<span id="line4168"></span>
<span id="line4169"></span>
<span id="line4170"></span>
<span id="line4171"></span>
<span id="line4172"></span>
<span id="line4173"></span>
<span id="line4174"></span>
<span id="line4175"></span>
<span id="line4176"></span>          For example, in the expression
<span id="line4177"></span>
<span id="line4178"></span>                               A .OR. B .AND. C
<span id="line4179"></span>
<span id="line4180"></span>          the .AND.  operator  has  higher  precedence  than  the
<span id="line4181"></span>          <span class="entity"><span>&amp;</span>amp;</span>'.OR.   operator; therefore, the interpretation of the
<span id="line4182"></span>          above expression is the same as the  interpretation  of
<span id="line4183"></span>          the expression
<span id="line4184"></span>
<span id="line4185"></span>                               A .OR. (B .AND. C)
<span id="line4186"></span>
<span id="line4187"></span>          The logical operands are:
<span id="line4188"></span>
<span id="line4189"></span>             (1) Logical primary
<span id="line4190"></span>
<span id="line4191"></span>             (2) Logical factor
<span id="line4192"></span>
<span id="line4193"></span>             (3) Logical term
<span id="line4194"></span>
<span id="line4195"></span>             (4) Logical disjunct
<span id="line4196"></span>
<span id="line4197"></span>
<span id="line4198"></span>
<span id="line4199"></span>
<span id="line4200"></span>
<span id="line4201"></span>          FORTRAN 77 Full Language                      Page 6-13
<span id="line4202"></span>
<span id="line4203"></span>
<span id="line4204"></span>
<span id="line4205"></span>
<span id="line4206"></span>
<span id="line4207"></span>
<span id="line4208"></span>
<span id="line4209"></span>          EXPRESSIONS                              ANSI X3J3/90.4
<span id="line4210"></span>
<span id="line4211"></span>
<span id="line4212"></span>
<span id="line4213"></span>             (5) Logical expression
<span id="line4214"></span>
<span id="line4215"></span>          The formation rules to be applied in  establishing  the
<span id="line4216"></span>          interpretation  of  a logical expression are in 6.4.2.1
<span id="line4217"></span>          through 6.4.2.5.
<span id="line4218"></span>
<span id="line4219"></span>          6.4.2.1  Logical_Primaries.  The logical primaries are:
<span id="line4220"></span>
<span id="line4221"></span>             (1) Logical constant (4.7.1)
<span id="line4222"></span>
<span id="line4223"></span>             (2) Symbolic name of a logical constant (8.6)
<span id="line4224"></span>
<span id="line4225"></span>             (3) Logical variable reference (2.5)
<span id="line4226"></span>
<span id="line4227"></span>             (4) Logical array element reference (5.3)
<span id="line4228"></span>
<span id="line4229"></span>             (5) Logical function reference (15.2)
<span id="line4230"></span>
<span id="line4231"></span>             (6) Relational expression (6.3)
<span id="line4232"></span>
<span id="line4233"></span>             (7) Logical  expression  enclosed   in   parentheses
<span id="line4234"></span>                 (6.4.2.5)
<span id="line4235"></span>
<span id="line4236"></span>          6.4.2.2  Logical_Factor.  The forms of a logical factor
<span id="line4237"></span>          are:
<span id="line4238"></span>
<span id="line4239"></span>             (1) Logical primary
<span id="line4240"></span>
<span id="line4241"></span>             (2) .NOT. logical primary
<span id="line4242"></span>
<span id="line4243"></span>          6.4.2.3  Logical_Term.  The forms  of  a  logical  term
<span id="line4244"></span>          are:
<span id="line4245"></span>
<span id="line4246"></span>             (1) Logical factor
<span id="line4247"></span>
<span id="line4248"></span>             (2) Logical term .AND. logical factor
<span id="line4249"></span>
<span id="line4250"></span>          Thus, a logical term is a sequence of  logical  factors
<span id="line4251"></span>          separated  by  the  .AND. operator.  Form (2) indicates
<span id="line4252"></span>          that in interpreting a logical term containing  two  or
<span id="line4253"></span>          more .AND.  operators, the logical factors are combined
<span id="line4254"></span>          from left to right.
<span id="line4255"></span>
<span id="line4256"></span>          6.4.2.4  Logical_Disjunct.   The  forms  of  a  logical
<span id="line4257"></span>          disjunct are:
<span id="line4258"></span>
<span id="line4259"></span>             (1) Logical term
<span id="line4260"></span>
<span id="line4261"></span>             (2) Logical disjunct .OR. logical term
<span id="line4262"></span>
<span id="line4263"></span>
<span id="line4264"></span>
<span id="line4265"></span>
<span id="line4266"></span>
<span id="line4267"></span>          FORTRAN 77 Full Language                      Page 6-14
<span id="line4268"></span>
<span id="line4269"></span>
<span id="line4270"></span>
<span id="line4271"></span>
<span id="line4272"></span>
<span id="line4273"></span>
<span id="line4274"></span>
<span id="line4275"></span>          EXPRESSIONS                              ANSI X3J3/90.4
<span id="line4276"></span>
<span id="line4277"></span>
<span id="line4278"></span>
<span id="line4279"></span>          Thus, a logical disjunct is a sequence of logical terms
<span id="line4280"></span>          separated  by  the  .OR.  operator.  Form (2) indicates
<span id="line4281"></span>          that in interpreting a logical disjunct containing  two
<span id="line4282"></span>          or  more .OR. operators, the logical terms are combined
<span id="line4283"></span>          from left to right.
<span id="line4284"></span>
<span id="line4285"></span>          6.4.2.5  Logical_Expression.  The forms  of  a  logical
<span id="line4286"></span>          expression are:
<span id="line4287"></span>
<span id="line4288"></span>             (1) Logical disjunct
<span id="line4289"></span>
<span id="line4290"></span>             (2) Logical expression .EQV. logical disjunct
<span id="line4291"></span>
<span id="line4292"></span>             (3) Logical expression .NEQV. logical disjunct
<span id="line4293"></span>
<span id="line4294"></span>          Thus, a logical expression is  a  sequence  of  logical
<span id="line4295"></span>          disjuncts separated by either the .EQV. operator or the
<span id="line4296"></span>          .NEQV. operator.  Forms (2) and (3)  indicate  that  in
<span id="line4297"></span>          interpreting  a  logical  expression  containing two or
<span id="line4298"></span>          more .EQV. or .NEQV. operators, the  logical  disjuncts
<span id="line4299"></span>          are combined from left to right.
<span id="line4300"></span>
<span id="line4301"></span>          6.4.3  Value of Logical Factors, Terms, Disjuncts,  and
<span id="line4302"></span>          Expressions.   The  value of a logical factor involving
<span id="line4303"></span>          .NOT. is shown below:
<span id="line4304"></span>
<span id="line4305"></span>8                            __________________
<span id="line4306"></span>
<span id="line4307"></span>                              x928     .NOT. x92
<span id="line4308"></span>7                            __________________
<span id="line4309"></span>
<span id="line4310"></span>                             true     false
<span id="line4311"></span>                             false    true
<span id="line4312"></span>8                            __________________
<span id="line4313"></span>7                           |7|7|7|7|7|
<span id="line4314"></span>
<span id="line4315"></span>
<span id="line4316"></span>
<span id="line4317"></span>
<span id="line4318"></span>                                  |7|7|7|7|7|
<span id="line4319"></span>
<span id="line4320"></span>
<span id="line4321"></span>
<span id="line4322"></span>
<span id="line4323"></span>                                             |7|7|7|7|7|
<span id="line4324"></span>
<span id="line4325"></span>
<span id="line4326"></span>
<span id="line4327"></span>
<span id="line4328"></span>
<span id="line4329"></span>
<span id="line4330"></span>          The value of a logical term involving  .AND.  is  shown
<span id="line4331"></span>          below:
<span id="line4332"></span>
<span id="line4333"></span>8                       _____________________________
<span id="line4334"></span>
<span id="line4335"></span>                         x918      x928     x918 .AND. x92
<span id="line4336"></span>7                       _____________________________
<span id="line4337"></span>
<span id="line4338"></span>                        true    true       true
<span id="line4339"></span>                        true    false      false
<span id="line4340"></span>                        false   true       false
<span id="line4341"></span>                        false   false      false
<span id="line4342"></span>8                       _____________________________
<span id="line4343"></span>7                      |7|7|7|7|7|7|7|
<span id="line4344"></span>
<span id="line4345"></span>
<span id="line4346"></span>
<span id="line4347"></span>
<span id="line4348"></span>
<span id="line4349"></span>
<span id="line4350"></span>                             |7|7|7|7|7|7|7|
<span id="line4351"></span>
<span id="line4352"></span>
<span id="line4353"></span>
<span id="line4354"></span>
<span id="line4355"></span>
<span id="line4356"></span>
<span id="line4357"></span>                                     |7|7|7|7|7|7|7|
<span id="line4358"></span>
<span id="line4359"></span>
<span id="line4360"></span>
<span id="line4361"></span>
<span id="line4362"></span>
<span id="line4363"></span>
<span id="line4364"></span>                                                   |7|7|7|7|7|7|7|
<span id="line4365"></span>
<span id="line4366"></span>
<span id="line4367"></span>
<span id="line4368"></span>
<span id="line4369"></span>
<span id="line4370"></span>
<span id="line4371"></span>
<span id="line4372"></span>
<span id="line4373"></span>          The value of a logical disjunct involving .OR. is shown
<span id="line4374"></span>          below:
<span id="line4375"></span>
<span id="line4376"></span>
<span id="line4377"></span>
<span id="line4378"></span>
<span id="line4379"></span>
<span id="line4380"></span>
<span id="line4381"></span>          FORTRAN 77 Full Language                      Page 6-15
<span id="line4382"></span>
<span id="line4383"></span>
<span id="line4384"></span>
<span id="line4385"></span>
<span id="line4386"></span>
<span id="line4387"></span>
<span id="line4388"></span>
<span id="line4389"></span>          EXPRESSIONS                              ANSI X3J3/90.4
<span id="line4390"></span>
<span id="line4391"></span>
<span id="line4392"></span>
<span id="line4393"></span>8                       ____________________________
<span id="line4394"></span>
<span id="line4395"></span>                         x918      x928     x918 .OR. x92
<span id="line4396"></span>7                       ____________________________
<span id="line4397"></span>
<span id="line4398"></span>                        true    true      true
<span id="line4399"></span>                        true    false     true
<span id="line4400"></span>                        false   true      true
<span id="line4401"></span>                        false   false     false
<span id="line4402"></span>8                       ____________________________
<span id="line4403"></span>7                      |7|7|7|7|7|7|7|
<span id="line4404"></span>
<span id="line4405"></span>
<span id="line4406"></span>
<span id="line4407"></span>
<span id="line4408"></span>
<span id="line4409"></span>
<span id="line4410"></span>                             |7|7|7|7|7|7|7|
<span id="line4411"></span>
<span id="line4412"></span>
<span id="line4413"></span>
<span id="line4414"></span>
<span id="line4415"></span>
<span id="line4416"></span>
<span id="line4417"></span>                                     |7|7|7|7|7|7|7|
<span id="line4418"></span>
<span id="line4419"></span>
<span id="line4420"></span>
<span id="line4421"></span>
<span id="line4422"></span>
<span id="line4423"></span>
<span id="line4424"></span>                                                  |7|7|7|7|7|7|7|
<span id="line4425"></span>
<span id="line4426"></span>
<span id="line4427"></span>
<span id="line4428"></span>
<span id="line4429"></span>
<span id="line4430"></span>
<span id="line4431"></span>
<span id="line4432"></span>
<span id="line4433"></span>          The value of a logical expression  involving  .EQV.  is
<span id="line4434"></span>          shown below:
<span id="line4435"></span>
<span id="line4436"></span>8                       _____________________________
<span id="line4437"></span>
<span id="line4438"></span>                         x918      x928     x918 .EQV. x92
<span id="line4439"></span>7                       _____________________________
<span id="line4440"></span>
<span id="line4441"></span>                        true    true       true
<span id="line4442"></span>                        true    false      false
<span id="line4443"></span>                        false   true       false
<span id="line4444"></span>                        false   false      true
<span id="line4445"></span>8                       _____________________________
<span id="line4446"></span>7                      |7|7|7|7|7|7|7|
<span id="line4447"></span>
<span id="line4448"></span>
<span id="line4449"></span>
<span id="line4450"></span>
<span id="line4451"></span>
<span id="line4452"></span>
<span id="line4453"></span>                             |7|7|7|7|7|7|7|
<span id="line4454"></span>
<span id="line4455"></span>
<span id="line4456"></span>
<span id="line4457"></span>
<span id="line4458"></span>
<span id="line4459"></span>
<span id="line4460"></span>                                     |7|7|7|7|7|7|7|
<span id="line4461"></span>
<span id="line4462"></span>
<span id="line4463"></span>
<span id="line4464"></span>
<span id="line4465"></span>
<span id="line4466"></span>
<span id="line4467"></span>                                                   |7|7|7|7|7|7|7|
<span id="line4468"></span>
<span id="line4469"></span>
<span id="line4470"></span>
<span id="line4471"></span>
<span id="line4472"></span>
<span id="line4473"></span>
<span id="line4474"></span>
<span id="line4475"></span>
<span id="line4476"></span>          The value of a logical expression involving  .NEQV.  is
<span id="line4477"></span>          shown below:
<span id="line4478"></span>
<span id="line4479"></span>8                      ______________________________
<span id="line4480"></span>
<span id="line4481"></span>                        x918      x928     x918 .NEQV. x92
<span id="line4482"></span>7                      ______________________________
<span id="line4483"></span>
<span id="line4484"></span>                       true    true       false
<span id="line4485"></span>                       true    false      true
<span id="line4486"></span>                       false   true       true
<span id="line4487"></span>                       false   false      false
<span id="line4488"></span>8                      ______________________________
<span id="line4489"></span>7                     |7|7|7|7|7|7|7|
<span id="line4490"></span>
<span id="line4491"></span>
<span id="line4492"></span>
<span id="line4493"></span>
<span id="line4494"></span>
<span id="line4495"></span>
<span id="line4496"></span>                            |7|7|7|7|7|7|7|
<span id="line4497"></span>
<span id="line4498"></span>
<span id="line4499"></span>
<span id="line4500"></span>
<span id="line4501"></span>
<span id="line4502"></span>
<span id="line4503"></span>                                    |7|7|7|7|7|7|7|
<span id="line4504"></span>
<span id="line4505"></span>
<span id="line4506"></span>
<span id="line4507"></span>
<span id="line4508"></span>
<span id="line4509"></span>
<span id="line4510"></span>                                                   |7|7|7|7|7|7|7|
<span id="line4511"></span>
<span id="line4512"></span>
<span id="line4513"></span>
<span id="line4514"></span>
<span id="line4515"></span>
<span id="line4516"></span>
<span id="line4517"></span>
<span id="line4518"></span>
<span id="line4519"></span>          6.4.4  Logical_Constant_Expression.  A logical constant
<span id="line4520"></span>          expression  is  a  logical  expression  in  which  each
<span id="line4521"></span>          primary is a logical constant, the symbolic name  of  a
<span id="line4522"></span>          logical constant, a relational expression in which each
<span id="line4523"></span>          primary is a constant expression, or a logical constant
<span id="line4524"></span>          expression   enclosed   in   parentheses.    Note  that
<span id="line4525"></span>          variable, array element, and  function  references  are
<span id="line4526"></span>          not allowed.
<span id="line4527"></span>
<span id="line4528"></span>          6.5  Precedence_of_Operators
<span id="line4529"></span>
<span id="line4530"></span>          In 6.1.2 and 6.4.2 precedences  have  been  established
<span id="line4531"></span>          among   the   arithmetic   operators  and  the  logical
<span id="line4532"></span>          operators, respectively.  There is only  one  character
<span id="line4533"></span>          operator.  No precedence has been established among the
<span id="line4534"></span>          relational operators. The precedences among the various
<span id="line4535"></span>          operators are:
<span id="line4536"></span>
<span id="line4537"></span>9
<span id="line4538"></span>          FORTRAN 77 Full Language                      Page 6-16
<span id="line4539"></span>
<span id="line4540"></span>
<span id="line4541"></span>
<span id="line4542"></span>
<span id="line4543"></span>
<span id="line4544"></span>
<span id="line4545"></span>
<span id="line4546"></span>          EXPRESSIONS                              ANSI X3J3/90.4
<span id="line4547"></span>
<span id="line4548"></span>
<span id="line4549"></span>
<span id="line4550"></span>8                         _________________________
<span id="line4551"></span>
<span id="line4552"></span>                          Operator     Precedence
<span id="line4553"></span>8                         _________________________
<span id="line4554"></span>
<span id="line4555"></span>                          Arithmetic   Highest
<span id="line4556"></span>                          Character
<span id="line4557"></span>                          Relational
<span id="line4558"></span>                          Logical      Lowest
<span id="line4559"></span>8                         _________________________
<span id="line4560"></span>7                        |7|7|7|7|7|7|7|
<span id="line4561"></span>
<span id="line4562"></span>
<span id="line4563"></span>
<span id="line4564"></span>
<span id="line4565"></span>
<span id="line4566"></span>
<span id="line4567"></span>                                    |7|7|7|7|7|7|7|
<span id="line4568"></span>
<span id="line4569"></span>
<span id="line4570"></span>
<span id="line4571"></span>
<span id="line4572"></span>
<span id="line4573"></span>
<span id="line4574"></span>                                                 |7|7|7|7|7|7|7|
<span id="line4575"></span>
<span id="line4576"></span>
<span id="line4577"></span>
<span id="line4578"></span>
<span id="line4579"></span>
<span id="line4580"></span>
<span id="line4581"></span>
<span id="line4582"></span>
<span id="line4583"></span>          An  expression  may  contain  more  than  one  kind  of
<span id="line4584"></span>          operator.  For example, the logical expression
<span id="line4585"></span>
<span id="line4586"></span>                               L .OR. A + B .GE. C
<span id="line4587"></span>
<span id="line4588"></span>          where A, B, and C are of type real, and L  is  of  type
<span id="line4589"></span>          logical,  contains an arithmetic operator, a relational
<span id="line4590"></span>          operator, and  a  logical  operator.   This  expression
<span id="line4591"></span>          would be interpreted the same as the expression
<span id="line4592"></span>
<span id="line4593"></span>                               L .OR. ((A + B) .GE. C)
<span id="line4594"></span>
<span id="line4595"></span>          6.5.1  Summary_of_Interpretation_Rules.  The  order  in
<span id="line4596"></span>          which   primaries   are  combined  using  operators  is
<span id="line4597"></span>          determined by the following:
<span id="line4598"></span>
<span id="line4599"></span>             (1) Use of parentheses
<span id="line4600"></span>
<span id="line4601"></span>             (2) Precedence of the operators
<span id="line4602"></span>
<span id="line4603"></span>             (3) Right-to-left interpretation of  exponentiations
<span id="line4604"></span>                 in a factor
<span id="line4605"></span>
<span id="line4606"></span>             (4) Left-to-right interpretation of  multiplications
<span id="line4607"></span>                 and divisions in a term
<span id="line4608"></span>
<span id="line4609"></span>             (5) Left-to-right interpretation  of  additions  and
<span id="line4610"></span>                 subtractions in an arithmetic expression
<span id="line4611"></span>
<span id="line4612"></span>             (6) Left-to-right interpretation  of  concatenations
<span id="line4613"></span>                 in a character expression
<span id="line4614"></span>
<span id="line4615"></span>             (7) Left-to-right interpretation of conjunctions  in
<span id="line4616"></span>                 a logical term
<span id="line4617"></span>
<span id="line4618"></span>             (8) Left-to-right interpretation of disjunctions  in
<span id="line4619"></span>                 a logical disjunct
<span id="line4620"></span>
<span id="line4621"></span>             (9) Left-to-right    interpretation    of    logical
<span id="line4622"></span>                 equivalences in a logical expression
<span id="line4623"></span>
<span id="line4624"></span>9
<span id="line4625"></span>
<span id="line4626"></span>
<span id="line4627"></span>          FORTRAN 77 Full Language                      Page 6-17
<span id="line4628"></span>
<span id="line4629"></span>
<span id="line4630"></span>
<span id="line4631"></span>
<span id="line4632"></span>
<span id="line4633"></span>
<span id="line4634"></span>
<span id="line4635"></span>          EXPRESSIONS                              ANSI X3J3/90.4
<span id="line4636"></span>
<span id="line4637"></span>
<span id="line4638"></span>
<span id="line4639"></span>          6.6  Evaluation_of_Expressions
<span id="line4640"></span>
<span id="line4641"></span>          This  section   applies   to   arithmetic,   character,
<span id="line4642"></span>          relational, and logical expressions.
<span id="line4643"></span>
<span id="line4644"></span>          Any variable, array  element,  function,  or  character
<span id="line4645"></span>          substring  referenced  as  an  operand in an expression
<span id="line4646"></span>          must be defined at the time the reference is  executed.
<span id="line4647"></span>          An  integer  operand  must  be  defined with an integer
<span id="line4648"></span>          value rather than a statement label value.   Note  that
<span id="line4649"></span>          if  a  character string or substring is referenced, all
<span id="line4650"></span>          of the referenced characters must  be  defined  at  the
<span id="line4651"></span>          time the reference is executed.
<span id="line4652"></span>
<span id="line4653"></span>          Any  arithmetic   operation   whose   result   is   not
<span id="line4654"></span>          mathematically  defined  is prohibited in the execution
<span id="line4655"></span>          of an executable program.   Examples  are  dividing  by
<span id="line4656"></span>          zero  and  raising  a  zero-  valued primary to a zero-
<span id="line4657"></span>          valued or negative-valued power.  Raising  a  negative-
<span id="line4658"></span>          valued  primary  to a real or double precision power is
<span id="line4659"></span>          also prohibited.
<span id="line4660"></span>
<span id="line4661"></span>          The execution of a function reference  in  a  statement
<span id="line4662"></span>          may  not alter the value of any other entity within the
<span id="line4663"></span>          statement in which the function reference appears.  The
<span id="line4664"></span>          execution  of  a  function reference in a statement may
<span id="line4665"></span>          not alter the value of any entity in common (8.3)  that
<span id="line4666"></span>          affects  the  value  of any other function reference in
<span id="line4667"></span>          that  statement.   However,  execution  of  a  function
<span id="line4668"></span>          reference in the expression e_ of a logical IF statement
<span id="line4669"></span>          (11.5) is permitted to affect entities in the statement
<span id="line4670"></span>          st__ that is executed when the value of the expression e_
<span id="line4671"></span>          is true.  If a function reference causes definition  of
<span id="line4672"></span>          an  actual  argument  of the function, that argument or
<span id="line4673"></span>          any associated entities must not  appear  elsewhere  in
<span id="line4674"></span>          the same statement. For example, the statements
<span id="line4675"></span>
<span id="line4676"></span>                               A(I) = F(I)
<span id="line4677"></span>
<span id="line4678"></span>                               Y = G(X) + X
<span id="line4679"></span>
<span id="line4680"></span>          are prohibited if the reference to F defines I  or  the
<span id="line4681"></span>          reference to G defines X.
<span id="line4682"></span>
<span id="line4683"></span>          The data type of an  expression  in  which  a  function
<span id="line4684"></span>          reference appears does not affect the evaluation of the
<span id="line4685"></span>          actual arguments of the function.  The data type of  an
<span id="line4686"></span>          expression in which a function reference appears is not
<span id="line4687"></span>          affected by the evaluation of the actual  arguments  of
<span id="line4688"></span>          the  function,  except  that  the  result  of a generic
<span id="line4689"></span>          function reference assumes a data type that depends  on
<span id="line4690"></span>
<span id="line4691"></span>
<span id="line4692"></span>
<span id="line4693"></span>          FORTRAN 77 Full Language                      Page 6-18
<span id="line4694"></span>
<span id="line4695"></span>
<span id="line4696"></span>
<span id="line4697"></span>
<span id="line4698"></span>
<span id="line4699"></span>
<span id="line4700"></span>
<span id="line4701"></span>          EXPRESSIONS                              ANSI X3J3/90.4
<span id="line4702"></span>
<span id="line4703"></span>
<span id="line4704"></span>
<span id="line4705"></span>          the data type of its arguments as specified in 15.10.
<span id="line4706"></span>
<span id="line4707"></span>          Any execution of an array  element  reference  requires
<span id="line4708"></span>          the  evaluation  of its subscript.  The data type of an
<span id="line4709"></span>          expression  in  which  a  subscript  appears  does  not
<span id="line4710"></span>          affect,  nor  is  it affected by, the evaluation of the
<span id="line4711"></span>          subscript.
<span id="line4712"></span>
<span id="line4713"></span>          Any execution of a  substring  reference  requires  the
<span id="line4714"></span>          evaluation of its substring expressions.  The data type
<span id="line4715"></span>          of an expression in which a substring name appears does
<span id="line4716"></span>          not  affect,  nor  is it affected by, the evaluation of
<span id="line4717"></span>          the substring expressions.
<span id="line4718"></span>
<span id="line4719"></span>          6.6.1  Evaluation_of_Operands.  It is not necessary for
<span id="line4720"></span>          a  processor  to  evaluate  all  of  the operands of an
<span id="line4721"></span>          expression if  the  value  of  the  expression  can  be
<span id="line4722"></span>          determined  otherwise.   This  principle  is most often
<span id="line4723"></span>          applicable to logical express(ions, but it  applies  to
<span id="line4724"></span>          all   expressions.   For  example,  in  evaluating  the
<span id="line4725"></span>          logical expression
<span id="line4726"></span>
<span id="line4727"></span>                               X .GT. Y .OR. L(Z)
<span id="line4728"></span>
<span id="line4729"></span>          where X, Y,  and  Z  are  real,  and  L  is  a  logical
<span id="line4730"></span>          function,  the  function  reference  L(Z)  need  not be
<span id="line4731"></span>          evaluated if X is  greater  than  Y.   If  a  statement
<span id="line4732"></span>          contains   a   function  reference  in  a  part  of  an
<span id="line4733"></span>          expression that need not  be  evaluated,  all  entities
<span id="line4734"></span>          that would have become defined in the execution of that
<span id="line4735"></span>          reference  become  undefined  at  the   completion   of
<span id="line4736"></span>          evaluation  of  the  expression containing the function
<span id="line4737"></span>          reference.  In the example  above,  evaluation  of  the
<span id="line4738"></span>          expression  causes  Z  to become undefined if L defines
<span id="line4739"></span>          its argument.
<span id="line4740"></span>
<span id="line4741"></span>          6.6.2  Order_of_Evaluation_of_Functions.      If      a
<span id="line4742"></span>          statement  contains more than one function reference, a
<span id="line4743"></span>          processor may evaluate  the  functions  in  any  order,
<span id="line4744"></span>          except  for  a  logical  IF  statement  and  a function
<span id="line4745"></span>          argument  list  containing  function  references.   For
<span id="line4746"></span>          example, the statement
<span id="line4747"></span>
<span id="line4748"></span>                               Y = F(G(X))
<span id="line4749"></span>
<span id="line4750"></span>          where F and G are functions, requires G to be evaluated
<span id="line4751"></span>          before F is evaluated.
<span id="line4752"></span>
<span id="line4753"></span>          In a statement that contains  more  than  one  function
<span id="line4754"></span>          reference,   the   value   provided  by  each  function
<span id="line4755"></span>          reference must be independent of the  order  chosen  by
<span id="line4756"></span>
<span id="line4757"></span>
<span id="line4758"></span>
<span id="line4759"></span>          FORTRAN 77 Full Language                      Page 6-19
<span id="line4760"></span>
<span id="line4761"></span>
<span id="line4762"></span>
<span id="line4763"></span>
<span id="line4764"></span>
<span id="line4765"></span>
<span id="line4766"></span>
<span id="line4767"></span>          EXPRESSIONS                              ANSI X3J3/90.4
<span id="line4768"></span>
<span id="line4769"></span>
<span id="line4770"></span>
<span id="line4771"></span>          the   processor   for   evaluation   of   the  function
<span id="line4772"></span>          references.
<span id="line4773"></span>
<span id="line4774"></span>          6.6.3  Integrity_of_Parentheses.   The  sections   that
<span id="line4775"></span>          follow state certain conditions under which a processor
<span id="line4776"></span>          may evaluate  an  expression  different  from  the  one
<span id="line4777"></span>          obtained  by applying the interpretation rules given in
<span id="line4778"></span>          6.1 through 6.5.  However, any expression contained  in
<span id="line4779"></span>          parentheses must be treated as an entity.  For example,
<span id="line4780"></span>          in evaluating the expression A*(B*C), the product of  B
<span id="line4781"></span>          and  C  must be evaluated and then multiplied by A; the
<span id="line4782"></span>          processor  must   not   evaluate   the   mathematically
<span id="line4783"></span>          equivalent expression (A*B)*C.
<span id="line4784"></span>
<span id="line4785"></span>          6.6.4  Evaluation_of_Arithmetic_Expressions.  The rules
<span id="line4786"></span>          given   in  6.1.2  specify  the  interpretation  of  an
<span id="line4787"></span>          arithmetic expression.   Once  the  interpretation  has
<span id="line4788"></span>          been  established  in  accordance with those rules, the
<span id="line4789"></span>          processor may evaluate  any  mathematically  equivalent
<span id="line4790"></span>          expression,  provided that the integrity of parentheses
<span id="line4791"></span>          is not violated.
<span id="line4792"></span>
<span id="line4793"></span>          Two   arithmetic   expressions    are    mathematically
<span id="line4794"></span>          equivalent   if,  for  all  possible  values  of  their
<span id="line4795"></span>          primaries,  their  mathematical   values   are   equal.
<span id="line4796"></span>          However,     mathematically    equivalent    arithmetic
<span id="line4797"></span>          expressions   may   produce   different   computational
<span id="line4798"></span>          results.
<span id="line4799"></span>
<span id="line4800"></span>          The mathematical  definition  of  integer  division  is
<span id="line4801"></span>          given  in  6.1.5.   The difference between the value of
<span id="line4802"></span>          the  expression  5/2  and  5./2.  is   a   mathematical
<span id="line4803"></span>          difference, not a computational difference.
<span id="line4804"></span>
<span id="line4805"></span>          The following are examples of expressions,  along  with
<span id="line4806"></span>          allowable  alternative  forms  that  may be used by the
<span id="line4807"></span>          processor in the evaluation of those  expressions.   A,
<span id="line4808"></span>          B, and C represent arbitrary real, double precision, or
<span id="line4809"></span>          complex operands; I and J represent  arbitrary  integer
<span id="line4810"></span>          operands;   and   X,   Y,  and  Z  represent  arbitrary
<span id="line4811"></span>          arithmetic operands.   (Note  that  Table  2  prohibits
<span id="line4812"></span>          combinations  of  double  precision  and  complex  data
<span id="line4813"></span>          types.)
<span id="line4814"></span>
<span id="line4815"></span>
<span id="line4816"></span>
<span id="line4817"></span>
<span id="line4818"></span>
<span id="line4819"></span>
<span id="line4820"></span>
<span id="line4821"></span>
<span id="line4822"></span>
<span id="line4823"></span>
<span id="line4824"></span>
<span id="line4825"></span>          FORTRAN 77 Full Language                      Page 6-20
<span id="line4826"></span>
<span id="line4827"></span>
<span id="line4828"></span>
<span id="line4829"></span>
<span id="line4830"></span>
<span id="line4831"></span>
<span id="line4832"></span>
<span id="line4833"></span>          EXPRESSIONS                              ANSI X3J3/90.4
<span id="line4834"></span>
<span id="line4835"></span>
<span id="line4836"></span>
<span id="line4837"></span>8                 _________________________________________
<span id="line4838"></span>
<span id="line4839"></span>                  Expression   Allowable Alternative Form
<span id="line4840"></span>8                 _________________________________________
<span id="line4841"></span>
<span id="line4842"></span>                  X+Y          Y+X
<span id="line4843"></span>                  X*Y          Y*X
<span id="line4844"></span>                  -X+Y         Y-X
<span id="line4845"></span>                  X+Y+Z        X+(Y+Z)
<span id="line4846"></span>                  X-Y+Z        X-(Y-Z)
<span id="line4847"></span>                  X*B/Z        X*(B/Z)
<span id="line4848"></span>                  X*Y-X*Z      X*(Y-Z)
<span id="line4849"></span>                  A/B/C        A/(B*C)
<span id="line4850"></span>                  A/5.0        0.2*A
<span id="line4851"></span>8                 _________________________________________
<span id="line4852"></span>7                |7|7|7|7|7|7|7|7|7|7|7|7|
<span id="line4853"></span>
<span id="line4854"></span>
<span id="line4855"></span>
<span id="line4856"></span>
<span id="line4857"></span>
<span id="line4858"></span>
<span id="line4859"></span>
<span id="line4860"></span>
<span id="line4861"></span>
<span id="line4862"></span>
<span id="line4863"></span>
<span id="line4864"></span>                            |7|7|7|7|7|7|7|7|7|7|7|7|
<span id="line4865"></span>
<span id="line4866"></span>
<span id="line4867"></span>
<span id="line4868"></span>
<span id="line4869"></span>
<span id="line4870"></span>
<span id="line4871"></span>
<span id="line4872"></span>
<span id="line4873"></span>
<span id="line4874"></span>
<span id="line4875"></span>
<span id="line4876"></span>                                                         |7|7|7|7|7|7|7|7|7|7|7|7|
<span id="line4877"></span>
<span id="line4878"></span>
<span id="line4879"></span>
<span id="line4880"></span>
<span id="line4881"></span>
<span id="line4882"></span>
<span id="line4883"></span>
<span id="line4884"></span>
<span id="line4885"></span>
<span id="line4886"></span>
<span id="line4887"></span>
<span id="line4888"></span>
<span id="line4889"></span>
<span id="line4890"></span>          The following are examples of  expressions  along  with
<span id="line4891"></span>          forbidden  forms that must not be used by the processor
<span id="line4892"></span>          in the evaluation of those expressions.
<span id="line4893"></span>
<span id="line4894"></span>8                 ________________________________________
<span id="line4895"></span>
<span id="line4896"></span>                  Expression    Nonallowable Alternative
<span id="line4897"></span>                                          Form
<span id="line4898"></span>8                 ________________________________________
<span id="line4899"></span>
<span id="line4900"></span>                  I/2           0.5*I
<span id="line4901"></span>                  X*I/J         X*(I/J)
<span id="line4902"></span>                  I/J/A         I/(J*A)
<span id="line4903"></span>                  (X*Y)-(X*Z)   X*(Y-Z)
<span id="line4904"></span>                  X*(Y-Z)       X*Y-X*Z
<span id="line4905"></span>8                 ________________________________________
<span id="line4906"></span>7                |7|7|7|7|7|7|7|7|7|
<span id="line4907"></span>
<span id="line4908"></span>
<span id="line4909"></span>
<span id="line4910"></span>
<span id="line4911"></span>
<span id="line4912"></span>
<span id="line4913"></span>
<span id="line4914"></span>
<span id="line4915"></span>                             |7|7|7|7|7|7|7|7|7|
<span id="line4916"></span>
<span id="line4917"></span>
<span id="line4918"></span>
<span id="line4919"></span>
<span id="line4920"></span>
<span id="line4921"></span>
<span id="line4922"></span>
<span id="line4923"></span>
<span id="line4924"></span>                                                        |7|7|7|7|7|7|7|7|7|
<span id="line4925"></span>
<span id="line4926"></span>
<span id="line4927"></span>
<span id="line4928"></span>
<span id="line4929"></span>
<span id="line4930"></span>
<span id="line4931"></span>
<span id="line4932"></span>
<span id="line4933"></span>
<span id="line4934"></span>
<span id="line4935"></span>          In addition to the parentheses  required  to  establish
<span id="line4936"></span>          the desired interpretation, parentheses may be included
<span id="line4937"></span>          to restrict the alternative forms that may be  used  by
<span id="line4938"></span>          the   processor   in   the  actual  evaluation  of  the
<span id="line4939"></span>          expression.   This  is  useful  for   controlling   the
<span id="line4940"></span>          magnitude and accuracy of intermediate values developed
<span id="line4941"></span>          during the evaluation of an expression.   For  example,
<span id="line4942"></span>          in the expression
<span id="line4943"></span>
<span id="line4944"></span>                               A+(B-C)
<span id="line4945"></span>
<span id="line4946"></span>          the term (B-C) must be evaluated and then added  to  A.
<span id="line4947"></span>          Note  that  the inclusion of parentheses may change the
<span id="line4948"></span>          mathematical value of an expression.  For example,  the
<span id="line4949"></span>          two expressions:
<span id="line4950"></span>
<span id="line4951"></span>                               A*I/J
<span id="line4952"></span>
<span id="line4953"></span>                               A*(I/J)
<span id="line4954"></span>
<span id="line4955"></span>          may have different mathematical values if I and  J  are
<span id="line4956"></span>
<span id="line4957"></span>
<span id="line4958"></span>
<span id="line4959"></span>          FORTRAN 77 Full Language                      Page 6-21
<span id="line4960"></span>
<span id="line4961"></span>
<span id="line4962"></span>
<span id="line4963"></span>
<span id="line4964"></span>
<span id="line4965"></span>
<span id="line4966"></span>
<span id="line4967"></span>          EXPRESSIONS                              ANSI X3J3/90.4
<span id="line4968"></span>
<span id="line4969"></span>
<span id="line4970"></span>
<span id="line4971"></span>          factors of integer data type.
<span id="line4972"></span>
<span id="line4973"></span>          Each operand of an arithmetic operator has a data  type
<span id="line4974"></span>          that  may depend on the order of evaluation used by the
<span id="line4975"></span>          processor.  For  example,  in  the  evaluation  of  the
<span id="line4976"></span>          expression
<span id="line4977"></span>
<span id="line4978"></span>                               D+R+I
<span id="line4979"></span>
<span id="line4980"></span>          where D, R, and I represent terms of double  precision,
<span id="line4981"></span>          real,  and  integer  data  type, respectively, the data
<span id="line4982"></span>          type of the operand that is added to I  may  be  either
<span id="line4983"></span>          double  precision  or  real, depending on which pair of
<span id="line4984"></span>          operands (D and R, R and I, or D and I) is added first.
<span id="line4985"></span>
<span id="line4986"></span>          6.6.5  Evaluation_of_Character_Expressions.  The  rules
<span id="line4987"></span>          given   in   6.2.2  specify  the  interpretation  of  a
<span id="line4988"></span>          character expression as  a  string  of  characters.   A
<span id="line4989"></span>          processor  needs  to  evaluate  only  as  much  of  the
<span id="line4990"></span>          character expression as is required by the  context  in
<span id="line4991"></span>          which   the   expression  appears.   For  example,  the
<span id="line4992"></span>          statements
<span id="line4993"></span>
<span id="line4994"></span>                     CHARACTER*2 C1,C2,C3,CF
<span id="line4995"></span>                     C1 = C2 // CF(C3)
<span id="line4996"></span>
<span id="line4997"></span>          do not require the function CF to be evaluated, because
<span id="line4998"></span>          only  the  value of C2 is needed to determine the value
<span id="line4999"></span>          of C1.
<span id="line5000"></span>
<span id="line5001"></span>          6.6.6  Evaluation_of_Relational_Expressions.  The rules
<span id="line5002"></span>          given  in 6.3.3 and 6.3.5 specify the interpretation of
<span id="line5003"></span>          relational expressions.  Once the interpretation of  an
<span id="line5004"></span>          expression  has  been  established  in  accordance with
<span id="line5005"></span>          those rules,  the  processor  may  evaluate  any  other
<span id="line5006"></span>          expression   that   is  relationally  equivalent.   For
<span id="line5007"></span>          example, the  processor  may  choose  to  evaluate  the
<span id="line5008"></span>          relational expression
<span id="line5009"></span>
<span id="line5010"></span>                               I .GT. J
<span id="line5011"></span>
<span id="line5012"></span>          where I and J are integer variables, as
<span id="line5013"></span>
<span id="line5014"></span>                               J - I .LT. 0
<span id="line5015"></span>
<span id="line5016"></span>          Two relational expressions are relationally  equivalent
<span id="line5017"></span>          if  their  logical  values  are  equal for all possible
<span id="line5018"></span>          values of their primaries.
<span id="line5019"></span>
<span id="line5020"></span>
<span id="line5021"></span>
<span id="line5022"></span>
<span id="line5023"></span>
<span id="line5024"></span>
<span id="line5025"></span>          FORTRAN 77 Full Language                      Page 6-22
<span id="line5026"></span>
<span id="line5027"></span>
<span id="line5028"></span>
<span id="line5029"></span>
<span id="line5030"></span>
<span id="line5031"></span>
<span id="line5032"></span>
<span id="line5033"></span>          EXPRESSIONS                              ANSI X3J3/90.4
<span id="line5034"></span>
<span id="line5035"></span>
<span id="line5036"></span>
<span id="line5037"></span>          6.6.7  Evaluation_of_Logical_Expressions.   The   rules
<span id="line5038"></span>          given  in 6.4.2 specify the interpretation of a logical
<span id="line5039"></span>          expression.  Once the interpretation of  an  expression
<span id="line5040"></span>          has  been  established  in accordance with those rules,
<span id="line5041"></span>          the processor may evaluate any other expression that is
<span id="line5042"></span>          logically  equivalent,  provided  that the integrity of
<span id="line5043"></span>          parentheses  is  not  violated.    For   example,   the
<span id="line5044"></span>          processor may choose to evaluate the logical expression
<span id="line5045"></span>
<span id="line5046"></span>                               L1 .AND. L2 .AND. L3
<span id="line5047"></span>
<span id="line5048"></span>          where L1, L2, and L3 are logical variables, as
<span id="line5049"></span>
<span id="line5050"></span>                               L1 .AND. (L2 .AND. L3)
<span id="line5051"></span>
<span id="line5052"></span>          Two logical expressions  are  logically  equivalent  if
<span id="line5053"></span>          their values are equal for all possible values of their
<span id="line5054"></span>          primaries.
<span id="line5055"></span>
<span id="line5056"></span>          6.7  Constant_Expressions
<span id="line5057"></span>
<span id="line5058"></span>          A  constant  expression  is  an   arithmetic   constant
<span id="line5059"></span>          expression  (6.1.3),  a  character  constant expression
<span id="line5060"></span>          (6.2.3), or a logical constant expression (6.4.4).
<span id="line5061"></span>
<span id="line5062"></span>
<span id="line5063"></span>
<span id="line5064"></span>
<span id="line5065"></span>
<span id="line5066"></span>
<span id="line5067"></span>
<span id="line5068"></span>
<span id="line5069"></span>
<span id="line5070"></span>
<span id="line5071"></span>
<span id="line5072"></span>
<span id="line5073"></span>
<span id="line5074"></span>
<span id="line5075"></span>
<span id="line5076"></span>
<span id="line5077"></span>
<span id="line5078"></span>
<span id="line5079"></span>
<span id="line5080"></span>
<span id="line5081"></span>
<span id="line5082"></span>
<span id="line5083"></span>
<span id="line5084"></span>
<span id="line5085"></span>
<span id="line5086"></span>
<span id="line5087"></span>
<span id="line5088"></span>
<span id="line5089"></span>
<span id="line5090"></span>
<span id="line5091"></span>          FORTRAN 77 Full Language                      Page 6-23
<span id="line5092"></span>
<span id="line5093"></span>
<span id="line5094"></span>
<span id="line5095"></span>
<span id="line5096"></span>
<span id="line5097"></span>
<span id="line5098"></span>
<span id="line5099"></span>
<span id="line5100"></span>
<span id="line5101"></span>
<span id="line5102"></span>
<span id="line5103"></span>                                 CONTENTS
<span id="line5104"></span>
<span id="line5105"></span>
<span id="line5106"></span>          6.  EXPRESSIONS..................................   6-1
<span id="line5107"></span>              6.1  Arithmetic Expressions..................   6-1
<span id="line5108"></span>                   6.1.1  Arithmetic Operators.............   6-1
<span id="line5109"></span>                   6.1.2  Form and Interpretation of
<span id="line5110"></span>                          Arithmetic Expressions...........   6-2
<span id="line5111"></span>                   6.1.3  Arithmetic Constant
<span id="line5112"></span>                          Expression.......................   6-5
<span id="line5113"></span>                   6.1.4  Type and Interpretation of
<span id="line5114"></span>                          Arithmetic Expressions...........   6-5
<span id="line5115"></span>                   6.1.5  Integer Division.................   6-8
<span id="line5116"></span>              6.2  Character Expressions...................   6-8
<span id="line5117"></span>                   6.2.1  Character Operator...............   6-8
<span id="line5118"></span>                   6.2.2  Form and Interpretation of
<span id="line5119"></span>                          Character Expressions............   6-9
<span id="line5120"></span>                   6.2.3  Character Constant
<span id="line5121"></span>                          Expression.......................  6-10
<span id="line5122"></span>              6.3  Relational Expressions..................  6-10
<span id="line5123"></span>                   6.3.1  Relational Operators.............  6-11
<span id="line5124"></span>                   6.3.2  Arithmetic Relational
<span id="line5125"></span>                          Expression.......................  6-11
<span id="line5126"></span>                   6.3.3  Interpretation of Arithmetic
<span id="line5127"></span>                          Relational Expressions...........  6-11
<span id="line5128"></span>                   6.3.4  Character Relational
<span id="line5129"></span>                          Expression.......................  6-12
<span id="line5130"></span>                   6.3.5  Interpretation of Character
<span id="line5131"></span>                          Relational Expressions...........  6-12
<span id="line5132"></span>              6.4  Logical Expressions.....................  6-12
<span id="line5133"></span>                   6.4.1  Logical Operators................  6-12
<span id="line5134"></span>                   6.4.2  Form and Interpretation of
<span id="line5135"></span>                          Logical Expressions..............  6-13
<span id="line5136"></span>                   6.4.3  Value of Logical Factors, Terms,
<span id="line5137"></span>                          Disjuncts, and Expressions.......  6-
<span id="line5138"></span>                          15
<span id="line5139"></span>                   6.4.4  Logical Constant
<span id="line5140"></span>                          Expression.......................  6-16
<span id="line5141"></span>              6.5  Precedence of Operators.................  6-16
<span id="line5142"></span>                   6.5.1  Summary of Interpretation
<span id="line5143"></span>                          Rules............................  6-17
<span id="line5144"></span>              6.6  Evaluation of Expressions...............  6-18
<span id="line5145"></span>                   6.6.1  Evaluation of Operands...........  6-19
<span id="line5146"></span>                   6.6.2  Order of Evaluation of
<span id="line5147"></span>                          Functions........................  6-19
<span id="line5148"></span>                   6.6.3  Integrity of Parentheses.........  6-20
<span id="line5149"></span>                   6.6.4  Evaluation of Arithmetic
<span id="line5150"></span>                          Expressions......................  6-20
<span id="line5151"></span>                   6.6.5  Evaluation of Character
<span id="line5152"></span>                          Expressions......................  6-22
<span id="line5153"></span>
<span id="line5154"></span>
<span id="line5155"></span>
<span id="line5156"></span>
<span id="line5157"></span>                                   - i -
<span id="line5158"></span>
<span id="line5159"></span>
<span id="line5160"></span>
<span id="line5161"></span>
<span id="line5162"></span>
<span id="line5163"></span>
<span id="line5164"></span>
<span id="line5165"></span>
<span id="line5166"></span>
<span id="line5167"></span>
<span id="line5168"></span>
<span id="line5169"></span>                   6.6.6  Evaluation of Relational
<span id="line5170"></span>                          Expressions......................  6-22
<span id="line5171"></span>                   6.6.7  Evaluation of Logical
<span id="line5172"></span>                          Expressions......................  6-23
<span id="line5173"></span>              6.7  Constant Expressions....................  6-23
<span id="line5174"></span>
<span id="line5175"></span>
<span id="line5176"></span>
<span id="line5177"></span>
<span id="line5178"></span>
<span id="line5179"></span>
<span id="line5180"></span>
<span id="line5181"></span>
<span id="line5182"></span>
<span id="line5183"></span>
<span id="line5184"></span>
<span id="line5185"></span>
<span id="line5186"></span>
<span id="line5187"></span>
<span id="line5188"></span>
<span id="line5189"></span>
<span id="line5190"></span>
<span id="line5191"></span>
<span id="line5192"></span>
<span id="line5193"></span>
<span id="line5194"></span>
<span id="line5195"></span>
<span id="line5196"></span>
<span id="line5197"></span>
<span id="line5198"></span>
<span id="line5199"></span>
<span id="line5200"></span>
<span id="line5201"></span>
<span id="line5202"></span>
<span id="line5203"></span>
<span id="line5204"></span>
<span id="line5205"></span>
<span id="line5206"></span>
<span id="line5207"></span>
<span id="line5208"></span>
<span id="line5209"></span>
<span id="line5210"></span>
<span id="line5211"></span>
<span id="line5212"></span>
<span id="line5213"></span>
<span id="line5214"></span>
<span id="line5215"></span>
<span id="line5216"></span>
<span id="line5217"></span>
<span id="line5218"></span>
<span id="line5219"></span>
<span id="line5220"></span>
<span id="line5221"></span>
<span id="line5222"></span>
<span id="line5223"></span>                                  - ii -
<span id="line5224"></span>
<span id="line5225"></span>
<span id="line5226"></span>
<span id="line5227"></span>
<span id="line5228"></span>
<span id="line5229"></span>
<span id="line5230"></span>
<span id="line5231"></span>                                                   ANSI X3J3/90.4
<span id="line5232"></span>
<span id="line5233"></span>
<span id="line5234"></span>
<span id="line5235"></span>          7.  EXECUTABLE AND NONEXECUTABLE STATEMENT CLASSIFICATION
<span id="line5236"></span>
<span id="line5237"></span>          Each  statement  is   classified   as   executable   or
<span id="line5238"></span>          nonexecutable.   Executable  statements specify actions
<span id="line5239"></span>          and  form  an  execution  sequence  in  an   executable
<span id="line5240"></span>          program.       Nonexecutable     statements     specify
<span id="line5241"></span>          characteristics, arrangement,  and  initial  values  of
<span id="line5242"></span>          data;  contain  editing  information; specify statement
<span id="line5243"></span>          functions; classify program units;  and  specify  entry
<span id="line5244"></span>          points  within  subprograms.   Nonexecutable statements
<span id="line5245"></span>          are not part of the execution  sequence.  Nonexecutable
<span id="line5246"></span>          statements  may  be  labeled, but such statement labels
<span id="line5247"></span>          must not be used to control the execution sequence.
<span id="line5248"></span>
<span id="line5249"></span>          7.1  Executable_Statements
<span id="line5250"></span>
<span id="line5251"></span>          The following statements are classified as executable:
<span id="line5252"></span>
<span id="line5253"></span>             (1) Arithmetic, logical, statement  label  (ASSIGN),
<span id="line5254"></span>                 and character  assignment statements
<span id="line5255"></span>
<span id="line5256"></span>             (2) Unconditional  GO  TO,  assigned  GO   TO,   and
<span id="line5257"></span>                 computed GO TO statements
<span id="line5258"></span>
<span id="line5259"></span>             (3) Arithmetic IF and logical IF statements
<span id="line5260"></span>
<span id="line5261"></span>             (4) Block IF, ELSE IF, ELSE, and END IF statements
<span id="line5262"></span>
<span id="line5263"></span>             (5) CONTINUE statement
<span id="line5264"></span>
<span id="line5265"></span>             (6) STOP and PAUSE statements
<span id="line5266"></span>
<span id="line5267"></span>             (7) DO statement
<span id="line5268"></span>
<span id="line5269"></span>             (8) READ, WRITE, and PRINT statements
<span id="line5270"></span>
<span id="line5271"></span>             (9) REWIND, BACKSPACE,  ENDFILE,  OPEN,  CLOSE,  and
<span id="line5272"></span>                 INQUIRE statements
<span id="line5273"></span>
<span id="line5274"></span>            (10) CALL and RETURN statements
<span id="line5275"></span>
<span id="line5276"></span>            (11) END statement
<span id="line5277"></span>
<span id="line5278"></span>          7.2  Nonexecutable_Statements
<span id="line5279"></span>
<span id="line5280"></span>          The   following   statements    are    classified    as
<span id="line5281"></span>          nonexecutable:
<span id="line5282"></span>
<span id="line5283"></span>             (1) PROGRAM, FUNCTION, SUBROUTINE, ENTRY, and  BLOCK
<span id="line5284"></span>                 DATA statements
<span id="line5285"></span>
<span id="line5286"></span>
<span id="line5287"></span>
<span id="line5288"></span>
<span id="line5289"></span>          FORTRAN 77 Full Language                       Page 7-1
<span id="line5290"></span>
<span id="line5291"></span>
<span id="line5292"></span>
<span id="line5293"></span>
<span id="line5294"></span>
<span id="line5295"></span>
<span id="line5296"></span>
<span id="line5297"></span>          STATEMENT CLASSIFICATION                 ANSI X3J3/90.4
<span id="line5298"></span>
<span id="line5299"></span>
<span id="line5300"></span>
<span id="line5301"></span>             (2) DIMENSION,   COMMON,   EQUIVALENCE,    IMPLICIT,
<span id="line5302"></span>                 PARAMETER,   EXTERNAL,   INTRINSIC,   and   SAVE
<span id="line5303"></span>                 statements
<span id="line5304"></span>
<span id="line5305"></span>             (3) INTEGER,  REAL,   DOUBLE   PRECISION,   COMPLEX,
<span id="line5306"></span>                 LOGICAL, and CHARACTER type-statements
<span id="line5307"></span>
<span id="line5308"></span>             (4) DATA statement
<span id="line5309"></span>
<span id="line5310"></span>             (5) FORMAT statement
<span id="line5311"></span>
<span id="line5312"></span>             (6) Statement function statement
<span id="line5313"></span>
<span id="line5314"></span>
<span id="line5315"></span>
<span id="line5316"></span>
<span id="line5317"></span>
<span id="line5318"></span>
<span id="line5319"></span>
<span id="line5320"></span>
<span id="line5321"></span>
<span id="line5322"></span>
<span id="line5323"></span>
<span id="line5324"></span>
<span id="line5325"></span>
<span id="line5326"></span>
<span id="line5327"></span>
<span id="line5328"></span>
<span id="line5329"></span>
<span id="line5330"></span>
<span id="line5331"></span>
<span id="line5332"></span>
<span id="line5333"></span>
<span id="line5334"></span>
<span id="line5335"></span>
<span id="line5336"></span>
<span id="line5337"></span>
<span id="line5338"></span>
<span id="line5339"></span>
<span id="line5340"></span>
<span id="line5341"></span>
<span id="line5342"></span>
<span id="line5343"></span>
<span id="line5344"></span>
<span id="line5345"></span>
<span id="line5346"></span>
<span id="line5347"></span>
<span id="line5348"></span>
<span id="line5349"></span>
<span id="line5350"></span>
<span id="line5351"></span>
<span id="line5352"></span>
<span id="line5353"></span>
<span id="line5354"></span>
<span id="line5355"></span>          FORTRAN 77 Full Language                       Page 7-2
<span id="line5356"></span>
<span id="line5357"></span>
<span id="line5358"></span>
<span id="line5359"></span>
<span id="line5360"></span>
<span id="line5361"></span>
<span id="line5362"></span>
<span id="line5363"></span>
<span id="line5364"></span>
<span id="line5365"></span>
<span id="line5366"></span>
<span id="line5367"></span>                                 CONTENTS
<span id="line5368"></span>
<span id="line5369"></span>
<span id="line5370"></span>          7.  EXECUTABLE AND NONEXECUTABLE STATEMENT CLASSIFICATION  7-
<span id="line5371"></span>              1
<span id="line5372"></span>              7.1  Executable Statements....................  7-1
<span id="line5373"></span>              7.2  Nonexecutable Statements.................  7-1
<span id="line5374"></span>
<span id="line5375"></span>
<span id="line5376"></span>
<span id="line5377"></span>
<span id="line5378"></span>
<span id="line5379"></span>
<span id="line5380"></span>
<span id="line5381"></span>
<span id="line5382"></span>
<span id="line5383"></span>
<span id="line5384"></span>
<span id="line5385"></span>
<span id="line5386"></span>
<span id="line5387"></span>
<span id="line5388"></span>
<span id="line5389"></span>
<span id="line5390"></span>
<span id="line5391"></span>
<span id="line5392"></span>
<span id="line5393"></span>
<span id="line5394"></span>
<span id="line5395"></span>
<span id="line5396"></span>
<span id="line5397"></span>
<span id="line5398"></span>
<span id="line5399"></span>
<span id="line5400"></span>
<span id="line5401"></span>
<span id="line5402"></span>
<span id="line5403"></span>
<span id="line5404"></span>
<span id="line5405"></span>
<span id="line5406"></span>
<span id="line5407"></span>
<span id="line5408"></span>
<span id="line5409"></span>
<span id="line5410"></span>
<span id="line5411"></span>
<span id="line5412"></span>
<span id="line5413"></span>
<span id="line5414"></span>
<span id="line5415"></span>
<span id="line5416"></span>
<span id="line5417"></span>
<span id="line5418"></span>
<span id="line5419"></span>
<span id="line5420"></span>
<span id="line5421"></span>                                   - i -
<span id="line5422"></span>
<span id="line5423"></span>
<span id="line5424"></span>
<span id="line5425"></span>
<span id="line5426"></span>
<span id="line5427"></span>
<span id="line5428"></span>
<span id="line5429"></span>                                                   ANSI X3J3/90.4
<span id="line5430"></span>
<span id="line5431"></span>
<span id="line5432"></span>
<span id="line5433"></span>                       8.  SPECIFICATION_STATEMENTS
<span id="line5434"></span>
<span id="line5435"></span>          There are nine kinds of specification statements:
<span id="line5436"></span>
<span id="line5437"></span>             (1) DIMENSION
<span id="line5438"></span>
<span id="line5439"></span>             (2) EQUIVALENCE
<span id="line5440"></span>
<span id="line5441"></span>             (3) COMMON
<span id="line5442"></span>
<span id="line5443"></span>             (4) INTEGER,  REAL,   DOUBLE   PRECISION,   COMPLEX,
<span id="line5444"></span>                 LOGICAL, and CHARACTER type-statements
<span id="line5445"></span>
<span id="line5446"></span>             (5) IMPLICIT
<span id="line5447"></span>
<span id="line5448"></span>             (6) PARAMETER
<span id="line5449"></span>
<span id="line5450"></span>             (7) EXTERNAL
<span id="line5451"></span>
<span id="line5452"></span>             (8) INTRINSIC
<span id="line5453"></span>
<span id="line5454"></span>             (9) SAVE
<span id="line5455"></span>
<span id="line5456"></span>          All specification statements are nonexecutable.
<span id="line5457"></span>
<span id="line5458"></span>          8.1  DIMENSION_Statement
<span id="line5459"></span>
<span id="line5460"></span>          A DIMENSION statement is used to specify  the  symbolic
<span id="line5461"></span>          names and dimension specifications of arrays.
<span id="line5462"></span>
<span id="line5463"></span>          The form of a DIMENSION statement is:
<span id="line5464"></span>
<span id="line5465"></span>                               DIMENSION a_(d_) [,a_(d_)]...
<span id="line5466"></span>
<span id="line5467"></span>          where each a_(d_) is an array declarator (5.1).
<span id="line5468"></span>
<span id="line5469"></span>          Each symbolic name a_ appearing in a DIMENSION statement
<span id="line5470"></span>          declares  a_ to be an array in that program unit.  Note
<span id="line5471"></span>          that  array  declarators  may  also  appear  in  COMMON
<span id="line5472"></span>          statements and type-statements.  Only one appearance of
<span id="line5473"></span>          a symbolic name as an array name in an array declarator
<span id="line5474"></span>          in a program unit is permitted.
<span id="line5475"></span>
<span id="line5476"></span>          8.2  EQUIVALENCE_Statement
<span id="line5477"></span>
<span id="line5478"></span>          An EQUIVALENCE statement is used to specify the sharing
<span id="line5479"></span>          of  storage  units by two or more entities in a program
<span id="line5480"></span>          unit.  This causes association  of  the  entities  that
<span id="line5481"></span>          share the storage units.
<span id="line5482"></span>
<span id="line5483"></span>
<span id="line5484"></span>
<span id="line5485"></span>
<span id="line5486"></span>
<span id="line5487"></span>          FORTRAN 77 Full Language                       Page 8-1
<span id="line5488"></span>
<span id="line5489"></span>
<span id="line5490"></span>
<span id="line5491"></span>
<span id="line5492"></span>
<span id="line5493"></span>
<span id="line5494"></span>
<span id="line5495"></span>          SPECIFICATION STATEMENTS                 ANSI X3J3/90.4
<span id="line5496"></span>
<span id="line5497"></span>
<span id="line5498"></span>
<span id="line5499"></span>          If the equivalenced  entities  are  of  different  data
<span id="line5500"></span>          types,  the  EQUIVALENCE  statement does not cause type
<span id="line5501"></span>          conversion or imply  mathematical  equivalence.   If  a
<span id="line5502"></span>          variable  and  an  array are equivalenced, the variable
<span id="line5503"></span>          does not have array properties and the array  does  not
<span id="line5504"></span>          have the properties of a variable.
<span id="line5505"></span>
<span id="line5506"></span>          8.2.1  Form_of_an_EQUIVALENCE_Statement.  The  form  of
<span id="line5507"></span>          an EQUIVALENCE statement is:
<span id="line5508"></span>
<span id="line5509"></span>                               EQUIVALENCE (nlist_____) [,(nlist_____)]...
<span id="line5510"></span>
<span id="line5511"></span>          where each nlist_____ is a list (2.10)  of  variable  names,
<span id="line5512"></span>          array   element   names,  array  names,  and  character
<span id="line5513"></span>          substring names.  Each list must contain at  least  two
<span id="line5514"></span>          names.    Names  of  dummy  arguments  of  an  external
<span id="line5515"></span>          procedure in a subprogram must not appear in the  list.
<span id="line5516"></span>          If  a  variable  name is also a function name (15.5.1),
<span id="line5517"></span>          that name must not appear in the list.
<span id="line5518"></span>
<span id="line5519"></span>          Each subscript expression or substring expression in  a
<span id="line5520"></span>          list nlist_____ must be an integer constant expression.
<span id="line5521"></span>
<span id="line5522"></span>          8.2.2  Equivalence_Association.      An     EQUIVALENCE
<span id="line5523"></span>          statement  specifies  that the storage sequences of the
<span id="line5524"></span>          entities whose names appear in a list nlist____ _  have  the
<span id="line5525"></span>          same  first  storage unit.  This causes the association
<span id="line5526"></span>          of the entities in the list nlist_ _ _ _ _  and  may  cause
<span id="line5527"></span>          association of other entities (17.1).
<span id="line5528"></span>
<span id="line5529"></span>          8.2.3  Equivalence_of_Character_Entities.  An entity of
<span id="line5530"></span>          type  character  may  be  equivalenced  only with other
<span id="line5531"></span>          entities  of  type  character.  The  lengths   of   the
<span id="line5532"></span>          equivalenced entities are not required to be the same.
<span id="line5533"></span>
<span id="line5534"></span>          An EQUIVALENCE statement  specifies  that  the  storage
<span id="line5535"></span>          sequences  of the character entities whose names appear
<span id="line5536"></span>          in a list nlist_____ have the same first  character  storage
<span id="line5537"></span>          unit.   This  causes the association of the entities in
<span id="line5538"></span>          the list nlist_____  and  may  cause  association  of  other
<span id="line5539"></span>          entities   (17.1).   Any  adjacent  characters  in  the
<span id="line5540"></span>          associated entities may also have  the  same  character
<span id="line5541"></span>          storage  unit  and thus may also be associated.  In the
<span id="line5542"></span>          example:
<span id="line5543"></span>
<span id="line5544"></span>                     CHARACTER A*4, B*4, C(2)*3
<span id="line5545"></span>                     EQUIVALENCE (A,C(1)), (B,C(2))
<span id="line5546"></span>
<span id="line5547"></span>          the association of A,  B,  and  C  can  be  graphically
<span id="line5548"></span>          illustrated as:
<span id="line5549"></span>
<span id="line5550"></span>
<span id="line5551"></span>
<span id="line5552"></span>
<span id="line5553"></span>          FORTRAN 77 Full Language                       Page 8-2
<span id="line5554"></span>
<span id="line5555"></span>
<span id="line5556"></span>
<span id="line5557"></span>
<span id="line5558"></span>
<span id="line5559"></span>
<span id="line5560"></span>
<span id="line5561"></span>          SPECIFICATION STATEMENTS                 ANSI X3J3/90.4
<span id="line5562"></span>
<span id="line5563"></span>
<span id="line5564"></span>
<span id="line5565"></span>                   | 01|  02|  03|  04
<span id="line5566"></span>7                                      |  05|  06|  07|
<span id="line5567"></span>
<span id="line5568"></span>                   | --------A--------|
<span id="line5569"></span>                                    --------B--------|
<span id="line5570"></span>                     ----C(1)----   ----C(2)----
<span id="line5571"></span>7                   |
<span id="line5572"></span>7                                 |8|
<span id="line5573"></span>8                                                |
<span id="line5574"></span>
<span id="line5575"></span>          8.2.4  Array_Names_and_Array_Element_Names.    If    an
<span id="line5576"></span>          array element name appears in an EQUIVALENCE statement,
<span id="line5577"></span>          the number of subscript expressions must be the same as
<span id="line5578"></span>          the   number  of  dimensions  specified  in  the  array
<span id="line5579"></span>          declarator for the array name.
<span id="line5580"></span>
<span id="line5581"></span>          The use of an array name unqualified by a subscript  in
<span id="line5582"></span>          an  EQUIVALENCE  statement has the same effect as using
<span id="line5583"></span>          an array element name that identifies the first element
<span id="line5584"></span>          of the array.
<span id="line5585"></span>
<span id="line5586"></span>          8.2.5  Restrictions_on_EQUIVALENCE_Statements.       An
<span id="line5587"></span>          EQUIVALENCE  statement  must  not specify that the same
<span id="line5588"></span>          storage unit is to occur more than once  in  a  storage
<span id="line5589"></span>          sequence.  For example,
<span id="line5590"></span>
<span id="line5591"></span>                     DIMENSION A(2)
<span id="line5592"></span>                     EQUIVALENCE (A(1),B), (A(2),B)
<span id="line5593"></span>
<span id="line5594"></span>          is  prohibited,  because  it  would  specify  the  same
<span id="line5595"></span>          storage   unit  for  A(1)  and  A(2).   An  EQUIVALENCE
<span id="line5596"></span>          statement must not  specify  that  consecutive  storage
<span id="line5597"></span>          units  are  to  be  nonconsecutive.   For  example, the
<span id="line5598"></span>          following is prohibited:
<span id="line5599"></span>
<span id="line5600"></span>                     REAL A(2)
<span id="line5601"></span>                     DOUBLE PRECISION D(2)
<span id="line5602"></span>                     EQUIVALENCE (A(1),D(1)), (A(2),D(2))
<span id="line5603"></span>
<span id="line5604"></span>          8.3  COMMON_Statement
<span id="line5605"></span>
<span id="line5606"></span>          The COMMON statement provides a  means  of  associating
<span id="line5607"></span>          entities  in  different  program  units.   This  allows
<span id="line5608"></span>          different program units to  define  and  reference  the
<span id="line5609"></span>          same data without using arguments, and to share storage
<span id="line5610"></span>          units.
<span id="line5611"></span>
<span id="line5612"></span>          8.3.1  Form_of_a_COMMON_Statement.   The  form   of   a
<span id="line5613"></span>          COMMON statement is:
<span id="line5614"></span>
<span id="line5615"></span>                               COMMON [/[cb__]/] nlist_____ [[,]/[cb__]/ nlist_____]...
<span id="line5616"></span>
<span id="line5617"></span>          where: cb__  is a common block name (18.2.1)
<span id="line5618"></span>
<span id="line5619"></span>
<span id="line5620"></span>
<span id="line5621"></span>
<span id="line5622"></span>
<span id="line5623"></span>          FORTRAN 77 Full Language                       Page 8-3
<span id="line5624"></span>
<span id="line5625"></span>
<span id="line5626"></span>
<span id="line5627"></span>
<span id="line5628"></span>
<span id="line5629"></span>
<span id="line5630"></span>
<span id="line5631"></span>          SPECIFICATION STATEMENTS                 ANSI X3J3/90.4
<span id="line5632"></span>
<span id="line5633"></span>
<span id="line5634"></span>
<span id="line5635"></span>                 nlist_____ is a list (2.10) of variable names,  array
<span id="line5636"></span>                     names,  and  array  declarators.   Only  one
<span id="line5637"></span>                     appearance of a symbolic name as a  variable
<span id="line5638"></span>                     name,  array  name,  or  array declarator is
<span id="line5639"></span>                     permitted in all such lists within a program
<span id="line5640"></span>                     unit.    Names  of  dummy  arguments  of  an
<span id="line5641"></span>                     external procedure in a subprogram must  not
<span id="line5642"></span>                     appear  in  the list.  If a variable name is
<span id="line5643"></span>                     also a function  name  (15.5.1),  that  name
<span id="line5644"></span>                     must not appear in the list.
<span id="line5645"></span>
<span id="line5646"></span>          Each omitted cb__ specifies the blank common  block.   If
<span id="line5647"></span>          the  first  cb_ _  is omitted, the first two slashes are
<span id="line5648"></span>          optional.
<span id="line5649"></span>
<span id="line5650"></span>          In each COMMON  statement,  the  entities  whose  names
<span id="line5651"></span>          appear  in  an  nlist_ _ _ __ following a block name cb__ are
<span id="line5652"></span>          declared to be in common block cb__.  If the first cb__  is
<span id="line5653"></span>          omitted, all entities whose names appear in the first nlist_
<span id="line5654"></span>          _ _ _ _  are  specified  to   be   in   blank   common.
<span id="line5655"></span>          Alternatively,  the  appearance  of two slashes with no
<span id="line5656"></span>          block name between them  declares  the  entities  whose
<span id="line5657"></span>          names  appear  in  the list nlist_____ that follows to be in
<span id="line5658"></span>          blank common.
<span id="line5659"></span>
<span id="line5660"></span>          Any common block name cb__ or an omitted cb_ _  for  blank
<span id="line5661"></span>          common  may  occur more than once in one or more COMMON
<span id="line5662"></span>          statements in a program unit.  The list nlist_____ following
<span id="line5663"></span>          each  successive  appearance  of  the same common block
<span id="line5664"></span>          name is treated as a continuation of the list for  that
<span id="line5665"></span>          common block name.
<span id="line5666"></span>
<span id="line5667"></span>          If a character variable or  character  array  is  in  a
<span id="line5668"></span>          common  block, all of the entities in that common block
<span id="line5669"></span>          must be of type character.
<span id="line5670"></span>
<span id="line5671"></span>          8.3.2  Common_Block_Storage_Sequence.  For each  common
<span id="line5672"></span>          block,  a  common  block  storage sequence is formed as
<span id="line5673"></span>          follows:
<span id="line5674"></span>
<span id="line5675"></span>             (1) A storage sequence is formed consisting  of  the
<span id="line5676"></span>                 storage sequences of all entities in the lists nlist_
<span id="line5677"></span>                 ____Z for the common block.  The  order  of  the
<span id="line5678"></span>                 storage sequence is the same as the order of the
<span id="line5679"></span>                 appearance of the lists nlist____ _  in  the  program
<span id="line5680"></span>                 unit.
<span id="line5681"></span>
<span id="line5682"></span>             (2) The storage sequence formed in (1)  is  extended
<span id="line5683"></span>                 to  include  all  storage  units  of any storage
<span id="line5684"></span>                 sequence  associated  with  it  by   equivalence
<span id="line5685"></span>                 association.   The sequence may be extended only
<span id="line5686"></span>
<span id="line5687"></span>
<span id="line5688"></span>
<span id="line5689"></span>          FORTRAN 77 Full Language                       Page 8-4
<span id="line5690"></span>
<span id="line5691"></span>
<span id="line5692"></span>
<span id="line5693"></span>
<span id="line5694"></span>
<span id="line5695"></span>
<span id="line5696"></span>
<span id="line5697"></span>          SPECIFICATION STATEMENTS                 ANSI X3J3/90.4
<span id="line5698"></span>
<span id="line5699"></span>
<span id="line5700"></span>
<span id="line5701"></span>                 by adding storage units beyond the last  storage
<span id="line5702"></span>                 unit.   Entities  associated with an entity in a
<span id="line5703"></span>                 common block are considered to be in that common
<span id="line5704"></span>                 block.
<span id="line5705"></span>
<span id="line5706"></span>          8.3.3  Size_of_a_Common_Block.  The size  of  a  common
<span id="line5707"></span>          block is the size of its common block storage sequence,
<span id="line5708"></span>          including any extensions of the sequence resulting from
<span id="line5709"></span>          equivalence association.
<span id="line5710"></span>
<span id="line5711"></span>          Within an executable program, all named  common  blocks
<span id="line5712"></span>          that  have  the same name must be the same size.  Blank
<span id="line5713"></span>          common blocks within  an  executable  program  are  not
<span id="line5714"></span>          required to be the same size.
<span id="line5715"></span>
<span id="line5716"></span>          8.3.4  Common_Association.    Within   an    executable
<span id="line5717"></span>          program,  the  common  block  storage  sequences of all
<span id="line5718"></span>          common blocks with the same name have  the  same  first
<span id="line5719"></span>          storage unit.  Within an executable program, the common
<span id="line5720"></span>          block storage sequences of all blank common blocks have
<span id="line5721"></span>          the  same  first  storage  unit.   This  results in the
<span id="line5722"></span>          association (17.1) of  entities  in  different  program
<span id="line5723"></span>          units.
<span id="line5724"></span>
<span id="line5725"></span>          8.3.5  Differences  between  Named  Common  and   Blank
<span id="line5726"></span>          Common.   A  blank common block has the same properties
<span id="line5727"></span>          as a named common block, except for the following:
<span id="line5728"></span>
<span id="line5729"></span>             (1) Execution of a RETURN or END statement sometimes
<span id="line5730"></span>                 causes entities in named common blocks to become
<span id="line5731"></span>                 undefined but never  causes  entities  in  blank
<span id="line5732"></span>                 common to become undefined (15.8.4).
<span id="line5733"></span>
<span id="line5734"></span>             (2) Named common blocks of the same name must be  of
<span id="line5735"></span>                 the  same  size  in  all  program  units  of  an
<span id="line5736"></span>                 executable program in  which  they  appear,  but
<span id="line5737"></span>                 blank common blocks may be of different sizes.
<span id="line5738"></span>
<span id="line5739"></span>             (3) Entities in named common blocks may be initially
<span id="line5740"></span>                 defined  by means of a DATA statement in a block
<span id="line5741"></span>                 data subprogram, but entities  in  blank  common
<span id="line5742"></span>                 must not be initially defined (Section 9).
<span id="line5743"></span>
<span id="line5744"></span>          8.3.6  Restrictions_on_Common_and_Equivalence.       An
<span id="line5745"></span>          EQUIVALENCE   statement  must  not  cause  the  storage
<span id="line5746"></span>          sequences of two different common blocks  in  the  same
<span id="line5747"></span>          program unit to be associated.  Equivalence association
<span id="line5748"></span>          must not cause a common block storage  sequence  to  be
<span id="line5749"></span>          extended  by  adding  storage units preceding the first
<span id="line5750"></span>          storage unit of the first entity specified in a  COMMON
<span id="line5751"></span>          statement  for  the  common  block.   For  example, the
<span id="line5752"></span>
<span id="line5753"></span>
<span id="line5754"></span>
<span id="line5755"></span>          FORTRAN 77 Full Language                       Page 8-5
<span id="line5756"></span>
<span id="line5757"></span>
<span id="line5758"></span>
<span id="line5759"></span>
<span id="line5760"></span>
<span id="line5761"></span>
<span id="line5762"></span>
<span id="line5763"></span>          SPECIFICATION STATEMENTS                 ANSI X3J3/90.4
<span id="line5764"></span>
<span id="line5765"></span>
<span id="line5766"></span>
<span id="line5767"></span>          following is not permitted:
<span id="line5768"></span>
<span id="line5769"></span>                     COMMON /X/A
<span id="line5770"></span>                     REAL B(2)
<span id="line5771"></span>                     EQUIVALENCE (A,B(2))
<span id="line5772"></span>
<span id="line5773"></span>          8.4  Type-Statements
<span id="line5774"></span>
<span id="line5775"></span>          A  type-statement  is  used  to  override  or   confirm
<span id="line5776"></span>          implicit typing and may specify dimension information.
<span id="line5777"></span>
<span id="line5778"></span>          The appearance of the  symbolic  name  of  a  constant,
<span id="line5779"></span>          variable,   array,   external  function,  or  statement
<span id="line5780"></span>          function in a type-statement specifies  the  data  type
<span id="line5781"></span>          for  that name for all appearances in the program unit.
<span id="line5782"></span>          Within a program unit, a name must not  have  its  type
<span id="line5783"></span>          explicitly specified more than once.
<span id="line5784"></span>
<span id="line5785"></span>          A type-statement that confirms the type of an intrinsic
<span id="line5786"></span>          function whose name appears in the Specific Name column
<span id="line5787"></span>          of Table 5 is not required,  but is  permitted.   If  a
<span id="line5788"></span>          generic function name appears in a type-statement, such
<span id="line5789"></span>          an appearance is not sufficient by itself to remove the
<span id="line5790"></span>          generic properties from that function.
<span id="line5791"></span>
<span id="line5792"></span>          The name of a main program, subroutine, or  block  data
<span id="line5793"></span>          subprogram must not appear in a type-statement.
<span id="line5794"></span>
<span id="line5795"></span>          8.4.1  INTEGER, REAL, DOUBLE  PRECISION,  COMPLEX,  and
<span id="line5796"></span>          LOGICAL  Type-Statements.   An  INTEGER,  REAL,  DOUBLE
<span id="line5797"></span>          PRECISION, COMPLEX, or LOGICAL type-statement is of the
<span id="line5798"></span>          form:
<span id="line5799"></span>
<span id="line5800"></span>                               typ___ v_[,v_]...
<span id="line5801"></span>
<span id="line5802"></span>          where: typ___ is one of INTEGER, REAL,  DOUBLE  PRECISION,
<span id="line5803"></span>                     COMPLEX, or LOGICAL
<span id="line5804"></span>
<span id="line5805"></span>                 v_    is  a  variable  name,  array  name,  array
<span id="line5806"></span>                     declarator,  symbolic  name  of  a constant,
<span id="line5807"></span>                     function  name,  or  dummy  procedure   name
<span id="line5808"></span>                     (18.2.11)
<span id="line5809"></span>
<span id="line5810"></span>          8.4.2  CHARACTER_Type-Statement.    The   form   of   a
<span id="line5811"></span>          CHARACTER type-statement is:
<span id="line5812"></span>
<span id="line5813"></span>                               CHARACTER [*len___ [,]] nam___ [,nam___]...
<span id="line5814"></span>
<span id="line5815"></span>          where: nam___ is of one of the forms:
<span id="line5816"></span>
<span id="line5817"></span>
<span id="line5818"></span>
<span id="line5819"></span>
<span id="line5820"></span>
<span id="line5821"></span>          FORTRAN 77 Full Language                       Page 8-6
<span id="line5822"></span>
<span id="line5823"></span>
<span id="line5824"></span>
<span id="line5825"></span>
<span id="line5826"></span>
<span id="line5827"></span>
<span id="line5828"></span>
<span id="line5829"></span>          SPECIFICATION STATEMENTS                 ANSI X3J3/90.4
<span id="line5830"></span>
<span id="line5831"></span>
<span id="line5832"></span>
<span id="line5833"></span>                     v_ [*len___]
<span id="line5834"></span>
<span id="line5835"></span>                     a_ [(d_)] [*len___]
<span id="line5836"></span>
<span id="line5837"></span>                 v_   is a  variable  name,  symbolic  name  of  a
<span id="line5838"></span>                     constant,  function name, or dummy procedure
<span id="line5839"></span>                     name
<span id="line5840"></span>
<span id="line5841"></span>                 a_   is an array name
<span id="line5842"></span>
<span id="line5843"></span>                 a_(d_) is an array declarator
<span id="line5844"></span>
<span id="line5845"></span>                 len___ is the length (number of  characters)  of  a
<span id="line5846"></span>                     character variable, character array element,
<span id="line5847"></span>                     character constant that has a symbolic name,
<span id="line5848"></span>                     or character function, and is called the length specification___
<span id="line5849"></span>                     _________________.  len_ _ _  is  one  of  the
<span id="line5850"></span>                     following:
<span id="line5851"></span>
<span id="line5852"></span>                     (1) An unsigned, nonzero, integer constant
<span id="line5853"></span>
<span id="line5854"></span>                     (2) An integer constant expression (6.1.3.1)
<span id="line5855"></span>                         enclosed   in  parentheses  and  with  a
<span id="line5856"></span>                         positive value
<span id="line5857"></span>
<span id="line5858"></span>                     (3) An asterisk in parentheses, (*)
<span id="line5859"></span>
<span id="line5860"></span>          A length len___ immediately following the  word  CHARACTER
<span id="line5861"></span>          is  the  length  specification  for  each entity in the
<span id="line5862"></span>          statement not having its own length  specification.   A
<span id="line5863"></span>          length specification immediately following an entity is
<span id="line5864"></span>          the length specification for only  that  entity.   Note
<span id="line5865"></span>          that  for  an  array  the  length specified is for each
<span id="line5866"></span>          array element.  If a length is  not  specified  for  an
<span id="line5867"></span>          entity, its length is one.
<span id="line5868"></span>
<span id="line5869"></span>          An entity declared in a CHARACTER statement must have a
<span id="line5870"></span>          length   specification  that  is  an  integer  constant
<span id="line5871"></span>          expression, unless that entity is an external function,
<span id="line5872"></span>          a  dummy  argument  of  an  external  procedure,  or  a
<span id="line5873"></span>          character constant that has a symbolic name.
<span id="line5874"></span>
<span id="line5875"></span>          If a dummy argument has a len__ _  of  (*)  declared,  the
<span id="line5876"></span>          dummy  argument  assumes  the  length of the associated
<span id="line5877"></span>          actual argument for each reference of the subroutine or
<span id="line5878"></span>          function.   If  the  associated  actual  argument is an
<span id="line5879"></span>          array name, the length assumed by the dummy argument is
<span id="line5880"></span>          the length of an array element in the associated actual
<span id="line5881"></span>          argument array.
<span id="line5882"></span>
<span id="line5883"></span>
<span id="line5884"></span>
<span id="line5885"></span>
<span id="line5886"></span>
<span id="line5887"></span>          FORTRAN 77 Full Language                       Page 8-7
<span id="line5888"></span>
<span id="line5889"></span>
<span id="line5890"></span>
<span id="line5891"></span>
<span id="line5892"></span>
<span id="line5893"></span>
<span id="line5894"></span>
<span id="line5895"></span>          SPECIFICATION STATEMENTS                 ANSI X3J3/90.4
<span id="line5896"></span>
<span id="line5897"></span>
<span id="line5898"></span>
<span id="line5899"></span>          If an external function has a len___ of (*) declared in  a
<span id="line5900"></span>          function  subprogram,  the function name must appear as
<span id="line5901"></span>          the name of a function in a FUNCTION or ENTRY statement
<span id="line5902"></span>          in  the  same  subprogram.   When a reference to such a
<span id="line5903"></span>          function is executed, the function assumes  the  length
<span id="line5904"></span>          specified in the referencing program unit.
<span id="line5905"></span>
<span id="line5906"></span>          The length specified for a character  function  in  the
<span id="line5907"></span>          program  unit  that  references the function must be an
<span id="line5908"></span>          integer constant expression and  must  agree  with  the
<span id="line5909"></span>          length  specified  in the subprogram that specifies the
<span id="line5910"></span>          function.  Note  that  there  always  is  agreement  of
<span id="line5911"></span>          length  if  a len___ of (*) is specified in the subprogram
<span id="line5912"></span>          that specifies the function.
<span id="line5913"></span>
<span id="line5914"></span>          If a character constant that has a symbolic name has a len
<span id="line5915"></span>          ___ of (*) declared, the constant assumes the length of
<span id="line5916"></span>          its corresponding constant expression  in  a  PARAMETER
<span id="line5917"></span>          statement.
<span id="line5918"></span>
<span id="line5919"></span>          The length specified for a character statement function
<span id="line5920"></span>          or  statement function dummy argument of type character
<span id="line5921"></span>          must be an integer constant expression.
<span id="line5922"></span>
<span id="line5923"></span>          8.5  IMPLICIT_Statement
<span id="line5924"></span>
<span id="line5925"></span>          An IMPLICIT statement is used to change or confirm  the
<span id="line5926"></span>          default implied integer and real typing.
<span id="line5927"></span>
<span id="line5928"></span>          The form of an IMPLICIT statement is:
<span id="line5929"></span>
<span id="line5930"></span>                        IMPLICIT typ___ (a_ [,a_]...) [,typ___ (a_ [,a_]...)]...
<span id="line5931"></span>
<span id="line5932"></span>          where: typ___ is one of INTEGER, REAL,  DOUBLE  PRECISION,
<span id="line5933"></span>                     COMPLEX, LOGICAL, or CHARACTER [*len___]
<span id="line5934"></span>
<span id="line5935"></span>                 a_   is either a single  letter  or  a  range  of
<span id="line5936"></span>                     single  letters  in  alphabetical  order.  A
<span id="line5937"></span>                     range is  denoted  by  the  first  and  last
<span id="line5938"></span>                     letter  of  the  range separated by a minus.
<span id="line5939"></span>                     Writing a range of letters a_918 - a_928  has  the
<span id="line5940"></span>                     same  effect as writing a list of the single
<span id="line5941"></span>                     letters a_918 through a_928.
<span id="line5942"></span>
<span id="line5943"></span>                 len___ is the length of the character entities  and
<span id="line5944"></span>                     is one of the following:
<span id="line5945"></span>
<span id="line5946"></span>                     (1) An unsigned, nonzero, integer constant
<span id="line5947"></span>
<span id="line5948"></span>                     (2) An  integer  constant  expression   (6..
<span id="line5949"></span>                         1.3.1)  enclosed in parentheses and with
<span id="line5950"></span>
<span id="line5951"></span>
<span id="line5952"></span>
<span id="line5953"></span>          FORTRAN 77 Full Language                       Page 8-8
<span id="line5954"></span>
<span id="line5955"></span>
<span id="line5956"></span>
<span id="line5957"></span>
<span id="line5958"></span>
<span id="line5959"></span>
<span id="line5960"></span>
<span id="line5961"></span>          SPECIFICATION STATEMENTS                 ANSI X3J3/90.4
<span id="line5962"></span>
<span id="line5963"></span>
<span id="line5964"></span>
<span id="line5965"></span>                         a positive value
<span id="line5966"></span>
<span id="line5967"></span>                     If len___ is not specified, the length is one.
<span id="line5968"></span>
<span id="line5969"></span>          An  IMPLICIT  statement  specifies  a  type   for   all
<span id="line5970"></span>          variables,   arrays,   symbolic   names  of  constants,
<span id="line5971"></span>          external  functions,  and  statement^   functions  that
<span id="line5972"></span>          begin   with   any   letter   that   appears   in   the
<span id="line5973"></span>          specification, either as a single letter or included in
<span id="line5974"></span>          a  range of letters.  IMPLICIT statements do not change
<span id="line5975"></span>          the type  of  any  intrinsic  functions.   An  IMPLICIT
<span id="line5976"></span>          statement   applies  only  to  the  program  unit  that
<span id="line5977"></span>          contains it.
<span id="line5978"></span>
<span id="line5979"></span>          Type  specification by an  IMPLICIT  statement  may  be
<span id="line5980"></span>          overridden  or  confirmed  for any particular variable,
<span id="line5981"></span>          array, symbolic name of a constant, external  function,
<span id="line5982"></span>          or  statement  function  name by the appearance of that
<span id="line5983"></span>          name   in   a   type-statement.    An   explicit   type
<span id="line5984"></span>          specification  in  a  FUNCTION  statement  overrides an
<span id="line5985"></span>          IMPLICIT  statement  for  the  name  of  that  function
<span id="line5986"></span>          subprogram.   Note  that  the length is also overridden
<span id="line5987"></span>          when a  particular  name  appears  in  a  CHARACTER  or
<span id="line5988"></span>          CHARACTER FUNCTION statement.
<span id="line5989"></span>
<span id="line5990"></span>          Within the specification statements of a program  unit,
<span id="line5991"></span>          IMPLICIT    statements    must    precede   all   other
<span id="line5992"></span>          specification statements except  PARAMETER  statements.
<span id="line5993"></span>          A  program  unit  may  contain  more  than one IMPLICIT
<span id="line5994"></span>          statement.
<span id="line5995"></span>
<span id="line5996"></span>          The same letter must not appear as a single letter,  or
<span id="line5997"></span>          be  included  in  a range of letters, more than once in
<span id="line5998"></span>          all of the IMPLICIT statements in a program unit.
<span id="line5999"></span>
<span id="line6000"></span>          8.6  PARAMETER_Statement
<span id="line6001"></span>
<span id="line6002"></span>          The PARAMETER statement is used to give  a  constant  a
<span id="line6003"></span>          symbolic name.
<span id="line6004"></span>
<span id="line6005"></span>          The form of a PARAMETER statement is:
<span id="line6006"></span>
<span id="line6007"></span>                               PARAMETER (p_=e_ [,p_=e_]...)
<span id="line6008"></span>
<span id="line6009"></span>          where: p_   is a symbolic name
<span id="line6010"></span>
<span id="line6011"></span>                 e_   is a constant expression (6.7)
<span id="line6012"></span>
<span id="line6013"></span>          If the symbolic name p_ is of type integer, real, double
<span id="line6014"></span>          precision,  or  complex, the corresponding expression e_
<span id="line6015"></span>          must be an arithmetic constant expression (6.1.3).   If
<span id="line6016"></span>
<span id="line6017"></span>
<span id="line6018"></span>
<span id="line6019"></span>          FORTRAN 77 Full Language                       Page 8-9
<span id="line6020"></span>
<span id="line6021"></span>
<span id="line6022"></span>
<span id="line6023"></span>
<span id="line6024"></span>
<span id="line6025"></span>
<span id="line6026"></span>
<span id="line6027"></span>          SPECIFICATION STATEMENTS                 ANSI X3J3/90.4
<span id="line6028"></span>
<span id="line6029"></span>
<span id="line6030"></span>
<span id="line6031"></span>          the  symbolic  name  p_ is of type character or logical,
<span id="line6032"></span>          the corresponding expression e_  must  be  a  character
<span id="line6033"></span>          constant  expression  (6.2.3)  or  a  logical  constant
<span id="line6034"></span>          expression (6.4.4), respectively.
<span id="line6035"></span>
<span id="line6036"></span>          Each p_ is the symbolic name of a constant that  becomes
<span id="line6037"></span>          defined with the value determined from the expression e_
<span id="line6038"></span>          that appears on the right of the equals, in  accordance
<span id="line6039"></span>          with  the  rules for assignment statements (10.1, 10.2,
<span id="line6040"></span>          and 10.4).
<span id="line6041"></span>
<span id="line6042"></span>          Any symbolic name of a  constant  that  appears  in  an
<span id="line6043"></span>          expression  e_ must have been defined previously in the
<span id="line6044"></span>          same or a different PARAMETER  statement  in  the  same
<span id="line6045"></span>          program unit.
<span id="line6046"></span>
<span id="line6047"></span>          A symbolic name of a constant must not  become  defined
<span id="line6048"></span>          more than once in a program unit.
<span id="line6049"></span>
<span id="line6050"></span>          If a symbolic name of a  constant  is  not  of  default
<span id="line6051"></span>          implied  type,  its  type  must be specified by a type-
<span id="line6052"></span>          statement or IMPLICIT  statement  prior  to  its  first
<span id="line6053"></span>          appearance  in  a  PARAMETER  statement.  If the length
<span id="line6054"></span>          specified for the symbolic name of a constant  of  type
<span id="line6055"></span>          character  is not the default length of one, its length
<span id="line6056"></span>          must be  specified  in  a  type-statement  or  IMPLICIT
<span id="line6057"></span>          statement prior to the first appearance of the symbolic
<span id="line6058"></span>          name of the constant.  Its length must not  be  changed
<span id="line6059"></span>          by subsequent statements including IMPLICIT statements.
<span id="line6060"></span>
<span id="line6061"></span>          Once such a symbolic name is  defined,  that  name  may
<span id="line6062"></span>          appear in that program unit in any subsequent statement
<span id="line6063"></span>          as a primary in an expression or in  a  DATA  statement
<span id="line6064"></span>          (9.1).   A symbolic name of a constant must not be part
<span id="line6065"></span>          of a  format  specification.   A  symbolic  name  of  a
<span id="line6066"></span>          constant  must  not  be  used  to  form part of another
<span id="line6067"></span>          constant, for example, any part of a complex constant.
<span id="line6068"></span>
<span id="line6069"></span>          A symbolic name in a PARAMETER statement  may  identify
<span id="line6070"></span>          only the corresponding constant in that program unit.
<span id="line6071"></span>
<span id="line6072"></span>          8.7  EXTERNAL_Statement
<span id="line6073"></span>
<span id="line6074"></span>          An EXTERNAL statement is used to  identify  a  symbolic
<span id="line6075"></span>          name  as  representing  an  external procedure or dummy
<span id="line6076"></span>          procedure, and to permit such a name to be used  as  an
<span id="line6077"></span>          actual argument.
<span id="line6078"></span>
<span id="line6079"></span>          The form of an EXTERNAL statement is:
<span id="line6080"></span>
<span id="line6081"></span>
<span id="line6082"></span>
<span id="line6083"></span>
<span id="line6084"></span>
<span id="line6085"></span>          FORTRAN 77 Full Language                      Page 8-10
<span id="line6086"></span>
<span id="line6087"></span>
<span id="line6088"></span>
<span id="line6089"></span>
<span id="line6090"></span>
<span id="line6091"></span>
<span id="line6092"></span>
<span id="line6093"></span>          SPECIFICATION STATEMENTS                 ANSI X3J3/90.4
<span id="line6094"></span>
<span id="line6095"></span>
<span id="line6096"></span>
<span id="line6097"></span>                               EXTERNAL proc____ [,proc____]...
<span id="line6098"></span>
<span id="line6099"></span>          where each proc____ is the name of an  external  procedure,
<span id="line6100"></span>          dummy  procedure, or block data subprogram.  Appearance
<span id="line6101"></span>          of a name in an EXTERNAL statement declares  that  name
<span id="line6102"></span>          to  be  an  external  procedure name or dummy procedure
<span id="line6103"></span>          name, or block data subprogram name.   If  an  external
<span id="line6104"></span>          procedure  na`)me  or a dummy procedure name is used as
<span id="line6105"></span>          an actual argument in a program unit, it must appear in
<span id="line6106"></span>          an  EXTERNAL statement in that program unit.  Note that
<span id="line6107"></span>          a  statement  function  name  must  not  appear  in  an
<span id="line6108"></span>          EXTERNAL statement.
<span id="line6109"></span>
<span id="line6110"></span>          If an intrinsic function name appears  in  an  EXTERNAL
<span id="line6111"></span>          statement in a program unit, that name becomes the name
<span id="line6112"></span>          of some external procedure and an intrinsic function of
<span id="line6113"></span>          the  same  name  is  not available for reference in the
<span id="line6114"></span>          program unit.
<span id="line6115"></span>
<span id="line6116"></span>          Only one appearance of a symbolic name in  all  of  the
<span id="line6117"></span>          EXTERNAL statements of a program unit is permitted.
<span id="line6118"></span>
<span id="line6119"></span>          8.8  INTRINSIC_Statement
<span id="line6120"></span>
<span id="line6121"></span>          An INTRINSIC statement is used to identify  a  symbolic
<span id="line6122"></span>          name  as representing an intrinsic function (15.3).  It
<span id="line6123"></span>          also  permits  a  name  that  represents   a   specific
<span id="line6124"></span>          intrinsic function to be used as an actual argument.
<span id="line6125"></span>
<span id="line6126"></span>          The form of an INTRINSIC statement is:
<span id="line6127"></span>
<span id="line6128"></span>                               INTRINSIC fun___ [,fun___]...
<span id="line6129"></span>
<span id="line6130"></span>          where each fun___ is an intrinsic function name.
<span id="line6131"></span>
<span id="line6132"></span>          Appearance of a name in an INTRINSIC statement declares
<span id="line6133"></span>          that  name  to  be  an  intrinsic  function name.  If a
<span id="line6134"></span>          specific name of an intrinsic function is  used  as  an
<span id="line6135"></span>          actual argument in a program unit, it must appear in an
<span id="line6136"></span>          INTRINSIC statement in that program unit.  The names of
<span id="line6137"></span>          intrinsic  functions  for  type  conversion (INT, IFIX,
<span id="line6138"></span>          IDINT, FLOAT, SNGL, REAL, DBLE,  CMPLX,  ICHAR,  CHAR),
<span id="line6139"></span>          lexical  relationship  (LGE,  LGT,  LLE,  LLT), and for
<span id="line6140"></span>          choosing the largest  or  smallest  value  (MAX,  MAX0,
<span id="line6141"></span>          AMAX1,  DMAX1,  AMAX0,  MAX1,  MIN, MIN0, AMIN1, DMIN1,
<span id="line6142"></span>          AMIN0, MIN1) must not be used as actual arguments.
<span id="line6143"></span>
<span id="line6144"></span>          The  appearance  of  a  generic  function  name  in  an
<span id="line6145"></span>          INTRINSIC  statement  does  not cause that name to lose
<span id="line6146"></span>          its generic property.
<span id="line6147"></span>
<span id="line6148"></span>
<span id="line6149"></span>
<span id="line6150"></span>
<span id="line6151"></span>          FORTRAN 77 Full Language                      Page 8-11
<span id="line6152"></span>
<span id="line6153"></span>
<span id="line6154"></span>
<span id="line6155"></span>
<span id="line6156"></span>
<span id="line6157"></span>
<span id="line6158"></span>
<span id="line6159"></span>          SPECIFICATION STATEMENTS                 ANSI X3J3/90.4
<span id="line6160"></span>
<span id="line6161"></span>
<span id="line6162"></span>
<span id="line6163"></span>          Only one appearance of a symbolic name in  all  of  the
<span id="line6164"></span>          INTRINSIC  statements  of  a program unit is permitted.
<span id="line6165"></span>          Note that a symbolic name must not appear  in  both  an
<span id="line6166"></span>          EXTERNAL and an INTRINSIC statement in a program unit.
<span id="line6167"></span>
<span id="line6168"></span>          8.9  SAVE_Statement
<span id="line6169"></span>
<span id="line6170"></span>          A SAVE statement  is  used  to  retain  the  definition
<span id="line6171"></span>          status  of an entity after the execution of a RETURN or
<span id="line6172"></span>          END statement in a subprogram.  Within  a  function  or
<span id="line6173"></span>          subroutine  subprogram,  an  entity specified by a SAVE
<span id="line6174"></span>          statement does not become undefined as a result of  the
<span id="line6175"></span>          execution   of   a  RETURN  or  END  statement  in  the
<span id="line6176"></span>          subprogram.  However, such an entity in a common  block
<span id="line6177"></span>          may  become  undefined  or redefined in another program
<span id="line6178"></span>          unit.
<span id="line6179"></span>
<span id="line6180"></span>          The form of a SAVE statement is:
<span id="line6181"></span>
<span id="line6182"></span>                               SAVE [a_ [,a_]...]
<span id="line6183"></span>
<span id="line6184"></span>          where each a_ is a named common block name preceded  and
<span id="line6185"></span>          followed by a slash, a variable name, or an array name.
<span id="line6186"></span>          Redundant appearances of an item are not permitted.
<span id="line6187"></span>
<span id="line6188"></span>          Dummy argument names, procedure  names,  and  names  of
<span id="line6189"></span>          entities  in  a  common block must not appear in a SAVE
<span id="line6190"></span>          statement.
<span id="line6191"></span>
<span id="line6192"></span>          A SAVE statement without a list is treated as though it
<span id="line6193"></span>          contained  the  names  of  all  allowable  items in the
<span id="line6194"></span>          program unit.
<span id="line6195"></span>
<span id="line6196"></span>          The appearance of a  common  block  name  preceded  and
<span id="line6197"></span>          followed  by a slash in a SAVE statement has the effect
<span id="line6198"></span>          of specifying all of the entities in that common block.
<span id="line6199"></span>
<span id="line6200"></span>          If a particular common block name  is  specified  by  a
<span id="line6201"></span>          SAVE   statement  in  a  subprogram  of  an  executable
<span id="line6202"></span>          program, it must be specified by a  SAVE  statement  in
<span id="line6203"></span>          every subprogram in which that common block appears.
<span id="line6204"></span>
<span id="line6205"></span>          A SAVE statement is optional in a main program and  has
<span id="line6206"></span>          no effect.
<span id="line6207"></span>
<span id="line6208"></span>          If  a  named  common  block  is  specified  in  a  SAVE
<span id="line6209"></span>          statement  in  a  subprogram, the current values of the
<span id="line6210"></span>          entities in the common block storage  sequence  (8.3.3)
<span id="line6211"></span>          at  the  time a RETURN or END statement is executed are
<span id="line6212"></span>          made available to the next program unit that  specifies
<span id="line6213"></span>          that  common block name in the execution sequence of an
<span id="line6214"></span>
<span id="line6215"></span>
<span id="line6216"></span>
<span id="line6217"></span>          FORTRAN 77 Full Language                      Page 8-12
<span id="line6218"></span>
<span id="line6219"></span>
<span id="line6220"></span>
<span id="line6221"></span>
<span id="line6222"></span>
<span id="line6223"></span>
<span id="line6224"></span>
<span id="line6225"></span>          SPECIFICATION STATEMENTS                 ANSI X3J3/90.4
<span id="line6226"></span>
<span id="line6227"></span>
<span id="line6228"></span>
<span id="line6229"></span>          executable program.
<span id="line6230"></span>
<span id="line6231"></span>          If a named  common  block  is  specified  in  the  main
<span id="line6232"></span>          program  unit,  the  current values of the common block
<span id="line6233"></span>          storage sequence are made available to each  subprogram
<span id="line6234"></span>          that   specifies   that  named  common  block;  a  SAVE
<span id="line6235"></span>          statement in the subprogram has no effect.
<span id="line6236"></span>
<span id="line6237"></span>          The definition status  of  each  entity  in  the  named
<span id="line6238"></span>          common   block   storage   sequence   depends   on  the
<span id="line6239"></span>          association that has been established  for  the  common
<span id="line6240"></span>          block storage sequence (17.2 and 17.3).
<span id="line6241"></span>
<span id="line6242"></span>          If a local entity that is specified by a SAVE statement
<span id="line6243"></span>          and  is  not in a common block is in a defined state at
<span id="line6244"></span>          the time a RETURN or END statement  is  executed  in  a
<span id="line6245"></span>          subprogram,  that entity is defined with the same value
<span id="line6246"></span>          at the next reference of that subprogram.
<span id="line6247"></span>
<span id="line6248"></span>          The execution of a RETURN statement or an END statement
<span id="line6249"></span>          within  a  subprogram  causes  all  entities within the
<span id="line6250"></span>          subprogram  to  become   undefined   except   for   the
<span id="line6251"></span>          following:
<span id="line6252"></span>
<span id="line6253"></span>             (1) Entities specified by SAVE statements
<span id="line6254"></span>
<span id="line6255"></span>             (2) Entities in blank common
<span id="line6256"></span>
<span id="line6257"></span>             (3) Initially defined  entities  that  have  neither
<span id="line6258"></span>                 been redefined nor become undefined
<span id="line6259"></span>
<span id="line6260"></span>             (4) Entities in a named common block that appears in
<span id="line6261"></span>                 the subprogram and appears in at least one other
<span id="line6262"></span>                 program  unit  that   is   referencing,   either
<span id="line6263"></span>                 directly or indirectly, that subprogram
<span id="line6264"></span>
<span id="line6265"></span>
<span id="line6266"></span>
<span id="line6267"></span>
<span id="line6268"></span>
<span id="line6269"></span>
<span id="line6270"></span>
<span id="line6271"></span>
<span id="line6272"></span>
<span id="line6273"></span>
<span id="line6274"></span>
<span id="line6275"></span>
<span id="line6276"></span>
<span id="line6277"></span>
<span id="line6278"></span>
<span id="line6279"></span>
<span id="line6280"></span>
<span id="line6281"></span>
<span id="line6282"></span>
<span id="line6283"></span>          FORTRAN 77 Full Language                      Page 8-13
<span id="line6284"></span>
<span id="line6285"></span>
<span id="line6286"></span>
<span id="line6287"></span>
<span id="line6288"></span>
<span id="line6289"></span>
<span id="line6290"></span>
<span id="line6291"></span>
<span id="line6292"></span>
<span id="line6293"></span>
<span id="line6294"></span>
<span id="line6295"></span>                                 CONTENTS
<span id="line6296"></span>
<span id="line6297"></span>
<span id="line6298"></span>          8.  SPECIFICATION STATEMENTS.....................   8-1
<span id="line6299"></span>              8.1  DIMENSION Statement.....................   8-1
<span id="line6300"></span>              8.2  EQUIVALENCE Statement...................   8-1
<span id="line6301"></span>                   8.2.1  Form of an EQUIVALENCE
<span id="line6302"></span>                          Statement........................   8-2
<span id="line6303"></span>                   8.2.2  Equivalence Association..........   8-2
<span id="line6304"></span>                   8.2.3  Equivalence of Character
<span id="line6305"></span>                          Entities.........................   8-2
<span id="line6306"></span>                   8.2.4  Array Names and Array Element
<span id="line6307"></span>                          Names............................   8-3
<span id="line6308"></span>                   8.2.5  Restrictions on EQUIVALENCE
<span id="line6309"></span>                          Statements.......................   8-3
<span id="line6310"></span>              8.3  COMMON Statement........................   8-3
<span id="line6311"></span>                   8.3.1  Form of a COMMON
<span id="line6312"></span>                          Statement........................   8-3
<span id="line6313"></span>                   8.3.2  Common Block Storage
<span id="line6314"></span>                          Sequence.........................   8-4
<span id="line6315"></span>                   8.3.3  Size of a Common Block...........   8-5
<span id="line6316"></span>                   8.3.4  Common Association...............   8-5
<span id="line6317"></span>                   8.3.5  Differences between Named Common
<span id="line6318"></span>                          and Blank Common.................   8-5
<span id="line6319"></span>                   8.3.6  Restrictions on Common and
<span id="line6320"></span>                          Equivalence......................   8-5
<span id="line6321"></span>              8.4  Type-Statements.........................   8-6
<span id="line6322"></span>                   8.4.1  INTEGER, REAL, DOUBLE PRECISION,
<span id="line6323"></span>                          COMPLEX, and LOGICAL Type-
<span id="line6324"></span>                          Statements.......................   8-6
<span id="line6325"></span>                   8.4.2  CHARACTER Type-Statement.........   8-6
<span id="line6326"></span>              8.5  IMPLICIT Statement......................   8-8
<span id="line6327"></span>              8.6  PARAMETER Statement.....................   8-9
<span id="line6328"></span>              8.7  EXTERNAL Statement......................  8-10
<span id="line6329"></span>              8.8  INTRINSIC Statement.....................  8-11
<span id="line6330"></span>              8.9  SAVE Statement..........................  8-12
<span id="line6331"></span>
<span id="line6332"></span>
<span id="line6333"></span>
<span id="line6334"></span>
<span id="line6335"></span>
<span id="line6336"></span>
<span id="line6337"></span>
<span id="line6338"></span>
<span id="line6339"></span>
<span id="line6340"></span>
<span id="line6341"></span>
<span id="line6342"></span>
<span id="line6343"></span>
<span id="line6344"></span>
<span id="line6345"></span>
<span id="line6346"></span>
<span id="line6347"></span>
<span id="line6348"></span>
<span id="line6349"></span>                                   - i -
<span id="line6350"></span>
<span id="line6351"></span>
<span id="line6352"></span>
<span id="line6353"></span>
<span id="line6354"></span>
<span id="line6355"></span>
<span id="line6356"></span>
<span id="line6357"></span>                                                   ANSI X3J3/90.4
<span id="line6358"></span>
<span id="line6359"></span>
<span id="line6360"></span>
<span id="line6361"></span>                            9.  DATA_STATEMENT
<span id="line6362"></span>
<span id="line6363"></span>          A DATA statement is used to provide initial values  for
<span id="line6364"></span>          variables,  arrays,  array elements, and substrings.  A
<span id="line6365"></span>          DATA statement is nonexecutable and  may  appear  in  a
<span id="line6366"></span>          program   unit   anywhere   after   the   specification
<span id="line6367"></span>          statements, if any.
<span id="line6368"></span>
<span id="line6369"></span>          All  initially  defined  entities are defined  when  an
<span id="line6370"></span>          executable program begins execution.  All entities  not
<span id="line6371"></span>          initially defined,  or  associated  with  an  initially
<span id="line6372"></span>          defined  entity,   are  undefined  at  the beginning of
<span id="line6373"></span>          execution of an executable program.
<span id="line6374"></span>
<span id="line6375"></span>          9.1  Form_of_a_DATA_Statement
<span id="line6376"></span>
<span id="line6377"></span>          The form of a DATA statement is:
<span id="line6378"></span>
<span id="line6379"></span>                               DATA nlist_____ /clist_____/ [[,] nlist_____ /clist_____/]...
<span id="line6380"></span>
<span id="line6381"></span>          where: nlist_____ is a list (2.10) of variable names,  array
<span id="line6382"></span>                     names, array element names, substring names,
<span id="line6383"></span>                     and implied-DO lists
<span id="line6384"></span>
<span id="line6385"></span>                 clist_____ is a list of the form:
<span id="line6386"></span>
<span id="line6387"></span>                     a_ [,a_]...
<span id="line6388"></span>
<span id="line6389"></span>                 where a_ is one of the forms:
<span id="line6390"></span>
<span id="line6391"></span>                         c_
<span id="line6392"></span>                         r_*c_
<span id="line6393"></span>
<span id="line6394"></span>                     c_   is a constant or the symbolic name of  a
<span id="line6395"></span>                         constant
<span id="line6396"></span>
<span id="line6397"></span>                     r_   is a nonzero, unsigned, integer constant
<span id="line6398"></span>                         or the symbolic name of such a constant.
<span id="line6399"></span>                         The r_ *c_  form  is  equivalent  to  r_
<span id="line6400"></span>                         successive appearances of the constant c_
<span id="line6401"></span>                         .
<span id="line6402"></span>
<span id="line6403"></span>          9.2  DATA_Statement_Restrictions
<span id="line6404"></span>
<span id="line6405"></span>          Names of dummy arguments, functions,  and  entities  in
<span id="line6406"></span>          blank  common  (including  entities  associated with an
<span id="line6407"></span>          entity in blank common) must not appear in the list nlist___
<span id="line6408"></span>          _ _ .   Names  of  entities in a named common block may
<span id="line6409"></span>          appear in the list nlist____ _  only  within  a  block  data
<span id="line6410"></span>          subprogram.
<span id="line6411"></span>
<span id="line6412"></span>
<span id="line6413"></span>
<span id="line6414"></span>
<span id="line6415"></span>          FORTRAN 77 Full Language                       Page 9-1
<span id="line6416"></span>
<span id="line6417"></span>
<span id="line6418"></span>
<span id="line6419"></span>
<span id="line6420"></span>
<span id="line6421"></span>
<span id="line6422"></span>
<span id="line6423"></span>          DATA STATEMENT                           ANSI X3J3/90.4
<span id="line6424"></span>
<span id="line6425"></span>
<span id="line6426"></span>
<span id="line6427"></span>          There must be the same number  of  items  specified  by
<span id="line6428"></span>          each  list  nlist_ _ _ __ and its corresponding list clist_____.
<span id="line6429"></span>          There is a one-to-one correspondence between the  items
<span id="line6430"></span>          specified by nlist_____ and the constants specified by clist_____
<span id="line6431"></span>          such that the first item of nlist_____  corresponds  to  the
<span id="line6432"></span>          first  constant of clist_____, etc.  By this correspondence,
<span id="line6433"></span>          the initial value is  established  and  the  entity  is
<span id="line6434"></span>          initially   defined.    If  an  array  name  without  a
<span id="line6435"></span>          subscript is in the list, there must  be  one  constant
<span id="line6436"></span>          for  each element of that array.  The ordering of array
<span id="line6437"></span>          elements is determined by the array  element  subscript
<span id="line6438"></span>          value (5.2.4).
<span id="line6439"></span>
<span id="line6440"></span>          The type of the nlist____ _  entity  and  the  type  of  the
<span id="line6441"></span>          corresponding  clist_____ constant must agree when either is
<span id="line6442"></span>          of type character or logical.  When the nlist_____ entity is
<span id="line6443"></span>          of  type  integer, real, double  precision, or complex,
<span id="line6444"></span>          the 1corresponding clist_____ constant must also be of  type
<span id="line6445"></span>          integer,   real,   double  precision,  or  complex;  if
<span id="line6446"></span>          necessary, the clist_____ constant is converted to the  type
<span id="line6447"></span>          of  the  nlist_ _ _ _ _  entity  according to the rules for
<span id="line6448"></span>          arithmetic conversion (Table 4).  Note that if an nlist_____
<span id="line6449"></span>          entity  is  of  type  double  precision  and  the clist_____
<span id="line6450"></span>          constant is of type real, the processor may supply more
<span id="line6451"></span>          precision   derived  from  the  constant  than  can  be
<span id="line6452"></span>          contained in a real datum.
<span id="line6453"></span>
<span id="line6454"></span>          Any  variable,  array  element,  or  substring  may  be
<span id="line6455"></span>          initially defined except for:
<span id="line6456"></span>
<span id="line6457"></span>             (1) an entity that is a dummy argument,
<span id="line6458"></span>
<span id="line6459"></span>             (2) an entity in blank  common,  which  includes  an
<span id="line6460"></span>                 entity   associated  with  an  entity  in  blank
<span id="line6461"></span>                 common, or
<span id="line6462"></span>
<span id="line6463"></span>             (3) a variable in a function subprogram  whose  name
<span id="line6464"></span>                 is  also  the name of the function subprogram or
<span id="line6465"></span>                 an entry in the function subprogram.
<span id="line6466"></span>
<span id="line6467"></span>          A variable, array element, or  substring  must  not  be
<span id="line6468"></span>          initially  defined  more  than  once  in  an executable
<span id="line6469"></span>          program.  If two entities are associated, only one  may
<span id="line6470"></span>          be  initially  defined  in a DATA statement in the same
<span id="line6471"></span>          executable program.
<span id="line6472"></span>
<span id="line6473"></span>          Each subscript expression in the list nlist_____ must be  an
<span id="line6474"></span>          integer  constant  expression  except  for  implied-DO-
<span id="line6475"></span>          variables as noted in 9.3.  Each  substring  expression
<span id="line6476"></span>          in  the  list  nlist_ _ _ _ _  must  be an integer constant
<span id="line6477"></span>          expression.
<span id="line6478"></span>
<span id="line6479"></span>
<span id="line6480"></span>
<span id="line6481"></span>          FORTRAN 77 Full Language                       Page 9-2
<span id="line6482"></span>
<span id="line6483"></span>
<span id="line6484"></span>
<span id="line6485"></span>
<span id="line6486"></span>
<span id="line6487"></span>
<span id="line6488"></span>
<span id="line6489"></span>          DATA STATEMENT                           ANSI X3J3/90.4
<span id="line6490"></span>
<span id="line6491"></span>
<span id="line6492"></span>
<span id="line6493"></span>          9.3  Implied-DO_in_a_DATA_Statement
<span id="line6494"></span>
<span id="line6495"></span>          The form of an implied-DO list in a DATA statement is:
<span id="line6496"></span>
<span id="line6497"></span>                               ( dlist_____, i_ = m_918,  m_928 [,m_938 ] )
<span id="line6498"></span>
<span id="line6499"></span>          where: dlist_____ is a  list  of  array  element  names  and
<span id="line6500"></span>                     implied-DO lists
<span id="line6501"></span>
<span id="line6502"></span>                 i_   is the name of an integer  variable,  called
<span id="line6503"></span>                     the implied_______-DO__-variable________
<span id="line6504"></span>
<span id="line6505"></span>                 m_91,8 m_92,8 m_938 are  each  an   integer   constant
<span id="line6506"></span>                     expression,  except  that the expression may
<span id="line6507"></span>                     contain  implied-  DO-variables   of   other
<span id="line6508"></span>                     implied-DO  lists  that have this implied-DO
<span id="line6509"></span>                     list within their ranges
<span id="line6510"></span>
<span id="line6511"></span>          The range of an implied-DO list is the list dlist_____.   An
<span id="line6512"></span>          iteration  count  and  the  values  of  the implied-DO-
<span id="line6513"></span>          variable are established from m_918, m_928, and m_938 exactly as
<span id="line6514"></span>          for  a DO-loop (11.10), except that the iteration count
<span id="line6515"></span>          must be positive.  When an implied-DO list appears in a
<span id="line6516"></span>          DATA  statement,  the list items in dlist_____ are specified
<span id="line6517"></span>          once for each iteration of the implied-DO list with the
<span id="line6518"></span>          appropriate  substitution  of values for any occurrence
<span id="line6519"></span>          of the implied-DO-variable i_.   The  appearance  of  an
<span id="line6520"></span>          implied-DO-variable  name  in a DATA statement does not
<span id="line6521"></span>          affect the definition status of a variable of the  same
<span id="line6522"></span>          name in the same program unit.
<span id="line6523"></span>
<span id="line6524"></span>          Each subscript expression in the list dlist_____ must be  an
<span id="line6525"></span>          integer constant expression, except that the expression
<span id="line6526"></span>          may contain implied-DO-variables  of  implied-DO  lists
<span id="line6527"></span>          that have the subscript expression within their ranges.
<span id="line6528"></span>
<span id="line6529"></span>          The following is an example of a  DATA  statement  that
<span id="line6530"></span>          contains implied-DO lists:
<span id="line6531"></span>
<span id="line6532"></span>                               DATA (( X(J,I), I=1,J), J=1,5) / 15*0. /
<span id="line6533"></span>
<span id="line6534"></span>          9.4  Character_Constant_in_a_DATA_Statement
<span id="line6535"></span>
<span id="line6536"></span>          An entity in the list nlist___ _ _  that  corresponds  to  a
<span id="line6537"></span>          character constant must be of type character.
<span id="line6538"></span>
<span id="line6539"></span>          If the length of the character entity in the list nlist_____
<span id="line6540"></span>          is  greater  than  the  length   of  its  corresponding
<span id="line6541"></span>          character   constant,    the    additional    rightmost
<span id="line6542"></span>          characters  in  the  entity  are initially defined with
<span id="line6543"></span>          blank characters.
<span id="line6544"></span>
<span id="line6545"></span>
<span id="line6546"></span>
<span id="line6547"></span>          FORTRAN 77 Full Language                       Page 9-3
<span id="line6548"></span>
<span id="line6549"></span>
<span id="line6550"></span>
<span id="line6551"></span>
<span id="line6552"></span>
<span id="line6553"></span>
<span id="line6554"></span>
<span id="line6555"></span>          DATA STATEMENT                           ANSI X3J3/90.4
<span id="line6556"></span>
<span id="line6557"></span>
<span id="line6558"></span>
<span id="line6559"></span>          If the length of the character entity in the list nlist_____
<span id="line6560"></span>          is  less than the length of its corresponding character
<span id="line6561"></span>          constant, the additional rightmost  characters  in  the
<span id="line6562"></span>          constant are ignored.
<span id="line6563"></span>
<span id="line6564"></span>          Note that initial  definition  of  a  character  entity
<span id="line6565"></span>          causes  definition  of  all  of  the  characters in the
<span id="line6566"></span>          entity, and  that  each  character  constant  initially
<span id="line6567"></span>          defines   exactly   one  variable,  array  element,  or
<span id="line6568"></span>          substring.
<span id="line6569"></span>
<span id="line6570"></span>
<span id="line6571"></span>
<span id="line6572"></span>
<span id="line6573"></span>
<span id="line6574"></span>
<span id="line6575"></span>
<span id="line6576"></span>
<span id="line6577"></span>
<span id="line6578"></span>
<span id="line6579"></span>
<span id="line6580"></span>
<span id="line6581"></span>
<span id="line6582"></span>
<span id="line6583"></span>
<span id="line6584"></span>
<span id="line6585"></span>
<span id="line6586"></span>
<span id="line6587"></span>
<span id="line6588"></span>
<span id="line6589"></span>
<span id="line6590"></span>
<span id="line6591"></span>
<span id="line6592"></span>
<span id="line6593"></span>
<span id="line6594"></span>
<span id="line6595"></span>
<span id="line6596"></span>
<span id="line6597"></span>
<span id="line6598"></span>
<span id="line6599"></span>
<span id="line6600"></span>
<span id="line6601"></span>
<span id="line6602"></span>
<span id="line6603"></span>
<span id="line6604"></span>
<span id="line6605"></span>
<span id="line6606"></span>
<span id="line6607"></span>
<span id="line6608"></span>
<span id="line6609"></span>
<span id="line6610"></span>
<span id="line6611"></span>
<span id="line6612"></span>
<span id="line6613"></span>          FORTRAN 77 Full Language                       Page 9-4
<span id="line6614"></span>
<span id="line6615"></span>
<span id="line6616"></span>
<span id="line6617"></span>
<span id="line6618"></span>
<span id="line6619"></span>
<span id="line6620"></span>
<span id="line6621"></span>
<span id="line6622"></span>
<span id="line6623"></span>
<span id="line6624"></span>
<span id="line6625"></span>                                 CONTENTS
<span id="line6626"></span>
<span id="line6627"></span>
<span id="line6628"></span>          9.  DATA STATEMENT................................  9-1
<span id="line6629"></span>              9.1  Form of a DATA Statement.................  9-1
<span id="line6630"></span>              9.2  DATA Statement Restrictions..............  9-1
<span id="line6631"></span>              9.3  Implied-DO in a DATA Statement...........  9-3
<span id="line6632"></span>              9.4  Character Constant in a DATA
<span id="line6633"></span>                   Statement................................  9-3
<span id="line6634"></span>
<span id="line6635"></span>
<span id="line6636"></span>
<span id="line6637"></span>
<span id="line6638"></span>
<span id="line6639"></span>
<span id="line6640"></span>
<span id="line6641"></span>
<span id="line6642"></span>
<span id="line6643"></span>
<span id="line6644"></span>
<span id="line6645"></span>
<span id="line6646"></span>
<span id="line6647"></span>
<span id="line6648"></span>
<span id="line6649"></span>
<span id="line6650"></span>
<span id="line6651"></span>
<span id="line6652"></span>
<span id="line6653"></span>
<span id="line6654"></span>
<span id="line6655"></span>
<span id="line6656"></span>
<span id="line6657"></span>
<span id="line6658"></span>
<span id="line6659"></span>
<span id="line6660"></span>
<span id="line6661"></span>
<span id="line6662"></span>
<span id="line6663"></span>
<span id="line6664"></span>
<span id="line6665"></span>
<span id="line6666"></span>
<span id="line6667"></span>
<span id="line6668"></span>
<span id="line6669"></span>
<span id="line6670"></span>
<span id="line6671"></span>
<span id="line6672"></span>
<span id="line6673"></span>
<span id="line6674"></span>
<span id="line6675"></span>
<span id="line6676"></span>
<span id="line6677"></span>
<span id="line6678"></span>
<span id="line6679"></span>                                   - i -
<span id="line6680"></span>
<span id="line6681"></span>
<span id="line6682"></span>
<span id="line6683"></span>
<span id="line6684"></span>
<span id="line6685"></span>
<span id="line6686"></span>
<span id="line6687"></span>                                                   ANSI X3J3/90.4
<span id="line6688"></span>
<span id="line6689"></span>
<span id="line6690"></span>
<span id="line6691"></span>                        10.  ASSIGNMENT_STATEMENTS
<span id="line6692"></span>
<span id="line6693"></span>          Completion of  execution  of  an  assignment  statement
<span id="line6694"></span>          causes definition of an entity.
<span id="line6695"></span>
<span id="line6696"></span>          There are four kinds of assignment statements:
<span id="line6697"></span>
<span id="line6698"></span>             (1) Arithmetic
<span id="line6699"></span>
<span id="line6700"></span>             (2) Logical
<span id="line6701"></span>
<span id="line6702"></span>             (3) Statement label (ASSIGN)
<span id="line6703"></span>
<span id="line6704"></span>             (4) Character
<span id="line6705"></span>
<span id="line6706"></span>          10.1  Arithmetic_Assignment_Statement
<span id="line6707"></span>
<span id="line6708"></span>          The form of an arithmetic assignment statement is:
<span id="line6709"></span>
<span id="line6710"></span>                               v_ = e_
<span id="line6711"></span>
<span id="line6712"></span>          where: v_   is the name of a variable or  array  element
<span id="line6713"></span>                     of  type integer, real, double precision, or
<span id="line6714"></span>                     complex
<span id="line6715"></span>
<span id="line6716"></span>                 e_   is an arithmetic expression
<span id="line6717"></span>
<span id="line6718"></span>          Execution of an arithmetic assignment statement  causes
<span id="line6719"></span>          the  evaluation  of  the  expression  e_ by the rules in
<span id="line6720"></span>          Section 6, conversion of e_ to  the  type  of  v_ ,  and
<span id="line6721"></span>          definition  and  assignment  of  v_  with the resulting
<span id="line6722"></span>          value, as established by the rules in Table 4.
<span id="line6723"></span>
<span id="line6724"></span>                                  Table 4
<span id="line6725"></span>
<span id="line6726"></span>              Arithmetic Conversion and Assignment of e_ to v_
<span id="line6727"></span>8                       _____________________________
<span id="line6728"></span>
<span id="line6729"></span>                        Type of v_          Value
<span id="line6730"></span>                                           Assigned
<span id="line6731"></span>8                       _____________________________
<span id="line6732"></span>
<span id="line6733"></span>                        Integer            INT(e_)
<span id="line6734"></span>8                       _____________________________
<span id="line6735"></span>
<span id="line6736"></span>                        Real               REAL(e_)
<span id="line6737"></span>8                       _____________________________
<span id="line6738"></span>
<span id="line6739"></span>                        Double precision   DBLE(e_)
<span id="line6740"></span>8                       _____________________________
<span id="line6741"></span>
<span id="line6742"></span>                        Complex            CMPLX(e_)
<span id="line6743"></span>8                       _____________________________
<span id="line6744"></span>7                      |8|7|7|7|7|7|7|7|7|7|7|7|7|
<span id="line6745"></span>
<span id="line6746"></span>
<span id="line6747"></span>
<span id="line6748"></span>
<span id="line6749"></span>
<span id="line6750"></span>
<span id="line6751"></span>
<span id="line6752"></span>
<span id="line6753"></span>
<span id="line6754"></span>
<span id="line6755"></span>
<span id="line6756"></span>9                                        |8|7|7|7|7|7|7|7|7|7|7|7|7|
<span id="line6757"></span>
<span id="line6758"></span>
<span id="line6759"></span>
<span id="line6760"></span>
<span id="line6761"></span>
<span id="line6762"></span>
<span id="line6763"></span>
<span id="line6764"></span>
<span id="line6765"></span>
<span id="line6766"></span>
<span id="line6767"></span>
<span id="line6768"></span>9                                                   |8|7|7|7|7|7|7|7|7|7|7|7|7|
<span id="line6769"></span>
<span id="line6770"></span>
<span id="line6771"></span>
<span id="line6772"></span>
<span id="line6773"></span>
<span id="line6774"></span>
<span id="line6775"></span>
<span id="line6776"></span>
<span id="line6777"></span>
<span id="line6778"></span>
<span id="line6779"></span>
<span id="line6780"></span>
<span id="line6781"></span>
<span id="line6782"></span>9
<span id="line6783"></span>
<span id="line6784"></span>
<span id="line6785"></span>          FORTRAN 77 Full Language                      Page 10-1
<span id="line6786"></span>
<span id="line6787"></span>
<span id="line6788"></span>
<span id="line6789"></span>
<span id="line6790"></span>
<span id="line6791"></span>
<span id="line6792"></span>
<span id="line6793"></span>          ASSIGNMENT STATEMENTS                    ANSI X3J3/90.4
<span id="line6794"></span>
<span id="line6795"></span>
<span id="line6796"></span>
<span id="line6797"></span>          The functions in the "Value Assigned" column of Table 4
<span id="line6798"></span>          are generic functions described in Table 5 (15.10).
<span id="line6799"></span>
<span id="line6800"></span>          10.2  Logical_Assignment_Statement
<span id="line6801"></span>
<span id="line6802"></span>          The form of a logical assignment statement is:
<span id="line6803"></span>
<span id="line6804"></span>                               v_ = e_
<span id="line6805"></span>
<span id="line6806"></span>          where: v_   is the name of a logical variable or logical
<span id="line6807"></span>                     array element
<span id="line6808"></span>
<span id="line6809"></span>                 e_   is a logical expression
<span id="line6810"></span>
<span id="line6811"></span>          Execution of a logical assignment statement causes  the
<span id="line6812"></span>          evaluation   of  the  logical  expression  e_  and  the
<span id="line6813"></span>          assignment and definition of v_ with the value  of  e_ .
<span id="line6814"></span>          Note that e_ must have a value of either true or false.
<span id="line6815"></span>
<span id="line6816"></span>          10.3  Statement_Label_Assignment_(ASSIGN)_Statement
<span id="line6817"></span>
<span id="line6818"></span>          The form of a statement label assignment statement is:
<span id="line6819"></span>
<span id="line6820"></span>                               ASSIGN s_ TO i_
<span id="line6821"></span>
<span id="line6822"></span>          where: s_   is a statement label
<span id="line6823"></span>
<span id="line6824"></span>                 i_   is an integer variable name
<span id="line6825"></span>
<span id="line6826"></span>          Execution of an ASSIGN statement causes  the  statement
<span id="line6827"></span>          label  s_ to be assigned to the integer variable i_.  The
<span id="line6828"></span>          statement label must be the label of a  statement  that
<span id="line6829"></span>          appears   in  the  same  program  unit  as  the  ASSIGN
<span id="line6830"></span>          statement.  The statement label must be the label of an
<span id="line6831"></span>          executable statement or a FORMAT statement.
<span id="line6832"></span>
<span id="line6833"></span>          Execution of a statement label assignment statement  is
<span id="line6834"></span>          the  only  way  that  a  variable may be defined with a
<span id="line6835"></span>          statement label value.
<span id="line6836"></span>
<span id="line6837"></span>          A variable must be defined with a statement label value
<span id="line6838"></span>          when  referenced  in an assigned GO TO statement (11.3)
<span id="line6839"></span>          or as a format identifier  (12.4)  in  an  input/output
<span id="line6840"></span>          statement.  While defined with a statement label value,
<span id="line6841"></span>          the variable must not be referenced in any other way.
<span id="line6842"></span>
<span id="line6843"></span>          An integer variable  defined  with  a  statement  label
<span id="line6844"></span>          value  may  be  redefined  with the same or a different
<span id="line6845"></span>          statement label value or an integer value.
<span id="line6846"></span>
<span id="line6847"></span>
<span id="line6848"></span>
<span id="line6849"></span>
<span id="line6850"></span>
<span id="line6851"></span>          FORTRAN 77 Full Language                      Page 10-2
<span id="line6852"></span>
<span id="line6853"></span>
<span id="line6854"></span>
<span id="line6855"></span>
<span id="line6856"></span>
<span id="line6857"></span>
<span id="line6858"></span>
<span id="line6859"></span>          ASSIGNMENT STATEMENTS                    ANSI X3J3/90.4
<span id="line6860"></span>
<span id="line6861"></span>
<span id="line6862"></span>
<span id="line6863"></span>          10.4  Character_Assignment_Statement
<span id="line6864"></span>
<span id="line6865"></span>          The form of a character assignment statement is:
<span id="line6866"></span>
<span id="line6867"></span>                               v_ = e_
<span id="line6868"></span>
<span id="line6869"></span>          where: v_   is  the  name  of  a  character   variable,
<span id="line6870"></span>                     character   array   element,   or  character
<span id="line6871"></span>                     substring
<span id="line6872"></span>
<span id="line6873"></span>                 e_   is a character expression
<span id="line6874"></span>
<span id="line6875"></span>          Execution of a character  assignment  statement  causes
<span id="line6876"></span>          the  evaluation  of the expression e_ and the assignment
<span id="line6877"></span>          and definition of v_ with the value of e_.  None  of  the
<span id="line6878"></span>          character   positions   being  defined  in  v_  may  be
<span id="line6879"></span>          referenced in e_.  v_ and e_ may have  different  lengths.
<span id="line6880"></span>          If the length of v_ is greater than the length of e_, the
<span id="line6881"></span>          effect is as though e_ were extended to the  right  with
<span id="line6882"></span>          blank  characters  until it is the same length as v_ and
<span id="line6883"></span>          then assigned.  If the length of v_  is  less  than  the
<span id="line6884"></span>          length  of  e_, the effect is as though e_ were truncated
<span id="line6885"></span>          from the right until it is the same length  as  v_  and
<span id="line6886"></span>          then assigned.
<span id="line6887"></span>
<span id="line6888"></span>          Only as much of the value of e_ must be  defined  as  is
<span id="line6889"></span>          needed to define v_.  In the example:
<span id="line6890"></span>
<span id="line6891"></span>                     CHARACTER A*2,B*4
<span id="line6892"></span>                     A=B
<span id="line6893"></span>
<span id="line6894"></span>          the assignment A=B requires that the  substring  B(1:2)
<span id="line6895"></span>          be  defined.   It  does  not require that the substring
<span id="line6896"></span>          B(3:4) be defined.
<span id="line6897"></span>
<span id="line6898"></span>          If v_ is  a  substring,  e_  is  assigned  only  to  the
<span id="line6899"></span>          substring.   The  definition  status  of substrings not
<span id="line6900"></span>          specified by v_ is unchanged.
<span id="line6901"></span>
<span id="line6902"></span>
<span id="line6903"></span>
<span id="line6904"></span>
<span id="line6905"></span>
<span id="line6906"></span>
<span id="line6907"></span>
<span id="line6908"></span>
<span id="line6909"></span>
<span id="line6910"></span>
<span id="line6911"></span>
<span id="line6912"></span>
<span id="line6913"></span>
<span id="line6914"></span>
<span id="line6915"></span>
<span id="line6916"></span>
<span id="line6917"></span>          FORTRAN 77 Full Language                      Page 10-3
<span id="line6918"></span>
<span id="line6919"></span>
<span id="line6920"></span>
<span id="line6921"></span>
<span id="line6922"></span>
<span id="line6923"></span>
<span id="line6924"></span>
<span id="line6925"></span>
<span id="line6926"></span>
<span id="line6927"></span>
<span id="line6928"></span>
<span id="line6929"></span>                                 CONTENTS
<span id="line6930"></span>
<span id="line6931"></span>
<span id="line6932"></span>          10.  ASSIGNMENT STATEMENTS.......................  10-1
<span id="line6933"></span>               10.1  Arithmetic Assignment Statement.......  10-1
<span id="line6934"></span>               10.2  Logical Assignment Statement..........  10-2
<span id="line6935"></span>               10.3  Statement Label Assignment (ASSIGN)
<span id="line6936"></span>                     Statement.............................  10-2
<span id="line6937"></span>               10.4  Character Assignment Statement........  10-3
<span id="line6938"></span>
<span id="line6939"></span>
<span id="line6940"></span>
<span id="line6941"></span>
<span id="line6942"></span>
<span id="line6943"></span>
<span id="line6944"></span>
<span id="line6945"></span>
<span id="line6946"></span>
<span id="line6947"></span>
<span id="line6948"></span>
<span id="line6949"></span>
<span id="line6950"></span>
<span id="line6951"></span>
<span id="line6952"></span>
<span id="line6953"></span>
<span id="line6954"></span>
<span id="line6955"></span>
<span id="line6956"></span>
<span id="line6957"></span>
<span id="line6958"></span>
<span id="line6959"></span>
<span id="line6960"></span>
<span id="line6961"></span>
<span id="line6962"></span>
<span id="line6963"></span>
<span id="line6964"></span>
<span id="line6965"></span>
<span id="line6966"></span>
<span id="line6967"></span>
<span id="line6968"></span>
<span id="line6969"></span>
<span id="line6970"></span>
<span id="line6971"></span>
<span id="line6972"></span>
<span id="line6973"></span>
<span id="line6974"></span>
<span id="line6975"></span>
<span id="line6976"></span>
<span id="line6977"></span>
<span id="line6978"></span>
<span id="line6979"></span>
<span id="line6980"></span>
<span id="line6981"></span>
<span id="line6982"></span>
<span id="line6983"></span>                                   - i -
<span id="line6984"></span>
<span id="line6985"></span>
<span id="line6986"></span>
<span id="line6987"></span>
<span id="line6988"></span>
<span id="line6989"></span>
<span id="line6990"></span>
<span id="line6991"></span>                                                   ANSI X3J3/90.4
<span id="line6992"></span>
<span id="line6993"></span>
<span id="line6994"></span>
<span id="line6995"></span>                          11.  CONTROL_STATEMENTS
<span id="line6996"></span>
<span id="line6997"></span>          Control statements may be used to control the execution
<span id="line6998"></span>          sequence.
<span id="line6999"></span>
<span id="line7000"></span>          There are sixteen control statements:
<span id="line7001"></span>
<span id="line7002"></span>             (1) Unconditional GO TO
<span id="line7003"></span>
<span id="line7004"></span>             (2) Computed GO TO
<span id="line7005"></span>
<span id="line7006"></span>             (3) Assigned GO TO
<span id="line7007"></span>
<span id="line7008"></span>             (4) Arithmetic IF
<span id="line7009"></span>
<span id="line7010"></span>             (5) Logical IF
<span id="line7011"></span>
<span id="line7012"></span>             (6) Block IF
<span id="line7013"></span>
<span id="line7014"></span>             (7) ELSE IF
<span id="line7015"></span>
<span id="line7016"></span>             (8) ELSE
<span id="line7017"></span>
<span id="line7018"></span>             (9) END IF
<span id="line7019"></span>
<span id="line7020"></span>            (10) DO
<span id="line7021"></span>
<span id="line7022"></span>            (11) CONTINUE
<span id="line7023"></span>
<span id="line7024"></span>            (12) STOP
<span id="line7025"></span>
<span id="line7026"></span>            (13) PAUSE
<span id="line7027"></span>
<span id="line7028"></span>            (14) END
<span id="line7029"></span>
<span id="line7030"></span>            (15) CALL
<span id="line7031"></span>
<span id="line7032"></span>            (16) RETURN
<span id="line7033"></span>
<span id="line7034"></span>          The CALL and RETURN statements are described in Section
<span id="line7035"></span>          15.
<span id="line7036"></span>
<span id="line7037"></span>          11.1  Unconditional_GO_TO_Statement
<span id="line7038"></span>
<span id="line7039"></span>          The form of an unconditional GO TO statement is:
<span id="line7040"></span>
<span id="line7041"></span>                               GO TO s_
<span id="line7042"></span>
<span id="line7043"></span>          where s_  is  the  statement  label  of  an  executable
<span id="line7044"></span>          statement  that appears in the same program unit as the
<span id="line7045"></span>          unconditional GO TO statement.
<span id="line7046"></span>
<span id="line7047"></span>
<span id="line7048"></span>
<span id="line7049"></span>          FORTRAN 77 Full Language                      Page 11-1
<span id="line7050"></span>
<span id="line7051"></span>
<span id="line7052"></span>
<span id="line7053"></span>
<span id="line7054"></span>
<span id="line7055"></span>
<span id="line7056"></span>
<span id="line7057"></span>          CONTROL STATEMENTS                       ANSI X3J3/90.4
<span id="line7058"></span>
<span id="line7059"></span>
<span id="line7060"></span>
<span id="line7061"></span>          Execution of an unconditional GO TO statement causes  a
<span id="line7062"></span>          transfer of control so that the statement identified by
<span id="line7063"></span>          the statement label is executed next.
<span id="line7064"></span>
<span id="line7065"></span>          11.2  Computed_GO_TO_Statement
<span id="line7066"></span>
<span id="line7067"></span>          The form of a computed GO TO statement is:
<span id="line7068"></span>
<span id="line7069"></span>                               GO TO (s_ [,s_]...) [,] i_
<span id="line7070"></span>
<span id="line7071"></span>          where: i_   is an integer expression
<span id="line7072"></span>
<span id="line7073"></span>                 s_   is the  statement  label  of  an  executable
<span id="line7074"></span>                     statement  that  appears in the same program
<span id="line7075"></span>                     unit as the computed GO TO  statement.   The
<span id="line7076"></span>                     same  statement  label  may appear more than
<span id="line7077"></span>                     once in the same computed GO TO statement.
<span id="line7078"></span>
<span id="line7079"></span>          Execution  of  a  computed  GO  TO   statement   causes
<span id="line7080"></span>          evaluation of the expression i_.  The evaluation of i_ is
<span id="line7081"></span>          followed by a transfer of control so that the statement
<span id="line7082"></span>          identified  by  the  i_th statement label in the list of
<span id="line7083"></span>          statement labels is executed next, provided that 1 <span class="entity"><span>&amp;</span>lt;</span> i_
<span id="line7084"></span>          <span class="entity"><span>&amp;</span>lt;</span>  n_, where n_ is the number of statement labels in the
<span id="line7085"></span>          list of statement labels.  If i_<span class="entity"><span>&amp;</span>lt;</span>1 or i_<span class="entity"><span>&amp;</span>gt;</span>n_, the execution
<span id="line7086"></span>          sequence  continues as though a CONTINUE statement were
<span id="line7087"></span>          executed.
<span id="line7088"></span>
<span id="line7089"></span>          11.3  Assigned_GO_TO_Statement
<span id="line7090"></span>
<span id="line7091"></span>          The form of an assigned GO TO statement is:
<span id="line7092"></span>
<span id="line7093"></span>                               GO TO i_ [[,] (s_ [,s_]...)]
<span id="line7094"></span>
<span id="line7095"></span>          where: i_   is an integer variable name
<span id="line7096"></span>
<span id="line7097"></span>                 s_   is the  statement  label  of  an  executable
<span id="line7098"></span>                     statement  that  appears in the same program
<span id="line7099"></span>                     unit as the assigned GO TO  statement.   The
<span id="line7100"></span>                     same  statement  label  may appear more than
<span id="line7101"></span>                     once in the same assigned GO TO statement.
<span id="line7102"></span>
<span id="line7103"></span>          At  the  time  of  execution  of  an  assigned  GO   TO
<span id="line7104"></span>          statement,  the  variable  i_  must be defined with the
<span id="line7105"></span>          value of a statement label of an  executable  statement
<span id="line7106"></span>          that  appears  in the same program unit.  Note that the
<span id="line7107"></span>          variable may be defined with a  statement  label  value
<span id="line7108"></span>          only  by an ASSIGN statement (10.3) in the same program
<span id="line7109"></span>          unit as the assigned GO TO statement.  The execution of
<span id="line7110"></span>          the  assigned  GO  TO  statement  causes  a transfer of
<span id="line7111"></span>          control  so  that  the  statement  identified  by  that
<span id="line7112"></span>
<span id="line7113"></span>
<span id="line7114"></span>
<span id="line7115"></span>          FORTRAN 77 Full Language                      Page 11-2
<span id="line7116"></span>
<span id="line7117"></span>
<span id="line7118"></span>
<span id="line7119"></span>
<span id="line7120"></span>
<span id="line7121"></span>
<span id="line7122"></span>
<span id="line7123"></span>          CONTROL STATEMENTS                       ANSI X3J3/90.4
<span id="line7124"></span>
<span id="line7125"></span>
<span id="line7126"></span>
<span id="line7127"></span>          statement label is executed next.
<span id="line7128"></span>
<span id="line7129"></span>          If the  parenthesized list is  present,  the  statement
<span id="line7130"></span>          label assigned to i_ must be one of the statement labels
<span id="line7131"></span>          in the list.
<span id="line7132"></span>
<span id="line7133"></span>          11.4  Arithmetic_IF_Statement
<span id="line7134"></span>
<span id="line7135"></span>          The form of an arithmetic IF statement is:
<span id="line7136"></span>
<span id="line7137"></span>                               IF (e_) s_918 , s_928 , s_93
<span id="line7138"></span>9          where: e_   is an integer,  real,  or  double  precision
<span id="line7139"></span>                     expression
<span id="line7140"></span>
<span id="line7141"></span>                 s_918,  s_928,  and s_938 are each the statement label of
<span id="line7142"></span>                     an  executable statement that appears in the
<span id="line7143"></span>                     same  program  unit  as  the  arithmetic  IF
<span id="line7144"></span>                     statement.   The  same  statement  label may
<span id="line7145"></span>                     appear more than once in the same arithmetic
<span id="line7146"></span>                     IF statement.
<span id="line7147"></span>
<span id="line7148"></span>          Execution  of  an  arithmetic   IF   statement   causes
<span id="line7149"></span>          evaluation  of  the expression e_ followed by a transfer
<span id="line7150"></span>          of control.  The statement identified by s_918, s_928, or s_93
<span id="line7151"></span>8          is  executed  next as the value of e_ is less than zero,
<span id="line7152"></span>          equal to zero, or greater than zero, respectively.
<span id="line7153"></span>
<span id="line7154"></span>          11.5  Logical_IF_Statement
<span id="line7155"></span>
<span id="line7156"></span>          The form of a logical IF statement is:
<span id="line7157"></span>
<span id="line7158"></span>                               IF (e_) st__
<span id="line7159"></span>
<span id="line7160"></span>          where: e_   is a logical expression
<span id="line7161"></span>
<span id="line7162"></span>                 st__  is any executable  statement  except  a  DO,
<span id="line7163"></span>                     block  IF,  ELSE  IF,  ELSE, END IF, END, or
<span id="line7164"></span>                     another logical IF statement
<span id="line7165"></span>
<span id="line7166"></span>          Execution of a logical IF statement  causes  evaluation
<span id="line7167"></span>          of  the  expression  e_ .   If  the value of e_ is true,
<span id="line7168"></span>          statement st__ is executed.  If the value of e_ is  false,
<span id="line7169"></span>          statement st__ is not executed and the execution sequence
<span id="line7170"></span>          continues as though a CONTINUE statement were executed.
<span id="line7171"></span>
<span id="line7172"></span>          Note that the execution of a function reference in  the
<span id="line7173"></span>          expression  e_ of a logical IF statement is permitted to
<span id="line7174"></span>          affect entities in the statement st__.
<span id="line7175"></span>
<span id="line7176"></span>
<span id="line7177"></span>
<span id="line7178"></span>
<span id="line7179"></span>
<span id="line7180"></span>          FORTRAN 77 Full Language                      Page 11-3
<span id="line7181"></span>
<span id="line7182"></span>
<span id="line7183"></span>
<span id="line7184"></span>
<span id="line7185"></span>
<span id="line7186"></span>
<span id="line7187"></span>
<span id="line7188"></span>          CONTROL STATEMENTS                       ANSI X3J3/90.4
<span id="line7189"></span>
<span id="line7190"></span>
<span id="line7191"></span>
<span id="line7192"></span>          11.6  Block_IF_Statement
<span id="line7193"></span>
<span id="line7194"></span>          The  block  IF  statement  is  used  with  the  END  IF
<span id="line7195"></span>          statement   and,  optionally,  the  ELSE  IF  and  ELSE
<span id="line7196"></span>          statements to control the execution sequence.
<span id="line7197"></span>
<span id="line7198"></span>          The form of a block IF statement is:
<span id="line7199"></span>
<span id="line7200"></span>                               IF (e_) THEN
<span id="line7201"></span>
<span id="line7202"></span>          where e_ is a logical expression.
<span id="line7203"></span>
<span id="line7204"></span>          11.6.1  IF-Level.  The IF-level of a statement s_ is
<span id="line7205"></span>
<span id="line7206"></span>                               n_918 - n_92
<span id="line7207"></span>9          where n_918 is the number of block IF statements from  the
<span id="line7208"></span>          beginning  of  the  program unit up to and including s_,
<span id="line7209"></span>          and n_928 is the  number  of  END  IF  statements  in  the
<span id="line7210"></span>          program unit up to but not including s_.
<span id="line7211"></span>
<span id="line7212"></span>          The  IF-level  of  every  statement  must  be  zero  or
<span id="line7213"></span>          positive.   The  IF-level  of  each  block IF, ELSE IF,
<span id="line7214"></span>          ELSE, and END IF statement must be positive.   The  IF-
<span id="line7215"></span>          level of the END statement of each program unit must be
<span id="line7216"></span>          zero.
<span id="line7217"></span>
<span id="line7218"></span>          11.6.2  IF-Block.  An IF-block consists of all  of  the
<span id="line7219"></span>          executable  statements  that appear following the block
<span id="line7220"></span>          IF statement up to, but not including,  the  next  ELSE
<span id="line7221"></span>          IF,  ELSE,  or  END  IF statement that has the same IF-
<span id="line7222"></span>          level as the block IF statement.  An  IF-block  may  be
<span id="line7223"></span>          empty.
<span id="line7224"></span>
<span id="line7225"></span>          11.6.3  Execution_of_a_Block_IF_Statement.    Execution
<span id="line7226"></span>          of  a  block  IF  statement  causes  evaluation  of the
<span id="line7227"></span>          expression e_.  If the  value  of  e_  is  true,  normal
<span id="line7228"></span>          execution  sequence  continues with the first statement
<span id="line7229"></span>          of the IF-block.  If the value of e_  is  true  and  the
<span id="line7230"></span>          IF-block  is  empty, control is transferred to the next
<span id="line7231"></span>          END IF statement that has  the  same  IF-level  as  the
<span id="line7232"></span>          block  IF  statement.   If  the  value  of  e_ is false,
<span id="line7233"></span>          control is transferred to the next ELSE  IF,  ELSE,  or
<span id="line7234"></span>          END  IF  statement  that  has  the same IF-level as the
<span id="line7235"></span>          block IF statement.
<span id="line7236"></span>
<span id="line7237"></span>          Transfer of control into an IF-block from  outside  the
<span id="line7238"></span>          IF-block is prohibited.
<span id="line7239"></span>
<span id="line7240"></span>          If the execution of the last statement in the  IF-block
<span id="line7241"></span>          does  not  result  in a transfer of control, control is
<span id="line7242"></span>
<span id="line7243"></span>
<span id="line7244"></span>
<span id="line7245"></span>          FORTRAN 77 Full Language                      Page 11-4
<span id="line7246"></span>
<span id="line7247"></span>
<span id="line7248"></span>
<span id="line7249"></span>
<span id="line7250"></span>
<span id="line7251"></span>
<span id="line7252"></span>
<span id="line7253"></span>          CONTROL STATEMENTS                       ANSI X3J3/90.4
<span id="line7254"></span>
<span id="line7255"></span>
<span id="line7256"></span>
<span id="line7257"></span>          transferred to the next END IF statement that  has  the
<span id="line7258"></span>          same  IF-level  as the block IF statement that precedes
<span id="line7259"></span>          the IF-block.
<span id="line7260"></span>
<span id="line7261"></span>          11.7  ELSE_IF_Statement
<span id="line7262"></span>
<span id="line7263"></span>          The form of an ELSE IF statement is:
<span id="line7264"></span>
<span id="line7265"></span>                               ELSE IF (e_) THEN
<span id="line7266"></span>
<span id="line7267"></span>          where e_ is a logical expression.
<span id="line7268"></span>
<span id="line7269"></span>          11.7.1  ELSE_IF-Block.  An ELSE  IF-block  consists  of
<span id="line7270"></span>          all  of the executable statements that appear following
<span id="line7271"></span>          the ELSE IF statement up to,  but  not  including,  the
<span id="line7272"></span>          next  ELSE  IF,  ELSE, or END IF statement that has the
<span id="line7273"></span>          same IF-level as the ELSE IF statement.   An  ELSE  IF-
<span id="line7274"></span>          block may be empty.
<span id="line7275"></span>
<span id="line7276"></span>          11.7.2  Execution_of_an_ELSE_IF_Statement.    Execution
<span id="line7277"></span>          of  an  ELSE  IF  statement  causes  evaluation  of the
<span id="line7278"></span>          expression e_.  If the  value  of  e_  is  true,  normal
<span id="line7279"></span>          execution  sequence  continues with the first statement
<span id="line7280"></span>          of the ELSE IF-block.  If the value of e_  is  true  and
<span id="line7281"></span>          the  ELSE  IF-block is empty, control is transferred to
<span id="line7282"></span>          the next END IF statement that has the same IF-level as
<span id="line7283"></span>          the  ELSE  IF  statement.   If the value of e_ is false,
<span id="line7284"></span>          control is transferred to the next ELSE  IF,  ELSE,  or
<span id="line7285"></span>          END IF statement that has the same IF-level as the ELSE
<span id="line7286"></span>          IF statement.
<span id="line7287"></span>
<span id="line7288"></span>          Transfer of control into an ELSE IF-block from  outside
<span id="line7289"></span>          the  ELSE IF-block is prohibited.  The statement label,
<span id="line7290"></span>          if any, of the ELSE IF statement must not be referenced
<span id="line7291"></span>          by any statement.
<span id="line7292"></span>
<span id="line7293"></span>          If execution of the last statement in the ELSE IF-block
<span id="line7294"></span>          does  not  result  in a transfer of control, control is
<span id="line7295"></span>          transferred to the next END IF statement that  has  the
<span id="line7296"></span>          same  IF-level  as  the ELSE IF statement that precedes
<span id="line7297"></span>          the ELSE IF-block.
<span id="line7298"></span>
<span id="line7299"></span>          11.8  ELSE_Statement
<span id="line7300"></span>
<span id="line7301"></span>          The form of an ELSE statement is:
<span id="line7302"></span>
<span id="line7303"></span>                               ELSE
<span id="line7304"></span>
<span id="line7305"></span>          11.8.1  ELSE-Block.  An ELSE-block consists of  all  of
<span id="line7306"></span>          the  executable  statements  that  appear following the
<span id="line7307"></span>          ELSE statement up to, but not including, the  next  END
<span id="line7308"></span>
<span id="line7309"></span>
<span id="line7310"></span>
<span id="line7311"></span>          FORTRAN 77 Full Language                      Page 11-5
<span id="line7312"></span>
<span id="line7313"></span>
<span id="line7314"></span>
<span id="line7315"></span>
<span id="line7316"></span>
<span id="line7317"></span>
<span id="line7318"></span>
<span id="line7319"></span>          CONTROL STATEMENTS                       ANSI X3J3/90.4
<span id="line7320"></span>
<span id="line7321"></span>
<span id="line7322"></span>
<span id="line7323"></span>          IF  statement  that  has  the same IF-level as the ELSE
<span id="line7324"></span>          statement.  An ELSE-block may be empty.
<span id="line7325"></span>
<span id="line7326"></span>          An END IF statement of the same IF-level  as  the  ELSE
<span id="line7327"></span>          statement  must appear before the appearance of an ELSE
<span id="line7328"></span>          IF or ELSE statement of the same IF-level.
<span id="line7329"></span>
<span id="line7330"></span>          11.8.2  Execution_of_an_ELSE_Statement.   Execution  of
<span id="line7331"></span>          an ELSE statement has no effect.
<span id="line7332"></span>
<span id="line7333"></span>          Transfer of control into an ELSE-block from outside the
<span id="line7334"></span>          ELSE-block is prohibited.  The statement label, if any,
<span id="line7335"></span>          of an ELSE statement must  not  be  referenced  by  any
<span id="line7336"></span>          statement.
<span id="line7337"></span>
<span id="line7338"></span>          11.9  END_IF_Statement
<span id="line7339"></span>
<span id="line7340"></span>          The form of an END IF statement is:
<span id="line7341"></span>
<span id="line7342"></span>                               END IF
<span id="line7343"></span>
<span id="line7344"></span>          Execution of an END IF statement has no effect.
<span id="line7345"></span>
<span id="line7346"></span>          For  each  block  IF  statement   there   must   be   a
<span id="line7347"></span>          corresponding  END  IF  statement  in  the same program
<span id="line7348"></span>          unit. A corresponding END IF statement is the next  END
<span id="line7349"></span>          IF statement that has the same IF-level as the block IF
<span id="line7350"></span>          statement.
<span id="line7351"></span>
<span id="line7352"></span>          11.10  DO_Statement
<span id="line7353"></span>
<span id="line7354"></span>          A DO statement is used to specify a loop, called a  DO-
<span id="line7355"></span>          loop.
<span id="line7356"></span>
<span id="line7357"></span>          The form of a DO statement is:
<span id="line7358"></span>
<span id="line7359"></span>                               DO s_ [,] i_ = e_918, e_928, [,e_938]
<span id="line7360"></span>
<span id="line7361"></span>          where: s_   is the  statement  label  of  an  executable
<span id="line7362"></span>                     statement.   The  statement identified by s_,
<span id="line7363"></span>                     called the terminal________ statement________ _  of  the  DO-
<span id="line7364"></span>                     loop,  must  follow  the DO statement in the
<span id="line7365"></span>                     sequence  of  statements  within  the   same
<span id="line7366"></span>                     program unit as the DO statement.
<span id="line7367"></span>
<span id="line7368"></span>                 i_   is the name of an integer, real,  or  double
<span id="line7369"></span>                     precision variable, called the DO-variable___________
<span id="line7370"></span>
<span id="line7371"></span>                 e_918,  e_928, and e_938 are each an  integer,  real,  or
<span id="line7372"></span>                     double precision expression
<span id="line7373"></span>
<span id="line7374"></span>
<span id="line7375"></span>
<span id="line7376"></span>
<span id="line7377"></span>          FORTRAN 77 Full Language                      Page 11-6
<span id="line7378"></span>
<span id="line7379"></span>
<span id="line7380"></span>
<span id="line7381"></span>
<span id="line7382"></span>
<span id="line7383"></span>
<span id="line7384"></span>
<span id="line7385"></span>          CONTROL STATEMENTS                       ANSI X3J3/90.4
<span id="line7386"></span>
<span id="line7387"></span>
<span id="line7388"></span>
<span id="line7389"></span>          The terminal statement of a  DO-loop  must  not  be  an
<span id="line7390"></span>          unconditional  GO  TO,  assigned  GO TO, arithmetic IF,
<span id="line7391"></span>          block IF, ELSE IF, ELSE, END IF, RETURN, STOP, END,  or
<span id="line7392"></span>          DO  statement.   If the terminal statement of a DO-loop
<span id="line7393"></span>          is  a  logical  IF  statement,  it  may   contain   any
<span id="line7394"></span>          executable  statement  except  a DO, block IF, ELSE IF,
<span id="line7395"></span>          ELSE, END IF, END, or another logical IF statement.
<span id="line7396"></span>
<span id="line7397"></span>          11.10.1  Range_of_a_DO-Loop.  The range  of  a  DO-loop
<span id="line7398"></span>          consists  of  all  of  the  executable  statements that
<span id="line7399"></span>          appear following the DO statement  that  specifies  the
<span id="line7400"></span>          DO-loop,  up to and including the terminal statement of
<span id="line7401"></span>          the DO-loop.
<span id="line7402"></span>
<span id="line7403"></span>          If a DO statement appears within the  range  of  a  DO-
<span id="line7404"></span>          loop,  the  range  of  the DO-loop specified by that DO
<span id="line7405"></span>          statement must be contained entirely within  the  range
<span id="line7406"></span>          of  the  outer DO-loop.  More than one DO-loop may have
<span id="line7407"></span>          the same terminal statement.
<span id="line7408"></span>
<span id="line7409"></span>          If a DO statement appears within an IF-block, ELSE  IF-
<span id="line7410"></span>          block, or ELSE-block, the range of that DO-loop must be
<span id="line7411"></span>          contained entirely within that IF-block, ELSE IF-block,
<span id="line7412"></span>          or ELSE-block, respectively.
<span id="line7413"></span>
<span id="line7414"></span>          If a block IF statement appears within the range  of  a
<span id="line7415"></span>          DO-loop,  the  corresponding END IF statement must also
<span id="line7416"></span>          appear within the range of that DO-loop.
<span id="line7417"></span>
<span id="line7418"></span>          11.10.2  Active_and_Inactive_DO-Loops.   A  DO-loop  is
<span id="line7419"></span>          either  active  or inactive.  Initially inactive, a DO-
<span id="line7420"></span>          loop becomes active  only  when  its  DO  statement  is
<span id="line7421"></span>          executed.
<span id="line7422"></span>
<span id="line7423"></span>          Once active, the DO-loop becomes inactive only when:
<span id="line7424"></span>
<span id="line7425"></span>             (1) its iteration  count  is  tested  (11.10.4)  and
<span id="line7426"></span>                 determined to be zero,
<span id="line7427"></span>
<span id="line7428"></span>             (2) a RETURN statement is executed within its range,
<span id="line7429"></span>
<span id="line7430"></span>             (3) control is transferred to a statement that is in
<span id="line7431"></span>                 the  same  program unit and is outside the range
<span id="line7432"></span>                 of the DO-loop, or
<span id="line7433"></span>
<span id="line7434"></span>             (4) any STOP statement in the executable program  is
<span id="line7435"></span>                 executed,  or  execution  is  terminated for any
<span id="line7436"></span>                 other reason (12.6).
<span id="line7437"></span>
<span id="line7438"></span>          Execution of a function  reference  or  CALL  statement
<span id="line7439"></span>          that  appears  in the range of a DO-loop does not cause
<span id="line7440"></span>
<span id="line7441"></span>
<span id="line7442"></span>
<span id="line7443"></span>          FORTRAN 77 Full Language                      Page 11-7
<span id="line7444"></span>
<span id="line7445"></span>
<span id="line7446"></span>
<span id="line7447"></span>
<span id="line7448"></span>
<span id="line7449"></span>
<span id="line7450"></span>
<span id="line7451"></span>          CONTROL STATEMENTS                       ANSI X3J3/90.4
<span id="line7452"></span>
<span id="line7453"></span>
<span id="line7454"></span>
<span id="line7455"></span>          the DO-loop to become inactive, except when control  is
<span id="line7456"></span>          returned by means of an alternate return specifier in a
<span id="line7457"></span>          CALL statement to a statement that is not in the  range
<span id="line7458"></span>          of the DO-loop.
<span id="line7459"></span>
<span id="line7460"></span>          When a DO-loop becomes inactive, the DO-variable of the
<span id="line7461"></span>          DO-loop retains its last defined value.
<span id="line7462"></span>
<span id="line7463"></span>          11.10.3  Executing_a_DO_Statement.    The   effect   of
<span id="line7464"></span>          executing  a  DO  statement is to perform the following
<span id="line7465"></span>          steps in sequence:
<span id="line7466"></span>
<span id="line7467"></span>             (1) The initial parameter m918, the terminal parameter
<span id="line7468"></span>                 m928,  and  the  incrementation  parameter  m938 are
<span id="line7469"></span>                 established by evaluating  e_918,  e_928,  and  e_938,
<span id="line7470"></span>                 respectively,     including,    if    necessary,
<span id="line7471"></span>                 conversion  to  the  type  of  the   DO-variable
<span id="line7472"></span>                 according to the rules for arithmetic conversion
<span id="line7473"></span>                 (Table 4).  If e_938 does not  appear,  m_938  has  a
<span id="line7474"></span>                 value of one.  m_938 must not have a value of zero.
<span id="line7475"></span>
<span id="line7476"></span>             (2) The DO-variable becomes defined with  the  value
<span id="line7477"></span>                 of the initial parameter m_918.
<span id="line7478"></span>
<span id="line7479"></span>             (3) The iteration count is established  and  is  the
<span id="line7480"></span>                 value of the expression
<span id="line7481"></span>
<span id="line7482"></span>                         MAX( INT( (m_928 - m_918 + m_938)/m_938), 0)
<span id="line7483"></span>
<span id="line7484"></span>                 Note that the iteration count is zero whenever:
<span id="line7485"></span>
<span id="line7486"></span>                         m_918 <span class="entity"><span>&amp;</span>gt;</span> m_928 and m_938 <span class="entity"><span>&amp;</span>gt;</span> 0, or
<span id="line7487"></span>
<span id="line7488"></span>                         m_918 <span class="entity"><span>&amp;</span>lt;</span> m_928 and m_938 <span class="entity"><span>&amp;</span>lt;</span> 0.
<span id="line7489"></span>
<span id="line7490"></span>          At the completion of execution  of  the  DO  statement,
<span id="line7491"></span>          loop control processing begins.
<span id="line7492"></span>
<span id="line7493"></span>          11.10.4  Loop_Control_Processing.      Loop     control
<span id="line7494"></span>          processing determines if further execution of the range
<span id="line7495"></span>          of the DO-loop is  required.  The  iteration  count  is
<span id="line7496"></span>          tested.  If  it  is  not  zero,  execution of the first
<span id="line7497"></span>          statement in the range of the DO-loop begins.   If  the
<span id="line7498"></span>          iteration  count is zero, the DO-loop becomes inactive.
<span id="line7499"></span>          If, as a  result,  all  of  the  DO-loops  sharing  the
<span id="line7500"></span>          terminal statement of this DO-loop are inactive, normal
<span id="line7501"></span>          execution  continues  with  execution   of   the   next
<span id="line7502"></span>          executable  statement following the terminal statement.
<span id="line7503"></span>          However, if some of the DO-loops sharing  the  terminal
<span id="line7504"></span>          statement   are   active,   execution   continues  with
<span id="line7505"></span>          incrementation processing, as described in 11.10.7.
<span id="line7506"></span>
<span id="line7507"></span>
<span id="line7508"></span>
<span id="line7509"></span>          FORTRAN 77 Full Language                      Page 11-8
<span id="line7510"></span>
<span id="line7511"></span>
<span id="line7512"></span>
<span id="line7513"></span>
<span id="line7514"></span>
<span id="line7515"></span>
<span id="line7516"></span>
<span id="line7517"></span>          CONTROL STATEMENTS                       ANSI X3J3/90.4
<span id="line7518"></span>
<span id="line7519"></span>
<span id="line7520"></span>
<span id="line7521"></span>          11.10.5  Execution_of_the_Range.   Statements  in   the
<span id="line7522"></span>          range  of  a  DO-loop  are  executed until the terminal
<span id="line7523"></span>          statement is reached.   Except  by  the  incrementation
<span id="line7524"></span>          described  in  11.10.7,  the DO-variable of the DO-loop
<span id="line7525"></span>          may neither be redefined nor  become  undefined  during
<span id="line7526"></span>          execution of the range of the DO-loop.
<span id="line7527"></span>
<span id="line7528"></span>          11.10.6  Terminal_Statement_Execution.   Execution   of
<span id="line7529"></span>          the terminal statement occurs as a result of the normal
<span id="line7530"></span>          execution sequence  or  as  a  result  of  transfer  of
<span id="line7531"></span>          control,   subject  to  the  restrictions  in  11.10.8.
<span id="line7532"></span>          Unless execution of the terminal statement results in a
<span id="line7533"></span>          transfer  of  control,  execution  then  continues with
<span id="line7534"></span>          incrementation processing, as described in 11.10.7.
<span id="line7535"></span>
<span id="line7536"></span>          11.10.7  Incrementation_Processing.      Incrementation
<span id="line7537"></span>          processing  has  the  effect  of  the  following  steps
<span id="line7538"></span>          performed in sequence:
<span id="line7539"></span>
<span id="line7540"></span>             (1) The DO-variable, the iteration  count,  and  the
<span id="line7541"></span>                 incrementation  parameter  of the active DO-loop
<span id="line7542"></span>                 whose DO statement was most  recently  executed,
<span id="line7543"></span>                 are selected for processing.
<span id="line7544"></span>
<span id="line7545"></span>             (2) The value of the DO-variable is  incremented  by
<span id="line7546"></span>                 the value of the incrementation parameter m_938.
<span id="line7547"></span>
<span id="line7548"></span>             (3) The iteration count is decremented by one.
<span id="line7549"></span>
<span id="line7550"></span>             (4) Execution continues with loop control processing
<span id="line7551"></span>                 (11.10.4)  of  the  same DO-loop whose iteration
<span id="line7552"></span>                 count was decremented.
<span id="line7553"></span>
<span id="line7554"></span>          For example:
<span id="line7555"></span>
<span id="line7556"></span>                     N=0
<span id="line7557"></span>                     DO 100 I=1,10
<span id="line7558"></span>                     J=I
<span id="line7559"></span>                     DO 100 K=1,5
<span id="line7560"></span>                     L=K
<span id="line7561"></span>                 100 N=N+1
<span id="line7562"></span>                 101 CONTINUE
<span id="line7563"></span>
<span id="line7564"></span>          After  execution  of  these  statements  and   at   the
<span id="line7565"></span>          execution  of  the CONTINUE statement, I=11, J=10, K=6,
<span id="line7566"></span>          L=5, and N=50.
<span id="line7567"></span>
<span id="line7568"></span>          Also consider the following example:
<span id="line7569"></span>
<span id="line7570"></span>                     N=0
<span id="line7571"></span>                     DO 200=I=1,10
<span id="line7572"></span>
<span id="line7573"></span>
<span id="line7574"></span>
<span id="line7575"></span>          FORTRAN 77 Full Language                      Page 11-9
<span id="line7576"></span>
<span id="line7577"></span>
<span id="line7578"></span>
<span id="line7579"></span>
<span id="line7580"></span>
<span id="line7581"></span>
<span id="line7582"></span>
<span id="line7583"></span>          CONTROL STATEMENTS                       ANSI X3J3/90.4
<span id="line7584"></span>
<span id="line7585"></span>
<span id="line7586"></span>
<span id="line7587"></span>                     J=I
<span id="line7588"></span>                     D0 200 K=5,1
<span id="line7589"></span>                     L=K
<span id="line7590"></span>                 200 N=N+1
<span id="line7591"></span>                 201 CONTINUE
<span id="line7592"></span>
<span id="line7593"></span>          After  execution  of  these  statements  and   at   the
<span id="line7594"></span>          execution  of  the CONTINUE statement, I=11, J=10, K=5,
<span id="line7595"></span>          and N=0.  L is not defined by these statements.
<span id="line7596"></span>
<span id="line7597"></span>          11.10.8  Transfer_into_the_Range_of_a_DO-Loop.
<span id="line7598"></span>          Transfer  of  control  into the range of a DO-loop from
<span id="line7599"></span>          outside the range is not permitted.
<span id="line7600"></span>
<span id="line7601"></span>          11.11  CONTINUE_Statement
<span id="line7602"></span>
<span id="line7603"></span>          The form of a CONTINUE statement is:
<span id="line7604"></span>
<span id="line7605"></span>                               CONTINUE
<span id="line7606"></span>
<span id="line7607"></span>          Execution of a CONTINUE statement has no effect.
<span id="line7608"></span>
<span id="line7609"></span>          If the CONTINUE statement is the terminal statement  of
<span id="line7610"></span>          a  DO-loop,  the next statement executed depends on the
<span id="line7611"></span>          result  of  the   DO-loop   incrementation   processing
<span id="line7612"></span>          (11.10.7).
<span id="line7613"></span>
<span id="line7614"></span>          11.12  STOP_Statement
<span id="line7615"></span>
<span id="line7616"></span>          The form of a STOP statement is:
<span id="line7617"></span>
<span id="line7618"></span>                               STOP [n_]
<span id="line7619"></span>
<span id="line7620"></span>          where n_ is a string of not more than five digits, or is
<span id="line7621"></span>          a character constant.
<span id="line7622"></span>
<span id="line7623"></span>          Execution of a STOP  statement  causes  termination  of
<span id="line7624"></span>          execution  of  the  executable program.  At the time of
<span id="line7625"></span>          termination, the digit string or character constant  is
<span id="line7626"></span>          accessible.
<span id="line7627"></span>
<span id="line7628"></span>          11.13  PAUSE_Statement
<span id="line7629"></span>
<span id="line7630"></span>          The form of a PAUSE statement is:
<span id="line7631"></span>
<span id="line7632"></span>                               PAUSE [n_]
<span id="line7633"></span>
<span id="line7634"></span>          where n_ is a string of not more than five digits, or is
<span id="line7635"></span>          a character constant.
<span id="line7636"></span>
<span id="line7637"></span>
<span id="line7638"></span>
<span id="line7639"></span>
<span id="line7640"></span>
<span id="line7641"></span>          FORTRAN 77 Full Language                     Page 11-10
<span id="line7642"></span>
<span id="line7643"></span>
<span id="line7644"></span>
<span id="line7645"></span>
<span id="line7646"></span>
<span id="line7647"></span>
<span id="line7648"></span>
<span id="line7649"></span>          CONTROL STATEMENTS                       ANSI X3J3/90.4
<span id="line7650"></span>
<span id="line7651"></span>
<span id="line7652"></span>
<span id="line7653"></span>          Execution of a PAUSE statement causes  a  cessation  of
<span id="line7654"></span>          execution of the executable program.  Execution must be
<span id="line7655"></span>          resumable.  At the time of cessation of execution,  the
<span id="line7656"></span>          digit  string  or  character  constant  is  accessible.
<span id="line7657"></span>          Resumption of execution is not  under  control  of  the
<span id="line7658"></span>          program.    If  execution  is  resumed,  the  execution
<span id="line7659"></span>          sequence continues as though a CONTINUE statement  were
<span id="line7660"></span>          executed.
<span id="line7661"></span>
<span id="line7662"></span>          11.14  END_Statement
<span id="line7663"></span>
<span id="line7664"></span>          The END statement indicates  the end of the sequence of
<span id="line7665"></span>          statements  and  comment lines of a program unit (3.5).
<span id="line7666"></span>          If executed in a function or subroutine subprogram,  it
<span id="line7667"></span>          has  the  effect  of  a  RETURN  statement  (15.8).  If
<span id="line7668"></span>          executed in a main program, it terminates the execution
<span id="line7669"></span>          of the executable program.
<span id="line7670"></span>
<span id="line7671"></span>          The form of an END statement is:
<span id="line7672"></span>
<span id="line7673"></span>                               END
<span id="line7674"></span>
<span id="line7675"></span>          An END statement is written only in columns  7  through
<span id="line7676"></span>          72  of  an  initial line.  An END statement must not be
<span id="line7677"></span>          continued.  No other statement in a  program  unit  may
<span id="line7678"></span>          have  an  initial  line  that  appears  to  be  an  END
<span id="line7679"></span>          statement.
<span id="line7680"></span>
<span id="line7681"></span>          The last line of every program  unit  must  be  an  END
<span id="line7682"></span>          statement.
<span id="line7683"></span>
<span id="line7684"></span>
<span id="line7685"></span>
<span id="line7686"></span>
<span id="line7687"></span>
<span id="line7688"></span>
<span id="line7689"></span>
<span id="line7690"></span>
<span id="line7691"></span>
<span id="line7692"></span>
<span id="line7693"></span>
<span id="line7694"></span>
<span id="line7695"></span>
<span id="line7696"></span>
<span id="line7697"></span>
<span id="line7698"></span>
<span id="line7699"></span>
<span id="line7700"></span>
<span id="line7701"></span>
<span id="line7702"></span>
<span id="line7703"></span>
<span id="line7704"></span>
<span id="line7705"></span>
<span id="line7706"></span>
<span id="line7707"></span>          FORTRAN 77 Full Language                     Page 11-11
<span id="line7708"></span>
<span id="line7709"></span>
<span id="line7710"></span>
<span id="line7711"></span>
<span id="line7712"></span>
<span id="line7713"></span>
<span id="line7714"></span>
<span id="line7715"></span>
<span id="line7716"></span>
<span id="line7717"></span>
<span id="line7718"></span>
<span id="line7719"></span>                                 CONTENTS
<span id="line7720"></span>
<span id="line7721"></span>
<span id="line7722"></span>          11.  CONTROL STATEMENTS.........................   11-1
<span id="line7723"></span>               11.1   Unconditional GO TO
<span id="line7724"></span>                      Statement...........................   11-1
<span id="line7725"></span>               11.2   Computed GO TO Statement............   11-2
<span id="line7726"></span>               11.3   Assigned GO TO Statement............   11-2
<span id="line7727"></span>               11.4   Arithmetic IF Statement.............   11-3
<span id="line7728"></span>               11.5   Logical IF Statement................   11-3
<span id="line7729"></span>               11.6   Block IF Statement..................   11-4
<span id="line7730"></span>                      11.6.1   IF-Level...................   11-4
<span id="line7731"></span>                      11.6.2   IF-Block...................   11-4
<span id="line7732"></span>                      11.6.3   Execution of a Block IF
<span id="line7733"></span>                               Statement..................   11-4
<span id="line7734"></span>               11.7   ELSE IF Statement...................   11-5
<span id="line7735"></span>                      11.7.1   ELSE IF-Block..............   11-5
<span id="line7736"></span>                      11.7.2   Execution of an ELSE IF
<span id="line7737"></span>                               Statement..................   11-5
<span id="line7738"></span>               11.8   ELSE Statement......................   11-5
<span id="line7739"></span>                      11.8.1   ELSE-Block.................   11-5
<span id="line7740"></span>                      11.8.2   Execution of an ELSE
<span id="line7741"></span>                               Statement..................   11-6
<span id="line7742"></span>               11.9   END IF Statement....................   11-6
<span id="line7743"></span>               11.10  DO Statement........................   11-6
<span id="line7744"></span>                      11.10.1  Range of a DO-Loop.........   11-7
<span id="line7745"></span>                      11.10.2  Active and Inactive DO-
<span id="line7746"></span>                               Loops......................   11-7
<span id="line7747"></span>                      11.10.3  Executing a DO
<span id="line7748"></span>                               Statement..................   11-8
<span id="line7749"></span>                      11.10.4  Loop Control
<span id="line7750"></span>                               Processing.................   11-8
<span id="line7751"></span>                      11.10.5  Execution of the
<span id="line7752"></span>                               Range......................   11-9
<span id="line7753"></span>                      11.10.6  Terminal Statement
<span id="line7754"></span>                               Execution..................   11-9
<span id="line7755"></span>                      11.10.7  Incrementation
<span id="line7756"></span>                               Processing.................   11-9
<span id="line7757"></span>                      11.10.8  Transfer into the Range of
<span id="line7758"></span>                               a DO-Loop..................  11-10
<span id="line7759"></span>               11.11  CONTINUE Statement..................  11-10
<span id="line7760"></span>               11.12  STOP Statement......................  11-10
<span id="line7761"></span>               11.13  PAUSE Statement.....................  11-10
<span id="line7762"></span>               11.14  END Statement.......................  11-11
<span id="line7763"></span>
<span id="line7764"></span>
<span id="line7765"></span>
<span id="line7766"></span>
<span id="line7767"></span>
<span id="line7768"></span>
<span id="line7769"></span>
<span id="line7770"></span>
<span id="line7771"></span>
<span id="line7772"></span>
<span id="line7773"></span>                                   - i -
<span id="line7774"></span>
<span id="line7775"></span>
<span id="line7776"></span>
<span id="line7777"></span>
<span id="line7778"></span>
<span id="line7779"></span>
<span id="line7780"></span>
<span id="line7781"></span>                                                   ANSI X3J3/90.4
<span id="line7782"></span>
<span id="line7783"></span>
<span id="line7784"></span>
<span id="line7785"></span>                       12.  INPUT/OUTPUT_STATEMENTS
<span id="line7786"></span>
<span id="line7787"></span>          Input statements provide the means of transferring data
<span id="line7788"></span>          from  external  media  to  internal  storage or from an
<span id="line7789"></span>          internal file to internal  storage.   This  process  is
<span id="line7790"></span>          called reading.  Output statements provide the means of
<span id="line7791"></span>          transferring data from  internal  storage  to  external
<span id="line7792"></span>          media  or  from  internal  storage to an internal file.
<span id="line7793"></span>          This process  is  called  writing.   Some  input/output
<span id="line7794"></span>          statements  specify  that  editing of the data is to be
<span id="line7795"></span>          performed.
<span id="line7796"></span>
<span id="line7797"></span>          In addition to the statements that transfer data, there
<span id="line7798"></span>          are auxiliary input/output statements to manipulate the
<span id="line7799"></span>          external medium, or to inquire about  or  describe  the
<span id="line7800"></span>          properties of the connection to the external medium.
<span id="line7801"></span>
<span id="line7802"></span>          There are nine input/output statements:
<span id="line7803"></span>
<span id="line7804"></span>             (1) READ
<span id="line7805"></span>
<span id="line7806"></span>             (2) WRITE
<span id="line7807"></span>
<span id="line7808"></span>             (3) PRINT
<span id="line7809"></span>
<span id="line7810"></span>             (4) OPEN
<span id="line7811"></span>
<span id="line7812"></span>             (5) CLOSE
<span id="line7813"></span>
<span id="line7814"></span>             (6) INQUIRE
<span id="line7815"></span>
<span id="line7816"></span>             (7) BACKSPACE
<span id="line7817"></span>
<span id="line7818"></span>             (8) ENDFILE
<span id="line7819"></span>
<span id="line7820"></span>             (9) REWIND
<span id="line7821"></span>
<span id="line7822"></span>          The READ, WRITE, and PRINT statements are data transfer
<span id="line7823"></span>          input/output   statements  (12.8).   The  OPEN,  CLOSE,
<span id="line7824"></span>          INQUIRE, BACKSPACE, ENDFILE, and REWIND statements  are
<span id="line7825"></span>          auxiliary   input/output   statements   (12.10).    The
<span id="line7826"></span>          BACKSPACE, ENDFILE,  and  REWIND  statements  are  file
<span id="line7827"></span>          positioning input/output statements (12.10.4).
<span id="line7828"></span>
<span id="line7829"></span>          12.1  Records
<span id="line7830"></span>
<span id="line7831"></span>          A record is a sequence (2.1) of values or a sequence of
<span id="line7832"></span>          characters.   For  example,  a  punched card is usually
<span id="line7833"></span>          considered to be a record.  However, a record does  not
<span id="line7834"></span>          necessarily correspond to a physical entity.  There are
<span id="line7835"></span>          three kinds of records:
<span id="line7836"></span>
<span id="line7837"></span>
<span id="line7838"></span>
<span id="line7839"></span>          FORTRAN 77 Full Language                      Page 12-1
<span id="line7840"></span>
<span id="line7841"></span>
<span id="line7842"></span>
<span id="line7843"></span>
<span id="line7844"></span>
<span id="line7845"></span>
<span id="line7846"></span>
<span id="line7847"></span>          INPUT/OUTPUT STATEMENTS                  ANSI X3J3/90.4
<span id="line7848"></span>
<span id="line7849"></span>
<span id="line7850"></span>
<span id="line7851"></span>             (1) Formatted
<span id="line7852"></span>
<span id="line7853"></span>             (2) Unformatted
<span id="line7854"></span>
<span id="line7855"></span>             (3) Endfile
<span id="line7856"></span>
<span id="line7857"></span>          12.1.1  Formatted_Record.  A formatted record  consists
<span id="line7858"></span>          of  a  sequence  of  characters  that  are  capable  of
<span id="line7859"></span>          representation in  the  processor.   The  length  of  a
<span id="line7860"></span>          formatted  record is measured in characters and depends
<span id="line7861"></span>          primarily on the number  of  characters  put  into  the
<span id="line7862"></span>          record  when  it is written.  However, it may depend on
<span id="line7863"></span>          the processor and the external medium.  The length  may
<span id="line7864"></span>          be zero.  Formatted records may be read or written only
<span id="line7865"></span>          by formatted input/output statements (12.8.1).
<span id="line7866"></span>
<span id="line7867"></span>          Formatted records may be prepared by some  means  other
<span id="line7868"></span>          than FORTRAN; for example, by some manual input device.
<span id="line7869"></span>
<span id="line7870"></span>          12.1.2  Unformatted_Record.   An   unformatted   record
<span id="line7871"></span>          consists  of  a  sequence  of  values  in  a processor-
<span id="line7872"></span>          dependent form  and  may  contain  both  character  and
<span id="line7873"></span>          noncharacter  data  or may contain no data.  The length
<span id="line7874"></span>          of an unformatted  record  is  measured  in  processor-
<span id="line7875"></span>          dependent units and depends on the output list (12.8.2)
<span id="line7876"></span>          used when it is written, as well as  on  the  processor
<span id="line7877"></span>          and the external medium.  The length may be zero.
<span id="line7878"></span>
<span id="line7879"></span>          Unformatted records may be  read  or  written  only  by
<span id="line7880"></span>          unformatted input/output statements (12.8.1).
<span id="line7881"></span>
<span id="line7882"></span>          12.1.3  Endfile_Record.  An endfile record  is  written
<span id="line7883"></span>          by  an  ENDFILE statement.  An endfile record may occur
<span id="line7884"></span>          only as the last record of a file.  An  endfile  record
<span id="line7885"></span>          does not have a length property.
<span id="line7886"></span>
<span id="line7887"></span>          12.2  Files
<span id="line7888"></span>
<span id="line7889"></span>          A file is a sequence (2.1) of records.
<span id="line7890"></span>
<span id="line7891"></span>          There are two kinds of files:
<span id="line7892"></span>
<span id="line7893"></span>             (1) External
<span id="line7894"></span>
<span id="line7895"></span>             (2) Internal
<span id="line7896"></span>
<span id="line7897"></span>          12.2.1  File_Existence.  At any given time, there is  a
<span id="line7898"></span>          processor-determined  set  of  files  that  are said to
<span id="line7899"></span>          exist for an executable program.  A file may  be  known
<span id="line7900"></span>          to  the  processor,  yet  not  exist  for an executable
<span id="line7901"></span>          program at a particular time.   For  example,  security
<span id="line7902"></span>
<span id="line7903"></span>
<span id="line7904"></span>
<span id="line7905"></span>          FORTRAN 77 Full Language                      Page 12-2
<span id="line7906"></span>
<span id="line7907"></span>
<span id="line7908"></span>
<span id="line7909"></span>
<span id="line7910"></span>
<span id="line7911"></span>
<span id="line7912"></span>
<span id="line7913"></span>          INPUT/OUTPUT STATEMENTS                  ANSI X3J3/90.4
<span id="line7914"></span>
<span id="line7915"></span>
<span id="line7916"></span>
<span id="line7917"></span>          reasons  may  prevent  a  file  from  existing  for  an
<span id="line7918"></span>          executable program.  A file may exist  and  contain  no
<span id="line7919"></span>          records;  an  example  is  a newly created file not yet
<span id="line7920"></span>          written.
<span id="line7921"></span>
<span id="line7922"></span>          To create a file means to cause a file  to  exist  that
<span id="line7923"></span>          did  not  previously  exist.  To delete a file means to
<span id="line7924"></span>          terminate the existence of the file.
<span id="line7925"></span>
<span id="line7926"></span>          All input/output statements may  refer  to  files  that
<span id="line7927"></span>          exist.   The  INQUIRE,  OPEN,  CLOSE, WRITE, PRINT, and
<span id="line7928"></span>          ENDFILE statements may also refer to files that do  not
<span id="line7929"></span>          exist.
<span id="line7930"></span>
<span id="line7931"></span>          12.2.2  File_Properties.  At any given time, there is a
<span id="line7932"></span>          processor-determined  set  of allowed access methods, a
<span id="line7933"></span>          processor-determined  set  of  allowed  forms,  and   a
<span id="line7934"></span>          processor-determined  set of allowed record lengths for
<span id="line7935"></span>          a file.
<span id="line7936"></span>
<span id="line7937"></span>          A file may have a name; a  file  that  has  a  name  is
<span id="line7938"></span>          called  a  named  file.   The name of a named file is a
<span id="line7939"></span>          character  string.   The  set  of  allowable  names  is
<span id="line7940"></span>          processor dependent and may be empty.
<span id="line7941"></span>
<span id="line7942"></span>          12.2.3  File_Position.  A file that is connected  to  a
<span id="line7943"></span>          unit  (12.3)  has  a  position  property.  Execution of
<span id="line7944"></span>          certain input/output statements affects the position of
<span id="line7945"></span>          a  file.   Certain circumstances can cause the position
<span id="line7946"></span>          of a file to become indeterminate.
<span id="line7947"></span>
<span id="line7948"></span>          The initial point of a file is the position just before
<span id="line7949"></span>          the  first  record  The  terminal point is the position
<span id="line7950"></span>          just after the last record.
<span id="line7951"></span>
<span id="line7952"></span>          If a file is positioned within a record, that record is
<span id="line7953"></span>          the  current  record;  otherwise,  there  is no current
<span id="line7954"></span>          record.
<span id="line7955"></span>
<span id="line7956"></span>          Let n_ be the number of records in the file.  If 1 <span class="entity"><span>&amp;</span>lt;</span> i_ <span class="entity"><span>&amp;</span>lt;</span>
<span id="line7957"></span>           n_  and  a file is positioned within the i_th record or
<span id="line7958"></span>          between the (i_-1)th record and the i_th record, the (i_ -
<span id="line7959"></span>          1)th  record  is the preceding record.  If n_ <span class="entity"><span>&amp;</span>gt;</span>1 and the
<span id="line7960"></span>          file is positioned at its terminal point, the preceding
<span id="line7961"></span>          record is the n_th and last record.  If n_=0 or if a file
<span id="line7962"></span>          is positioned at its initial point or within the  first
<span id="line7963"></span>          record, there is no preceding record.
<span id="line7964"></span>
<span id="line7965"></span>          If 1 <span class="entity"><span>&amp;</span>lt;</span> i_ <span class="entity"><span>&amp;</span>lt;</span> n_ and a file is positioned within the  i_ th
<span id="line7966"></span>          record  or  between the i_th and (i_+1)th record, the (i_+
<span id="line7967"></span>          1)th record is the next record.  If n_ <span class="entity"><span>&amp;</span>gt;</span> 1 and the  file
<span id="line7968"></span>
<span id="line7969"></span>
<span id="line7970"></span>
<span id="line7971"></span>          FORTRAN 77 Full Language                      Page 12-3
<span id="line7972"></span>
<span id="line7973"></span>
<span id="line7974"></span>
<span id="line7975"></span>
<span id="line7976"></span>
<span id="line7977"></span>
<span id="line7978"></span>
<span id="line7979"></span>          INPUT/OUTPUT STATEMENTS                  ANSI X3J3/90.4
<span id="line7980"></span>
<span id="line7981"></span>
<span id="line7982"></span>
<span id="line7983"></span>          is positioned at its initial point, the first record is
<span id="line7984"></span>          the next record.  If n_=0 or if a file is positioned  at
<span id="line7985"></span>          its  terminal  point or within the n_th and last record,
<span id="line7986"></span>          there is no next record.
<span id="line7987"></span>
<span id="line7988"></span>          12.2.4  File_Access.   There   are   two   methods   of
<span id="line7989"></span>          accessing  the  records of an external file: sequential
<span id="line7990"></span>          and direct.  Some files may have more than one  allowed
<span id="line7991"></span>          access  method;  other  files  may be restricted to one
<span id="line7992"></span>          access method.  For example, a processor may allow only
<span id="line7993"></span>          sequential  access  to  a file on magnetic tape.  Thus,
<span id="line7994"></span>          the set of allowed access methods depends on  the  file
<span id="line7995"></span>          and the processor.
<span id="line7996"></span>
<span id="line7997"></span>          The method of accessing the file is determined when the
<span id="line7998"></span>          file is connected to a unit (12.3.2).
<span id="line7999"></span>
<span id="line8000"></span>          An internal file must be accessed sequentially.
<span id="line8001"></span>
<span id="line8002"></span>          12.2.4.1  Sequential_Access.    When   connected    for
<span id="line8003"></span>          sequential access, a file has the following properties:
<span id="line8004"></span>
<span id="line8005"></span>             (1) The order of the records is the order  in  which
<span id="line8006"></span>                 they were written if the direct access method is
<span id="line8007"></span>                 not a  member  of  the  set  of  allowed  access
<span id="line8008"></span>                 methods  for  the  file.   If  the direct access
<span id="line8009"></span>                 method is also a member of the  set  of  allowed
<span id="line8010"></span>                 access  methods  for  the file, the order of the
<span id="line8011"></span>                 records is the same as that specified for direct
<span id="line8012"></span>                 access (12.2.4.2).  The first record accessed by
<span id="line8013"></span>                 sequential access is  the  record  whose  record
<span id="line8014"></span>                 number  is  1  for  direct  access.   The second
<span id="line8015"></span>                 record accessed  by  sequential  access  is  the
<span id="line8016"></span>                 record  whose  record  number  is  2  for direct
<span id="line8017"></span>                 access, etc.  A record that has not been written
<span id="line8018"></span>                 since the file was created must not be read.
<span id="line8019"></span>
<span id="line8020"></span>             (2) The records of the file are either all formatted
<span id="line8021"></span>                 or  all unformatted, except that the last record
<span id="line8022"></span>                 of the file may be an endfile record.
<span id="line8023"></span>
<span id="line8024"></span>             (3) The records of the file  must  not  be  read  or
<span id="line8025"></span>                 written by direct access input/output statements
<span id="line8026"></span>                 (12.8.1).
<span id="line8027"></span>
<span id="line8028"></span>          12.2.4.2  Direct_Access.   When  connected  for  direct
<span id="line8029"></span>          access, a file has the following properties:
<span id="line8030"></span>
<span id="line8031"></span>             (1) The order of the records is the order  of  their
<span id="line8032"></span>                 record  numbers.   The  records  may  be read or
<span id="line8033"></span>                 written in any order.
<span id="line8034"></span>
<span id="line8035"></span>
<span id="line8036"></span>
<span id="line8037"></span>          FORTRAN 77 Full Language                      Page 12-4
<span id="line8038"></span>
<span id="line8039"></span>
<span id="line8040"></span>
<span id="line8041"></span>
<span id="line8042"></span>
<span id="line8043"></span>
<span id="line8044"></span>
<span id="line8045"></span>          INPUT/OUTPUT STATEMENTS                  ANSI X3J3/90.4
<span id="line8046"></span>
<span id="line8047"></span>
<span id="line8048"></span>
<span id="line8049"></span>             (2) The records of the file are either all formatted
<span id="line8050"></span>                 or  all  unformatted.   If the sequential access
<span id="line8051"></span>                 method is also a member of the  set  of  allowed
<span id="line8052"></span>                 access methods for the file, its endfile record,
<span id="line8053"></span>                 if any, is not considered to be part of the file
<span id="line8054"></span>                 while it is connected for direct access.  If the
<span id="line8055"></span>                 sequential access method is not a member of  the
<span id="line8056"></span>                 set  of allowed access methods for the file, the
<span id="line8057"></span>                 file must not contain an endfile record.
<span id="line8058"></span>
<span id="line8059"></span>             (3) Reading and writing records is accomplished only
<span id="line8060"></span>                 by   direct   access   input/output   statements
<span id="line8061"></span>                 (12.8.1).
<span id="line8062"></span>
<span id="line8063"></span>             (4) All records of the file have the same length.
<span id="line8064"></span>
<span id="line8065"></span>             (5) Each record of the file is  uniquely  identified
<span id="line8066"></span>                 by  a positive integer called the record number.
<span id="line8067"></span>                 The record number of a record is specified  when
<span id="line8068"></span>                 the  record  is  written.  Once established, the
<span id="line8069"></span>                 record number of a record can never be changed.
<span id="line8070"></span>
<span id="line8071"></span>                 Note that a record may not be deleted;  however,
<span id="line8072"></span>                 a record may be rewritten.
<span id="line8073"></span>
<span id="line8074"></span>             (6) Records need not be read or written in the order
<span id="line8075"></span>                 of  their  record  numbers.   Any  record may be
<span id="line8076"></span>                 written into the  file  while  it  is  connected
<span id="line8077"></span>                 (12.3.2)   to   a  unit.   For  example,  it  is
<span id="line8078"></span>                 permissible  to  write  record  3,  even  though
<span id="line8079"></span>                 records  1  and  2  have  not been written.  Any
<span id="line8080"></span>                 record may be read from the  file  while  it  is
<span id="line8081"></span>                 connected  to  a  unit, provided that the record
<span id="line8082"></span>                 was written since the file was created.
<span id="line8083"></span>
<span id="line8084"></span>             (7) The records of the file  must  not  be  read  or
<span id="line8085"></span>                 written using list-directed formatting.
<span id="line8086"></span>
<span id="line8087"></span>          12.2.5  Internal_Files.  Internal files provide a means
<span id="line8088"></span>          of  transferring  and  converting  data  from  internal
<span id="line8089"></span>          storage to internal storage.
<span id="line8090"></span>
<span id="line8091"></span>          12.2.5.1  Internal_File_Properties.  An  internal  file
<span id="line8092"></span>          has the following properties:
<span id="line8093"></span>
<span id="line8094"></span>             (1) The file  is  a  character  variable,  character
<span id="line8095"></span>                 array  element,  character  array,  or character
<span id="line8096"></span>                 substring.
<span id="line8097"></span>
<span id="line8098"></span>             (2) A record of an  internal  file  is  a  character
<span id="line8099"></span>                 variable,  character array element, or character
<span id="line8100"></span>
<span id="line8101"></span>
<span id="line8102"></span>
<span id="line8103"></span>          FORTRAN 77 Full Language                      Page 12-5
<span id="line8104"></span>
<span id="line8105"></span>
<span id="line8106"></span>
<span id="line8107"></span>
<span id="line8108"></span>
<span id="line8109"></span>
<span id="line8110"></span>
<span id="line8111"></span>          INPUT/OUTPUT STATEMENTS                  ANSI X3J3/90.4
<span id="line8112"></span>
<span id="line8113"></span>
<span id="line8114"></span>
<span id="line8115"></span>                 substring.
<span id="line8116"></span>
<span id="line8117"></span>             (3) If the file is a character  variable,  character
<span id="line8118"></span>                 array   element,   or  character  substring,  it
<span id="line8119"></span>                 consists of a single record whose length is  the
<span id="line8120"></span>                 same  as  the  length  of  the  variable,  array
<span id="line8121"></span>                 element, or  substring,  respectively.   If  the
<span id="line8122"></span>                 file  is  a  character array, it is treated as a
<span id="line8123"></span>                 sequence  of  character  array  elements.   Each
<span id="line8124"></span>                 array  element  is  a  record  of the file.  The
<span id="line8125"></span>                 ordering of the records of the file is the  same
<span id="line8126"></span>                 as  the  ordering  of  the array elements in the
<span id="line8127"></span>                 array (5.2.4).  Every record of the file has the
<span id="line8128"></span>                 same  length,  which  is  the length of an array
<span id="line8129"></span>                 element in the array.
<span id="line8130"></span>
<span id="line8131"></span>             (4) The variable, array element, or  substring  that
<span id="line8132"></span>                 is  the  record  of  the  internal  file becomes
<span id="line8133"></span>                 defined by writing the record.  If the number of
<span id="line8134"></span>                 characters  written in a record is less than the
<span id="line8135"></span>                 length of the record, the remaining  portion  of
<span id="line8136"></span>                 the record is filled with blanks.
<span id="line8137"></span>
<span id="line8138"></span>             (5) A record may be read only if the variable, array
<span id="line8139"></span>                 element,  or  substring  that  is  the record is
<span id="line8140"></span>                 defined.
<span id="line8141"></span>
<span id="line8142"></span>             (6) A variable, array element, or substring that  is
<span id="line8143"></span>                 a  record of an internal file may become defined
<span id="line8144"></span>                 (or undefined) by means  other  than  an  output
<span id="line8145"></span>                 statement.   For  example,  the  variable, array
<span id="line8146"></span>                 element, or substring may become  defined  by  a
<span id="line8147"></span>                 character assignment statement.
<span id="line8148"></span>
<span id="line8149"></span>             (7) An internal file is  always  positioned  at  the
<span id="line8150"></span>                 beginning  of  the  first  record  prior to data
<span id="line8151"></span>                 transfer.
<span id="line8152"></span>
<span id="line8153"></span>          12.2.5.2  Internal_File_Restrictions.  An internal file
<span id="line8154"></span>          has the following restrictions:
<span id="line8155"></span>
<span id="line8156"></span>             (1) Reading and writing records is accomplished only
<span id="line8157"></span>                 by   sequential  access  formatted  input/output
<span id="line8158"></span>                 statements (12.8.1) that do  not  specify  list-
<span id="line8159"></span>                 directed formatting.
<span id="line8160"></span>
<span id="line8161"></span>             (2) An auxiliary  input/output  statement  must  not
<span id="line8162"></span>                 specify an internal file.
<span id="line8163"></span>
<span id="line8164"></span>
<span id="line8165"></span>
<span id="line8166"></span>
<span id="line8167"></span>
<span id="line8168"></span>
<span id="line8169"></span>          FORTRAN 77 Full Language                      Page 12-6
<span id="line8170"></span>
<span id="line8171"></span>
<span id="line8172"></span>
<span id="line8173"></span>
<span id="line8174"></span>
<span id="line8175"></span>
<span id="line8176"></span>
<span id="line8177"></span>          INPUT/OUTPUT STATEMENTS                  ANSI X3J3/90.4
<span id="line8178"></span>
<span id="line8179"></span>
<span id="line8180"></span>
<span id="line8181"></span>          12.3  Units
<span id="line8182"></span>
<span id="line8183"></span>          A unit is a means of referring to a file.
<span id="line8184"></span>
<span id="line8185"></span>          12.3.1  Unit_Existence.  At any given time, there is  a
<span id="line8186"></span>          processor-determined  set  of  units  that  are said to
<span id="line8187"></span>          exist for an executable program.
<span id="line8188"></span>
<span id="line8189"></span>          All input/output statements may  refer  to  units  that
<span id="line8190"></span>          exist.  The INQUIRE and CLOSE statements may also refer
<span id="line8191"></span>          to units that do not exist.
<span id="line8192"></span>
<span id="line8193"></span>          12.3.2  Connection_of_a_Unit.  A unit has a property of
<span id="line8194"></span>          being  connected  or  not  connected.  If connected, it
<span id="line8195"></span>          refers to a file.   A  unit  may  become  connected  by
<span id="line8196"></span>          preconnection or by the execution of an OPEN statement.
<span id="line8197"></span>          The property of connection is symmetric: if a  unit  is
<span id="line8198"></span>          connected to a file, the file is connected to the unit.
<span id="line8199"></span>
<span id="line8200"></span>          Preconnection means that the unit  is  connected  to  a
<span id="line8201"></span>          file  at  the  beginning of execution of the executable
<span id="line8202"></span>          program and therefore may be referenced by input/output
<span id="line8203"></span>          statements  without  the  prior  execution  of  an OPEN
<span id="line8204"></span>          statement.
<span id="line8205"></span>
<span id="line8206"></span>          All input/output statements  except  OPEN,  CLOSE,  and
<span id="line8207"></span>          INQUIRE  must  reference  a unit that is connected to a
<span id="line8208"></span>          file and thereby make use of or affect that file.
<span id="line8209"></span>
<span id="line8210"></span>          A file may be connected and not exist.  An example is a
<span id="line8211"></span>          preconnected new file.
<span id="line8212"></span>
<span id="line8213"></span>          A unit must not be connected to more than one  file  at
<span id="line8214"></span>          the same time, and a file must not be connected to more
<span id="line8215"></span>          than one unit at the same  time.   However,  means  are
<span id="line8216"></span>          provided  to change the status of a unit and to connect
<span id="line8217"></span>          a unit to a different file.
<span id="line8218"></span>
<span id="line8219"></span>          After a unit has been disconnected by the execution  of
<span id="line8220"></span>          a CLOSE statement, it may be connected again within the
<span id="line8221"></span>          same executable program to the same file or a different
<span id="line8222"></span>          file.   After  a  file  has  been  disconnected  by the
<span id="line8223"></span>          execution of a CLOSE statement,  it  may  be  connected
<span id="line8224"></span>          again  within  the  same executable program to the same
<span id="line8225"></span>          unit or a different unit.  Note, however, that the only
<span id="line8226"></span>          means  to refer to a file that has been disconnected is
<span id="line8227"></span>          by  its  name  in  an  OPEN   or   INQUIRE   statement.
<span id="line8228"></span>          Therefore,  there  may  be  no means of reconnecting an
<span id="line8229"></span>          unnamed file once it is disconnected.
<span id="line8230"></span>
<span id="line8231"></span>
<span id="line8232"></span>
<span id="line8233"></span>
<span id="line8234"></span>
<span id="line8235"></span>          FORTRAN 77 Full Language                      Page 12-7
<span id="line8236"></span>
<span id="line8237"></span>
<span id="line8238"></span>
<span id="line8239"></span>
<span id="line8240"></span>
<span id="line8241"></span>
<span id="line8242"></span>
<span id="line8243"></span>          INPUT/OUTPUT STATEMENTS                  ANSI X3J3/90.4
<span id="line8244"></span>
<span id="line8245"></span>
<span id="line8246"></span>
<span id="line8247"></span>          12.3.3  Unit_Specifier_and_Identifier.  The form  of  a
<span id="line8248"></span>          unit specifier is:
<span id="line8249"></span>
<span id="line8250"></span>                               [UNIT =] u_
<span id="line8251"></span>
<span id="line8252"></span>          where u_ is an external unit identifier or  an  internal
<span id="line8253"></span>          file identifier.
<span id="line8254"></span>
<span id="line8255"></span>          An external unit identifier is  used  to  refer  to  an
<span id="line8256"></span>          external  file.  An internal file identifier is used to
<span id="line8257"></span>          refer to an internal file.
<span id="line8258"></span>
<span id="line8259"></span>          An external unit identifier is one of the following:
<span id="line8260"></span>
<span id="line8261"></span>             (1) An integer expression i_ whose value must be zero
<span id="line8262"></span>                 or positive
<span id="line8263"></span>
<span id="line8264"></span>             (2) An   asterisk,    identifying    a    particular
<span id="line8265"></span>                 processor-determined   external   unit  that  is
<span id="line8266"></span>                 preconnected  for  formatted  sequential  access
<span id="line8267"></span>                 (12.9.2)
<span id="line8268"></span>
<span id="line8269"></span>          The external unit identified by the value of i_  is  the
<span id="line8270"></span>          same   external  unit  in  all  program  units  of  the
<span id="line8271"></span>          executable program.  In the example:
<span id="line8272"></span>
<span id="line8273"></span>                     SUBROUTINE A
<span id="line8274"></span>                     READ (6) X
<span id="line8275"></span>
<span id="line8276"></span>                     SUBROUTINE B
<span id="line8277"></span>                     N=6
<span id="line8278"></span>                     REWIND N
<span id="line8279"></span>
<span id="line8280"></span>          the value 6 used in both program units  identifies  the
<span id="line8281"></span>          same external unit.
<span id="line8282"></span>
<span id="line8283"></span>          An   external   unit   identifier   in   an   auxiliary
<span id="line8284"></span>          input/output statement (12.10) must not be an asterisk.
<span id="line8285"></span>
<span id="line8286"></span>          An internal file identifier is the name of a  character
<span id="line8287"></span>          variable,  character array, character array element, or
<span id="line8288"></span>          character substring.
<span id="line8289"></span>
<span id="line8290"></span>          If the optional characters UNIT= are omitted  from  the
<span id="line8291"></span>          unit  specifier,  the  unit specifier must be the first
<span id="line8292"></span>          item in a list of specifiers.
<span id="line8293"></span>
<span id="line8294"></span>
<span id="line8295"></span>
<span id="line8296"></span>
<span id="line8297"></span>
<span id="line8298"></span>
<span id="line8299"></span>
<span id="line8300"></span>
<span id="line8301"></span>          FORTRAN 77 Full Language                      Page 12-8
<span id="line8302"></span>
<span id="line8303"></span>
<span id="line8304"></span>
<span id="line8305"></span>
<span id="line8306"></span>
<span id="line8307"></span>
<span id="line8308"></span>
<span id="line8309"></span>          INPUT/OUTPUT STATEMENTS                  ANSI X3J3/90.4
<span id="line8310"></span>
<span id="line8311"></span>
<span id="line8312"></span>
<span id="line8313"></span>          12.4  Format_Specifier_and_Identifier
<span id="line8314"></span>
<span id="line8315"></span>          The form of a format specifier is:
<span id="line8316"></span>
<span id="line8317"></span>                               [FMT =] f_
<span id="line8318"></span>
<span id="line8319"></span>          where f_ is a format identifier.
<span id="line8320"></span>
<span id="line8321"></span>          A format identifier  identifies  a  format.   A  format
<span id="line8322"></span>          identifier must be one of the following:
<span id="line8323"></span>
<span id="line8324"></span>             (1) The statement label of a FORMAT  statement  that
<span id="line8325"></span>                 appears  in  the same program unit as the format
<span id="line8326"></span>                 identifier.
<span id="line8327"></span>
<span id="line8328"></span>             (2) An integer variable name that has been  assigned
<span id="line8329"></span>                 the  statement  label of a FORMAT statement that
<span id="line8330"></span>                 appears in the same program unit as  the  format
<span id="line8331"></span>                 identifier (10.3).
<span id="line8332"></span>
<span id="line8333"></span>             (3) A character array name (13.1.2).
<span id="line8334"></span>
<span id="line8335"></span>             (4) Any  character  expression  except  a  character
<span id="line8336"></span>                 expression involving concatenation of an operand
<span id="line8337"></span>                 whose length specification  is  an  asterisk  in
<span id="line8338"></span>                 parentheses  unless  the operand is the symbolic
<span id="line8339"></span>                 name of  a  constant.   Note  that  a  character
<span id="line8340"></span>                 constant is permitted.
<span id="line8341"></span>
<span id="line8342"></span>             (5) An    asterisk,     specifying     list-directed
<span id="line8343"></span>                 formatting.
<span id="line8344"></span>
<span id="line8345"></span>          If the optional characters FMT= are  omitted  from  the
<span id="line8346"></span>          format  specifier,  the  format  specifier  must be the
<span id="line8347"></span>          second item in the control  information  list  and  the
<span id="line8348"></span>          first  item  must  be  the  unit  specifier without the
<span id="line8349"></span>          optional characters UNIT=.
<span id="line8350"></span>
<span id="line8351"></span>          12.5  Record_Specifier
<span id="line8352"></span>
<span id="line8353"></span>          The form of a record specifier is:
<span id="line8354"></span>
<span id="line8355"></span>                               REC = rn__
<span id="line8356"></span>
<span id="line8357"></span>          where rn__  is  an  integer  expression  whose  value  is
<span id="line8358"></span>          positive.   It  specifies the number of the record that
<span id="line8359"></span>          is to be read or written in a file connected for direct
<span id="line8360"></span>          access.
<span id="line8361"></span>
<span id="line8362"></span>
<span id="line8363"></span>
<span id="line8364"></span>
<span id="line8365"></span>
<span id="line8366"></span>
<span id="line8367"></span>          FORTRAN 77 Full Language                      Page 12-9
<span id="line8368"></span>
<span id="line8369"></span>
<span id="line8370"></span>
<span id="line8371"></span>
<span id="line8372"></span>
<span id="line8373"></span>
<span id="line8374"></span>
<span id="line8375"></span>          INPUT/OUTPUT STATEMENTS                  ANSI X3J3/90.4
<span id="line8376"></span>
<span id="line8377"></span>
<span id="line8378"></span>
<span id="line8379"></span>          12.6  Error_and_End-of-File_Conditions
<span id="line8380"></span>
<span id="line8381"></span>          The set of input/output error conditions  is  processor
<span id="line8382"></span>          dependent.
<span id="line8383"></span>
<span id="line8384"></span>          An  end-of-file  condition  exists  if  either  of  the
<span id="line8385"></span>          following events occurs:
<span id="line8386"></span>
<span id="line8387"></span>             (1) An endfile  record  is  encountered  during  the
<span id="line8388"></span>                 reading  of  a  file  connected  for  sequential
<span id="line8389"></span>                 access.  In this case, the  file  is  positioned
<span id="line8390"></span>                 after the endfile record.
<span id="line8391"></span>
<span id="line8392"></span>             (2) An attempt is made to read a record  beyond  the
<span id="line8393"></span>                 end of an internal file.
<span id="line8394"></span>
<span id="line8395"></span>          If an error condition occurs  during  execution  of  an
<span id="line8396"></span>          input/output  statement,  execution of the input/output
<span id="line8397"></span>          statement terminates  and  the  position  of  the  file
<span id="line8398"></span>          becomes indeterminate.
<span id="line8399"></span>
<span id="line8400"></span>          If an  error  condition  or  an  end-of-file  condition
<span id="line8401"></span>          occurs  during execution of a READ statement, execution
<span id="line8402"></span>          of the  READ  statement  terminates  and  the  entities
<span id="line8403"></span>          specified by the input list and implied-DO-variables in
<span id="line8404"></span>          the input list become undefined.  Note  that  variables
<span id="line8405"></span>          and   array  elements  appearing  only  in  subscripts,
<span id="line8406"></span>          substring expressions, and implied-DO parameters in  an
<span id="line8407"></span>          input  list  do  not become undefined when the entities
<span id="line8408"></span>          specified by the list become undefined.
<span id="line8409"></span>
<span id="line8410"></span>          If an error condition occurs  during  execution  of  an
<span id="line8411"></span>          output  statement,  execution  of  the output statement
<span id="line8412"></span>          terminates and implied-DO-variables in the output  list
<span id="line8413"></span>          become undefined.
<span id="line8414"></span>
<span id="line8415"></span>          If an error condition occurs  during  execution  of  an
<span id="line8416"></span>          input/output   statement   that   contains  neither  an
<span id="line8417"></span>          input/output  status  specifier  (12.7)  nor  an  error
<span id="line8418"></span>          specifier  (12.7.1),  or  if  an  end-of-file condition
<span id="line8419"></span>          occurs  during  execution  of  a  READ  statement  that
<span id="line8420"></span>          contains  neither  an input/output status specifier nor
<span id="line8421"></span>          an end-of-file specifier  (12.7.2),  execution  of  the
<span id="line8422"></span>          executable program is terminated.
<span id="line8423"></span>
<span id="line8424"></span>
<span id="line8425"></span>
<span id="line8426"></span>
<span id="line8427"></span>
<span id="line8428"></span>
<span id="line8429"></span>
<span id="line8430"></span>
<span id="line8431"></span>
<span id="line8432"></span>
<span id="line8433"></span>          FORTRAN 77 Full Language                     Page 12-10
<span id="line8434"></span>
<span id="line8435"></span>
<span id="line8436"></span>
<span id="line8437"></span>
<span id="line8438"></span>
<span id="line8439"></span>
<span id="line8440"></span>
<span id="line8441"></span>          INPUT/OUTPUT STATEMENTS                  ANSI X3J3/90.4
<span id="line8442"></span>
<span id="line8443"></span>
<span id="line8444"></span>
<span id="line8445"></span>          12.7  Input/Output Status, Error, and End-of-File
<span id="line8446"></span>                Specifiers
<span id="line8447"></span>
<span id="line8448"></span>          The form of an input/output status specifier is:
<span id="line8449"></span>
<span id="line8450"></span>                               IOSTAT = ios___
<span id="line8451"></span>
<span id="line8452"></span>          where ios___ is  an  integer  variable  or  integer  array
<span id="line8453"></span>          element.
<span id="line8454"></span>
<span id="line8455"></span>          Execution of an input/output statement containing  this
<span id="line8456"></span>          specifier causes ios___ to become defined:
<span id="line8457"></span>
<span id="line8458"></span>             (1) with a zero value if neither an error  condition
<span id="line8459"></span>                 nor  an  end-of-file condition is encountered by
<span id="line8460"></span>                 the processor,
<span id="line8461"></span>
<span id="line8462"></span>             (2) with  a  processor-dependent  positive   integer
<span id="line8463"></span>                 value if an error condition is encountered, or
<span id="line8464"></span>
<span id="line8465"></span>             (3) with  a  processor-dependent  negative   integer
<span id="line8466"></span>                 value if an end-of-file condition is encountered
<span id="line8467"></span>                 and no error condition is encountered.
<span id="line8468"></span>
<span id="line8469"></span>          12.7.1  Error_Specifier.   The   form   of   an   error
<span id="line8470"></span>          specifier is:
<span id="line8471"></span>
<span id="line8472"></span>                               ERR = s_
<span id="line8473"></span>
<span id="line8474"></span>          where s_  is  the  statement  label  of  an  executable
<span id="line8475"></span>          statement  that appears in the same program unit as the
<span id="line8476"></span>          error specifier.
<span id="line8477"></span>
<span id="line8478"></span>          If  an  input/output  statement   contains   an   error
<span id="line8479"></span>          specifier   and   the  processor  encounters  an  error
<span id="line8480"></span>          condition during execution of the statement:
<span id="line8481"></span>
<span id="line8482"></span>             (1) execution   of   the   input/output    statement
<span id="line8483"></span>                 terminates,
<span id="line8484"></span>
<span id="line8485"></span>             (2) the  position  of  the  file  specified  in  the
<span id="line8486"></span>                 input/output  statement                  becomes
<span id="line8487"></span>                 indeterminate,
<span id="line8488"></span>
<span id="line8489"></span>             (3) if  the  input/output  statement   contains   an
<span id="line8490"></span>                 input/output   status   specifier   (12.7),  the
<span id="line8491"></span>                 variable or array element ios__ _  becomes  defined
<span id="line8492"></span>                 with   a  processor-dependent  positive  integer
<span id="line8493"></span>                 value, and
<span id="line8494"></span>
<span id="line8495"></span>
<span id="line8496"></span>
<span id="line8497"></span>
<span id="line8498"></span>
<span id="line8499"></span>          FORTRAN 77 Full Language                     Page 12-11
<span id="line8500"></span>
<span id="line8501"></span>
<span id="line8502"></span>
<span id="line8503"></span>
<span id="line8504"></span>
<span id="line8505"></span>
<span id="line8506"></span>
<span id="line8507"></span>          INPUT/OUTPUT STATEMENTS                  ANSI X3J3/90.4
<span id="line8508"></span>
<span id="line8509"></span>
<span id="line8510"></span>
<span id="line8511"></span>             (4) execution continues with the statement labeled s_
<span id="line8512"></span>                 .
<span id="line8513"></span>
<span id="line8514"></span>          12.7.2  End-of-File_Specifier.  The form of an  end-of-
<span id="line8515"></span>          file specifier is:
<span id="line8516"></span>
<span id="line8517"></span>                               END = s_
<span id="line8518"></span>
<span id="line8519"></span>          where s_  is  the  statement  label  of  an  executable
<span id="line8520"></span>          statement  that appears in the same program unit as the
<span id="line8521"></span>          end-of-file specifier.
<span id="line8522"></span>
<span id="line8523"></span>          If a READ statement contains an  end-of-file  specifier
<span id="line8524"></span>          and  the  processor encounters an end-of-file condition
<span id="line8525"></span>          and  no  error  condition  during  execution   of   the
<span id="line8526"></span>          statement:
<span id="line8527"></span>
<span id="line8528"></span>             (1) execution of the READ statement terminates,
<span id="line8529"></span>
<span id="line8530"></span>             (2) if the READ statement contains  an  input/output
<span id="line8531"></span>                 status  specifier  (12.7), the variable or array
<span id="line8532"></span>                 element ios___ becomes defined  with  a  processor-
<span id="line8533"></span>                 dependent negative integer value, and
<span id="line8534"></span>
<span id="line8535"></span>             (3) execution continues with the statement labeled s_
<span id="line8536"></span>                 .
<span id="line8537"></span>
<span id="line8538"></span>          12.8  READ,_WRITE,_and_PRINT_Statements
<span id="line8539"></span>
<span id="line8540"></span>          The  READ  statement  is  the   data   transfer   input
<span id="line8541"></span>          statement.  The WRITE and PRINT statements are the data
<span id="line8542"></span>          transfer output statements.   The  forms  of  the  data
<span id="line8543"></span>          transfer input/output statements are:
<span id="line8544"></span>
<span id="line8545"></span>                               READ (cilist______) [iolist______]
<span id="line8546"></span>
<span id="line8547"></span>                               READ f_ [,iolist______]
<span id="line8548"></span>
<span id="line8549"></span>                               WRITE (cilist______) [iolist______]
<span id="line8550"></span>
<span id="line8551"></span>                               PRINT f_ [,iolist______]
<span id="line8552"></span>
<span id="line8553"></span>          where: cilist______ is a control  information  list  (12.8.1)
<span id="line8554"></span>                     that includes:
<span id="line8555"></span>
<span id="line8556"></span>                     (1) A reference to the source or destination
<span id="line8557"></span>                         of the data to be transferred
<span id="line8558"></span>
<span id="line8559"></span>                     (2) Optional   specification   of=   editing
<span id="line8560"></span>                         processes
<span id="line8561"></span>
<span id="line8562"></span>
<span id="line8563"></span>
<span id="line8564"></span>
<span id="line8565"></span>          FORTRAN 77 Full Language                     Page 12-12
<span id="line8566"></span>
<span id="line8567"></span>
<span id="line8568"></span>
<span id="line8569"></span>
<span id="line8570"></span>
<span id="line8571"></span>
<span id="line8572"></span>
<span id="line8573"></span>          INPUT/OUTPUT STATEMENTS                  ANSI X3J3/90.4
<span id="line8574"></span>
<span id="line8575"></span>
<span id="line8576"></span>
<span id="line8577"></span>                     (3) Optional specifiers that  determine  the
<span id="line8578"></span>                         execution  sequence on the occurrence of
<span id="line8579"></span>                         certain events
<span id="line8580"></span>
<span id="line8581"></span>                     (4) Optional  specification  to  identify  a
<span id="line8582"></span>                         record
<span id="line8583"></span>
<span id="line8584"></span>                     (5) Optional specification to provide  t|%he
<span id="line8585"></span>                         return of the input/output status
<span id="line8586"></span>
<span id="line8587"></span>                 f_   is a format identifier (12.4)
<span id="line8588"></span>
<span id="line8589"></span>                 iolist_ _ _ _ _ _ is  an  input/output  list  (12.8.2)
<span id="line8590"></span>                     specifying the data to be transferred
<span id="line8591"></span>
<span id="line8592"></span>          12.8.1  Control_Information_List.       A       control
<span id="line8593"></span>          information  list,  cilist, is a list (2.10) whose list
<span id="line8594"></span>          items may be any of the following:
<span id="line8595"></span>
<span id="line8596"></span>8                              ______________
<span id="line8597"></span>
<span id="line8598"></span>                               [UNIT =] u_
<span id="line8599"></span>                               [FMT =] f_
<span id="line8600"></span>                               REC = rn__
<span id="line8601"></span>                               IOSTAT = ios___
<span id="line8602"></span>                               ERR = s_
<span id="line8603"></span>                               END = s_
<span id="line8604"></span>8                              ______________
<span id="line8605"></span>7                             |8|7|7|7|7|7|7|
<span id="line8606"></span>
<span id="line8607"></span>
<span id="line8608"></span>
<span id="line8609"></span>
<span id="line8610"></span>
<span id="line8611"></span>9                                           |8|7|7|7|7|7|7|
<span id="line8612"></span>
<span id="line8613"></span>
<span id="line8614"></span>
<span id="line8615"></span>
<span id="line8616"></span>
<span id="line8617"></span>
<span id="line8618"></span>
<span id="line8619"></span>9          A control information list  must  contain  exactly  one
<span id="line8620"></span>          unit  specifier  (12.3.3), at most one format specifier
<span id="line8621"></span>          (12.4), at most one record specifier  (12.5),  at  most
<span id="line8622"></span>          one  input/output  status specifier (12.7), at most one
<span id="line8623"></span>          error specifier (12.7.1), and at most  one  end-of-file
<span id="line8624"></span>          specifier (12.7.2).
<span id="line8625"></span>
<span id="line8626"></span>          If the  control  information  list  contains  a  format
<span id="line8627"></span>          specifier,  the  statement  is a formatted input/output
<span id="line8628"></span>          statement; otherwise, it is an unformatted input/output
<span id="line8629"></span>          statement.
<span id="line8630"></span>
<span id="line8631"></span>          If the  control  information  list  contains  a  record
<span id="line8632"></span>          specifier,   the   statement   is   a   direct   access
<span id="line8633"></span>          input/output statement; otherwise, it is  a  sequential
<span id="line8634"></span>          access input/output statement.
<span id="line8635"></span>
<span id="line8636"></span>          If the optional characters UNIT= are omitted  from  the
<span id="line8637"></span>          unit  specifier,  the  unit specifier must be the first
<span id="line8638"></span>          item in the control information list.
<span id="line8639"></span>
<span id="line8640"></span>          If the optional characters FMT= are  omitted  from  the
<span id="line8641"></span>          format  specifier,  the  format  specifier  must be the
<span id="line8642"></span>
<span id="line8643"></span>
<span id="line8644"></span>
<span id="line8645"></span>          FORTRAN 77 Full Language                     Page 12-13
<span id="line8646"></span>
<span id="line8647"></span>
<span id="line8648"></span>
<span id="line8649"></span>
<span id="line8650"></span>
<span id="line8651"></span>
<span id="line8652"></span>
<span id="line8653"></span>          INPUT/OUTPUT STATEMENTS                  ANSI X3J3/90.4
<span id="line8654"></span>
<span id="line8655"></span>
<span id="line8656"></span>
<span id="line8657"></span>          second item in the control  information  list  and  the
<span id="line8658"></span>          first  item  must  be  the  unit  specifier without the
<span id="line8659"></span>          optional characters UNIT=.
<span id="line8660"></span>
<span id="line8661"></span>          A control information list  must  not  contain  both  a
<span id="line8662"></span>          record specifier and an end-of-file specifier.
<span id="line8663"></span>
<span id="line8664"></span>          If the format identifier is an asterisk, the  statement
<span id="line8665"></span>          is  a list-directed input/output statement and a record
<span id="line8666"></span>          specifier must not be present.
<span id="line8667"></span>
<span id="line8668"></span>          In a WRITE statement, the control information list must
<span id="line8669"></span>          not contain an end-of-file specifier.
<span id="line8670"></span>
<span id="line8671"></span>          If the unit specifier specifies an internal  file,  the
<span id="line8672"></span>          control   information   list   must  contain  a  format
<span id="line8673"></span>          identifier other than an asterisk and must not  contain
<span id="line8674"></span>          a record specifier.
<span id="line8675"></span>
<span id="line8676"></span>          12.8.2  Input/Output_List.    An   input/output   list,
<span id="line8677"></span>          iolist,   specifies   the  entities  whose  values  are
<span id="line8678"></span>          transferred by a data transfer input/output statement.
<span id="line8679"></span>
<span id="line8680"></span>          An input/output list is a list (2.10)  of  input/output
<span id="line8681"></span>          list   items   and  implied-DO  lists  (12.8.2.3).   An
<span id="line8682"></span>          input/output list item is either an input list item  or
<span id="line8683"></span>          an output list item.
<span id="line8684"></span>
<span id="line8685"></span>          If an array name appears as an input/output list  item,
<span id="line8686"></span>          it  is  treated  as if all of the elements of the array
<span id="line8687"></span>          were specified in the  order  given  by  array  element
<span id="line8688"></span>          ordering  (5.2.4).   The  name of an assumed-size dummy
<span id="line8689"></span>          array must not appear as an input/output list item.
<span id="line8690"></span>
<span id="line8691"></span>          12.8.2.1  Input_List_Items.  An input list item must be
<span id="line8692"></span>          one of the following:
<span id="line8693"></span>
<span id="line8694"></span>             (1) A variable name
<span id="line8695"></span>
<span id="line8696"></span>             (2) An array element name
<span id="line8697"></span>
<span id="line8698"></span>             (3) A character substring name
<span id="line8699"></span>
<span id="line8700"></span>             (4) An array name
<span id="line8701"></span>
<span id="line8702"></span>          Only input list items may appear as  input/output  list
<span id="line8703"></span>          items in an input statement.
<span id="line8704"></span>
<span id="line8705"></span>          12.8.2.2  Output_List_Items.  An output list item  must
<span id="line8706"></span>          be one of the following:
<span id="line8707"></span>
<span id="line8708"></span>
<span id="line8709"></span>
<span id="line8710"></span>
<span id="line8711"></span>          FORTRAN 77 Full Language                     Page 12-14
<span id="line8712"></span>
<span id="line8713"></span>
<span id="line8714"></span>
<span id="line8715"></span>
<span id="line8716"></span>
<span id="line8717"></span>
<span id="line8718"></span>
<span id="line8719"></span>          INPUT/OUTPUT STATEMENTS                  ANSI X3J3/90.4
<span id="line8720"></span>
<span id="line8721"></span>
<span id="line8722"></span>
<span id="line8723"></span>             (1) A variable name
<span id="line8724"></span>
<span id="line8725"></span>             (2) An array element name
<span id="line8726"></span>
<span id="line8727"></span>             (3) A character substring name
<span id="line8728"></span>
<span id="line8729"></span>             (4) An array name
<span id="line8730"></span>
<span id="line8731"></span>             (5) Any  other   expression   except   a   character
<span id="line8732"></span>                 expression involving concatenation of an operand
<span id="line8733"></span>                 whose length specification  is  an  asterisk  in
<span id="line8734"></span>                 parentheses  unless  the operand is the symbolic
<span id="line8735"></span>                 name of a constant
<span id="line8736"></span>
<span id="line8737"></span>          Note that a constant, an expression involving operators
<span id="line8738"></span>          or  function  references,  or an expression enclosed in
<span id="line8739"></span>          parentheses may appear as an output list item but  must
<span id="line8740"></span>          not appear as an input list item.
<span id="line8741"></span>
<span id="line8742"></span>          12.8.2.3  Implied-DO_List.  An implied-DO  list  is  of
<span id="line8743"></span>          the form:
<span id="line8744"></span>
<span id="line8745"></span>                               ( dlist_____, i_ = e_918, e_928 [,e_938 ] )
<span id="line8746"></span>
<span id="line8747"></span>          where: i_ ,  are  as  specified  for  the  DO  statement
<span id="line8748"></span>                     (11.10)
<span id="line8749"></span>
<span id="line8750"></span>                 dlistunde<span class="entity"><span>&amp;</span>gt;</span>r is an input/output list
<span id="line8751"></span>
<span id="line8752"></span>          The range of an implied-DO list is the list dlist_ _ _ _ _ .
<span id="line8753"></span>          Note  that  dlist_____ may contain implied-DO . lists.  The
<span id="line8754"></span>          iteration count and the values of the DO-variable i_ are
<span id="line8755"></span>          established  from  e_918, e_928, and e_938 exactly as for a DO-
<span id="line8756"></span>          loop.  In an input statement, the DO-variable i_, or  an
<span id="line8757"></span>          associated  entity,  must  not  appear as an input list
<span id="line8758"></span>          item in dlist_____.  When an implied-DO list appears  in  an
<span id="line8759"></span>          input/output  list,  the  list  items  in  dlist_ _ ___ are
<span id="line8760"></span>          specified once for each  iteration  of  the  implied-DO
<span id="line8761"></span>          list   with  appropriate substitution of values for any
<span id="line8762"></span>          occurrence of the DO-variable i_.
<span id="line8763"></span>
<span id="line8764"></span>          12.9  Execution of a Data Transfer Input/Output
<span id="line8765"></span>                Statement
<span id="line8766"></span>
<span id="line8767"></span>          The effect of executing a  data  transfer  input/output
<span id="line8768"></span>          statement  must  be as if the following operations were
<span id="line8769"></span>          performed in the order specified:
<span id="line8770"></span>
<span id="line8771"></span>             (1) Determine the direction of data transfer
<span id="line8772"></span>
<span id="line8773"></span>
<span id="line8774"></span>
<span id="line8775"></span>
<span id="line8776"></span>
<span id="line8777"></span>          FORTRAN 77 Full Language                     Page 12-15
<span id="line8778"></span>
<span id="line8779"></span>
<span id="line8780"></span>
<span id="line8781"></span>
<span id="line8782"></span>
<span id="line8783"></span>
<span id="line8784"></span>
<span id="line8785"></span>          INPUT/OUTPUT STATEMENTS                  ANSI X3J3/90.4
<span id="line8786"></span>
<span id="line8787"></span>
<span id="line8788"></span>
<span id="line8789"></span>             (2) Identify the unit
<span id="line8790"></span>
<span id="line8791"></span>             (3) Establish the format if any is specified
<span id="line8792"></span>
<span id="line8793"></span>             (4) Position the file prior to data transfer
<span id="line8794"></span>
<span id="line8795"></span>             (5) Transfer data between the file and the  entities
<span id="line8796"></span>                 specified by the input/output list (if any)
<span id="line8797"></span>
<span id="line8798"></span>             (6) Position the file after data transfer
<span id="line8799"></span>
<span id="line8800"></span>             (7) Cause the specified integer  variable  or  array
<span id="line8801"></span>                 element in the input/output status specifier (if
<span id="line8802"></span>                 any) to become defined
<span id="line8803"></span>
<span id="line8804"></span>          12.9.1  Direction_of_Data_Transfer.   Execution  of   a
<span id="line8805"></span>          READ  statement  causes values to be transferred from a
<span id="line8806"></span>          file to the entities specified by the  input  list,  if
<span id="line8807"></span>          one is specified.
<span id="line8808"></span>
<span id="line8809"></span>          Execution of a WRITE or PRINT statement  causes  values
<span id="line8810"></span>          to be transferred to a file from the entities specified
<span id="line8811"></span>          by the output list and format specification  (if  any).
<span id="line8812"></span>          Execution of a WRITE or PRINT statement for a file that
<span id="line8813"></span>          does not  exist  creates  the  file,  unless  an  error
<span id="line8814"></span>          condition occurs.
<span id="line8815"></span>
<span id="line8816"></span>          12.9.2  Identifying_a_Unit.     A     data     transfer
<span id="line8817"></span>          input/output   statement   that   contains   a  control
<span id="line8818"></span>          information list (12.8.1)  includes  a  unit  specifier
<span id="line8819"></span>          that  identifies  an external unit or an internal file.
<span id="line8820"></span>          A READ  statement  that  does  not  contain  a  control
<span id="line8821"></span>          information  list  specifies  a  particular  processor-
<span id="line8822"></span>          determined  unit,  which  is  the  same  as  the   unit
<span id="line8823"></span>          identified  by  an  asterisk  in  a READ statement that
<span id="line8824"></span>          contains a control information list.  A PRINT statement
<span id="line8825"></span>          specifies  some  other processor-determined unit, which
<span id="line8826"></span>          is the same as the unit identified by an asterisk in  a
<span id="line8827"></span>          WRITE statement.  Thus, each data transfer input/output
<span id="line8828"></span>          statement identifies an external unit  or  an  internal
<span id="line8829"></span>          file.
<span id="line8830"></span>
<span id="line8831"></span>          The unit identified by  a  data  transfer  input/output
<span id="line8832"></span>          statement must be connected to a file when execution of
<span id="line8833"></span>          the statement begins.
<span id="line8834"></span>
<span id="line8835"></span>          12.9.3  Establishing_a_Format.     If    the    control
<span id="line8836"></span>          information  list  contains  a  format identifier other
<span id="line8837"></span>          than an asterisk, the format  specification  identified
<span id="line8838"></span>          by the format identifier is established.  If the format
<span id="line8839"></span>          identifier is an asterisk, list-directed formatting  is
<span id="line8840"></span>
<span id="line8841"></span>
<span id="line8842"></span>
<span id="line8843"></span>          FORTRAN 77 Full Language                     Page 12-16
<span id="line8844"></span>
<span id="line8845"></span>
<span id="line8846"></span>
<span id="line8847"></span>
<span id="line8848"></span>
<span id="line8849"></span>
<span id="line8850"></span>
<span id="line8851"></span>          INPUT/OUTPUT STATEMENTS                  ANSI X3J3/90.4
<span id="line8852"></span>
<span id="line8853"></span>
<span id="line8854"></span>
<span id="line8855"></span>          established.
<span id="line8856"></span>
<span id="line8857"></span>          On output, if an internal file has  been  specified,  a
<span id="line8858"></span>          format  specification  (13.1) that is in the file or is
<span id="line8859"></span>          associated (17.1) with the file must not be specified.
<span id="line8860"></span>
<span id="line8861"></span>          12.9.4  File_Position_Prior_to_Data_Transfer.       The
<span id="line8862"></span>          positioning  of the file prior to data transfer depends
<span id="line8863"></span>          on the method of access: sequential or direct.
<span id="line8864"></span>
<span id="line8865"></span>          If the file contains an endfile record, the  file  must
<span id="line8866"></span>          not  be  positioned  after  the endfile record prior to
<span id="line8867"></span>          data transfer.
<span id="line8868"></span>
<span id="line8869"></span>          12.9.4.1  Sequential_Access.  On  input,  the  file  is
<span id="line8870"></span>          positioned  at  the beginning of the next record.  This
<span id="line8871"></span>          record becomes the current record.  On  output,  a  new
<span id="line8872"></span>          record  is  created  and becomes the last record of the
<span id="line8873"></span>          file.
<span id="line8874"></span>
<span id="line8875"></span>          An internal file is always positioned at the  beginning
<span id="line8876"></span>          of  the  first record of the file.  This record becomes
<span id="line8877"></span>          the current record.
<span id="line8878"></span>
<span id="line8879"></span>          12.9.4.2  Direct_Access.  For direct access,  the  file
<span id="line8880"></span>          is  positioned at the beginning of the record specified
<span id="line8881"></span>          by the record specifier (12.5).   This  record  becomes
<span id="line8882"></span>          the current record.
<span id="line8883"></span>
<span id="line8884"></span>          12.9.5  Data_Transfer.  Data  are  transferred  between
<span id="line8885"></span>          records  and  entities  specified  by  the input/output
<span id="line8886"></span>          list.  The list items are processed in the order of the
<span id="line8887"></span>          input/output list.
<span id="line8888"></span>
<span id="line8889"></span>          All values  needed  to  determine  which  entities  are
<span id="line8890"></span>          specified  by  an input/output list item are determined
<span id="line8891"></span>          at the beginning of the processing of that  item.   All
<span id="line8892"></span>          values   are   transmitted  to  or  from  the  entities
<span id="line8893"></span>          specified by a list item prior to the processing of any
<span id="line8894"></span>          succeeding list item.  In the example,
<span id="line8895"></span>
<span id="line8896"></span>                               READ (3) N, A(N)
<span id="line8897"></span>
<span id="line8898"></span>          two values are read; one is  assigned  to  N,  and  the
<span id="line8899"></span>          second is assigned to A(N) for the new value of N.
<span id="line8900"></span>
<span id="line8901"></span>          An input list item, or an  entity  associated  with  it
<span id="line8902"></span>          (17.1.3),   must   not   contain  any  portion  of  the
<span id="line8903"></span>          established format specification.
<span id="line8904"></span>
<span id="line8905"></span>
<span id="line8906"></span>
<span id="line8907"></span>
<span id="line8908"></span>
<span id="line8909"></span>          FORTRAN 77 Full Language                     Page 12-17
<span id="line8910"></span>
<span id="line8911"></span>
<span id="line8912"></span>
<span id="line8913"></span>
<span id="line8914"></span>
<span id="line8915"></span>
<span id="line8916"></span>
<span id="line8917"></span>          INPUT/OUTPUT STATEMENTS                  ANSI X3J3/90.4
<span id="line8918"></span>
<span id="line8919"></span>
<span id="line8920"></span>
<span id="line8921"></span>          If an intern file has been specified,  an  input/output
<span id="line8922"></span>          list  item  must  not be in the file or associated with
<span id="line8923"></span>          the file.
<span id="line8924"></span>
<span id="line8925"></span>          A DO-variable  becomes  defined  at  the  beginning  of
<span id="line8926"></span>          processing of the items that constitute the range of an
<span id="line8927"></span>          implied-DO list.
<span id="line8928"></span>
<span id="line8929"></span>          On  output,  every  entity  whose  value   is   to   be
<span id="line8930"></span>          transferred must be defined.
<span id="line8931"></span>
<span id="line8932"></span>          On input, an  attempt  to  read  a  record  of  a  file
<span id="line8933"></span>          connected  for  direct  access  that has not previously
<span id="line8934"></span>          been written causes all entities specified by the input
<span id="line8935"></span>          list to become undefined.
<span id="line8936"></span>
<span id="line8937"></span>          12.9.5.1  Unformatted_Data_Transfer.             During
<span id="line8938"></span>          unformatted data transfer, data are transferred without
<span id="line8939"></span>          editing between the current  record  and  the  entities
<span id="line8940"></span>          specified by the input/output list.  Exactly one record
<span id="line8941"></span>          is read or written.
<span id="line8942"></span>
<span id="line8943"></span>          On input, the file  must  be  positioned  so  that  the
<span id="line8944"></span>          record  read  is  an  unformatted  record or an endfile
<span id="line8945"></span>          record.
<span id="line8946"></span>
<span id="line8947"></span>          On input, the number of values required  by  the  input
<span id="line8948"></span>          list must be less than or equal to the number of values
<span id="line8949"></span>          in the record.
<span id="line8950"></span>
<span id="line8951"></span>          On input, the type of each value  in  the  record  must
<span id="line8952"></span>          agree  with the type of the corresponding entity in the
<span id="line8953"></span>          input  list,  except  that  one   complex   value   may
<span id="line8954"></span>          correspond to two real list entities or two real values
<span id="line8955"></span>          may correspond to  one  complex  list  entity.   If  an
<span id="line8956"></span>          entity  in  the  input  list  is of type character, the
<span id="line8957"></span>          length of the character  entity  must  agree  with  the
<span id="line8958"></span>          length of the character value.
<span id="line8959"></span>
<span id="line8960"></span>          On output to a file connected for  direct  access,  the
<span id="line8961"></span>          output  list  must not specify more values than can fit
<span id="line8962"></span>          into a record.
<span id="line8963"></span>
<span id="line8964"></span>          On output, if the file is connected for  direct  access
<span id="line8965"></span>          and the values specified by the output list do not fill
<span id="line8966"></span>          the record, the remainder of the record is undefined.
<span id="line8967"></span>
<span id="line8968"></span>          If the file is connected  for  formatted  input/output,
<span id="line8969"></span>          unformatted data transfer is prohibited.
<span id="line8970"></span>
<span id="line8971"></span>
<span id="line8972"></span>
<span id="line8973"></span>
<span id="line8974"></span>
<span id="line8975"></span>          FORTRAN 77 Full Language                     Page 12-18
<span id="line8976"></span>
<span id="line8977"></span>
<span id="line8978"></span>
<span id="line8979"></span>
<span id="line8980"></span>
<span id="line8981"></span>
<span id="line8982"></span>
<span id="line8983"></span>          INPUT/OUTPUT STATEMENTS                  ANSI X3J3/90.4
<span id="line8984"></span>
<span id="line8985"></span>
<span id="line8986"></span>
<span id="line8987"></span>          The unit specified must be an external unit.
<span id="line8988"></span>
<span id="line8989"></span>          12.9.5.2  Formatted_Data_Transfer.   During   formatted
<span id="line8990"></span>          data   transfer,  data  are  transferred  with  editing
<span id="line8991"></span>          between the entities specified by the input/output list
<span id="line8992"></span>          and   the   file.   The  current  record  and  possibly
<span id="line8993"></span>          additional records are read or written.
<span id="line8994"></span>
<span id="line8995"></span>          On input, the file  must  be  positioned  so  that  the
<span id="line8996"></span>          record read is a formatted record or an endfile record.
<span id="line8997"></span>
<span id="line8998"></span>          If the file is connected for unformatted  input/output,
<span id="line8999"></span>          formatted data transfer is prohibited.
<span id="line9000"></span>
<span id="line9001"></span>          12.9.5.2.1  Using_a_Format_Specification.  If a  format
<span id="line9002"></span>          specification  has  been  established,  format  control
<span id="line9003"></span>          (13.3)  is  initiated  and  editing  is  performed   as
<span id="line9004"></span>          described in 13.3 through 13.5.
<span id="line9005"></span>
<span id="line9006"></span>          On input, the input list and format specification  must
<span id="line9007"></span>          not  require  more  characters  from  a record than the
<span id="line9008"></span>          record contains.
<span id="line9009"></span>
<span id="line9010"></span>          If the file is connected for direct access, the  record
<span id="line9011"></span>          number is increased by one as each succeeding record is
<span id="line9012"></span>          read or written.
<span id="line9013"></span>
<span id="line9014"></span>          On output, if the file is connected for  direct  access
<span id="line9015"></span>          or  is an internal file and the characters specified by
<span id="line9016"></span>          the output list and format do not fill a record,  blank
<span id="line9017"></span>          characters are added to fill the record.
<span id="line9018"></span>
<span id="line9019"></span>          On output, if the file is connected for  direct  access
<span id="line9020"></span>          or  is  an  internal  file,  the output list and format
<span id="line9021"></span>          specification must not specify more  characters  for  a
<span id="line9022"></span>          record than can fit into the record.
<span id="line9023"></span>
<span id="line9024"></span>          12.9.5.2.2  List-Directed_Formatting.  If list-directed
<span id="line9025"></span>          formatting  has  been established, editing is performed
<span id="line9026"></span>          as described in 13.6.
<span id="line9027"></span>
<span id="line9028"></span>          12.9.5.2.3  Printing_of_Formatted_Records.          The
<span id="line9029"></span>          transfer  of  information  in  a  formatted  record  to
<span id="line9030"></span>          certain devices determined by the processor  is  called
<span id="line9031"></span>          printing.   If a formatted record is printed, the first
<span id="line9032"></span>          character of the record is not printed.  The  remaining
<span id="line9033"></span>          characters  of  the  record, if any, are printed in one
<span id="line9034"></span>          line beginning at the left margin.
<span id="line9035"></span>
<span id="line9036"></span>          The  first  character  of  such  a  record   determines
<span id="line9037"></span>          vertical spacing as follows:
<span id="line9038"></span>
<span id="line9039"></span>
<span id="line9040"></span>
<span id="line9041"></span>          FORTRAN 77 Full Language                     Page 12-19
<span id="line9042"></span>
<span id="line9043"></span>
<span id="line9044"></span>
<span id="line9045"></span>
<span id="line9046"></span>
<span id="line9047"></span>
<span id="line9048"></span>
<span id="line9049"></span>          INPUT/OUTPUT STATEMENTS                  ANSI X3J3/90.4
<span id="line9050"></span>
<span id="line9051"></span>
<span id="line9052"></span>
<span id="line9053"></span>8              ______________________________________________
<span id="line9054"></span>
<span id="line9055"></span>               Character   Vertical Spacing Before Printing
<span id="line9056"></span>8              ______________________________________________
<span id="line9057"></span>
<span id="line9058"></span>                 Blank     One Line
<span id="line9059"></span>                   0       Two Lines
<span id="line9060"></span>                   1       To First Line of Next Page
<span id="line9061"></span>                   +       No Advance
<span id="line9062"></span>8              ______________________________________________
<span id="line9063"></span>7             |7|7|7|7|7|7|7|
<span id="line9064"></span>
<span id="line9065"></span>
<span id="line9066"></span>
<span id="line9067"></span>
<span id="line9068"></span>
<span id="line9069"></span>
<span id="line9070"></span>                        |7|7|7|7|7|7|7|
<span id="line9071"></span>
<span id="line9072"></span>
<span id="line9073"></span>
<span id="line9074"></span>
<span id="line9075"></span>
<span id="line9076"></span>
<span id="line9077"></span>                                                           |7|7|7|7|7|7|7|
<span id="line9078"></span>
<span id="line9079"></span>
<span id="line9080"></span>
<span id="line9081"></span>
<span id="line9082"></span>
<span id="line9083"></span>
<span id="line9084"></span>
<span id="line9085"></span>
<span id="line9086"></span>          If there are no characters in the record (13.5.4),  the
<span id="line9087"></span>          vertical  spacing  is  one line and no characters other
<span id="line9088"></span>          than blank are printed in that line.
<span id="line9089"></span>
<span id="line9090"></span>          A PRINT statement does not  imply  that  printing  will
<span id="line9091"></span>          occur,  and  a  WRITE  statement  does  not  imply that
<span id="line9092"></span>          printing will not occur.
<span id="line9093"></span>
<span id="line9094"></span>          12.9.6  File_Position_After_Data_Transfer.  If an  end-
<span id="line9095"></span>          of-file  condition  exists  as  a  result of reading an
<span id="line9096"></span>          endfile  record,  the  file  is  positioned  after  the
<span id="line9097"></span>          endfile record.
<span id="line9098"></span>
<span id="line9099"></span>          If no error condition or end-of-file condition  exists,
<span id="line9100"></span>          the  file  is  positioned after the last record read or
<span id="line9101"></span>          written and that record becomes the  preceding  record.
<span id="line9102"></span>          A  record  written  on  a file connected for sequential
<span id="line9103"></span>          access becomes the last record of the file.
<span id="line9104"></span>
<span id="line9105"></span>           If the file is positioned after  the  endfile  record,
<span id="line9106"></span>          execution  of a data transfer input/output statement is
<span id="line9107"></span>          prohibited.  However, a BACKSPACE or  REWIND  statement
<span id="line9108"></span>          may be used to reposition the file.
<span id="line9109"></span>
<span id="line9110"></span>          If an error condition exists, the position of the  file
<span id="line9111"></span>          is indeterminate.
<span id="line9112"></span>
<span id="line9113"></span>          12.9.7  Input/Output_Status_Specifier_Definition.    If
<span id="line9114"></span>          the  data  transfer  input/output statement contains an
<span id="line9115"></span>          input/output status specifier, the integer variable  or
<span id="line9116"></span>          array  element  ios_ _ _  becomes  defined.   If no error
<span id="line9117"></span>          condition or end-of-file condition exists, the value of
<span id="line9118"></span>          ios_ __ is zero.  If an error condition exists, the value
<span id="line9119"></span>          of ios___ is positive.  If an end-of-file condition exists
<span id="line9120"></span>          and  no  error  condition  exists,  the value of ios___ is
<span id="line9121"></span>          negative.
<span id="line9122"></span>
<span id="line9123"></span>
<span id="line9124"></span>
<span id="line9125"></span>
<span id="line9126"></span>
<span id="line9127"></span>9
<span id="line9128"></span>
<span id="line9129"></span>
<span id="line9130"></span>          FORTRAN 77 Full Language                     Page 12-20
<span id="line9131"></span>
<span id="line9132"></span>
<span id="line9133"></span>
<span id="line9134"></span>
<span id="line9135"></span>
<span id="line9136"></span>
<span id="line9137"></span>
<span id="line9138"></span>          INPUT/OUTPUT STATEMENTS                  ANSI X3J3/90.4
<span id="line9139"></span>
<span id="line9140"></span>
<span id="line9141"></span>
<span id="line9142"></span>          12.10  Auxiliary_Input/Output_Statements
<span id="line9143"></span>
<span id="line9144"></span>          12.10.1  OPEN_Statement.  An OPEN statement may be used
<span id="line9145"></span>          to  connect (12.3.2) an existing file to a unit, create
<span id="line9146"></span>          a file (12.2.1) that is preconnected, create a file and
<span id="line9147"></span>          connect it to a unit, or change certain specifiers of a
<span id="line9148"></span>          connection between a file and a unit.
<span id="line9149"></span>
<span id="line9150"></span>          The form of an OPEN statement is:
<span id="line9151"></span>
<span id="line9152"></span>                               OPEN (olist_____)
<span id="line9153"></span>
<span id="line9154"></span>          where olist_____ is a list (2.10) of specifiers:
<span id="line9155"></span>
<span id="line9156"></span>8                              ______________
<span id="line9157"></span>
<span id="line9158"></span>                               [UNIT =] u_
<span id="line9159"></span>                               IOSTAT = ios___
<span id="line9160"></span>                               ERR = s_
<span id="line9161"></span>                               FILE = fin___
<span id="line9162"></span>                               STATUS = sta___
<span id="line9163"></span>                               ACCESS = acc___
<span id="line9164"></span>                               FORM = fm__
<span id="line9165"></span>                               RECL = rl__
<span id="line9166"></span>                               BLANK = blnk____
<span id="line9167"></span>8                              ______________
<span id="line9168"></span>7                             |8|7|7|7|7|7|7|7|7|7|
<span id="line9169"></span>
<span id="line9170"></span>
<span id="line9171"></span>
<span id="line9172"></span>
<span id="line9173"></span>
<span id="line9174"></span>
<span id="line9175"></span>
<span id="line9176"></span>
<span id="line9177"></span>9                                           |8|7|7|7|7|7|7|7|7|7|
<span id="line9178"></span>
<span id="line9179"></span>
<span id="line9180"></span>
<span id="line9181"></span>
<span id="line9182"></span>
<span id="line9183"></span>
<span id="line9184"></span>
<span id="line9185"></span>
<span id="line9186"></span>
<span id="line9187"></span>
<span id="line9188"></span>9          olist_____ must contain exactly one external unit  specifier
<span id="line9189"></span>          (12.3.3)  and  may  contain  at most one of each of the
<span id="line9190"></span>          other specifiers.
<span id="line9191"></span>
<span id="line9192"></span>          The other specifiers are described as follows:
<span id="line9193"></span>
<span id="line9194"></span>          IOSTAT = ios___
<span id="line9195"></span>
<span id="line9196"></span>                 is  an  input/output  status  specifier  (12.7).
<span id="line9197"></span>                 Execution  of  an OPEN statement containing this
<span id="line9198"></span>                 specifier causes ios___ to become  defined  with  a
<span id="line9199"></span>                 zero  value if no error condition exists or with
<span id="line9200"></span>                 a processor-dependent positive integer value  if
<span id="line9201"></span>                 an error condition exists.
<span id="line9202"></span>
<span id="line9203"></span>          ERR = s_
<span id="line9204"></span>
<span id="line9205"></span>                 is an error specifier (12.7.1).
<span id="line9206"></span>
<span id="line9207"></span>          FILE = fin___
<span id="line9208"></span>
<span id="line9209"></span>                 fin___ is a character expression whose  value  when
<span id="line9210"></span>                 any  trailing  blanks are removed is the name of
<span id="line9211"></span>                 the file to be connected to the specified  unit.
<span id="line9212"></span>                 The  file name must be a name that is allowed by
<span id="line9213"></span>
<span id="line9214"></span>
<span id="line9215"></span>
<span id="line9216"></span>          FORTRAN 77 Full Language                     Page 12-21
<span id="line9217"></span>
<span id="line9218"></span>
<span id="line9219"></span>
<span id="line9220"></span>
<span id="line9221"></span>
<span id="line9222"></span>
<span id="line9223"></span>
<span id="line9224"></span>          INPUT/OUTPUT STATEMENTS                  ANSI X3J3/90.4
<span id="line9225"></span>
<span id="line9226"></span>
<span id="line9227"></span>
<span id="line9228"></span>                 the processor.  If this specifier is omitted and
<span id="line9229"></span>                 the  unit is not connected to a file, it becomes
<span id="line9230"></span>                 connected to a processor-determined file.   (See
<span id="line9231"></span>                 also 12.10.1.1.)
<span id="line9232"></span>
<span id="line9233"></span>          STATUS = sta___
<span id="line9234"></span>
<span id="line9235"></span>                 sta___ is a character expression whose  value  when
<span id="line9236"></span>                 any  trailing  blanks  are  removed is OLD, NEW,
<span id="line9237"></span>                 SCRATCH,  or  UNKNOWN.   If  OLD   or   NEW   is
<span id="line9238"></span>                 specified,  a FILE= specifier must be given.  If
<span id="line9239"></span>                 OLD is specified, the file must exist.   If  NEW
<span id="line9240"></span>                 is   specified,   the   file   must  not  exist.
<span id="line9241"></span>                 Successful execution of an OPEN  statement  with
<span id="line9242"></span>                 NEW  specified  creates the file and changes the
<span id="line9243"></span>                 status  to  OLD  (12.10.1.1).   If  SCRATCH   is
<span id="line9244"></span>                 specified  with  an  unnamed  file,  the file is
<span id="line9245"></span>                 connected to the specified unit for use  by  the
<span id="line9246"></span>                 executable  program  but  is deleted (12.2.1) at
<span id="line9247"></span>                 the execution of a CLOSE statement referring  to
<span id="line9248"></span>                 the  same  unit  or  at  the  termination of the
<span id="line9249"></span>                 executable  program.   SCRATCH   must   not   be
<span id="line9250"></span>                 specified  with  a  named  file.   If UNKNOWN is
<span id="line9251"></span>                 specified, the status  is  processor  dependent.
<span id="line9252"></span>                 If this specifier is omitted, a value of UNKNOWN
<span id="line9253"></span>                 is assumed.
<span id="line9254"></span>
<span id="line9255"></span>          ACCESS = acc___
<span id="line9256"></span>
<span id="line9257"></span>                 acc___ is a character expression whose  value  when
<span id="line9258"></span>                 any trailing blanks are removed is SEQUENTIAL or
<span id="line9259"></span>                 DIRECT.  It specifies the access method for  the
<span id="line9260"></span>                 connection  of  the  file as being sequential or
<span id="line9261"></span>                 direct (12.2.4).  If this specifier is  omitted,
<span id="line9262"></span>                 the   assumed   value  is  SEQUENTIAL.   For  an
<span id="line9263"></span>                 existing file, the specified access method  must
<span id="line9264"></span>                 be included in the set of allowed access methods
<span id="line9265"></span>                 for the file (12.2.4).   For  a  new  file,  the
<span id="line9266"></span>                 processor creates the file with a set of allowed
<span id="line9267"></span>                 access  methods  that  includes  the   specified
<span id="line9268"></span>                 method.
<span id="line9269"></span>
<span id="line9270"></span>          FORM = fm__
<span id="line9271"></span>
<span id="line9272"></span>                 fm__ is a character expression  whose  value  when
<span id="line9273"></span>                 any  trailing blanks are removed is FORMATTED or
<span id="line9274"></span>                 UNFORMATTED.  It  specifies  that  the  file  is
<span id="line9275"></span>                 being  connected  for  formatted  or unformatted
<span id="line9276"></span>                 input/output, respectively.  If  this  specifier
<span id="line9277"></span>                 is omitted, a value of UNFORMATTED is assumed if
<span id="line9278"></span>                 the file is being connected for  direct  access,
<span id="line9279"></span>
<span id="line9280"></span>
<span id="line9281"></span>
<span id="line9282"></span>          FORTRAN 77 Full Language                     Page 12-22
<span id="line9283"></span>
<span id="line9284"></span>
<span id="line9285"></span>
<span id="line9286"></span>
<span id="line9287"></span>
<span id="line9288"></span>
<span id="line9289"></span>
<span id="line9290"></span>          INPUT/OUTPUT STATEMENTS                  ANSI X3J3/90.4
<span id="line9291"></span>
<span id="line9292"></span>
<span id="line9293"></span>
<span id="line9294"></span>                 and  a value of FORMATTED is assumed if the file
<span id="line9295"></span>                 is being connected for sequential  access.   For
<span id="line9296"></span>                 an  existing  file,  the  specified form must be
<span id="line9297"></span>                 included in the set of  allowed  forms  for  the
<span id="line9298"></span>                 file  (12.2.2).   For  a new file, the processor
<span id="line9299"></span>                 creates the file with a  set  of  allowed  forms
<span id="line9300"></span>                 that includes the specified form.
<span id="line9301"></span>
<span id="line9302"></span>          RECL = rl__
<span id="line9303"></span>
<span id="line9304"></span>                 rl__ is an integer expression whose value must  be
<span id="line9305"></span>                 positive.   It  specifies  the  length  of  each
<span id="line9306"></span>                 record in a  file  being  connected  for  direct
<span id="line9307"></span>                 access.   If  the  file  is  being connected for
<span id="line9308"></span>                 formatted input/output, the length is the number
<span id="line9309"></span>                 of  characters.   If the file is being connected
<span id="line9310"></span>                 for  unformatted  input/output,  the  length  is
<span id="line9311"></span>                 measured  in  processor-dependent units.  For an
<span id="line9312"></span>                 existing file, the value of rl__ must be  included
<span id="line9313"></span>                 in  the  set  of  allowed record lengths for the
<span id="line9314"></span>                 file (12.2.2).  For a new  file,  the  processor
<span id="line9315"></span>                 creates  the  file  with a set of allowed record
<span id="line9316"></span>                 lengths that includes the specified value.  This
<span id="line9317"></span>                 specifier  must  be  given  when a file is being
<span id="line9318"></span>                 connected for direct access; otherwise, it  must
<span id="line9319"></span>                 be omitted.
<span id="line9320"></span>
<span id="line9321"></span>          BLANK = blnk____
<span id="line9322"></span>
<span id="line9323"></span>                 blnk____ is a character expression whose value  when
<span id="line9324"></span>                 any trailing blanks are removed is NULL or ZERO.
<span id="line9325"></span>                 If NULL is specified, all  blank  characters  in
<span id="line9326"></span>                 numeric  formatted input fields on the specified
<span id="line9327"></span>                 unit are ignored, except that  a  field  of  all
<span id="line9328"></span>                 blanks   has  a  value  of  zero.   If  ZERO  is
<span id="line9329"></span>                 specified, all blanks other than leading  blanks
<span id="line9330"></span>                 are  treated  as  zeros.   If  this specifier is
<span id="line9331"></span>                 omitted, a  value  of  NULL  is  assumed.   This
<span id="line9332"></span>                 specifier  is  permitted  only  for a file being
<span id="line9333"></span>                 connected for formatted input/output.
<span id="line9334"></span>
<span id="line9335"></span>          The unit specifier is required  to  appear;  all  other
<span id="line9336"></span>          specifiers are optional, except that the record length rl
<span id="line9337"></span>          __ must be specified if a file is being  connected  for
<span id="line9338"></span>          direct  access.   Note  that some of the specifications
<span id="line9339"></span>          have an assumed value if they are omitted.
<span id="line9340"></span>
<span id="line9341"></span>          The unit specified must exist.
<span id="line9342"></span>
<span id="line9343"></span>          A unit  may  be  connected  by  execution  of  an  OPEN
<span id="line9344"></span>          statement  in any program unit of an executable program
<span id="line9345"></span>
<span id="line9346"></span>
<span id="line9347"></span>
<span id="line9348"></span>          FORTRAN 77 Full Language                     Page 12-23
<span id="line9349"></span>
<span id="line9350"></span>
<span id="line9351"></span>
<span id="line9352"></span>
<span id="line9353"></span>
<span id="line9354"></span>
<span id="line9355"></span>
<span id="line9356"></span>          INPUT/OUTPUT STATEMENTS                  ANSI X3J3/90.4
<span id="line9357"></span>
<span id="line9358"></span>
<span id="line9359"></span>
<span id="line9360"></span>          and, once connected, may be referenced in  any  program
<span id="line9361"></span>          unit of the executable program.
<span id="line9362"></span>
<span id="line9363"></span>          12.10.1.1  Open_of_a_Connected_Unit.   If  a  unit   is
<span id="line9364"></span>          connected  to  a file that exists, execution of an OPEN
<span id="line9365"></span>          statement for that unit is  permitted.   If  the  FILE=
<span id="line9366"></span>          specifier  is  not  included in the OPEN statement, the
<span id="line9367"></span>          file to be connected to the unit is  the  same  as  the
<span id="line9368"></span>          file to which the unit is connected.
<span id="line9369"></span>
<span id="line9370"></span>          If the file to be connected to the unit does not exist,
<span id="line9371"></span>          but  is  the  same  as  the  file  to which the unit is
<span id="line9372"></span>          preconnected, the  properties  specified  by  the  OPEN
<span id="line9373"></span>          statement become a part of the connection.
<span id="line9374"></span>
<span id="line9375"></span>          If the file to be connected to the unit is not the same
<span id="line9376"></span>          as  the file to which the unit is connected, the effect
<span id="line9377"></span>          is as if a CLOSE statement (12.10.2) without a  STATUS=
<span id="line9378"></span>          specifier  had  been  executed for the unit immediately
<span id="line9379"></span>          prior to the execution of the OPEN statement.
<span id="line9380"></span>
<span id="line9381"></span>          If the file to be connected to the unit is the same  as
<span id="line9382"></span>          the  file  to  which  the  unit  is connected, only the
<span id="line9383"></span>          BLANK= specifier may have a value  different  from  the
<span id="line9384"></span>          one   currently  in  effect.   Execution  of  the  OPEN
<span id="line9385"></span>          statement causes the new value of the BLANK=  specifier
<span id="line9386"></span>          to   be  in  effect.   The  position  of  the  file  is
<span id="line9387"></span>          unaffected.
<span id="line9388"></span>
<span id="line9389"></span>          If a file is connected to a unit, execution of an  OPEN
<span id="line9390"></span>          statement  on  that  file  and  a different unit is not
<span id="line9391"></span>          permitted.
<span id="line9392"></span>
<span id="line9393"></span>          12.10.2  CLOSE_Statement.  A CLOSE statement is used to
<span id="line9394"></span>          terminate  the  connection  of  a  particular file to a
<span id="line9395"></span>          unit.
<span id="line9396"></span>
<span id="line9397"></span>          The form of a CLOSE statement is:
<span id="line9398"></span>
<span id="line9399"></span>                               CLOSE (cllist______)
<span id="line9400"></span>
<span id="line9401"></span>          where cllist______ is a list (2.10) of specifiers:
<span id="line9402"></span>
<span id="line9403"></span>8                              ______________
<span id="line9404"></span>
<span id="line9405"></span>                               [UNIT =] u_
<span id="line9406"></span>                               IOSTAT = ios___
<span id="line9407"></span>                               ERR = s_
<span id="line9408"></span>                               STATUS = sta___
<span id="line9409"></span>8                              ______________
<span id="line9410"></span>7                             |8|7|7|7|7|
<span id="line9411"></span>
<span id="line9412"></span>
<span id="line9413"></span>
<span id="line9414"></span>9                                           |8|7|7|7|7|
<span id="line9415"></span>
<span id="line9416"></span>
<span id="line9417"></span>
<span id="line9418"></span>
<span id="line9419"></span>
<span id="line9420"></span>9
<span id="line9421"></span>
<span id="line9422"></span>
<span id="line9423"></span>
<span id="line9424"></span>          FORTRAN 77 Full Language                     Page 12-24
<span id="line9425"></span>
<span id="line9426"></span>
<span id="line9427"></span>
<span id="line9428"></span>
<span id="line9429"></span>
<span id="line9430"></span>
<span id="line9431"></span>
<span id="line9432"></span>          INPUT/OUTPUT STATEMENTS                  ANSI X3J3/90.4
<span id="line9433"></span>
<span id="line9434"></span>
<span id="line9435"></span>
<span id="line9436"></span>          cllist______ must contain exactly one external unit specifier
<span id="line9437"></span>          (12.3.3)  and  may  contain  at most one of each of the
<span id="line9438"></span>          other specifiers.
<span id="line9439"></span>
<span id="line9440"></span>          The other specifiers are described as follows:
<span id="line9441"></span>
<span id="line9442"></span>          IOSTAT = ios___
<span id="line9443"></span>
<span id="line9444"></span>                 is  an  input/output  status  specifier  (12.7).
<span id="line9445"></span>                 Execution  of  a CLOSE statement containing this
<span id="line9446"></span>                 specifier causes ios___ to become  defined  with  a
<span id="line9447"></span>                 zero  value if no error condition exists or with
<span id="line9448"></span>                 a processor-dependent positive integer value  if
<span id="line9449"></span>                 an error condition exists.
<span id="line9450"></span>
<span id="line9451"></span>          ERR = s_
<span id="line9452"></span>
<span id="line9453"></span>                 is an error specifier (12.7.1).
<span id="line9454"></span>
<span id="line9455"></span>          STATUS = sta___
<span id="line9456"></span>
<span id="line9457"></span>                 sta___ is a character expression whose  value  when
<span id="line9458"></span>                 any  trailing  blanks  are  removed  is  KEEP or
<span id="line9459"></span>                 DELETE.  sta___ determines the disposition  of  the
<span id="line9460"></span>                 file  that  is  connected to the specified unit.
<span id="line9461"></span>                 KEEP must not be  specified  for  a  file  whose
<span id="line9462"></span>                 status prior to execution of the CLOSE statement
<span id="line9463"></span>                 is SCRATCH.   If KEEP is specified  for  a  file
<span id="line9464"></span>                 that  exists,  the file continues to exist after
<span id="line9465"></span>                 the execution of the CLOSE statement.   If  KEEP
<span id="line9466"></span>                 is specified for a file that does not exist, the
<span id="line9467"></span>                 file will not exist after the execution  of  the
<span id="line9468"></span>                 CLOSE  statement.   If  DELETE is specified, the
<span id="line9469"></span>                 file will not exist after execution of the CLOSE
<span id="line9470"></span>                 statement.   If  this  specifier is omitted, the
<span id="line9471"></span>                 assumed value is KEEP, unless  the  file  status
<span id="line9472"></span>                 prior  to  execution  of  the CLOSE statement is
<span id="line9473"></span>                 SCRATCH, in which  case  the  assumed  value  is
<span id="line9474"></span>                 DELETE.
<span id="line9475"></span>
<span id="line9476"></span>          Execution of a CLOSE statement that refers  to  a  unit
<span id="line9477"></span>          may  occur in any program unit of an executable program
<span id="line9478"></span>          and need not occur in the  same  program  unit  as  the
<span id="line9479"></span>          execution of an OPEN statement referring to that unit.
<span id="line9480"></span>
<span id="line9481"></span>          Execution of a CLOSE statement specifying a  unit  that
<span id="line9482"></span>          does  not  exist  or  has  no  file  connected to it is
<span id="line9483"></span>          permitted and affects no file.
<span id="line9484"></span>
<span id="line9485"></span>          After a unit has been disconnected by  execution  of  a
<span id="line9486"></span>          CLOSE  statement,  it may be connected again within the
<span id="line9487"></span>
<span id="line9488"></span>
<span id="line9489"></span>
<span id="line9490"></span>          FORTRAN 77 Full Language                     Page 12-25
<span id="line9491"></span>
<span id="line9492"></span>
<span id="line9493"></span>
<span id="line9494"></span>
<span id="line9495"></span>
<span id="line9496"></span>
<span id="line9497"></span>
<span id="line9498"></span>          INPUT/OUTPUT STATEMENTS                  ANSI X3J3/90.4
<span id="line9499"></span>
<span id="line9500"></span>
<span id="line9501"></span>
<span id="line9502"></span>          same executable program, either to the same file or  to
<span id="line9503"></span>          a  different  file.  After a file has been disconnected
<span id="line9504"></span>          by execution of a CLOSE statement, it may be  connected
<span id="line9505"></span>          again within the same executable program, either to the
<span id="line9506"></span>          same unit or to a different  unit,  provided  that  the
<span id="line9507"></span>          file still exists.
<span id="line9508"></span>
<span id="line9509"></span>          12.10.2.1  Implicit_Close_at_Termination_of_Execution.
<span id="line9510"></span>          At  termination  of  execution of an executable program
<span id="line9511"></span>          for reasons other than an error  condition,  all  units
<span id="line9512"></span>          that  are  connected  are  closed.  Each unit is closed
<span id="line9513"></span>          with status  KEEP  unless  the  file  status  prior  to
<span id="line9514"></span>          termination of execution was SCRATCH, in which case the
<span id="line9515"></span>          unit is closed  with  status  DELETE.   Note  that  the
<span id="line9516"></span>          effect is as though a CLOSE statement without a STATUS=
<span id="line9517"></span>          specifier were executed on each connected unit.
<span id="line9518"></span>
<span id="line9519"></span>          12.10.3  INQUIRE_Statement.  An INQUIRE  statement  may
<span id="line9520"></span>          be  used  to  inquire  about properties of a particular
<span id="line9521"></span>          named file or of the connection to a  particular  unit.
<span id="line9522"></span>          There  are  two forms of the INQUIRE statement: inquire
<span id="line9523"></span>          by file and inquire by unit.  All value assignments are
<span id="line9524"></span>          done according to the rules for assignment statements.
<span id="line9525"></span>
<span id="line9526"></span>          The INQUIRE statement may be executed before, while, or
<span id="line9527"></span>          after  a  file  is  connected  to  a  unit.  All values
<span id="line9528"></span>          assigned by the INQUIRE statement are  those  that  are
<span id="line9529"></span>          current at the time the statement is executed.
<span id="line9530"></span>
<span id="line9531"></span>          12.10.3.1  INQUIRE_by_File.  The form of an INQUIRE  by
<span id="line9532"></span>          file statement is:
<span id="line9533"></span>
<span id="line9534"></span>                               INQUIRE (iflist______)
<span id="line9535"></span>
<span id="line9536"></span>          where iflist______ is a list (2.10) of specifiers  that  must
<span id="line9537"></span>          contain  exactly  one  file  specifier  and may contain
<span id="line9538"></span>          other inquiry specifiers.  The iflist______  may  contain  at
<span id="line9539"></span>          most one of each of the inquiry specifiers described in
<span id="line9540"></span>          12.10.3.3.
<span id="line9541"></span>
<span id="line9542"></span>          The form of a file specifier is:
<span id="line9543"></span>
<span id="line9544"></span>                               FILE = fin___
<span id="line9545"></span>
<span id="line9546"></span>          where fin___ is a character expression  whose  value  when
<span id="line9547"></span>          any  trailing  blanks are removed specifies the name of
<span id="line9548"></span>          the file being inquired about.  The named file need not
<span id="line9549"></span>          exist or be connected to a unit.  The value of fin___ must
<span id="line9550"></span>          be of a form acceptable to  the  processor  as  a  file
<span id="line9551"></span>          name.
<span id="line9552"></span>
<span id="line9553"></span>
<span id="line9554"></span>
<span id="line9555"></span>
<span id="line9556"></span>          FORTRAN 77 Full Language                     Page 12-26
<span id="line9557"></span>
<span id="line9558"></span>
<span id="line9559"></span>
<span id="line9560"></span>
<span id="line9561"></span>
<span id="line9562"></span>
<span id="line9563"></span>
<span id="line9564"></span>          INPUT/OUTPUT STATEMENTS                  ANSI X3J3/90.4
<span id="line9565"></span>
<span id="line9566"></span>
<span id="line9567"></span>
<span id="line9568"></span>          12.10.3.2  INQUIRE_by_Unit.  The form of an INQUIRE  by
<span id="line9569"></span>          unit statement is:
<span id="line9570"></span>
<span id="line9571"></span>                               INQUIRE (iulist______)
<span id="line9572"></span>
<span id="line9573"></span>          where iulist______ is a list (2.10) of specifiers  that  must
<span id="line9574"></span>          contain  exactly  one  external unit specifier (12.3.3)
<span id="line9575"></span>          and may contain other inquiry specifiers.  The iulist____ _ _
<span id="line9576"></span>          may  contain  at  most  one  of  each  of  the  inquiry
<span id="line9577"></span>          specifiers described in 12.10.3.3.  The unit  specified
<span id="line9578"></span>          need  not  exist  or  be connected to a file.  If it is
<span id="line9579"></span>          connected to a file, the inquiry is  being  made  about
<span id="line9580"></span>          the connection and about the file connected.
<span id="line9581"></span>
<span id="line9582"></span>          12.10.3.3  Inquiry_Specifiers.  The  following  inquiry
<span id="line9583"></span>          specifiers  may  be  used in either form of the INQUIRE
<span id="line9584"></span>          statement:
<span id="line9585"></span>
<span id="line9586"></span>8                            ___________________
<span id="line9587"></span>
<span id="line9588"></span>                             IOSTAT = ios___
<span id="line9589"></span>                             ERR = s_
<span id="line9590"></span>                             EXIST = ex__
<span id="line9591"></span>                             OPENED = od__
<span id="line9592"></span>                             NUMBER = num___
<span id="line9593"></span>                             NAMED = nmd___
<span id="line9594"></span>                             NAME = fn__
<span id="line9595"></span>                             ACCESS = acc___
<span id="line9596"></span>                             SEQUENTIAL = seq___
<span id="line9597"></span>                             DIRECT = dir___
<span id="line9598"></span>                             FORM = fm__
<span id="line9599"></span>                             FORMATTED = fmt___
<span id="line9600"></span>                             UNFORMATTED = unf___
<span id="line9601"></span>                             RECL = rcl___
<span id="line9602"></span>                             NEXTREC = nr__
<span id="line9603"></span>                             BLANK = blnk____
<span id="line9604"></span>8                            ___________________
<span id="line9605"></span>7                           |8|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|
<span id="line9606"></span>
<span id="line9607"></span>
<span id="line9608"></span>
<span id="line9609"></span>
<span id="line9610"></span>
<span id="line9611"></span>
<span id="line9612"></span>
<span id="line9613"></span>
<span id="line9614"></span>
<span id="line9615"></span>
<span id="line9616"></span>
<span id="line9617"></span>
<span id="line9618"></span>
<span id="line9619"></span>
<span id="line9620"></span>
<span id="line9621"></span>9                                              |8|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|
<span id="line9622"></span>
<span id="line9623"></span>
<span id="line9624"></span>
<span id="line9625"></span>
<span id="line9626"></span>
<span id="line9627"></span>
<span id="line9628"></span>
<span id="line9629"></span>
<span id="line9630"></span>
<span id="line9631"></span>
<span id="line9632"></span>
<span id="line9633"></span>
<span id="line9634"></span>
<span id="line9635"></span>
<span id="line9636"></span>
<span id="line9637"></span>
<span id="line9638"></span>
<span id="line9639"></span>9          The specifiers are described as follows:
<span id="line9640"></span>
<span id="line9641"></span>          IOSTAT = ios___
<span id="line9642"></span>
<span id="line9643"></span>                 is  an  input/output  status  specifier  (12.7).
<span id="line9644"></span>                 Execution  of  an  INQUIRE  statement containing
<span id="line9645"></span>                 this specifier causes ios___ to become defined with
<span id="line9646"></span>                 a  zero  value  if  no error condition exists or
<span id="line9647"></span>                 with  a  processor-dependent  positive   integer
<span id="line9648"></span>                 value if an error condition exists.
<span id="line9649"></span>
<span id="line9650"></span>          ERR = s_
<span id="line9651"></span>
<span id="line9652"></span>
<span id="line9653"></span>
<span id="line9654"></span>
<span id="line9655"></span>
<span id="line9656"></span>          FORTRAN 77 Full Language                     Page 12-27
<span id="line9657"></span>
<span id="line9658"></span>
<span id="line9659"></span>
<span id="line9660"></span>
<span id="line9661"></span>
<span id="line9662"></span>
<span id="line9663"></span>
<span id="line9664"></span>          INPUT/OUTPUT STATEMENTS                  ANSI X3J3/90.4
<span id="line9665"></span>
<span id="line9666"></span>
<span id="line9667"></span>
<span id="line9668"></span>                 is an error specifier (12.7.1).
<span id="line9669"></span>
<span id="line9670"></span>          EXIST = ex__
<span id="line9671"></span>
<span id="line9672"></span>                 ex__  is  a  logical  variable  or  logical  array
<span id="line9673"></span>                 element.    Execution  of  an  INQUIRE  by  file
<span id="line9674"></span>                 statement causes ex__ to  be  assigned  the  value
<span id="line9675"></span>                 true  if  there exists a file with the specified
<span id="line9676"></span>                 name; otherwise, ex__ is assigned the value false.
<span id="line9677"></span>                 Execution of an INQUIRE by unit statement causes
<span id="line9678"></span>                 ex_ _  to  be  assigned  the  value  true  if  the
<span id="line9679"></span>                 specified unit exists; otherwise, ex__ is assigned
<span id="line9680"></span>                 the value false.
<span id="line9681"></span>
<span id="line9682"></span>          OPENED = od__
<span id="line9683"></span>
<span id="line9684"></span>                 od__  is  a  logical  variable  or  logical  array
<span id="line9685"></span>                 element.    Execution  of  an  INQUIRE  by  file
<span id="line9686"></span>                 statement causes od__ to  be  assigned  the  value
<span id="line9687"></span>                 true  if  the  file  specified is connected to a
<span id="line9688"></span>                 unit; otherwise, od__ is assigned the value false.
<span id="line9689"></span>                 Execution of an INQUIRE by unit statement causes
<span id="line9690"></span>                 od_ _  to  be  assigned  the  value  true  if  the
<span id="line9691"></span>                 specified   unit   is   connected   to  a  file;
<span id="line9692"></span>                 otherwise, od__ is assigned the value false.
<span id="line9693"></span>
<span id="line9694"></span>          NUMBER = num___
<span id="line9695"></span>
<span id="line9696"></span>                 num___ is an  integer  variable  or  integer  array
<span id="line9697"></span>                 element  that  is  assigned  the  value  of  the
<span id="line9698"></span>                 external unit identifier of  the  unit  that  is
<span id="line9699"></span>                 currently connected to the file.  If there is no
<span id="line9700"></span>                 unit  connected  to  the  file,  num_ _ _  becomes
<span id="line9701"></span>                 undefined.
<span id="line9702"></span>
<span id="line9703"></span>          NAMED = nmd___
<span id="line9704"></span>
<span id="line9705"></span>                 nmd___ is  a  logical  variable  or  logical  array
<span id="line9706"></span>                 element  that  is assigned the value true if the
<span id="line9707"></span>                 file has a name; otherwise, it is  assigned  the
<span id="line9708"></span>                 value false.
<span id="line9709"></span>
<span id="line9710"></span>          NAME = fn__
<span id="line9711"></span>
<span id="line9712"></span>                 fn__ is a character variable  or  character  array
<span id="line9713"></span>                 element  that  is assigned the value of the name
<span id="line9714"></span>                 of the file, if the file has a name;  otherwise,
<span id="line9715"></span>                 it   becomes   undefined.   Note  that  if  this
<span id="line9716"></span>                 specifier  appears  in  an   INQUIRE   by   file
<span id="line9717"></span>                 statement, its value is not necessarily the same
<span id="line9718"></span>                 as the name given in the FILE=  specifier.   For
<span id="line9719"></span>
<span id="line9720"></span>
<span id="line9721"></span>
<span id="line9722"></span>          FORTRAN 77 Full Language                     Page 12-28
<span id="line9723"></span>
<span id="line9724"></span>
<span id="line9725"></span>
<span id="line9726"></span>
<span id="line9727"></span>
<span id="line9728"></span>
<span id="line9729"></span>
<span id="line9730"></span>          INPUT/OUTPUT STATEMENTS                  ANSI X3J3/90.4
<span id="line9731"></span>
<span id="line9732"></span>
<span id="line9733"></span>
<span id="line9734"></span>                 example,  the  processor  may return a file name
<span id="line9735"></span>                 qualified by a  user  identification.   However,
<span id="line9736"></span>                 the  value  returned must be suitable for use as
<span id="line9737"></span>                 the value  of  a  FILE=  specifier  in  an  OPEN
<span id="line9738"></span>                 statement.
<span id="line9739"></span>
<span id="line9740"></span>          ACCESS = acc___
<span id="line9741"></span>
<span id="line9742"></span>                 acc___ is a character variable or character  array#
<span id="line9743"></span>                 element that is assigned the value SEQUENTIAL if
<span id="line9744"></span>                 the file is connected for sequential access, and
<span id="line9745"></span>                 DIRECT  if  the  file  is  connected  for direct
<span id="line9746"></span>                 access.  If there is no connection, acc___  becomes
<span id="line9747"></span>                 undefined.
<span id="line9748"></span>
<span id="line9749"></span>          SEQUENTIAL = seq___
<span id="line9750"></span>
<span id="line9751"></span>                 seq___ is a character variable or  character  array
<span id="line9752"></span>                 element  that  is  assigned  the  value  YES  if
<span id="line9753"></span>                 SEQUENTIAL is included in  the  set  of  allowed
<span id="line9754"></span>                 access methods for the file, NO if SEQUENTIAL is
<span id="line9755"></span>                 not  included  in  the  set  of  allowed  access
<span id="line9756"></span>                 methods   for  the  file,  and  UNKNOWN  if  the
<span id="line9757"></span>                 processor is unable to determine whether or  not
<span id="line9758"></span>                 SEQUENTIAL  is  included  in  the set of allowed
<span id="line9759"></span>                 access methods for the file.
<span id="line9760"></span>
<span id="line9761"></span>          DIRECT = dir___
<span id="line9762"></span>
<span id="line9763"></span>                 dir___ is a character variable or  character  array
<span id="line9764"></span>                 element that is assigned the value YES if DIRECT
<span id="line9765"></span>                 is included in the set of allowed access methods
<span id="line9766"></span>                 for  the  file,  NO if DIRECT is not included in
<span id="line9767"></span>                 the set of allowed access methods for the  file,
<span id="line9768"></span>                 and  UNKNOWN  if  the  processor  is  unable  to
<span id="line9769"></span>                 determine whether or not DIRECT is  included  in
<span id="line9770"></span>                 the set of allowed access methods for the file.
<span id="line9771"></span>
<span id="line9772"></span>          FORM = fm__
<span id="line9773"></span>
<span id="line9774"></span>                 fm__ is a character variable  or  character  array
<span id="line9775"></span>                 element  that is assigned the value FORMATTED if
<span id="line9776"></span>                 the   file   is    connected    for    formatted
<span id="line9777"></span>                 input/output,   and   is   assigned   the  value
<span id="line9778"></span>                 UNFORMATTED  if  the  file  is   connected   for
<span id="line9779"></span>                 unformatted   input/output.    If  there  is  no
<span id="line9780"></span>                 connection, fm__ becomes undefined.
<span id="line9781"></span>
<span id="line9782"></span>          FORMATTED = fmt___
<span id="line9783"></span>
<span id="line9784"></span>
<span id="line9785"></span>
<span id="line9786"></span>
<span id="line9787"></span>
<span id="line9788"></span>          FORTRAN 77 Full Language                     Page 12-29
<span id="line9789"></span>
<span id="line9790"></span>
<span id="line9791"></span>
<span id="line9792"></span>
<span id="line9793"></span>
<span id="line9794"></span>
<span id="line9795"></span>
<span id="line9796"></span>          INPUT/OUTPUT STATEMENTS                  ANSI X3J3/90.4
<span id="line9797"></span>
<span id="line9798"></span>
<span id="line9799"></span>
<span id="line9800"></span>                 fmt___ is a character variable or  character  array
<span id="line9801"></span>                 element  that  is  assigned  the  value  YES  if
<span id="line9802"></span>                 FORMATTED is included  in  the  set  of  allowed
<span id="line9803"></span>                 forms  for  the  file,  NO  if  FORMATTED is not
<span id="line9804"></span>                 included in the set of  allowed  forms  for  the
<span id="line9805"></span>                 file,  and UNKNOWN if the processor is unable to
<span id="line9806"></span>                 determine whether or not FORMATTED  is  included
<span id="line9807"></span>                 in the set of allowed forms for the file.
<span id="line9808"></span>
<span id="line9809"></span>          UNFORMATTED = unf___
<span id="line9810"></span>
<span id="line9811"></span>                 unf___ is a character variable or  character  array
<span id="line9812"></span>                 element  that  is  assigned  the  value  YES  if
<span id="line9813"></span>                 UNFORMATTED is included in the  set  of  allowed
<span id="line9814"></span>                 forms  for  the  file,  NO if UNFORMATTED is not
<span id="line9815"></span>                 included in the set of  allowed  forms  for  the
<span id="line9816"></span>                 file,  and UNKNOWN if the processor is unable to
<span id="line9817"></span>                 determine whether or not UNFORMATTED is included
<span id="line9818"></span>                 in the set of allowed forms for the file.
<span id="line9819"></span>
<span id="line9820"></span>          RECL = rcl___
<span id="line9821"></span>
<span id="line9822"></span>                 rcl___ is an  integer  variable  or  integer  array
<span id="line9823"></span>                 element that is assigned the value of the record
<span id="line9824"></span>                 length of the file connected for direct  access.
<span id="line9825"></span>                 If   the   file   is   connected  for  formatted
<span id="line9826"></span>                 input/output,  the  length  is  the  number   of
<span id="line9827"></span>                 characters.    If  the  file  is  connected  for
<span id="line9828"></span>                 unformatted input/output, the length is measured
<span id="line9829"></span>                 in  processor-dependent  units.   If there is no
<span id="line9830"></span>                 connection or  if  the  connection  is  not  for
<span id="line9831"></span>                 direct access, rcl___ becomes undefined.
<span id="line9832"></span>
<span id="line9833"></span>          NEXTREC = nr__
<span id="line9834"></span>
<span id="line9835"></span>                 nr__ is  an  integer  variable  or  integer  array
<span id="line9836"></span>                 element  that is assigned the value n_+1, where n_
<span id="line9837"></span>                 is the record number of the last record read  or
<span id="line9838"></span>                 written on the file connected for direct access.
<span id="line9839"></span>                 If the file is connected  but  no  records  have
<span id="line9840"></span>                 been read or written since the connection, nr__ is
<span id="line9841"></span>                 assigned the  value  1.   If  the  file  is  not
<span id="line9842"></span>                 connected  for  direct access or if the position
<span id="line9843"></span>                 of  the  file  is  indeterminate  because  of  a
<span id="line9844"></span>                 previous error condition, nr__ becomes undefined.
<span id="line9845"></span>
<span id="line9846"></span>          BLANK = blnk____
<span id="line9847"></span>
<span id="line9848"></span>                 blnk____ is a character variable or character  array
<span id="line9849"></span>                 element  assigned  the  value NULL if null blank
<span id="line9850"></span>                 control is in effect for the file connected  for
<span id="line9851"></span>
<span id="line9852"></span>
<span id="line9853"></span>
<span id="line9854"></span>          FORTRAN 77 Full Language                     Page 12-30
<span id="line9855"></span>
<span id="line9856"></span>
<span id="line9857"></span>
<span id="line9858"></span>
<span id="line9859"></span>
<span id="line9860"></span>
<span id="line9861"></span>
<span id="line9862"></span>          INPUT/OUTPUT STATEMENTS                  ANSI X3J3/90.4
<span id="line9863"></span>
<span id="line9864"></span>
<span id="line9865"></span>
<span id="line9866"></span>                 formatted  input/output,  and  is  assigned  the
<span id="line9867"></span>                 value ZERO if zero blank control  is  in  effect
<span id="line9868"></span>                 for    the    file   connected   for   formatted
<span id="line9869"></span>                 input/output.  If there is no connection, or  if
<span id="line9870"></span>                 the    connection    is    not   for   formatted
<span id="line9871"></span>                 input/output, blnk____ becomes undefined.
<span id="line9872"></span>
<span id="line9873"></span>          A variable or array element that may become defined  or
<span id="line9874"></span>          undefined  as  a result of its use as a specifier in an
<span id="line9875"></span>          INQUIRE statement, or any associated entity,  must  not
<span id="line9876"></span>          be  referenced  by  any  other  specifier  in  the same
<span id="line9877"></span>          INQUIRE statement.
<span id="line9878"></span>
<span id="line9879"></span>          Execution of an INQUIRE by file  statement  causes  the
<span id="line9880"></span>          specifier  variables  or  array  elements nmd, fn, seq,
<span id="line9881"></span>          dir, fmt, and unf to be assigned  values  only  if  the
<span id="line9882"></span>          value  of  fin___ is acceptable to the processor as a file
<span id="line9883"></span>          name  and  if  there  exists  a  file  by  that   name;
<span id="line9884"></span>          otherwise,  they  become  undefined.   Note  that  num___
<span id="line9885"></span>          becomes defined it and only if od__ becomes defined  with
<span id="line9886"></span>          the value true.  Note also that the specifier variables
<span id="line9887"></span>          or array elements acc, fm, rcl, nr, and blnk may become
<span id="line9888"></span>          defined only if od__ becomes defined with the value true.
<span id="line9889"></span>
<span id="line9890"></span>          Execution of an INQUIRE by unit  statement  causes  the
<span id="line9891"></span>          specifier  variables  or  array  elements num, nmd, fn,
<span id="line9892"></span>          acc, seq, dir, fm, fmt, unf, rcl, nr, and  blnk  to  be
<span id="line9893"></span>          assigned  values  only if the specified unit exists and
<span id="line9894"></span>          if a file is connected to  the  unit;  otherwise,  they
<span id="line9895"></span>          become undefined.
<span id="line9896"></span>
<span id="line9897"></span>          If an error condition occurs  during  execution  of  an
<span id="line9898"></span>          INQUIRE   statement,   all  of  the  inquiry  specifier
<span id="line9899"></span>          variables  and  array  elements  except  ios_ _ _  become
<span id="line9900"></span>          undefined.
<span id="line9901"></span>
<span id="line9902"></span>          Note that the specifier variables or array elements ex_ _
<span id="line9903"></span>          and  od__ always become defined unless an error condition
<span id="line9904"></span>          occurs.
<span id="line9905"></span>
<span id="line9906"></span>          12.10.4  File_Positioning_Statements.  The forms of the
<span id="line9907"></span>          file positioning statements are:
<span id="line9908"></span>
<span id="line9909"></span>                     BACKSPACE u_
<span id="line9910"></span>                     BACKSPACE (alist_____)
<span id="line9911"></span>
<span id="line9912"></span>                     ENDFILE u_
<span id="line9913"></span>                     ENDFILE (alist_____)
<span id="line9914"></span>
<span id="line9915"></span>                     REWIND u_
<span id="line9916"></span>                     REWIND (alist_____)
<span id="line9917"></span>
<span id="line9918"></span>
<span id="line9919"></span>
<span id="line9920"></span>          FORTRAN 77 Full Language                     Page 12-31
<span id="line9921"></span>
<span id="line9922"></span>
<span id="line9923"></span>
<span id="line9924"></span>
<span id="line9925"></span>
<span id="line9926"></span>
<span id="line9927"></span>
<span id="line9928"></span>          INPUT/OUTPUT STATEMENTS                  ANSI X3J3/90.4
<span id="line9929"></span>
<span id="line9930"></span>
<span id="line9931"></span>
<span id="line9932"></span>          where: u_   is an external unit identifier (12.3.3)
<span id="line9933"></span>
<span id="line9934"></span>                 alist_____ is a list (2.20) of specifiers:
<span id="line9935"></span>
<span id="line9936"></span>8                              ______________
<span id="line9937"></span>
<span id="line9938"></span>                               [ UNIT =] u_
<span id="line9939"></span>                               IOSTAT = ios___
<span id="line9940"></span>                               ERR = s_
<span id="line9941"></span>8                              ______________
<span id="line9942"></span>7                             |8|7|7|7|
<span id="line9943"></span>
<span id="line9944"></span>
<span id="line9945"></span>9                                           |8|7|7|7|
<span id="line9946"></span>
<span id="line9947"></span>
<span id="line9948"></span>
<span id="line9949"></span>
<span id="line9950"></span>9          alist_____ must contain exactly one external unit  specifier
<span id="line9951"></span>          (12.3.3)  and  may  contain  at most one of each of the
<span id="line9952"></span>          other specifiers.
<span id="line9953"></span>
<span id="line9954"></span>          The external unit specified by a BACKSPACE, ENDFILE, or
<span id="line9955"></span>          REWIND  statement  must  be  connected  for  sequential
<span id="line9956"></span>          access.
<span id="line9957"></span>
<span id="line9958"></span>          Execution of a file positioning statement containing an
<span id="line9959"></span>          input/output  status  specifier  causes  ios___ to become
<span id="line9960"></span>          defined with a zero value if no error condition  exists
<span id="line9961"></span>          or with a processor-dependent positive integer value if
<span id="line9962"></span>          an error condition exists.
<span id="line9963"></span>
<span id="line9964"></span>          12.10.4.1  BACKSPACE_Statement.    Execution    of    a
<span id="line9965"></span>          BACKSPACE  statement  causes  the file connected to the
<span id="line9966"></span>          specified unit to be positioned  before  the  preceding
<span id="line9967"></span>          record.   If there is no preceding record, the position
<span id="line9968"></span>          of the file is not changed.  Note that if the preceding
<span id="line9969"></span>          record   is   an   endfile  record,  the  file  becomes
<span id="line9970"></span>          positioned before the endfile record.
<span id="line9971"></span>
<span id="line9972"></span>          Backspacing a file that is connected but does not exist
<span id="line9973"></span>          is prohibited.
<span id="line9974"></span>
<span id="line9975"></span>          Backspacing over records  written  using  list-directed
<span id="line9976"></span>          formatting is prohibited.
<span id="line9977"></span>
<span id="line9978"></span>          12.10.4.2  ENDFILE_Statement.  Execution of an  ENDFILE
<span id="line9979"></span>          statement  writes  an endfile record as the next record
<span id="line9980"></span>          of the file.  The file is  then  positioned  after  the
<span id="line9981"></span>          endfile  record.  If the file may also be connected for
<span id="line9982"></span>          direct access, only those records  before  the  endfile
<span id="line9983"></span>          record are considered to have been written.  Thus, only
<span id="line9984"></span>          those records may  be  read  during  subsequent  direct
<span id="line9985"></span>          access connections to the file.
<span id="line9986"></span>
<span id="line9987"></span>          After execution of an ENDFILE statement, a BACKSPACE or
<span id="line9988"></span>          REWIND  statement  must  be used to reposition the file
<span id="line9989"></span>          prior to execution of any  data  transfer  input/output
<span id="line9990"></span>          statement.
<span id="line9991"></span>
<span id="line9992"></span>
<span id="line9993"></span>
<span id="line9994"></span>          FORTRAN 77 Full Language                     Page 12-32
<span id="line9995"></span>
<span id="line9996"></span>
<span id="line9997"></span>
<span id="line9998"></span>
<span id="line9999"></span>
<span id="line10000"></span>
<span id="line10001"></span>
<span id="line10002"></span>          INPUT/OUTPUT STATEMENTS                  ANSI X3J3/90.4
<span id="line10003"></span>
<span id="line10004"></span>
<span id="line10005"></span>
<span id="line10006"></span>          Execution of an ENDFILE statement for a  file  that  is
<span id="line10007"></span>          connected but does not exist creates the file.
<span id="line10008"></span>
<span id="line10009"></span>          12.10.4.3  REWIND_Statement.   Execution  of  a  REWIND
<span id="line10010"></span>          statement causes the specified file to be positioned at
<span id="line10011"></span>          its initial point.  Note that if the  file  is  already
<span id="line10012"></span>          positioned  at  its  initial  point,  execution of this
<span id="line10013"></span>          statement has no effect on the position of the file.
<span id="line10014"></span>
<span id="line10015"></span>          Execution of a REWIND statement  for  a  file  that  is
<span id="line10016"></span>          connected  but  does  not exist is permitted but has no
<span id="line10017"></span>          effect.
<span id="line10018"></span>
<span id="line10019"></span>          12.11  Restrictions on Function References and List
<span id="line10020"></span>                 Items
<span id="line10021"></span>
<span id="line10022"></span>          A function must not be referenced within an  expression
<span id="line10023"></span>          appearing anywhere in an input/output statement if such
<span id="line10024"></span>          a reference causes  an  input/output  statement  to  be
<span id="line10025"></span>          executed.  Note that a restriction in the evaluation of
<span id="line10026"></span>          expressions (6.6) prohibits certain side effects.
<span id="line10027"></span>
<span id="line10028"></span>          12.12  Restriction_on_Input/Output_Statements
<span id="line10029"></span>
<span id="line10030"></span>          If a unit, or a file connected to a unit, does not have
<span id="line10031"></span>          all  of  the  properties  required for the execution of
<span id="line10032"></span>          certain input/output statements, those statements  must
<span id="line10033"></span>          not refer to the unit.
<span id="line10034"></span>
<span id="line10035"></span>
<span id="line10036"></span>
<span id="line10037"></span>
<span id="line10038"></span>
<span id="line10039"></span>
<span id="line10040"></span>
<span id="line10041"></span>
<span id="line10042"></span>
<span id="line10043"></span>
<span id="line10044"></span>
<span id="line10045"></span>
<span id="line10046"></span>
<span id="line10047"></span>
<span id="line10048"></span>
<span id="line10049"></span>
<span id="line10050"></span>
<span id="line10051"></span>
<span id="line10052"></span>
<span id="line10053"></span>
<span id="line10054"></span>
<span id="line10055"></span>
<span id="line10056"></span>
<span id="line10057"></span>
<span id="line10058"></span>
<span id="line10059"></span>
<span id="line10060"></span>          FORTRAN 77 Full Language                     Page 12-33
<span id="line10061"></span>
<span id="line10062"></span>
<span id="line10063"></span>
<span id="line10064"></span>
<span id="line10065"></span>
<span id="line10066"></span>
<span id="line10067"></span>
<span id="line10068"></span>
<span id="line10069"></span>
<span id="line10070"></span>
<span id="line10071"></span>
<span id="line10072"></span>                                 CONTENTS
<span id="line10073"></span>
<span id="line10074"></span>
<span id="line10075"></span>          12.  INPUT/OUTPUT STATEMENTS....................   12-1
<span id="line10076"></span>               12.1   Records.............................   12-1
<span id="line10077"></span>                      12.1.1   Formatted Record...........   12-2
<span id="line10078"></span>                      12.1.2   Unformatted Record.........   12-2
<span id="line10079"></span>                      12.1.3   Endfile Record.............   12-2
<span id="line10080"></span>               12.2   Files...............................   12-2
<span id="line10081"></span>                      12.2.1   File Existence.............   12-2
<span id="line10082"></span>                      12.2.2   File Properties............   12-3
<span id="line10083"></span>                      12.2.3   File Position..............   12-3
<span id="line10084"></span>                      12.2.4   File Access................   12-4
<span id="line10085"></span>                      12.2.5   Internal Files.............   12-5
<span id="line10086"></span>               12.3   Units...............................   12-7
<span id="line10087"></span>                      12.3.1   Unit Existence.............   12-7
<span id="line10088"></span>                      12.3.2   Connection of a
<span id="line10089"></span>                               Unit.......................   12-7
<span id="line10090"></span>                      12.3.3   Unit Specifier and
<span id="line10091"></span>                               Identifier.................   12-8
<span id="line10092"></span>               12.4   Format Specifier and
<span id="line10093"></span>                      Identifier..........................   12-9
<span id="line10094"></span>               12.5   Record Specifier....................   12-9
<span id="line10095"></span>               12.6   Error and End-of-File
<span id="line10096"></span>                      Conditions..........................  12-10
<span id="line10097"></span>               12.7   Input/Output Status, Error, and
<span id="line10098"></span>                      End-of-File Specifiers..............  12-11
<span id="line10099"></span>                      12.7.1   Error Specifier............  12-11
<span id="line10100"></span>                      12.7.2   End-of-File
<span id="line10101"></span>                               Specifier..................  12-12
<span id="line10102"></span>               12.8   READ, WRITE, and PRINT
<span id="line10103"></span>                      Statements..........................  12-12
<span id="line10104"></span>                      12.8.1   Control Information
<span id="line10105"></span>                               List.......................  12-13
<span id="line10106"></span>                      12.8.2   Input/Output List..........  12-14
<span id="line10107"></span>               12.9   Execution of a Data Transfer
<span id="line10108"></span>                      Input/Output Statement..............  12-15
<span id="line10109"></span>                      12.9.1   Direction of Data
<span id="line10110"></span>                               Transfer...................  12-16
<span id="line10111"></span>                      12.9.2   Identifying a Unit.........  12-16
<span id="line10112"></span>                      12.9.3   Establishing a
<span id="line10113"></span>                               Format.....................  12-16
<span id="line10114"></span>                      12.9.4   File Position Prior to
<span id="line10115"></span>                               Data Transfer..............  12-17
<span id="line10116"></span>                      12.9.5   Data Transfer..............  12-17
<span id="line10117"></span>                      12.9.6   File Position After Data
<span id="line10118"></span>                               Transfer...................  12-20
<span id="line10119"></span>                      12.9.7   Input/Output Status
<span id="line10120"></span>                               Specifier
<span id="line10121"></span>                               Definition.................  12-20
<span id="line10122"></span>
<span id="line10123"></span>
<span id="line10124"></span>
<span id="line10125"></span>
<span id="line10126"></span>                                   - i -
<span id="line10127"></span>
<span id="line10128"></span>
<span id="line10129"></span>
<span id="line10130"></span>
<span id="line10131"></span>
<span id="line10132"></span>
<span id="line10133"></span>
<span id="line10134"></span>
<span id="line10135"></span>
<span id="line10136"></span>
<span id="line10137"></span>
<span id="line10138"></span>               12.10  Auxiliary Input/Output
<span id="line10139"></span>                      Statements..........................  12-21
<span id="line10140"></span>                      12.10.1  OPEN Statement.............  12-21
<span id="line10141"></span>                      12.10.2  CLOSE Statement............  12-24
<span id="line10142"></span>                      12.10.3  INQUIRE Statement..........  12-26
<span id="line10143"></span>                      12.10.4  File Positioning
<span id="line10144"></span>                               Statements.................  12-31
<span id="line10145"></span>               12.11  Restrictions on Function References
<span id="line10146"></span>                      and List Items......................  12-33
<span id="line10147"></span>               12.12  Restriction on Input/Output
<span id="line10148"></span>                      Statements..........................  12-33
<span id="line10149"></span>
<span id="line10150"></span>
<span id="line10151"></span>
<span id="line10152"></span>
<span id="line10153"></span>
<span id="line10154"></span>
<span id="line10155"></span>
<span id="line10156"></span>
<span id="line10157"></span>
<span id="line10158"></span>
<span id="line10159"></span>
<span id="line10160"></span>
<span id="line10161"></span>
<span id="line10162"></span>
<span id="line10163"></span>
<span id="line10164"></span>
<span id="line10165"></span>
<span id="line10166"></span>
<span id="line10167"></span>
<span id="line10168"></span>
<span id="line10169"></span>
<span id="line10170"></span>
<span id="line10171"></span>
<span id="line10172"></span>
<span id="line10173"></span>
<span id="line10174"></span>
<span id="line10175"></span>
<span id="line10176"></span>
<span id="line10177"></span>
<span id="line10178"></span>
<span id="line10179"></span>
<span id="line10180"></span>
<span id="line10181"></span>
<span id="line10182"></span>
<span id="line10183"></span>
<span id="line10184"></span>
<span id="line10185"></span>
<span id="line10186"></span>
<span id="line10187"></span>
<span id="line10188"></span>
<span id="line10189"></span>
<span id="line10190"></span>
<span id="line10191"></span>
<span id="line10192"></span>                                  - ii -
<span id="line10193"></span>
<span id="line10194"></span>
<span id="line10195"></span>
<span id="line10196"></span>
<span id="line10197"></span>
<span id="line10198"></span>
<span id="line10199"></span>
<span id="line10200"></span>                                                   ANSI X3J3/90.4
<span id="line10201"></span>
<span id="line10202"></span>
<span id="line10203"></span>
<span id="line10204"></span>                         13.  FORMAT_SPECIFICATION
<span id="line10205"></span>
<span id="line10206"></span>          A   format   used   in   conjunction   with   formatted
<span id="line10207"></span>          input/output   statements   provides  information  that
<span id="line10208"></span>          directs the editing between the internal representation
<span id="line10209"></span>          and  the character strings of a record or a sequence of
<span id="line10210"></span>          records in the file.
<span id="line10211"></span>
<span id="line10212"></span>          A  format  specification  provides   explicit   editing
<span id="line10213"></span>          information.  An asterisk (*) as a format identifier in
<span id="line10214"></span>          an  input/output  statement   indicates   list-directed
<span id="line10215"></span>          formatting (13.6).
<span id="line10216"></span>
<span id="line10217"></span>          13.1  Format_Specification_Methods
<span id="line10218"></span>
<span id="line10219"></span>          Format specifications may be given:
<span id="line10220"></span>
<span id="line10221"></span>             (1) In FORMAT statements
<span id="line10222"></span>
<span id="line10223"></span>             (2) As  values  of   character   arrays,   character
<span id="line10224"></span>                 variables, or other character expressions
<span id="line10225"></span>
<span id="line10226"></span>          13.1.1  FORMAT_Statement.   The  form   of   a   FORMAT
<span id="line10227"></span>          statement is:
<span id="line10228"></span>
<span id="line10229"></span>                               FORMAT fs__
<span id="line10230"></span>
<span id="line10231"></span>          where fs__ is a format  specification,  as  described  in
<span id="line10232"></span>          13.2.  The statement must be labeled.
<span id="line10233"></span>
<span id="line10234"></span>          13.1.2  Character_Format_Specification.  If the  format
<span id="line10235"></span>          identifier (12.4) in a formatted input/output statement
<span id="line10236"></span>          is a character array name, character variable name,  or
<span id="line10237"></span>          other  character  expression,  the  leftmost  character
<span id="line10238"></span>          positions of the specified entity must be in a  defined
<span id="line10239"></span>          state  with  character  data  that  constitute a format
<span id="line10240"></span>          specification when the statement is executed.
<span id="line10241"></span>
<span id="line10242"></span>          A character format specification must be  of  the  form
<span id="line10243"></span>          described  in  13.2.   Note that the form begins with a
<span id="line10244"></span>          left parenthesis and ends  with  a  right  parenthesis.
<span id="line10245"></span>          Character  data  may  follow the right parenthesis that
<span id="line10246"></span>          ends the format specification, with no  effect  on  the
<span id="line10247"></span>          format specification.  Blank characters may precede the
<span id="line10248"></span>          format specification.
<span id="line10249"></span>
<span id="line10250"></span>          If the format identifier is a character array name, the
<span id="line10251"></span>          length  of  the  format  specification  may  exceed the
<span id="line10252"></span>          length of the first element of the array;  a  character
<span id="line10253"></span>          array  format  specification  is  considered  to  be  a
<span id="line10254"></span>          concatenation of all the array elements of the array in
<span id="line10255"></span>
<span id="line10256"></span>
<span id="line10257"></span>
<span id="line10258"></span>          FORTRAN 77 Full Language                      Page 13-1
<span id="line10259"></span>
<span id="line10260"></span>
<span id="line10261"></span>
<span id="line10262"></span>
<span id="line10263"></span>
<span id="line10264"></span>
<span id="line10265"></span>
<span id="line10266"></span>          FORMAT SPECIFICATION                     ANSI X3J3/90.4
<span id="line10267"></span>
<span id="line10268"></span>
<span id="line10269"></span>
<span id="line10270"></span>          the  order  given  by  array  element ordering (5.2.4).
<span id="line10271"></span>          However, if a character array element name is specified
<span id="line10272"></span>          as  a  format  identifier,  the  length  of  the format
<span id="line10273"></span>          specification must not exceed the length of  the  array
<span id="line10274"></span>          element.
<span id="line10275"></span>
<span id="line10276"></span>          13.2  Form_of_a_Format_Specification
<span id="line10277"></span>
<span id="line10278"></span>          The form of a format specification is:
<span id="line10279"></span>
<span id="line10280"></span>                               ( [flist_____] )
<span id="line10281"></span>
<span id="line10282"></span>          where flist_____ is a list (2.10).  The forms of the flist___ _ _
<span id="line10283"></span>          items are:
<span id="line10284"></span>
<span id="line10285"></span>                               [r_] ed__
<span id="line10286"></span>
<span id="line10287"></span>                                   ned___
<span id="line10288"></span>
<span id="line10289"></span>                               [r_] fs__
<span id="line10290"></span>
<span id="line10291"></span>          where: ed__  is a repeatable edit descriptor (13.2.1)
<span id="line10292"></span>
<span id="line10293"></span>                 ned___ is a nonrepeatable edit descriptor (13.2.1)
<span id="line10294"></span>
<span id="line10295"></span>                 fs__  is a format specification  with  a  nonempty
<span id="line10296"></span>                     list flist_____
<span id="line10297"></span>
<span id="line10298"></span>                 r_   is a  nonzero,  unsigned,  integer  constant
<span id="line10299"></span>                     called a repeat______ specification_____________
<span id="line10300"></span>
<span id="line10301"></span>          The comma used to separate list items in the list flist_____
<span id="line10302"></span>          may be omitted as follows:
<span id="line10303"></span>
<span id="line10304"></span>             (1) Between a P edit descriptor and  an  immediately
<span id="line10305"></span>                 following F, E, D, or G edit descriptor (13.5.9)
<span id="line10306"></span>
<span id="line10307"></span>             (2) Before or after a slash edit descriptor (13.5.4)
<span id="line10308"></span>
<span id="line10309"></span>             (3) Before or after a colon edit descriptor (13.5.5)
<span id="line10310"></span>
<span id="line10311"></span>          13.2.1  Edit_Descriptors.  An edit descriptor is either
<span id="line10312"></span>          a  repeatable  edit  descriptor or a nonrepeatable edit
<span id="line10313"></span>          descriptor.
<span id="line10314"></span>
<span id="line10315"></span>          The forms of a repeatable edit descriptor are:
<span id="line10316"></span>
<span id="line10317"></span>                     Iw_
<span id="line10318"></span>                     Iw_.m_
<span id="line10319"></span>                     Fw_.d_
<span id="line10320"></span>                     Ew_.d_
<span id="line10321"></span>
<span id="line10322"></span>
<span id="line10323"></span>
<span id="line10324"></span>          FORTRAN 77 Full Language                      Page 13-2
<span id="line10325"></span>
<span id="line10326"></span>
<span id="line10327"></span>
<span id="line10328"></span>
<span id="line10329"></span>
<span id="line10330"></span>
<span id="line10331"></span>
<span id="line10332"></span>          FORMAT SPECIFICATION                     ANSI X3J3/90.4
<span id="line10333"></span>
<span id="line10334"></span>
<span id="line10335"></span>
<span id="line10336"></span>                     Ew_.d_Ee_
<span id="line10337"></span>                     Dw_.d_
<span id="line10338"></span>                     Gw_.d_
<span id="line10339"></span>                     Gw_.d_Ee_
<span id="line10340"></span>                     Lw_
<span id="line10341"></span>                     A
<span id="line10342"></span>                     Aw_
<span id="line10343"></span>
<span id="line10344"></span>          where: I, F, E, D, G, L, and A indicate the  manner  of
<span id="line10345"></span>                     editing
<span id="line10346"></span>
<span id="line10347"></span>                 w_ and e_ are nonzero, unsigned, integer constants
<span id="line10348"></span>
<span id="line10349"></span>                 d_ and m_ are unsigned integer constants
<span id="line10350"></span>
<span id="line10351"></span>          The forms of a nonrepeatable edit descriptor are:
<span id="line10352"></span>
<span id="line10353"></span>                     'h_918 h_928 ... h_9n8'
<span id="line10354"></span>                     n_Hh_918h_928 ... h_9n
<span id="line10355"></span>8                     Tc_
<span id="line10356"></span>                     TLc_
<span id="line10357"></span>                     TRc_
<span id="line10358"></span>                     n_X
<span id="line10359"></span>                     /
<span id="line10360"></span>                     :
<span id="line10361"></span>                     S
<span id="line10362"></span>                     SP
<span id="line10363"></span>                     SS
<span id="line10364"></span>                     k_P
<span id="line10365"></span>                     BN
<span id="line10366"></span>                     BZ
<span id="line10367"></span>
<span id="line10368"></span>          where: apostrophe, H, T, TL, TR, X,  slash,  colon,  S,
<span id="line10369"></span>                     SP, SS, P, BN, and BZ indicate the manner of
<span id="line10370"></span>                     editing
<span id="line10371"></span>
<span id="line10372"></span>                 h_   is  one  of  the  characters   capable   of
<span id="line10373"></span>                     representation by the processor
<span id="line10374"></span>
<span id="line10375"></span>                 n_   and  c_  are  nonzero,  unsigned,   integer
<span id="line10376"></span>                     constants
<span id="line10377"></span>
<span id="line10378"></span>                 k_   is an optionally signed integer constant
<span id="line10379"></span>
<span id="line10380"></span>          13.3  Interaction_Between_Input/Output_List_and_Format
<span id="line10381"></span>
<span id="line10382"></span>          The beginning of formatted data transfer using a format
<span id="line10383"></span>          specification  (12.9.5.2.1)  initiates  format control.
<span id="line10384"></span>          Each action of format control  depends  on  information
<span id="line10385"></span>          jointly provided by:
<span id="line10386"></span>
<span id="line10387"></span>
<span id="line10388"></span>
<span id="line10389"></span>
<span id="line10390"></span>          FORTRAN 77 Full Language                      Page 13-3
<span id="line10391"></span>
<span id="line10392"></span>
<span id="line10393"></span>
<span id="line10394"></span>
<span id="line10395"></span>
<span id="line10396"></span>
<span id="line10397"></span>
<span id="line10398"></span>          FORMAT SPECIFICATION                     ANSI X3J3/90.4
<span id="line10399"></span>
<span id="line10400"></span>
<span id="line10401"></span>
<span id="line10402"></span>             (1) the next edit descriptor contained in the format
<span id="line10403"></span>                 specification, and
<span id="line10404"></span>
<span id="line10405"></span>             (2) the next item in the input/output list,  if  one
<span id="line10406"></span>                 exists.
<span id="line10407"></span>
<span id="line10408"></span>          If an input/output list specifies  at  least  one  list
<span id="line10409"></span>          item,  at  least  one  repeatable  edit descriptor must
<span id="line10410"></span>          exist in the format specification.  Note that an  empty
<span id="line10411"></span>          format  specification  of the form ( ) may be used only
<span id="line10412"></span>          if no list items are specified; in this case, one input
<span id="line10413"></span>          record  is  skipped  or one output record containing no
<span id="line10414"></span>          characters is written.  Except for an  edit  descriptor
<span id="line10415"></span>          preceded  by a repeat specification, r_ ed__, and a format
<span id="line10416"></span>          specification preceded by a repeat specification, r_(flist___
<span id="line10417"></span>          __), a format specification is interpreted from left to
<span id="line10418"></span>          right.   A  format  specification  or  edit  descriptor
<span id="line10419"></span>          preceded  by a repeat specification r_ is processed as a
<span id="line10420"></span>          list of r_ format  specifications  or  edit  descriptors
<span id="line10421"></span>          identical   to   the   format   specification  or  edit
<span id="line10422"></span>          descriptor without the repeat specification.  Note that
<span id="line10423"></span>          an  omitted repeat specification is treated the same as
<span id="line10424"></span>          a repeat specification whose value is one.
<span id="line10425"></span>
<span id="line10426"></span>          To each repeatable edit  descriptor  interpreted  in  a
<span id="line10427"></span>          format   specification,   there  corresponds  one  item
<span id="line10428"></span>          specified by the  input/output  list  (12.8.2),  except
<span id="line10429"></span>          that   a   list  item  of  type  complex  requires  the
<span id="line10430"></span>          interpretation of two F, E, D, or G  edit  descriptors.
<span id="line10431"></span>          To  each  P, X, T, TL, TR, S, SP, SS, H, BN, BZ, slash,
<span id="line10432"></span>          colon, or  apostrophe  edit  descriptor,  there  is  no
<span id="line10433"></span>          corresponding  item specified by the input/output list,
<span id="line10434"></span>          and format control  communicates  information  directly
<span id="line10435"></span>          with the record.
<span id="line10436"></span>
<span id="line10437"></span>          Whenever format control encounters  a  repeatable  edit
<span id="line10438"></span>          descriptor  in  a  format  specification, it determines
<span id="line10439"></span>          whether there is a corresponding item specified by  the
<span id="line10440"></span>          input/output  list.   If  there  is  such  an  item, it
<span id="line10441"></span>          transmits appropriately edited information between  the
<span id="line10442"></span>          item  and the record, and then format control proceeds.
<span id="line10443"></span>          If there  is  no  corresponding  item,  format  control
<span id="line10444"></span>          terminates.
<span id="line10445"></span>
<span id="line10446"></span>          If format control encounters a colon edit descriptor in
<span id="line10447"></span>          a  format  specification  and  another list item is not
<span id="line10448"></span>          specified, format control terminates.
<span id="line10449"></span>
<span id="line10450"></span>          If format control encounters the rightmost  parenthesis
<span id="line10451"></span>          of  a  complete  format  specification and another list
<span id="line10452"></span>          item  is  not  specified,  format  control  terminates.
<span id="line10453"></span>
<span id="line10454"></span>
<span id="line10455"></span>
<span id="line10456"></span>          FORTRAN 77 Full Language                      Page 13-4
<span id="line10457"></span>
<span id="line10458"></span>
<span id="line10459"></span>
<span id="line10460"></span>
<span id="line10461"></span>
<span id="line10462"></span>
<span id="line10463"></span>
<span id="line10464"></span>          FORMAT SPECIFICATION                     ANSI X3J3/90.4
<span id="line10465"></span>
<span id="line10466"></span>
<span id="line10467"></span>
<span id="line10468"></span>          However, if another list item is specified, the file is
<span id="line10469"></span>          positioned at the beginning  of  the  next  record  and
<span id="line10470"></span>          format  control  then  reverts  to the beginning of the
<span id="line10471"></span>          format specification terminated by the  last  preceding
<span id="line10472"></span>          right parenthesis.  If there is no such preceding right
<span id="line10473"></span>          parenthesis, format control reverts to the  first  left
<span id="line10474"></span>          parenthesis  of  the  format  specification.   If  such
<span id="line10475"></span>          reversion occurs, the  reused  portion  of  the  format
<span id="line10476"></span>          specification must contain at least one repeatable edit
<span id="line10477"></span>          descriptor.  If format control reverts to a parenthesis
<span id="line10478"></span>          that  is preceded by a repeat specification, the repeat
<span id="line10479"></span>          specification is reused.  Reversion of format  control,
<span id="line10480"></span>          of  itself, has no effect on the scale factor (13.5.7),
<span id="line10481"></span>          the S, SP, or SS edit descriptor sign control (13.5.6),
<span id="line10482"></span>          or the BN or BZ edit descriptor blank control (13.5.8).
<span id="line10483"></span>
<span id="line10484"></span>          13.4  Positioning_by_Format_Control
<span id="line10485"></span>
<span id="line10486"></span>          After each I, F, E, D, G, L, A, H, or  apostrophe  edit
<span id="line10487"></span>          descriptor  is  processed, the file is positioned after
<span id="line10488"></span>          the last character  read  or  written  in  the  current
<span id="line10489"></span>          record.
<span id="line10490"></span>
<span id="line10491"></span>          After each T, TL, TR,  X, or slash edit  descriptor  is
<span id="line10492"></span>          processed,  the  file  is  positioned  as  described in
<span id="line10493"></span>          13.5.3 and 13.5.4.
<span id="line10494"></span>
<span id="line10495"></span>          If format control reverts as  described  in  13.3,  the
<span id="line10496"></span>          file  is positioned in a manner identical to the way it
<span id="line10497"></span>          is positioned when a slash edit descriptor is processed
<span id="line10498"></span>          (13.5.4).
<span id="line10499"></span>
<span id="line10500"></span>          During a read operation, any unprocessed characters  of
<span id="line10501"></span>          the  record  are  skipped  whenever  the next record is
<span id="line10502"></span>          read.
<span id="line10503"></span>
<span id="line10504"></span>          13.5  Editing
<span id="line10505"></span>
<span id="line10506"></span>          Edit descriptors are used to  specify  the  form  of  a
<span id="line10507"></span>          record and to direct the editing between the characters
<span id="line10508"></span>          in a record and internal representations of data.
<span id="line10509"></span>
<span id="line10510"></span>          A field is a part of a record that is read on input  or
<span id="line10511"></span>          written  on output when format control processes one I,
<span id="line10512"></span>          F, E, D, G, L, A, H,  or  apostrophe  edit  descriptor.
<span id="line10513"></span>          The field width is the size in characters of the field.
<span id="line10514"></span>
<span id="line10515"></span>          The internal representation of a datum  corresponds  to
<span id="line10516"></span>          the  internal  representation  of  a  constant  of  the
<span id="line10517"></span>          corresponding type (Section 4).
<span id="line10518"></span>
<span id="line10519"></span>
<span id="line10520"></span>
<span id="line10521"></span>
<span id="line10522"></span>          FORTRAN 77 Full Language                      Page 13-5
<span id="line10523"></span>
<span id="line10524"></span>
<span id="line10525"></span>
<span id="line10526"></span>
<span id="line10527"></span>
<span id="line10528"></span>
<span id="line10529"></span>
<span id="line10530"></span>          FORMAT SPECIFICATION                     ANSI X3J3/90.4
<span id="line10531"></span>
<span id="line10532"></span>
<span id="line10533"></span>
<span id="line10534"></span>          13.5.1  Apostrophe_Editing.    The   apostrophe    edit
<span id="line10535"></span>          descriptor  has  the  form of a character constant.  It
<span id="line10536"></span>          causes characters  to  be  written  from  the  enclosed
<span id="line10537"></span>          characters  (including  blanks)  of the edit descriptor
<span id="line10538"></span>          itself.  An apostrophe edit descriptor must not be used
<span id="line10539"></span>          on input.
<span id="line10540"></span>
<span id="line10541"></span>          The width of the field  is  the  number  of  characters
<span id="line10542"></span>          contained   in,   but  not  including,  the  delimiting
<span id="line10543"></span>          apostrophes.   Within  the   field,   two   consecutive
<span id="line10544"></span>          apostrophes with no intervening blanks are counted as a
<span id="line10545"></span>          single apostrophe.
<span id="line10546"></span>
<span id="line10547"></span>          13.5.2  H_Editing.  The  n_ H  edit  descriptor  causes
<span id="line10548"></span>          character   information  to  be  written  from  the  n_
<span id="line10549"></span>          characters (including blanks) following the H of the n_H
<span id="line10550"></span>          edit descriptor in the format specification itself.  An
<span id="line10551"></span>          H edit descriptor must not be used on input.
<span id="line10552"></span>
<span id="line10553"></span>          Note that if an  H  edit  descriptor  occurs  within  a
<span id="line10554"></span>          character  constant  and  includes  an  apostrophe, the
<span id="line10555"></span>          apostrophe  must  be  represented  by  two  consecutive
<span id="line10556"></span>          apostrophes,  which  are  counted  as  one character in
<span id="line10557"></span>          specifying n_.
<span id="line10558"></span>
<span id="line10559"></span>          13.5.3  Positional_Editing.  The T, TL, TR, and X  edit
<span id="line10560"></span>          descriptors  specify  the  position  at  which the next
<span id="line10561"></span>          character will be transmitted to or from the record.
<span id="line10562"></span>
<span id="line10563"></span>          The position specified by a T edit descriptor may be in
<span id="line10564"></span>          either  direction from the current position.  On input,
<span id="line10565"></span>          this allows portions of a record to be  processed  more
<span id="line10566"></span>          than once, possibly with different editing.
<span id="line10567"></span>
<span id="line10568"></span>          The position specified  by  an  X  edit  descriptor  is
<span id="line10569"></span>          forward   from  the  current  position.   On  input,  a
<span id="line10570"></span>          position beyond the last character of the record may be
<span id="line10571"></span>          specified  if  no  characters are transmitted from such
<span id="line10572"></span>          positions.
<span id="line10573"></span>
<span id="line10574"></span>          On output, a T, TL, TR, or X edit descriptor  does  not
<span id="line10575"></span>          by  itself  cause  characters  to  be  transmitted  and
<span id="line10576"></span>          therefore does not by itself affect the length  of  the
<span id="line10577"></span>          record.   If characters are transmitted to positions at
<span id="line10578"></span>          or after the position specified by a T, TL,  TR,  or  X
<span id="line10579"></span>          edit  descriptor,  positions skipped and not previously
<span id="line10580"></span>          filled are filled with blanks.  The result is as if the
<span id="line10581"></span>          entire record were initially filled with blanks.
<span id="line10582"></span>
<span id="line10583"></span>          On output, a character in the record may  be  replaced.
<span id="line10584"></span>          However,  a  T,  TL,  TR,  or  X  edit descriptor never
<span id="line10585"></span>
<span id="line10586"></span>
<span id="line10587"></span>
<span id="line10588"></span>          FORTRAN 77 Full Language                      Page 13-6
<span id="line10589"></span>
<span id="line10590"></span>
<span id="line10591"></span>
<span id="line10592"></span>
<span id="line10593"></span>
<span id="line10594"></span>
<span id="line10595"></span>
<span id="line10596"></span>          FORMAT SPECIFICATION                     ANSI X3J3/90.4
<span id="line10597"></span>
<span id="line10598"></span>
<span id="line10599"></span>
<span id="line10600"></span>          directly causes  a  character  already  placed  in  the
<span id="line10601"></span>          record  to  be  replaced.   Such  edit  descriptors may
<span id="line10602"></span>          result in positioning so that subsequent editing causes
<span id="line10603"></span>          a replacement.
<span id="line10604"></span>
<span id="line10605"></span>          13.5.3.1  T,_TL,_and_TR_Editing.    The   Tc  _    edit
<span id="line10606"></span>          descriptor  indicates that the transmission of the next
<span id="line10607"></span>          character to or from a record is to occur at the  c_ th
<span id="line10608"></span>          character position.
<span id="line10609"></span>
<span id="line10610"></span>          The TLc_ edit descriptor indicates that the transmission
<span id="line10611"></span>          of the next character to or from the record is to occur
<span id="line10612"></span>          at the character position c_  characters  backward  from
<span id="line10613"></span>          the current position.  However, if the current position
<span id="line10614"></span>          is less than or equal to position c_ ,  the  TLc_  edit
<span id="line10615"></span>          descriptor  indicates that the transmission of the next
<span id="line10616"></span>          character to or from the record is to occur at position
<span id="line10617"></span>          one of the current record.
<span id="line10618"></span>
<span id="line10619"></span>          The TRc_ edit descriptor indicates that the transmission
<span id="line10620"></span>          of the next character to or from the record is to occur
<span id="line10621"></span>          at the character position c_ characters forward from the
<span id="line10622"></span>          current position.
<span id="line10623"></span>
<span id="line10624"></span>          13.5.3.2  X_Editing.  The n_X edit descriptor  indicates
<span id="line10625"></span>          that  the transmission of the next character to or from
<span id="line10626"></span>          a record is to occur  at  the  position  n_  characters
<span id="line10627"></span>          forward from the current position.
<span id="line10628"></span>
<span id="line10629"></span>          13.5.4  Slash_Editing.   The  slash   edit   descriptor
<span id="line10630"></span>          indicates  the  end  of  data  transfer  on the current
<span id="line10631"></span>          record.
<span id="line10632"></span>
<span id="line10633"></span>          On input from a file connected for  sequential  access,
<span id="line10634"></span>          the  remaining portion of the current record is skipped
<span id="line10635"></span>          and the file is positioned at the beginning of the next
<span id="line10636"></span>          record.   This  record  becomes the current record.  On
<span id="line10637"></span>          output to a file connected for sequential access, a new
<span id="line10638"></span>          record  is  created  and  becomes  the last and current
<span id="line10639"></span>          record of the file.
<span id="line10640"></span>
<span id="line10641"></span>          Note that a record that contains no characters  may  be
<span id="line10642"></span>          written  on output.  If the file is an internal file or
<span id="line10643"></span>          a file connected  for  direct  access,  the  record  is
<span id="line10644"></span>          filled with blank characters.  Note also that an entire
<span id="line10645"></span>          record may be skipped on input.
<span id="line10646"></span>
<span id="line10647"></span>          For a file connected  for  direct  access,  the  record
<span id="line10648"></span>          number  is  increased by one and the file is positioned
<span id="line10649"></span>          at the beginning of the record  that  has  that  record
<span id="line10650"></span>          number.  This record becomes the current record.
<span id="line10651"></span>
<span id="line10652"></span>
<span id="line10653"></span>
<span id="line10654"></span>          FORTRAN 77 Full Language                      Page 13-7
<span id="line10655"></span>
<span id="line10656"></span>
<span id="line10657"></span>
<span id="line10658"></span>
<span id="line10659"></span>
<span id="line10660"></span>
<span id="line10661"></span>
<span id="line10662"></span>          FORMAT SPECIFICATION                     ANSI X3J3/90.4
<span id="line10663"></span>
<span id="line10664"></span>
<span id="line10665"></span>
<span id="line10666"></span>          13.5.5  Colon_Editing.   The  colon   edit   descriptor
<span id="line10667"></span>          terminates format control if there are no more items in
<span id="line10668"></span>          the  input/output  list   (13.3).    The   colon   edit
<span id="line10669"></span>          descriptor has no effect if there are more items in the
<span id="line10670"></span>          input/output list.
<span id="line10671"></span>
<span id="line10672"></span>          13.5.6  S,_SP,_and_SS_Editing.  The S, SP, and SS  edit
<span id="line10673"></span>          descriptors  may  be  used  to  control  optional  plus
<span id="line10674"></span>          characters in numeric output fields.  At the  beginning
<span id="line10675"></span>          of  execution  of  each formatted output statement, the
<span id="line10676"></span>          processor has the option of producing a plus in numeric
<span id="line10677"></span>          output fields.  If an SP edit descriptor is encountered
<span id="line10678"></span>          in a format specification, the processor must produce a
<span id="line10679"></span>          plus  in any subsequent position that normally contains
<span id="line10680"></span>          an  optional  plus.   If  an  SS  edit  descriptor   is
<span id="line10681"></span>          encountered,  the  processor must not produce a plus in
<span id="line10682"></span>          any  subsequent  position  that  normally  contains  an
<span id="line10683"></span>          optional plus.  If an S edit descriptor is encountered,
<span id="line10684"></span>          the option of producing the plus  is  restored  to  the
<span id="line10685"></span>          processor.
<span id="line10686"></span>
<span id="line10687"></span>          The S, SP, and SS edit descriptors affect only I, F, E,
<span id="line10688"></span>          D,  and  G  editing  during  the execution of an output
<span id="line10689"></span>          statement.  The S, SP, and SS edit descriptors have  no
<span id="line10690"></span>          effect during the execution of an input statement.
<span id="line10691"></span>
<span id="line10692"></span>          13.5.7  P_Editing.  A scale factor is specified by a  P
<span id="line10693"></span>          edit descriptor, which is of the form:
<span id="line10694"></span>
<span id="line10695"></span>                               k_P
<span id="line10696"></span>
<span id="line10697"></span>          where k_  is  an  optionally  signed  integer  constant,
<span id="line10698"></span>          called the scale factor.
<span id="line10699"></span>
<span id="line10700"></span>          13.5.7.1  Scale_Factor.  The value of the scale  factor
<span id="line10701"></span>          is   zero   at  the  beginning  of  execution  of  each
<span id="line10702"></span>          input/output statement.  It applies to all subsequently
<span id="line10703"></span>          interpreted  F,  E,  D,  and  G  edit descriptors until
<span id="line10704"></span>          another scale factor  is  encountered,  and  then  that
<span id="line10705"></span>          scale  factor  is  established.  Note that reversion of
<span id="line10706"></span>          format control (13.3) does not affect  the  established
<span id="line10707"></span>          scale factor.
<span id="line10708"></span>
<span id="line10709"></span>          The scale factor k_ affects the appropriate  editing  in
<span id="line10710"></span>          the following manner:
<span id="line10711"></span>
<span id="line10712"></span>             (1) On input, with F, E, D, and G editing  (provided
<span id="line10713"></span>                 that  no  exponent  exists  in  the field) and F
<span id="line10714"></span>                 output editing, the scale factor effect is  that
<span id="line10715"></span>                 the  externally  represented  number  equals the
<span id="line10716"></span>                 internally represented number multiplied by 10**k
<span id="line10717"></span>
<span id="line10718"></span>
<span id="line10719"></span>
<span id="line10720"></span>          FORTRAN 77 Full Language                      Page 13-8
<span id="line10721"></span>
<span id="line10722"></span>
<span id="line10723"></span>
<span id="line10724"></span>
<span id="line10725"></span>
<span id="line10726"></span>
<span id="line10727"></span>
<span id="line10728"></span>          FORMAT SPECIFICATION                     ANSI X3J3/90.4
<span id="line10729"></span>
<span id="line10730"></span>
<span id="line10731"></span>
<span id="line10732"></span>                 _
<span id="line10733"></span>
<span id="line10734"></span>
<span id="line10735"></span>             .(2) On input, with F, E,  D,  and  G  editing,  the
<span id="line10736"></span>                 scale  factor  has  no  effect  if  there  is an
<span id="line10737"></span>                 exponent in the field.
<span id="line10738"></span>
<span id="line10739"></span>             (3) On output, with E and D editing, the basic  real
<span id="line10740"></span>                 constant  (4.4.1)  part  of  the  quantity to be
<span id="line10741"></span>                 produced is multiplied by 10**k_ and the exponent
<span id="line10742"></span>                 is reduced by k_.
<span id="line10743"></span>
<span id="line10744"></span>             (4) On output, with G editing,  the  effect  of  the
<span id="line10745"></span>                 scale  factor  is suspended unless the magnitude
<span id="line10746"></span>                 of the datum to be edited is outside  the  range
<span id="line10747"></span>                 that  permits  the use of F editing.  If the use
<span id="line10748"></span>                 of E editing is required, the scale  factor  has
<span id="line10749"></span>                 the same effect as with E output editing.
<span id="line10750"></span>
<span id="line10751"></span>          13.5.8  BN_and_BZ_Editing.   The   BN   and   BZ   edit
<span id="line10752"></span>          descriptors  may  be used to specify the interpretation
<span id="line10753"></span>          of blanks, other than leading blanks, in numeric  input
<span id="line10754"></span>          fields.    At   the  beginning  of  execution  of  each
<span id="line10755"></span>          formatted input statement, such  blank  characters  are
<span id="line10756"></span>          interpreted  as  zeros or are ignored, depending on the
<span id="line10757"></span>          value of the BLANK= specifier  (12.10.1)  currently  in
<span id="line10758"></span>          effect  for  the  unit.   If  a  BN  edit descriptor is
<span id="line10759"></span>          encountered in a format specification, all  such  blank
<span id="line10760"></span>          characters  in  succeeding  numeric  input  fields  are
<span id="line10761"></span>          ignored.  The effect of ignoring blanks is to treat the
<span id="line10762"></span>          input   field  as  if  blanks  had  been  removed,  the
<span id="line10763"></span>          remaining portion of the field right-justified, and the
<span id="line10764"></span>          blanks replaced as leading blanks.  However, a field of
<span id="line10765"></span>          all blanks has the value zero.  If a BZ edit descriptor
<span id="line10766"></span>          is  encountered  in  a  format  specification, all such
<span id="line10767"></span>          blank characters in succeeding numeric input fields are
<span id="line10768"></span>          treated as zeros.
<span id="line10769"></span>
<span id="line10770"></span>          The BN and BZ edit descriptors affect only I, F, E,  D,
<span id="line10771"></span>          and  G  editing during execution of an input statement.
<span id="line10772"></span>          They have no  effect  during  execution  of  an  output
<span id="line10773"></span>          statement.
<span id="line10774"></span>
<span id="line10775"></span>          13.5.9  Numeric_Editing.  The I, F, E, D,  and  G  edit
<span id="line10776"></span>          descriptors   are   used  to  specify  input/output  of
<span id="line10777"></span>          integer, real, double precision, and complex data.  The
<span id="line10778"></span>          following general rules apply:
<span id="line10779"></span>
<span id="line10780"></span>             (1) On input, leading blanks  are  not  significant.
<span id="line10781"></span>                 The interpretation of blanks, other than leading
<span id="line10782"></span>                 blanks, is determined by a  combination  of  any
<span id="line10783"></span>
<span id="line10784"></span>
<span id="line10785"></span>
<span id="line10786"></span>          FORTRAN 77 Full Language                      Page 13-9
<span id="line10787"></span>
<span id="line10788"></span>
<span id="line10789"></span>
<span id="line10790"></span>
<span id="line10791"></span>
<span id="line10792"></span>
<span id="line10793"></span>
<span id="line10794"></span>          FORMAT SPECIFICATION                     ANSI X3J3/90.4
<span id="line10795"></span>
<span id="line10796"></span>
<span id="line10797"></span>
<span id="line10798"></span>                 BLANK=  specifier and any BN or BZ blank control
<span id="line10799"></span>                 that  is  currently  in  effect  for  the   unit
<span id="line10800"></span>                 (13.5.8).   Plus  signs may be omitted.  A field
<span id="line10801"></span>                 of all blanks is considered to be zero.
<span id="line10802"></span>
<span id="line10803"></span>             (2) On input, with F, E, D, and G editing, a decimal
<span id="line10804"></span>                 point appearing in the input field overrides the
<span id="line10805"></span>                 portion of an edit descriptor that specifies the
<span id="line10806"></span>                 decimal  point  location.   The  input field may
<span id="line10807"></span>                 have more digits  than  the  processor  uses  to
<span id="line10808"></span>                 approximate the value of the datum.
<span id="line10809"></span>
<span id="line10810"></span>             (3) On output, the representation of a  positive  or
<span id="line10811"></span>                 zero internal value in the field may be prefixed
<span id="line10812"></span>                 with a plus, as controlled by the S, SP, and  SS
<span id="line10813"></span>                 edit descriptors (13.5.6) or the processor.  The
<span id="line10814"></span>                 representation of a negative internal  value  in
<span id="line10815"></span>                 the   field  must  be  prefixed  with  a  minus.
<span id="line10816"></span>                 However,  the  processor  must  not  produce   a
<span id="line10817"></span>                 negative  signed  zero  in  a  formatted  output
<span id="line10818"></span>                 record.
<span id="line10819"></span>
<span id="line10820"></span>             (4) On output, the representation is right-justified
<span id="line10821"></span>                 in  the  field.   If  the  number  of characters
<span id="line10822"></span>                 produced by the  editing  is  smaller  than  the
<span id="line10823"></span>                 field  width, leading blanks will be inserted in
<span id="line10824"></span>                 the field.
<span id="line10825"></span>
<span id="line10826"></span>             (5) On output, if the number of characters  produced
<span id="line10827"></span>                 exceeds  the  field  width  or  if  an  exponent
<span id="line10828"></span>                 exceeds its specified length using the Ew_.d_Ee_ or
<span id="line10829"></span>                 Gw_.d_Ee_ edit descriptor, the processor will fill
<span id="line10830"></span>                 the entire field of  width  w_  with  asterisks.
<span id="line10831"></span>                 However,   the   processor   must   not  produce
<span id="line10832"></span>                 asterisks if the field  width  is  not  exceeded
<span id="line10833"></span>                 when optional characters are omitted.  Note that
<span id="line10834"></span>                 when an SP edit descriptor is in effect, a  plus
<span id="line10835"></span>                 is not optional (13.5.6).
<span id="line10836"></span>
<span id="line10837"></span>          13.5.9.1  Integer_Editing.  The Iw_  and  Iw_ .m_  edit
<span id="line10838"></span>          descriptors  indicate  that  the  field  to  be  edited
<span id="line10839"></span>          occupies w_ positions.  The specified input/output  list
<span id="line10840"></span>          item  must be of type integer.  On input, the specified
<span id="line10841"></span>          list item will become defined with  an  integer  datum.
<span id="line10842"></span>          On output, the specified list item must be defined with
<span id="line10843"></span>          an integer datum.
<span id="line10844"></span>
<span id="line10845"></span>          On  input,  an  Iw_ .m_  edit  descriptor  is   treated
<span id="line10846"></span>          identically to an Iw_ edit descriptor.
<span id="line10847"></span>
<span id="line10848"></span>
<span id="line10849"></span>
<span id="line10850"></span>
<span id="line10851"></span>
<span id="line10852"></span>          FORTRAN 77 Full Language                     Page 13-10
<span id="line10853"></span>
<span id="line10854"></span>
<span id="line10855"></span>
<span id="line10856"></span>
<span id="line10857"></span>
<span id="line10858"></span>
<span id="line10859"></span>
<span id="line10860"></span>          FORMAT SPECIFICATION                     ANSI X3J3/90.4
<span id="line10861"></span>
<span id="line10862"></span>
<span id="line10863"></span>
<span id="line10864"></span>          In the input field, the character string must be in the
<span id="line10865"></span>          form  of  an optionally signed integer constant, except
<span id="line10866"></span>          for the interpretation of blanks (13.5.9, item (1)).
<span id="line10867"></span>
<span id="line10868"></span>          The output field for the Iw_ edit descriptor consists of
<span id="line10869"></span>          zero  or more leading blanks followed by a minus if the
<span id="line10870"></span>          value of the internal datum is negative, or an optional
<span id="line10871"></span>          plus  otherwise,  followed  by  the  magnitude  of  the
<span id="line10872"></span>          internal value in  the  form  of  an  unsigned  integer
<span id="line10873"></span>          constant  without  leading zeros.  Note that an integer
<span id="line10874"></span>          constant always consists of at least one digit.
<span id="line10875"></span>
<span id="line10876"></span>          The output field for the Iw_.m_ edit  descriptor  is  the
<span id="line10877"></span>          same  as  for  the  Iw_ edit descriptor, except that the
<span id="line10878"></span>          unsigned integer constant consists of at least m_ digits
<span id="line10879"></span>          and,  if  necessary, has leading zeros.  The value of m_
<span id="line10880"></span>          must not exceed the value of w_.  If m_ is zero  and  the
<span id="line10881"></span>          value  of  the internal datum is zero, the output field
<span id="line10882"></span>          consists of only blank characters,  regardless  of  the
<span id="line10883"></span>          sign control in effect.
<span id="line10884"></span>
<span id="line10885"></span>          13.5.9.2  Real_and_Double_Precision_Editing.  The F, E,
<span id="line10886"></span>          D,  and G edit descriptors specify the editing of real,
<span id="line10887"></span>          double precision, and complex  data.   An  input/output
<span id="line10888"></span>          list  item  corresponding  to  an  F,  E,  D, or G edit
<span id="line10889"></span>          descriptor must be real, double precision, or  complex.
<span id="line10890"></span>          An  input  list  item  will become defined with a datum
<span id="line10891"></span>          whose type is the same as that of the  list  item.   An
<span id="line10892"></span>          output  list  item  must  be defined with a datum whose
<span id="line10893"></span>          type is the same as that of the list item.
<span id="line10894"></span>
<span id="line10895"></span>          13.5.9.2.1  F_Editing.   The  Fw_ .d_  edit  descriptor
<span id="line10896"></span>          indicates  that  the  field  occupies  w_ positions, the
<span id="line10897"></span>          fractional part of which consists of d_ digits.
<span id="line10898"></span>
<span id="line10899"></span>          The input field consists of an optional sign,  followed
<span id="line10900"></span>          by  a  string of digits optionally containing a decimal
<span id="line10901"></span>          point.  If the decimal point is omitted, the rightmost d
<span id="line10902"></span>          _  digits  of the string, with leading zeros assumed if
<span id="line10903"></span>          necessary, are interpreted as the  fractional  part  of
<span id="line10904"></span>          the  value  represented.   The  string  of  digits  may
<span id="line10905"></span>          contain  more  digits  than   a   processor   uses   to
<span id="line10906"></span>          approximate  the value of the constant.  The basic form
<span id="line10907"></span>          may be followed by an exponent of one of the  following
<span id="line10908"></span>          forms:
<span id="line10909"></span>
<span id="line10910"></span>             (1) Signed integer constant
<span id="line10911"></span>
<span id="line10912"></span>             (2) E followed by zero or more blanks,  followed  by
<span id="line10913"></span>                 an optionally signed integer constant
<span id="line10914"></span>
<span id="line10915"></span>
<span id="line10916"></span>
<span id="line10917"></span>
<span id="line10918"></span>          FORTRAN 77 Full Language                     Page 13-11
<span id="line10919"></span>
<span id="line10920"></span>
<span id="line10921"></span>
<span id="line10922"></span>
<span id="line10923"></span>
<span id="line10924"></span>
<span id="line10925"></span>
<span id="line10926"></span>          FORMAT SPECIFICATION                     ANSI X3J3/90.4
<span id="line10927"></span>
<span id="line10928"></span>
<span id="line10929"></span>
<span id="line10930"></span>             (3) D followed by zero or more blanks,  followed  by
<span id="line10931"></span>                 an optionally signed integer constant
<span id="line10932"></span>
<span id="line10933"></span>          An exponent containing a D is processed identically  to
<span id="line10934"></span>          an exponent containing an E.
<span id="line10935"></span>
<span id="line10936"></span>          The output field  consists  of  blanks,  if  necessary,
<span id="line10937"></span>          followed  by a minus if the internal value is negative,
<span id="line10938"></span>          or an optional plus otherwise, followed by a string  of
<span id="line10939"></span>          digits that contains a decimal point and represents the
<span id="line10940"></span>          magnitude of the internal value,  as  modified  by  the
<span id="line10941"></span>          established  scale  factor  and rounded to d_ fractional
<span id="line10942"></span>          digits.  Leading zeros are not permitted except for  an
<span id="line10943"></span>          optional  zero  immediately  to the left of the decimal
<span id="line10944"></span>          point if the magnitude of the value in the output field
<span id="line10945"></span>          is  less  than  one.   The optional zero must appear if
<span id="line10946"></span>          there would otherwise be no digits in the output field.
<span id="line10947"></span>
<span id="line10948"></span>          13.5.9.2.2  E_and_D_Editing.  The Ew_.d_, Dw_.d_, and Ew_.d_Ee
<span id="line10949"></span>          _  edit  descriptors  indicate  that the external field
<span id="line10950"></span>          occupies w_ positions,  the  fractional  part  of  which
<span id="line10951"></span>          consists  of  d_  digits, unless a scale factor greater
<span id="line10952"></span>          than one is in effect, and the exponent  part  consists
<span id="line10953"></span>          of e_ digits.  The e_ has no effect on input.
<span id="line10954"></span>
<span id="line10955"></span>          The form of the input  field  is  the  same  as  for  F
<span id="line10956"></span>          editing (13.5.9.2.1).
<span id="line10957"></span>
<span id="line10958"></span>          The form of the output field for a scale factor of zero
<span id="line10959"></span>          is:
<span id="line10960"></span>
<span id="line10961"></span>                               [+_] [0] . x918x928...x9d8 exp___
<span id="line10962"></span>
<span id="line10963"></span>          where: +_   signifies a plus or a minus (13.5.9)
<span id="line10964"></span>
<span id="line10965"></span>                 x918,x928...x9d8 are the Ld_ most significant digits of
<span id="line10966"></span>                     the value of the datum after rounding
<span id="line10967"></span>
<span id="line10968"></span>                 exp___ is a decimal exponent, one of the  following
<span id="line10969"></span>                     forms:
<span id="line10970"></span>
<span id="line10971"></span>
<span id="line10972"></span>
<span id="line10973"></span>
<span id="line10974"></span>
<span id="line10975"></span>
<span id="line10976"></span>
<span id="line10977"></span>
<span id="line10978"></span>
<span id="line10979"></span>
<span id="line10980"></span>
<span id="line10981"></span>
<span id="line10982"></span>
<span id="line10983"></span>
<span id="line10984"></span>          FORTRAN 77 Full Language                     Page 13-12
<span id="line10985"></span>
<span id="line10986"></span>
<span id="line10987"></span>
<span id="line10988"></span>
<span id="line10989"></span>
<span id="line10990"></span>
<span id="line10991"></span>
<span id="line10992"></span>          FORMAT SPECIFICATION                     ANSI X3J3/90.4
<span id="line10993"></span>
<span id="line10994"></span>
<span id="line10995"></span>
<span id="line10996"></span>8             _________________________________________________
<span id="line10997"></span>
<span id="line10998"></span>              Edit         Absolute Value    Form of
<span id="line10999"></span>              Descriptor   of Exponent       Exponent
<span id="line11000"></span>8             _________________________________________________
<span id="line11001"></span>
<span id="line11002"></span>              Ew_.d_         |exp___|<span class="entity"><span>&amp;</span>lt;</span>99          E+_z_918z_928 or +_0z_918z_92
<span id="line11003"></span>7                          ____________________________________
<span id="line11004"></span>
<span id="line11005"></span>                           99<span class="entity"><span>&amp;</span>lt;</span>|exp___|<span class="entity"><span>&amp;</span>lt;</span>999      +_z_918z_928z_93
<span id="line11006"></span>7             _________________________________________________
<span id="line11007"></span>
<span id="line11008"></span>              Ew_.d_Ee_       |exp___|<span class="entity"><span>&amp;</span>lt;</span>(10**e_)-1   E+_z_918z_928...z_9e
<span id="line11009"></span>7             _________________________________________________
<span id="line11010"></span>
<span id="line11011"></span>              Dw_.d_         |exp___|<span class="entity"><span>&amp;</span>lt;</span>99          D+_z_918z_928 or E+_z_918z_92
<span id="line11012"></span>8                                             or +_0z_918z_92
<span id="line11013"></span>7                          ____________________________________
<span id="line11014"></span>
<span id="line11015"></span>                           99<span class="entity"><span>&amp;</span>lt;</span>|exp___|<span class="entity"><span>&amp;</span>lt;</span>999      +_z_918z_928z_93
<span id="line11016"></span>7             _________________________________________________
<span id="line11017"></span>7            |7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|
<span id="line11018"></span>
<span id="line11019"></span>
<span id="line11020"></span>
<span id="line11021"></span>
<span id="line11022"></span>
<span id="line11023"></span>
<span id="line11024"></span>
<span id="line11025"></span>
<span id="line11026"></span>
<span id="line11027"></span>
<span id="line11028"></span>
<span id="line11029"></span>
<span id="line11030"></span>
<span id="line11031"></span>
<span id="line11032"></span>
<span id="line11033"></span>                        |7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|
<span id="line11034"></span>
<span id="line11035"></span>
<span id="line11036"></span>
<span id="line11037"></span>
<span id="line11038"></span>
<span id="line11039"></span>
<span id="line11040"></span>
<span id="line11041"></span>
<span id="line11042"></span>
<span id="line11043"></span>
<span id="line11044"></span>
<span id="line11045"></span>
<span id="line11046"></span>
<span id="line11047"></span>
<span id="line11048"></span>
<span id="line11049"></span>                                          |7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|
<span id="line11050"></span>
<span id="line11051"></span>
<span id="line11052"></span>
<span id="line11053"></span>
<span id="line11054"></span>
<span id="line11055"></span>
<span id="line11056"></span>
<span id="line11057"></span>
<span id="line11058"></span>
<span id="line11059"></span>
<span id="line11060"></span>
<span id="line11061"></span>
<span id="line11062"></span>
<span id="line11063"></span>
<span id="line11064"></span>
<span id="line11065"></span>                                                             |7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|
<span id="line11066"></span>
<span id="line11067"></span>
<span id="line11068"></span>
<span id="line11069"></span>
<span id="line11070"></span>
<span id="line11071"></span>
<span id="line11072"></span>
<span id="line11073"></span>
<span id="line11074"></span>
<span id="line11075"></span>
<span id="line11076"></span>
<span id="line11077"></span>
<span id="line11078"></span>
<span id="line11079"></span>
<span id="line11080"></span>
<span id="line11081"></span>
<span id="line11082"></span>
<span id="line11083"></span>          where z_ is a  digit.   The  sign  in  the  exponent  is
<span id="line11084"></span>          required.   A  plus  sign  must be used if the exponent
<span id="line11085"></span>          value is zero.  The forms Ew_.d_ and Dw_.d_  must  not  be
<span id="line11086"></span>          used if |exp___| <span class="entity"><span>&amp;</span>gt;</span> 999.
<span id="line11087"></span>
<span id="line11088"></span>          The scale factor k_ controls the  decimal  normalization
<span id="line11089"></span>          (13.5.7).   If   - d_ <span class="entity"><span>&amp;</span>lt;</span> k_ <span class="entity"><span>&amp;</span>lt;</span> 0, the output field contains
<span id="line11090"></span>          exactly |k_| leading zeros and d_   -  |k_ |  significant
<span id="line11091"></span>          digits  after the decimal point.  If 0 <span class="entity"><span>&amp;</span>lt;</span> k_ <span class="entity"><span>&amp;</span>lt;</span> d_ + 2, the
<span id="line11092"></span>          output field contains exactly k_ significant  digits  to
<span id="line11093"></span>          the left of the decimal point and d_ - k_ + 1 significant
<span id="line11094"></span>          digits to the right of the decimal point.  Other values
<span id="line11095"></span>          of k_ are not permitted.
<span id="line11096"></span>
<span id="line11097"></span>          13.5.9.2.3  G_Editing.  The Gw_.d_ and  Gw_ .d_ Ee_  edit
<span id="line11098"></span>          descriptors indicate that the external field occupies w_
<span id="line11099"></span>          positions, the fractional part of which consists of  d_
<span id="line11100"></span>          digits,  unless  a  scale factor greater than one is in
<span id="line11101"></span>          effect, and the exponent part consists of e_ digits.
<span id="line11102"></span>
<span id="line11103"></span>          G  input  editing  is  the  same  as  for   F   editing
<span id="line11104"></span>          (13.5.9.2.1).
<span id="line11105"></span>
<span id="line11106"></span>          The  method  of  representation  in  the  output  field
<span id="line11107"></span>          depends  on  the  magnitude  of the datum being edited.
<span id="line11108"></span>          Let N be the  magnitude  of  the  internal  datum.   If
<span id="line11109"></span>          N <span class="entity"><span>&amp;</span>lt;</span> 0.1 or N <span class="entity"><span>&amp;</span>gt;</span> 10**d_,Gw_.d_ output editing is the same as
<span id="line11110"></span>          k_PEw_.d_ output editing and Gw_.d_Ee_ output editing is  the
<span id="line11111"></span>          same  as  k_PEw_.d_Ee_ output editing, where k_ is the scale
<span id="line11112"></span>          factor currently in effect.  If N is  greater  than  or
<span id="line11113"></span>          equal  to  0.1 and is less than 10**d_, the scale factor
<span id="line11114"></span>          has no effect,  and  the  value  of  N  determines  the
<span id="line11115"></span>          editing as follows:
<span id="line11116"></span>
<span id="line11117"></span>9
<span id="line11118"></span>          FORTRAN 77 Full Language                     Page 13-13
<span id="line11119"></span>
<span id="line11120"></span>
<span id="line11121"></span>
<span id="line11122"></span>
<span id="line11123"></span>
<span id="line11124"></span>
<span id="line11125"></span>
<span id="line11126"></span>          FORMAT SPECIFICATION                     ANSI X3J3/90.4
<span id="line11127"></span>
<span id="line11128"></span>
<span id="line11129"></span>
<span id="line11130"></span>8              _______________________________________________
<span id="line11131"></span>
<span id="line11132"></span>               Magnitude of Datum      Equivalent Conversion
<span id="line11133"></span>8              _______________________________________________
<span id="line11134"></span>
<span id="line11135"></span>               0.1=N<span class="entity"><span>&amp;</span>lt;</span>1                 F(w_-n_).d_, n_('b_')
<span id="line11136"></span>
<span id="line11137"></span>               1</span><span>&lt;<span class="start-tag">n</span>&gt;</span><span><span class="entity"><span>&amp;</span>lt;</span>10                  F(w_-n_).(d_-1), n_('b_')
<span id="line11138"></span>
<span id="line11139"></span>                 .                           .
<span id="line11140"></span>                 .                           .
<span id="line11141"></span>                 .                           .
<span id="line11142"></span>               10**(d_-2)</span><span>&lt;<span class="start-tag">n</span>&gt;</span><span><span class="entity"><span>&amp;</span>lt;</span>10**(d_-1)   F(w_-n_).1, n_('b_')
<span id="line11143"></span>
<span id="line11144"></span>               10**(d_-1)</span><span>&lt;<span class="start-tag">n</span>&gt;</span><span><span class="entity"><span>&amp;</span>lt;</span>10**d_       F(w_-n_).0, n_('b_')
<span id="line11145"></span>
<span id="line11146"></span>8              _______________________________________________
<span id="line11147"></span>7             |7|7|7|7|7|7|7|7|7|7|7|7|7|7|
<span id="line11148"></span>
<span id="line11149"></span>
<span id="line11150"></span>
<span id="line11151"></span>
<span id="line11152"></span>
<span id="line11153"></span>
<span id="line11154"></span>
<span id="line11155"></span>
<span id="line11156"></span>
<span id="line11157"></span>
<span id="line11158"></span>
<span id="line11159"></span>
<span id="line11160"></span>
<span id="line11161"></span>                                    |7|7|7|7|7|7|7|7|7|7|7|7|7|7|
<span id="line11162"></span>
<span id="line11163"></span>
<span id="line11164"></span>
<span id="line11165"></span>
<span id="line11166"></span>
<span id="line11167"></span>
<span id="line11168"></span>
<span id="line11169"></span>
<span id="line11170"></span>
<span id="line11171"></span>
<span id="line11172"></span>
<span id="line11173"></span>
<span id="line11174"></span>
<span id="line11175"></span>                                                            |7|7|7|7|7|7|7|7|7|7|7|7|7|7|
<span id="line11176"></span>
<span id="line11177"></span>
<span id="line11178"></span>
<span id="line11179"></span>
<span id="line11180"></span>
<span id="line11181"></span>
<span id="line11182"></span>
<span id="line11183"></span>
<span id="line11184"></span>
<span id="line11185"></span>
<span id="line11186"></span>
<span id="line11187"></span>
<span id="line11188"></span>
<span id="line11189"></span>
<span id="line11190"></span>
<span id="line11191"></span>          where: b_   is a blank
<span id="line11192"></span>
<span id="line11193"></span>                 n_   is 4 for Gw_.d_ and e_+_2 for Gw_.d_Ee_
<span id="line11194"></span>
<span id="line11195"></span>          Note that the scale factor has  no  effect  unless  the
<span id="line11196"></span>          magnitude  of  the datum to be edited is outside of the
<span id="line11197"></span>          range that permits effective use of F editing.
<span id="line11198"></span>
<span id="line11199"></span>          13.5.9.2.4  Complex_Editing.  A complex datum  consists
<span id="line11200"></span>          of a pair of separate real data; therefore, the editing
<span id="line11201"></span>          is specified by two successively interpreted F,  E,  D,
<span id="line11202"></span>          or   G   edit  descriptors.   The  first  of  the  edit
<span id="line11203"></span>          descriptors  specifies  the  real  part;   the   second
<span id="line11204"></span>          specifies the imaginary part.  The two edit descriptors
<span id="line11205"></span>          may  be  different.   Note  that   nonrepeatable   edit
<span id="line11206"></span>          descriptors may appear between the two successive F, E,
<span id="line11207"></span>          D, or G edit descriptors.
<span id="line11208"></span>
<span id="line11209"></span>          13.5.10  L_Editing.  The Lw_ edit  descriptor  indicates
<span id="line11210"></span>          that  the  field  occupies  w_ positions.  The specified
<span id="line11211"></span>          input/output list item must be  of  type  logical.   On
<span id="line11212"></span>          input, the list item will become defined with a logical
<span id="line11213"></span>          datum.  On output, the  specified  list  item  must  be
<span id="line11214"></span>          defined with a logical datum.  The input field consists
<span id="line11215"></span>          of optional blanks, optionally followed  by  a  decimal
<span id="line11216"></span>          point,  followed by a T for true or F for false.  The T
<span id="line11217"></span>          or F may be followed by additional  characters  in  the
<span id="line11218"></span>          field.   Note  that  the  logical  constants .TRUE. and
<span id="line11219"></span>          .FALSE. are acceptable input forms.
<span id="line11220"></span>
<span id="line11221"></span>          The output field consists of w_ - 1 blanks followed by a
<span id="line11222"></span>          T  or  F, as the value of the internal datum is true or
<span id="line11223"></span>          false, respectively.
<span id="line11224"></span>
<span id="line11225"></span>9
<span id="line11226"></span>
<span id="line11227"></span>
<span id="line11228"></span>          FORTRAN 77 Full Language                     Page 13-14
<span id="line11229"></span>
<span id="line11230"></span>
<span id="line11231"></span>
<span id="line11232"></span>
<span id="line11233"></span>
<span id="line11234"></span>
<span id="line11235"></span>
<span id="line11236"></span>          FORMAT SPECIFICATION                     ANSI X3J3/90.4
<span id="line11237"></span>
<span id="line11238"></span>
<span id="line11239"></span>
<span id="line11240"></span>          13.5.11  A_Editing.  The A[w_] edit descriptor  is  used
<span id="line11241"></span>          with  an  input/output list item of type character.  On
<span id="line11242"></span>          input, the input list item  will  become  defined  with
<span id="line11243"></span>          character  data.   On output, the output list item must
<span id="line11244"></span>          be defined with character data.
<span id="line11245"></span>
<span id="line11246"></span>          If a field width  w_  is  specified  with  the  A  edit
<span id="line11247"></span>          descriptor,  the  field consists of w_ characters.  If a
<span id="line11248"></span>          field width  w_  is  not  specified  with  the  A  edit
<span id="line11249"></span>          descriptor,  the  number  of characters in the field is
<span id="line11250"></span>          the length of the character input/output list item.
<span id="line11251"></span>
<span id="line11252"></span>          Let len___ be the length of the  input/output  list  item.
<span id="line11253"></span>          If  the  specified field width w_ for A input is greater
<span id="line11254"></span>          than or equal to len___, the rightmost len___ characters will
<span id="line11255"></span>          be  taken from the input field.  If the specified field
<span id="line11256"></span>          width is less than len___, the w_  characters  will  appear
<span id="line11257"></span>          left-justified  with  len_ _ _ - w_ trailing blanks in the
<span id="line11258"></span>          internal representation.
<span id="line11259"></span>
<span id="line11260"></span>          If the specified field width w_ for A output is  greater
<span id="line11261"></span>          than len___, the output field will consist of w_-len___ blanks
<span id="line11262"></span>          followed by the len_ _ _  characters  from  the  internal
<span id="line11263"></span>          representation.  If the specified field width w_ is less
<span id="line11264"></span>          than or equal to len___, the output field will consist  of
<span id="line11265"></span>          the   leftmost   w _   characters   from  the  internal
<span id="line11266"></span>          representation.
<span id="line11267"></span>
<span id="line11268"></span>          13.6  List-Directed_Formatting
<span id="line11269"></span>
<span id="line11270"></span>          The characters in one  or  more  list-directed  records
<span id="line11271"></span>          constitute  a  sequence of values and value separators.
<span id="line11272"></span>          The end of a record has the  same  effect  as  a  blank
<span id="line11273"></span>          character,  unless  it  is within a character constant.
<span id="line11274"></span>          Any sequence of  two  or  more  consecutive  blanks  is
<span id="line11275"></span>          treated  as  a  single  blank,  unless  it  is within a
<span id="line11276"></span>          character constant.
<span id="line11277"></span>
<span id="line11278"></span>          Each value is either a constant, a null  value,  or  of
<span id="line11279"></span>          one of the forms:
<span id="line11280"></span>
<span id="line11281"></span>                               r_*c_
<span id="line11282"></span>
<span id="line11283"></span>                               r_*
<span id="line11284"></span>
<span id="line11285"></span>          where r_ is an unsigned, nonzero, integer constant.  The
<span id="line11286"></span>          r_ *c_ form is equivalent to r_ successive appearances of
<span id="line11287"></span>          the constant c_, add the r_* form  is  equivalent  to  r_
<span id="line11288"></span>          successive  appearances of the null values.  Neither of
<span id="line11289"></span>          these forms may contain embedded blanks,  except  where
<span id="line11290"></span>          permitted within the constant c_.
<span id="line11291"></span>
<span id="line11292"></span>
<span id="line11293"></span>
<span id="line11294"></span>          FORTRAN 77 Full Language                     Page 13-15
<span id="line11295"></span>
<span id="line11296"></span>
<span id="line11297"></span>
<span id="line11298"></span>
<span id="line11299"></span>
<span id="line11300"></span>
<span id="line11301"></span>
<span id="line11302"></span>          FORMAT SPECIFICATION                     ANSI X3J3/90.4
<span id="line11303"></span>
<span id="line11304"></span>
<span id="line11305"></span>
<span id="line11306"></span>          A value separator is one of the following:
<span id="line11307"></span>
<span id="line11308"></span>             (1) A comma  optionally  preceded  by  one  or  more
<span id="line11309"></span>                 contiguous blanks and optionally followed by one
<span id="line11310"></span>                 or more contiguous blanks
<span id="line11311"></span>
<span id="line11312"></span>             (2) A slash  optionally  preceded  by  one  or  more
<span id="line11313"></span>                 contiguous blanks and optionally followed by one
<span id="line11314"></span>                 or more contiguous blanks
<span id="line11315"></span>
<span id="line11316"></span>             (3) One  or  more  contiguous  blanks  between   two
<span id="line11317"></span>                 constants or following the last constant
<span id="line11318"></span>
<span id="line11319"></span>          13.6.1  List-Directed_Input.  Input forms acceptable to
<span id="line11320"></span>          format  specifications  for a given type are acceptable
<span id="line11321"></span>          for list-directed formatting, except  as  noted  below.
<span id="line11322"></span>          The  form of the input value must be acceptable for the
<span id="line11323"></span>          type of the input list item.  Blanks are never used  as
<span id="line11324"></span>          zeros,   and  embedded  blanks  are  not  permitted  in
<span id="line11325"></span>          constants,  except  within  character   constants   and
<span id="line11326"></span>          complex  constants  as  specified below.  Note that the
<span id="line11327"></span>          end of a record has the effect of a blank, except  when
<span id="line11328"></span>          it appears within a character constant.
<span id="line11329"></span>
<span id="line11330"></span>          When the corresponding input list item is of type  real
<span id="line11331"></span>          or  double  precision,  the  input  form  is  that of a
<span id="line11332"></span>          numeric input field.  A numeric input field is a  field
<span id="line11333"></span>          suitable  for  F  editing (13.5.9.2) that is assumed to
<span id="line11334"></span>          have  no  fractional  digits  unless  a  decimal  point
<span id="line11335"></span>          appears within the field.
<span id="line11336"></span>
<span id="line11337"></span>          When the corresponding list item is  of  type  complex,
<span id="line11338"></span>          the  input form consists of a left parenthesis followed
<span id="line11339"></span>          by an ordered pair of numeric input fields separated by
<span id="line11340"></span>          a  comma,  and  followed  by  a right parenthesis.  The
<span id="line11341"></span>          first numeric input field  is  the  real  part  of  the
<span id="line11342"></span>          complex  constant and the second is the imaginary part.
<span id="line11343"></span>          Each of the numeric input fields  may  be  preceded  or
<span id="line11344"></span>          followed  by  blanks.   The  end  of a record may occur
<span id="line11345"></span>          between the real part and  the  comma  or  between  the
<span id="line11346"></span>          comma and the imaginary part.
<span id="line11347"></span>
<span id="line11348"></span>          When the corresponding list item is  of  type  logical,
<span id="line11349"></span>          the  input  form  must  not  include  either slashes or
<span id="line11350"></span>          commas among the optional characters  permitted  for  L
<span id="line11351"></span>          editing (13.5.10).
<span id="line11352"></span>
<span id="line11353"></span>          When the corresponding list item is of type  character,
<span id="line11354"></span>          the  input  form  consists  of  a  nonempty  string  of
<span id="line11355"></span>          characters enclosed in  apostrophes.   Each  apostrophe
<span id="line11356"></span>          within  a character constant must be represented by two
<span id="line11357"></span>
<span id="line11358"></span>
<span id="line11359"></span>
<span id="line11360"></span>          FORTRAN 77 Full Language                     Page 13-16
<span id="line11361"></span>
<span id="line11362"></span>
<span id="line11363"></span>
<span id="line11364"></span>
<span id="line11365"></span>
<span id="line11366"></span>
<span id="line11367"></span>
<span id="line11368"></span>          FORMAT SPECIFICATION                     ANSI X3J3/90.4
<span id="line11369"></span>
<span id="line11370"></span>
<span id="line11371"></span>
<span id="line11372"></span>          consecutive apostrophes without an intervening blank or
<span id="line11373"></span>          end  of  record.   Character constants may be continued
<span id="line11374"></span>          from the end of one record to the beginning of the next
<span id="line11375"></span>          record.   The  end of the record does not cause a blank
<span id="line11376"></span>          or any other character to become part of the  constant.
<span id="line11377"></span>          The  constant  may  be  continued on as many records as
<span id="line11378"></span>          needed.  The characters blank,  comma,  and  slash  may
<span id="line11379"></span>          appear in character constants.
<span id="line11380"></span>
<span id="line11381"></span>          Let len___ be the length of the list item, and let  w_  be
<span id="line11382"></span>          the  length  of the character constant.  If len___ is less
<span id="line11383"></span>          than or equal to w_, the leftmost len___ characters of  the
<span id="line11384"></span>          constant  are  transmitted to the list item.  If len___ is
<span id="line11385"></span>          greater than w_, the  constant  is  transmitted  to  the
<span id="line11386"></span>          leftmost  w_  characters  of  the  list  item  and  the
<span id="line11387"></span>          remaining len___-w_ characters of the list item are  filled
<span id="line11388"></span>          with  blanks.   Note  that  the effect is as though the
<span id="line11389"></span>          constant were assigned to the list item in a  character
<span id="line11390"></span>          assignment statement (10.4).
<span id="line11391"></span>
<span id="line11392"></span>          A null value  is  specified  by  having  no  characters
<span id="line11393"></span>          between  successive  value  separators,  no  characters
<span id="line11394"></span>          preceding the first value separator in the first record
<span id="line11395"></span>          read   by  each  execution  of  a  list-directed  input
<span id="line11396"></span>          statement, or the r_* form.  A null value has no  effect
<span id="line11397"></span>          on  the  definition  status  of the corresponding input
<span id="line11398"></span>          list item.  If the  input  list  item  is  defined,  it
<span id="line11399"></span>          retains  its  previous  value;  if  it is undefined, it
<span id="line11400"></span>          remains undefined.  A null value may  not  be  used  as
<span id="line11401"></span>          either   the  real  or  imaginary  part  of  a  complex
<span id="line11402"></span>          constant, but a single  null  value  may  represent  an
<span id="line11403"></span>          entire complex constant.  Note that the end of a record
<span id="line11404"></span>          following  any  other  separator,   with   or   without
<span id="line11405"></span>          separating blanks, does not specify a null value.
<span id="line11406"></span>
<span id="line11407"></span>          A  slash  encountered  as  a  value  separator   during
<span id="line11408"></span>          execution  of  a  list-directed  input statement causes
<span id="line11409"></span>          termination of execution of that input statement  after
<span id="line11410"></span>          the  assignment  of  the  previous value.  If there are
<span id="line11411"></span>          additional items in the input list, the effect is as if
<span id="line11412"></span>          null values had been supplied for them.
<span id="line11413"></span>
<span id="line11414"></span>          Note that all blanks in a  list-directed  input  record
<span id="line11415"></span>          are  considered  to  be  part  of  some value separator
<span id="line11416"></span>          except for the following:
<span id="line11417"></span>
<span id="line11418"></span>             (1) Blanks embedded in a character constant
<span id="line11419"></span>
<span id="line11420"></span>             (2) Embedded  blanks   surrounding   the   real   or
<span id="line11421"></span>                 imaginary part of a complex constant
<span id="line11422"></span>
<span id="line11423"></span>
<span id="line11424"></span>
<span id="line11425"></span>
<span id="line11426"></span>          FORTRAN 77 Full Language                     Page 13-17
<span id="line11427"></span>
<span id="line11428"></span>
<span id="line11429"></span>
<span id="line11430"></span>
<span id="line11431"></span>
<span id="line11432"></span>
<span id="line11433"></span>
<span id="line11434"></span>          FORMAT SPECIFICATION                     ANSI X3J3/90.4
<span id="line11435"></span>
<span id="line11436"></span>
<span id="line11437"></span>
<span id="line11438"></span>             (3) Leading blanks in the first record read by  each
<span id="line11439"></span>                 execution  of  a  list-directed input statement,
<span id="line11440"></span>                 unless immediately followed by a slash or comma
<span id="line11441"></span>
<span id="line11442"></span>          13.6.2  List-Directed_Output.  The form of  the  values
<span id="line11443"></span>          produced is the same as that required for input, except
<span id="line11444"></span>          as noted otherwise.  With the  exception  of  character
<span id="line11445"></span>          constants,  the  values  are  separated  by  one of the
<span id="line11446"></span>          following:
<span id="line11447"></span>
<span id="line11448"></span>             (1) One or more blanks
<span id="line11449"></span>
<span id="line11450"></span>             (2) A comma  optionally  preceded  by  one  or  more
<span id="line11451"></span>                 blanks  and optionally followed by O</span><span>&lt;<span class="start-tag">one</span> <span class="attribute-name">more</span>="<a class="attribute-value"></a>" <span class="attribute-name">processor</span>="<a class="attribute-value"></a>" <span class="attribute-name">may</span>="<a class="attribute-value"></a>" <span class="attribute-name">begin</span>="<a class="attribute-value"></a>" <span class="attribute-name">new</span>="<a class="attribute-value"></a>" <span class="attribute-name">records</span>="<a class="attribute-value"></a>" <span class="attribute-name">as</span>="<a class="attribute-value"></a>" <span class="attribute-name">necessary,</span>="<a class="attribute-value"></a>" <span class="attribute-name">but,</span>="<a class="attribute-value"></a>" <span class="attribute-name">except</span>="<a class="attribute-value"></a>" <span class="attribute-name">complex</span>="<a class="attribute-value"></a>" <span class="attribute-name">character</span>="<a class="attribute-value"></a>" <span class="attribute-name">constants,</span>="<a class="attribute-value"></a>" <span class="attribute-name">end</span>="<a class="attribute-value"></a>" <span class="attribute-name">record</span>="<a class="attribute-value"></a>" <span class="attribute-name">occur</span>="<a class="attribute-value"></a>" <span class="attribute-name">constant</span>="<a class="attribute-value"></a>" <span class="attribute-name">blanks</span>="<a class="attribute-value"></a>" <span class="attribute-name">must</span>="<a class="attribute-value"></a>" <span class="attribute-name">not</span>="<a class="attribute-value"></a>" <span class="attribute-name">appear</span>="<a class="attribute-value"></a>" <span class="attribute-name">within</span>="<a class="attribute-value"></a>" <span class="attribute-name">constant.</span>="<a class="attribute-value"></a>" <span class="attribute-name">logical</span>="<a class="attribute-value"></a>" <span class="attribute-name">t</span>="<a class="attribute-value"></a>" <span class="attribute-name">true</span>="<a class="attribute-value"></a>" <span class="attribute-name">false.</span>="<a class="attribute-value"></a>" <span class="attribute-name">integer</span>="<a class="attribute-value"></a>" <span class="attribute-name">output</span>="<a class="attribute-value"></a>" <span class="attribute-name">iw_</span>="<a class="attribute-value"></a>" <span class="attribute-name">for</span>="<a class="attribute-value"></a>" <span class="attribute-name">some</span>="<a class="attribute-value"></a>" <span class="attribute-name">reasonable</span>="<a class="attribute-value"></a>" <span class="attribute-name">w</span>="<a class="attribute-value"></a>" <span class="attribute-name">_.</span>="<a class="attribute-value"></a>" <span class="attribute-name">real</span>="<a class="attribute-value"></a>" <span class="attribute-name">double</span>="<a class="attribute-value"></a>" <span class="attribute-name">precision</span>="<a class="attribute-value"></a>" <span class="attribute-name">constants</span>="<a class="attribute-value"></a>" <span class="attribute-name">are</span>="<a class="attribute-value"></a>" <span class="attribute-name">produced</span>="<a class="attribute-value"></a>" <span class="attribute-name">with</span>="<a class="attribute-value"></a>" <span class="attribute-name">effect</span>="<a class="attribute-value"></a>" <span class="attribute-name">either</span>="<a class="attribute-value"></a>" <span class="attribute-name">f</span>="<a class="attribute-value"></a>" <span class="attribute-name">descriptor</span>="<a class="attribute-value"></a>" <span class="attribute-name">or</span>="<a class="attribute-value"></a>" <span class="attribute-name">an</span>="<a class="attribute-value"></a>" <span class="attribute-name">e</span>="<a class="attribute-value"></a>" <span class="attribute-name">edit</span>="<a class="attribute-value"></a>" <span class="attribute-name">descriptor,</span>="<a class="attribute-value"></a>" <span class="attribute-name">depending</span>="<a class="attribute-value"></a>" <span class="attribute-name">on</span>="<a class="attribute-value"></a>" <span class="attribute-name">magnitude</span>="<a class="attribute-value"></a>" <span class="attribute-name">x_</span>="<a class="attribute-value"></a>" <span class="attribute-name">of</span>="<a class="attribute-value"></a>" <span class="attribute-name">the</span>="<a class="attribute-value"></a>" <span class="attribute-name">value</span>="<a class="attribute-value"></a>" <span class="attribute-name">and</span>="<a class="attribute-value"></a>" <span class="attribute-name">a</span>="<a class="attribute-value"></a>" <span class="attribute-name">range</span>="<a class="attribute-value"></a>" <span class="attribute-name">10**d_918</span>="<a class="attribute-value"></a>"&gt;</span><span><span class="entity"><span>&amp;</span>lt;</span> x_ <span class="entity"><span>&amp;</span>lt;</span> 10**d_928, where d_918 and d_928 are
<span id="line11452"></span>          processor-dependent integer values.  If the magnitude x_
<span id="line11453"></span>          is  within  this  range, the constant is produced using
<span id="line11454"></span>          OPFw_.d_; otherwise, 1PEw_ .d_ Ee_ is  used.   Reasonable
<span id="line11455"></span>          processor-dependent  values of w_, d_, and e_ are used for
<span id="line11456"></span>          each of the cases involved.
<span id="line11457"></span>
<span id="line11458"></span>          Complex constants are enclosed in parentheses,  with  a
<span id="line11459"></span>          comma separating the real and imaginary parts.  The end
<span id="line11460"></span>          of a  record  may  occur  between  the  comma  and  the
<span id="line11461"></span>          imaginary  part  only if the entire constant is as long
<span id="line11462"></span>          as,  or  longer  than,  an  entire  record.   The  only
<span id="line11463"></span>          embedded blanks permitted within a complex constant are
<span id="line11464"></span>          between the comma and the end of a record and one blank
<span id="line11465"></span>          at the beginning of the next record.
<span id="line11466"></span>
<span id="line11467"></span>          Character  constants  produced  are  not  delimited  by
<span id="line11468"></span>          apostrophes,  are  not  preceded or followed by a value
<span id="line11469"></span>          separator, have each  internal  apostrophe  represented
<span id="line11470"></span>          externally   by   one  apostrophe,  and  have  a  blank
<span id="line11471"></span>
<span id="line11472"></span>
<span id="line11473"></span>
<span id="line11474"></span>          FORTRAN 77 Full Language                     Page 13-18
<span id="line11475"></span>
<span id="line11476"></span>
<span id="line11477"></span>
<span id="line11478"></span>
<span id="line11479"></span>
<span id="line11480"></span>
<span id="line11481"></span>
<span id="line11482"></span>          FORMAT SPECIFICATION                     ANSI X3J3/90.4
<span id="line11483"></span>
<span id="line11484"></span>
<span id="line11485"></span>
<span id="line11486"></span>          character  inserted  by  the  processor  for   carriage
<span id="line11487"></span>          control at the beginning of any record that begins with
<span id="line11488"></span>          the continuation  of  a  character  constant  from  the
<span id="line11489"></span>          preceding record.
<span id="line11490"></span>
<span id="line11491"></span>          If two or more successive values in  an  output  record
<span id="line11492"></span>          produced  have  identical values, the processor has the
<span id="line11493"></span>          option of producing a repeated constant of the form r_*c_
<span id="line11494"></span>          instead of the sequence of identical values.
<span id="line11495"></span>
<span id="line11496"></span>          Slashes, as value separators, and null values  are  not
<span id="line11497"></span>          produced by list-directed formatting.
<span id="line11498"></span>
<span id="line11499"></span>          Each output record begins with  a  blank  character  to
<span id="line11500"></span>          provide carriage control when the record is printed.
<span id="line11501"></span>
<span id="line11502"></span>
<span id="line11503"></span>
<span id="line11504"></span>
<span id="line11505"></span>
<span id="line11506"></span>
<span id="line11507"></span>
<span id="line11508"></span>
<span id="line11509"></span>
<span id="line11510"></span>
<span id="line11511"></span>
<span id="line11512"></span>
<span id="line11513"></span>
<span id="line11514"></span>
<span id="line11515"></span>
<span id="line11516"></span>
<span id="line11517"></span>
<span id="line11518"></span>
<span id="line11519"></span>
<span id="line11520"></span>
<span id="line11521"></span>
<span id="line11522"></span>
<span id="line11523"></span>
<span id="line11524"></span>
<span id="line11525"></span>
<span id="line11526"></span>
<span id="line11527"></span>
<span id="line11528"></span>
<span id="line11529"></span>
<span id="line11530"></span>
<span id="line11531"></span>
<span id="line11532"></span>
<span id="line11533"></span>
<span id="line11534"></span>
<span id="line11535"></span>
<span id="line11536"></span>
<span id="line11537"></span>
<span id="line11538"></span>
<span id="line11539"></span>
<span id="line11540"></span>          FORTRAN 77 Full Language                     Page 13-19
<span id="line11541"></span>
<span id="line11542"></span>
<span id="line11543"></span>
<span id="line11544"></span>
<span id="line11545"></span>
<span id="line11546"></span>
<span id="line11547"></span>
<span id="line11548"></span>
<span id="line11549"></span>
<span id="line11550"></span>
<span id="line11551"></span>
<span id="line11552"></span>                                 CONTENTS
<span id="line11553"></span>
<span id="line11554"></span>
<span id="line11555"></span>          13.  FORMAT SPECIFICATION.......................   13-1
<span id="line11556"></span>               13.1  Format Specification Methods.........   13-1
<span id="line11557"></span>                     13.1.1   FORMAT Statement............   13-1
<span id="line11558"></span>                     13.1.2   Character Format
<span id="line11559"></span>                              Specification...............   13-1
<span id="line11560"></span>               13.2  Form of a Format
<span id="line11561"></span>                     Specification........................   13-2
<span id="line11562"></span>                     13.2.1   Edit Descriptors............   13-2
<span id="line11563"></span>               13.3  Interaction Between Input/Output
<span id="line11564"></span>                     List and Format......................   13-3
<span id="line11565"></span>               13.4  Positioning by Format Control........   13-5
<span id="line11566"></span>               13.5  Editing..............................   13-5
<span id="line11567"></span>                     13.5.1   Apostrophe Editing..........   13-6
<span id="line11568"></span>                     13.5.2   H Editing...................   13-6
<span id="line11569"></span>                     13.5.3   Positional Editing..........   13-6
<span id="line11570"></span>                     13.5.4   Slash Editing...............   13-7
<span id="line11571"></span>                     13.5.5   Colon Editing...............   13-8
<span id="line11572"></span>                     13.5.6   S, SP, and SS
<span id="line11573"></span>                              Editing.....................   13-8
<span id="line11574"></span>                     13.5.7   P Editing...................   13-8
<span id="line11575"></span>                     13.5.8   BN and BZ Editing...........   13-9
<span id="line11576"></span>                     13.5.9   Numeric Editing.............   13-9
<span id="line11577"></span>                     13.5.10  L Editing...................  13-14
<span id="line11578"></span>                     13.5.11  A Editing...................  13-15
<span id="line11579"></span>               13.6  List-Directed Formatting.............  13-15
<span id="line11580"></span>                     13.6.1   List-Directed Input.........  13-16
<span id="line11581"></span>                     13.6.2   List-Directed Output........  13-
<span id="line11582"></span>                              18
<span id="line11583"></span>
<span id="line11584"></span>
<span id="line11585"></span>
<span id="line11586"></span>
<span id="line11587"></span>
<span id="line11588"></span>
<span id="line11589"></span>
<span id="line11590"></span>
<span id="line11591"></span>
<span id="line11592"></span>
<span id="line11593"></span>
<span id="line11594"></span>
<span id="line11595"></span>
<span id="line11596"></span>
<span id="line11597"></span>
<span id="line11598"></span>
<span id="line11599"></span>
<span id="line11600"></span>
<span id="line11601"></span>
<span id="line11602"></span>
<span id="line11603"></span>
<span id="line11604"></span>
<span id="line11605"></span>
<span id="line11606"></span>                                   - i -
<span id="line11607"></span>
<span id="line11608"></span>
<span id="line11609"></span>
<span id="line11610"></span>
<span id="line11611"></span>
<span id="line11612"></span>
<span id="line11613"></span>
<span id="line11614"></span>                                                   ANSI X3J3/90.4
<span id="line11615"></span>
<span id="line11616"></span>
<span id="line11617"></span>
<span id="line11618"></span>                             14.  MAIN_PROGRAM
<span id="line11619"></span>
<span id="line11620"></span>          A main program is a program unit that does not  have  a
<span id="line11621"></span>          FUNCTION,  SUBROUTINE,  or  BLOCK DATA statement as its
<span id="line11622"></span>          first statement. It may have a PROGRAM statement as its
<span id="line11623"></span>          first statement.
<span id="line11624"></span>
<span id="line11625"></span>          There must be exactly one main program in an executable
<span id="line11626"></span>          program.   Execution  of  an  executable program begins
<span id="line11627"></span>          with the execution of the first executable statement of
<span id="line11628"></span>          the main program.
<span id="line11629"></span>
<span id="line11630"></span>          14.1  PROGRAM_Statement
<span id="line11631"></span>
<span id="line11632"></span>          The form of a PROGRAM statement is:
<span id="line11633"></span>
<span id="line11634"></span>                               PROGRAM pgm___
<span id="line11635"></span>
<span id="line11636"></span>          where pgm___ is the symbolic name of the main  program  in
<span id="line11637"></span>          which the PROGRAM statement appears.
<span id="line11638"></span>
<span id="line11639"></span>          A PROGRAM statement is not required  to  appear  in  an
<span id="line11640"></span>          executable  program.  If it does appear, it must be the
<span id="line11641"></span>          first statement of the main program.
<span id="line11642"></span>
<span id="line11643"></span>          The symbolic name pgm_ _ _  is  global  (18.1.1)  to  the
<span id="line11644"></span>          executable program and must not be the same as the name
<span id="line11645"></span>          of an external procedure,  block  data  subprogram,  or
<span id="line11646"></span>          common block in the same executable program.  The name pgm
<span id="line11647"></span>          ___ must not be the same as any local name in the  main
<span id="line11648"></span>          program.
<span id="line11649"></span>
<span id="line11650"></span>          14.2  Main_Program_Restrictions
<span id="line11651"></span>
<span id="line11652"></span>          The PROGRAM statement may  appear  only  as  the  first
<span id="line11653"></span>          statement  of  a  main  program.   A  main  program may
<span id="line11654"></span>          contain  any  other  statement  except  a  BLOCK  DATA,
<span id="line11655"></span>          FUNCTION, SUBROUTINE, ENTRY,  or RETURN statement.  The
<span id="line11656"></span>          appearance of a SAVE statement in a main program has no
<span id="line11657"></span>          effect.
<span id="line11658"></span>
<span id="line11659"></span>          A main program may not be referenced from a  subprogram
<span id="line11660"></span>          or from itself.
<span id="line11661"></span>
<span id="line11662"></span>
<span id="line11663"></span>
<span id="line11664"></span>
<span id="line11665"></span>
<span id="line11666"></span>
<span id="line11667"></span>
<span id="line11668"></span>
<span id="line11669"></span>
<span id="line11670"></span>
<span id="line11671"></span>
<span id="line11672"></span>          FORTRAN 77 Full Language                      Page 14-1
<span id="line11673"></span>
<span id="line11674"></span>
<span id="line11675"></span>
<span id="line11676"></span>
<span id="line11677"></span>
<span id="line11678"></span>
<span id="line11679"></span>
<span id="line11680"></span>
<span id="line11681"></span>
<span id="line11682"></span>
<span id="line11683"></span>
<span id="line11684"></span>                                 CONTENTS
<span id="line11685"></span>
<span id="line11686"></span>
<span id="line11687"></span>          14.  MAIN PROGRAM................................  14-1
<span id="line11688"></span>               14.1  PROGRAM Statement.....................  14-1
<span id="line11689"></span>               14.2  Main Program Restrictions.............  14-1
<span id="line11690"></span>
<span id="line11691"></span>
<span id="line11692"></span>
<span id="line11693"></span>
<span id="line11694"></span>
<span id="line11695"></span>
<span id="line11696"></span>
<span id="line11697"></span>
<span id="line11698"></span>
<span id="line11699"></span>
<span id="line11700"></span>
<span id="line11701"></span>
<span id="line11702"></span>
<span id="line11703"></span>
<span id="line11704"></span>
<span id="line11705"></span>
<span id="line11706"></span>
<span id="line11707"></span>
<span id="line11708"></span>
<span id="line11709"></span>
<span id="line11710"></span>
<span id="line11711"></span>
<span id="line11712"></span>
<span id="line11713"></span>
<span id="line11714"></span>
<span id="line11715"></span>
<span id="line11716"></span>
<span id="line11717"></span>
<span id="line11718"></span>
<span id="line11719"></span>
<span id="line11720"></span>
<span id="line11721"></span>
<span id="line11722"></span>
<span id="line11723"></span>
<span id="line11724"></span>
<span id="line11725"></span>
<span id="line11726"></span>
<span id="line11727"></span>
<span id="line11728"></span>
<span id="line11729"></span>
<span id="line11730"></span>
<span id="line11731"></span>
<span id="line11732"></span>
<span id="line11733"></span>
<span id="line11734"></span>
<span id="line11735"></span>
<span id="line11736"></span>
<span id="line11737"></span>
<span id="line11738"></span>                                   - i -
<span id="line11739"></span>
<span id="line11740"></span>
<span id="line11741"></span>
<span id="line11742"></span>
<span id="line11743"></span>
<span id="line11744"></span>
<span id="line11745"></span>
<span id="line11746"></span>                                                   ANSI X3J3/90.4
<span id="line11747"></span>
<span id="line11748"></span>
<span id="line11749"></span>
<span id="line11750"></span>                      15.  FUNCTIONS_AND_SUBROUTINES
<span id="line11751"></span>
<span id="line11752"></span>          15.1  Categories_of_Functions_and_Subroutines
<span id="line11753"></span>
<span id="line11754"></span>          15.1.1  Procedures.   Functions  and  subroutines   are
<span id="line11755"></span>          procedures.  There are four categories of procedures:
<span id="line11756"></span>
<span id="line11757"></span>             (1) Intrinsic functions
<span id="line11758"></span>
<span id="line11759"></span>             (2) Statement functions
<span id="line11760"></span>
<span id="line11761"></span>             (3) External functions
<span id="line11762"></span>
<span id="line11763"></span>             (4) Subroutines
<span id="line11764"></span>
<span id="line11765"></span>          Intrinsic functions, statement functions, and  external
<span id="line11766"></span>          functions are referred to collectively as functions.
<span id="line11767"></span>
<span id="line11768"></span>          External functions  and  subroutines  are  referred  to
<span id="line11769"></span>          collectively as external procedures.
<span id="line11770"></span>
<span id="line11771"></span>          15.1.2  External_Functions.  There are  two  categories
<span id="line11772"></span>          of external functions:
<span id="line11773"></span>
<span id="line11774"></span>             (1) External   functions   specified   in   function
<span id="line11775"></span>                 subprograms
<span id="line11776"></span>
<span id="line11777"></span>             (2) External functions specified by means other than
<span id="line11778"></span>                 FORTRAN subprograms
<span id="line11779"></span>
<span id="line11780"></span>          15.1.3  Subroutines.   There  are  two  categories   of
<span id="line11781"></span>          subroutines:
<span id="line11782"></span>
<span id="line11783"></span>             (1) Subroutines specified in subroutine subprograms
<span id="line11784"></span>
<span id="line11785"></span>             (2) Subroutines  specified  by  means   other   than
<span id="line11786"></span>                 FORTRAN subprograms
<span id="line11787"></span>
<span id="line11788"></span>          15.1.4  Dummy_Procedure.  A dummy procedure is a  dummy
<span id="line11789"></span>          argument that is identified as a procedure (18.2.11).
<span id="line11790"></span>
<span id="line11791"></span>          15.2  Referencing_a_Function
<span id="line11792"></span>
<span id="line11793"></span>          A function is referenced in an expression and  supplies
<span id="line11794"></span>          a  value  to the expression.  The value supplied is the
<span id="line11795"></span>          value of the function.
<span id="line11796"></span>
<span id="line11797"></span>          An intrinsic function may be  referenced  in  the  main
<span id="line11798"></span>          program or in any procedure subprogram of an executable
<span id="line11799"></span>          program.
<span id="line11800"></span>
<span id="line11801"></span>
<span id="line11802"></span>
<span id="line11803"></span>
<span id="line11804"></span>          FORTRAN 77 Full Language                      Page 15-1
<span id="line11805"></span>
<span id="line11806"></span>
<span id="line11807"></span>
<span id="line11808"></span>
<span id="line11809"></span>
<span id="line11810"></span>
<span id="line11811"></span>
<span id="line11812"></span>          FUNCTIONS AND SUBROUTINES                ANSI X3J3/90.4
<span id="line11813"></span>
<span id="line11814"></span>
<span id="line11815"></span>
<span id="line11816"></span>          A statement function may  be  referenced  only  in  the
<span id="line11817"></span>          program  unit in which the statement function statement
<span id="line11818"></span>          appears.
<span id="line11819"></span>
<span id="line11820"></span>          An external function specified by a function subprogram
<span id="line11821"></span>          may be referenced within any other procedure subprogram
<span id="line11822"></span>          or the main  program  of  the  executable  program.   A
<span id="line11823"></span>          subprogram  must  not reference itself, either directly
<span id="line11824"></span>          or indirectly.
<span id="line11825"></span>
<span id="line11826"></span>          An external function specified by means  other  than  a
<span id="line11827"></span>          subprogram  may  be  referenced  within  any  procedure
<span id="line11828"></span>          subprogram  or  the  main  program  of  the  executable
<span id="line11829"></span>          program.
<span id="line11830"></span>
<span id="line11831"></span>          If a character function  is  referenced  in  a  program
<span id="line11832"></span>          unit, the function length specified in the program unit
<span id="line11833"></span>          must be an integer constant expression.
<span id="line11834"></span>
<span id="line11835"></span>          15.2.1  Form_of_a_Function_Reference.     A    function
<span id="line11836"></span>          reference  is  used to reference an intrinsic function,
<span id="line11837"></span>          statement function, or external function.
<span id="line11838"></span>
<span id="line11839"></span>          The form of a function reference is:
<span id="line11840"></span>
<span id="line11841"></span>                               fun___ ( [a_ [,a_]...] )
<span id="line11842"></span>
<span id="line11843"></span>          where: fun___ is the symbolic name  of  a  function  or  a
<span id="line11844"></span>                     dummy procedure
<span id="line11845"></span>
<span id="line11846"></span>                 a_   is an actual argument
<span id="line11847"></span>
<span id="line11848"></span>          The type of the  result  of  a  statement  function  or
<span id="line11849"></span>          external  function reference is the same as the type of
<span id="line11850"></span>          the function name.  The type is specified in  the  same
<span id="line11851"></span>          manner  as  for variables and arrays (4.1.2).  The type
<span id="line11852"></span>          of the result of an intrinsic function is specified  in
<span id="line11853"></span>          Table 5 (15.10).
<span id="line11854"></span>
<span id="line11855"></span>          15.2.2  Execution_of_a_Function_Reference.  A  function
<span id="line11856"></span>          reference   may   appear   only  as  a  primary  in  an
<span id="line11857"></span>          arithmetic,   logical,   or    character    expression.
<span id="line11858"></span>          Execution  of  a  function  reference  in an expression
<span id="line11859"></span>          causes the evaluation of  the  function  identified  by
<span id="line11860"></span>          fun.
<span id="line11861"></span>
<span id="line11862"></span>          Return of control from a referenced function  completes
<span id="line11863"></span>          execution  of the function reference.  The value of the
<span id="line11864"></span>          function is available to the referencing expression.
<span id="line11865"></span>
<span id="line11866"></span>
<span id="line11867"></span>
<span id="line11868"></span>
<span id="line11869"></span>
<span id="line11870"></span>          FORTRAN 77 Full Language                      Page 15-2
<span id="line11871"></span>
<span id="line11872"></span>
<span id="line11873"></span>
<span id="line11874"></span>
<span id="line11875"></span>
<span id="line11876"></span>
<span id="line11877"></span>
<span id="line11878"></span>          FUNCTIONS AND SUBROUTINES                ANSI X3J3/90.4
<span id="line11879"></span>
<span id="line11880"></span>
<span id="line11881"></span>
<span id="line11882"></span>          15.3  Intrinsic_Functions
<span id="line11883"></span>
<span id="line11884"></span>          Intrinsic functions are supplied by the  processor  and
<span id="line11885"></span>          have  a  special  meaning.   The  specific  names  that
<span id="line11886"></span>          identify the intrinsic functions, their generic  names,
<span id="line11887"></span>          function  definitions,  type  of arguments, and type of
<span id="line11888"></span>          results appear in Table 5.
<span id="line11889"></span>
<span id="line11890"></span>          An IMPLICIT statement does not change the  type  of  an
<span id="line11891"></span>          intrinsic function.
<span id="line11892"></span>
<span id="line11893"></span>          15.3.1  Specific_Names_and_Generic_Names.       Generic
<span id="line11894"></span>          names  simplify the referencing of intrinsic functions,
<span id="line11895"></span>          because the same function name may be  used  with  more
<span id="line11896"></span>          than  one  type of argument.  Only a specific intrinsic
<span id="line11897"></span>          function name may be used as an  actual  argument  when
<span id="line11898"></span>          the argument is an intrinsic function.
<span id="line11899"></span>
<span id="line11900"></span>          If a generic name is used  to  reference  an  intrinsic
<span id="line11901"></span>          function,  the type of the result (except for intrinsic
<span id="line11902"></span>          functions performing type conversion, nearest  integer,
<span id="line11903"></span>          and absolute value with a complex argument) is the same
<span id="line11904"></span>          as the type of the argument.
<span id="line11905"></span>
<span id="line11906"></span>          For those intrinsic functions that have more  than  one
<span id="line11907"></span>          argument, all arguments must be of the same type.
<span id="line11908"></span>
<span id="line11909"></span>          If the specific name or generic name  of  an  intrinsic
<span id="line11910"></span>          function  appears  in  the  dummy  argument  list  of a
<span id="line11911"></span>          function or subroutine in a subprogram,  that  symbolic
<span id="line11912"></span>          name  does  not  identify  an intrinsic function in the
<span id="line11913"></span>          program  unit.   The  data  type  identified  with  the
<span id="line11914"></span>          symbolic  name  is  specified in the same manner as for
<span id="line11915"></span>          variables and arrays (4.1.2).
<span id="line11916"></span>
<span id="line11917"></span>          A name in an INTRINSIC statement must be  the  specific
<span id="line11918"></span>          name or generic name of an intrinsic function.
<span id="line11919"></span>
<span id="line11920"></span>          15.3.2  Referencing_an_Intrinsic_Function.           An
<span id="line11921"></span>          intrinsic function is referenced by using its reference
<span id="line11922"></span>          as a primary in  an  expression.   For  each  intrinsic
<span id="line11923"></span>          function   described   in  Table  5,  execution  of  an
<span id="line11924"></span>          intrinsic  function  reference   causes   the   actions
<span id="line11925"></span>          specified  in  Table  5,  and the result depends on the
<span id="line11926"></span>          values of the actual arguments.  The resulting value is
<span id="line11927"></span>          available  to the expression that contains the function
<span id="line11928"></span>          reference.
<span id="line11929"></span>
<span id="line11930"></span>          The actual arguments that constitute the argument  list
<span id="line11931"></span>          must   agree  in  order,  number,  and  type  with  the
<span id="line11932"></span>          specification in Table 5 and may be any  expression  of
<span id="line11933"></span>
<span id="line11934"></span>
<span id="line11935"></span>
<span id="line11936"></span>          FORTRAN 77 Full Language                      Page 15-3
<span id="line11937"></span>
<span id="line11938"></span>
<span id="line11939"></span>
<span id="line11940"></span>
<span id="line11941"></span>
<span id="line11942"></span>
<span id="line11943"></span>
<span id="line11944"></span>          FUNCTIONS AND SUBROUTINES                ANSI X3J3/90.4
<span id="line11945"></span>
<span id="line11946"></span>
<span id="line11947"></span>
<span id="line11948"></span>          the specified type.  An actual argument in an intrinsic
<span id="line11949"></span>          function reference  may  be  any  expression  except  a
<span id="line11950"></span>          character  expression  involving  concatenation  of  an
<span id="line11951"></span>          operand whose length specification is  an  asterisk  in
<span id="line11952"></span>          parentheses  unless the operand is the symbolic name of
<span id="line11953"></span>          a constant.
<span id="line11954"></span>
<span id="line11955"></span>          A specific name of an intrinsic function  that  appears
<span id="line11956"></span>          in  an  INTRINSIC  statement  may  be used as an actual
<span id="line11957"></span>          argument in an external procedure  reference;  however,
<span id="line11958"></span>          the  names  of intrinsic functions for type conversion,
<span id="line11959"></span>          lexical relationship, and for choosing the  largest  or
<span id="line11960"></span>          smallest  value  must  not be used as actual arguments.
<span id="line11961"></span>          Note  that  such  an  appearance  does  not  cause  the
<span id="line11962"></span>          intrinsic  function  to  be  classified  as an external
<span id="line11963"></span>          function (18.2.10).
<span id="line11964"></span>
<span id="line11965"></span>          15.3.3  Intrinsic_Function_Restrictions.  Arguments for
<span id="line11966"></span>          which  the  result  is  not  mathematically  defined or
<span id="line11967"></span>          exceeds the numeric range of the  processor  cause  the
<span id="line11968"></span>          result of the function to become undefined.
<span id="line11969"></span>
<span id="line11970"></span>          Restrictions on the range of arguments and results  for
<span id="line11971"></span>          intrinsic functions are described in 15.10.1.
<span id="line11972"></span>
<span id="line11973"></span>          15.4  Statement_Function
<span id="line11974"></span>
<span id="line11975"></span>          A statement function is  a  procedure  specified  by  a
<span id="line11976"></span>          single   statement  that  is  similar  in  form  to  an
<span id="line11977"></span>          arithmetic, logical, or character assignment statement.
<span id="line11978"></span>          A  statement  function statement must appear only after
<span id="line11979"></span>          the  specification  statements  and  before  the  first
<span id="line11980"></span>          executable statement of the program unit in which it is
<span id="line11981"></span>          referenced (3.5).
<span id="line11982"></span>
<span id="line11983"></span>          A statement  function  statement  is  classified  as  a
<span id="line11984"></span>          nonexecutable statement; it is not a part of the normal
<span id="line11985"></span>          execution sequence.
<span id="line11986"></span>
<span id="line11987"></span>          15.4.1  Form_of_a_Statement_Function_Statement.     The
<span id="line11988"></span>          form of a statement function statement is:
<span id="line11989"></span>
<span id="line11990"></span>                               fun___ ( [d_ [,d_]...] ) = e_
<span id="line11991"></span>
<span id="line11992"></span>          where: fun__ _ is  the  symbolic  name  of  the  statement
<span id="line11993"></span>                     function
<span id="line11994"></span>
<span id="line11995"></span>                 d_   is a statement function dummy argument
<span id="line11996"></span>
<span id="line11997"></span>                 e_   is an expression
<span id="line11998"></span>
<span id="line11999"></span>
<span id="line12000"></span>
<span id="line12001"></span>
<span id="line12002"></span>          FORTRAN 77 Full Language                      Page 15-4
<span id="line12003"></span>
<span id="line12004"></span>
<span id="line12005"></span>
<span id="line12006"></span>
<span id="line12007"></span>
<span id="line12008"></span>
<span id="line12009"></span>
<span id="line12010"></span>          FUNCTIONS AND SUBROUTINES                ANSI X3J3/90.4
<span id="line12011"></span>
<span id="line12012"></span>
<span id="line12013"></span>
<span id="line12014"></span>          The relationship between fun___ and e_ must conform to  the
<span id="line12015"></span>          assignment  rules  in  10.1, 10.2, and 10.4.  Note that
<span id="line12016"></span>          the type of the expression may be  different  from  the
<span id="line12017"></span>          type of the statement function name.
<span id="line12018"></span>
<span id="line12019"></span>          Each d_ is a variable name called a  statement  function
<span id="line12020"></span>          dummy  argument.  The statement function dummy argument
<span id="line12021"></span>          list serves only to indicate order, number, and type of
<span id="line12022"></span>          arguments  for  the  statement  function.  The variable
<span id="line12023"></span>          names that appear as dummy  arguments  of  a  statement
<span id="line12024"></span>          function  have  a  scope  of  that statement (18.1).  A
<span id="line12025"></span>          given  symbolic  name  may  appear  only  once  in  any
<span id="line12026"></span>          statement  function  dummy argument list.  The symbolic
<span id="line12027"></span>          name of a statement function dummy argument may be used
<span id="line12028"></span>          to  identify  other dummy arguments of the same type in
<span id="line12029"></span>          different statement function statements.  The name  may
<span id="line12030"></span>          also  be  used  to identify a variable of the same type
<span id="line12031"></span>          appearing elsewhere in the program unit, including  its
<span id="line12032"></span>          appearance   as   a   dummy  argument  in  a  FUNCTION,
<span id="line12033"></span>          SUBROUTINE, or ENTRY statement.  The name must  not  be
<span id="line12034"></span>          used  to  identify any other entity in the program unit
<span id="line12035"></span>          except a common block.
<span id="line12036"></span>
<span id="line12037"></span>          Each primary of the expression e_ must  be  one  of  the
<span id="line12038"></span>          following:
<span id="line12039"></span>
<span id="line12040"></span>             (1) A constant
<span id="line12041"></span>
<span id="line12042"></span>             (2) The symbolic name of a constant
<span id="line12043"></span>
<span id="line12044"></span>             (3) A variable reference
<span id="line12045"></span>
<span id="line12046"></span>             (4) An array element reference
<span id="line12047"></span>
<span id="line12048"></span>             (5) An intrinsic function reference
<span id="line12049"></span>
<span id="line12050"></span>             (6) A reference to a statement  function  for  which
<span id="line12051"></span>                 the  statement  function  statement  appears  in
<span id="line12052"></span>                 preceding lines of the program unit
<span id="line12053"></span>
<span id="line12054"></span>             (7) An external function reference
<span id="line12055"></span>
<span id="line12056"></span>             (8) A dummy procedure reference
<span id="line12057"></span>
<span id="line12058"></span>             (9) An expression enclosed in parentheses that meets
<span id="line12059"></span>                 all   of  the  requirements  specified  for  the
<span id="line12060"></span>                 expression e_
<span id="line12061"></span>
<span id="line12062"></span>          Each variable reference may be either a reference to  a
<span id="line12063"></span>          dummy argument of the statement function or a reference
<span id="line12064"></span>          to a variable that appears within the same program unit
<span id="line12065"></span>
<span id="line12066"></span>
<span id="line12067"></span>
<span id="line12068"></span>          FORTRAN 77 Full Language                      Page 15-5
<span id="line12069"></span>
<span id="line12070"></span>
<span id="line12071"></span>
<span id="line12072"></span>
<span id="line12073"></span>
<span id="line12074"></span>
<span id="line12075"></span>
<span id="line12076"></span>          FUNCTIONS AND SUBROUTINES                ANSI X3J3/90.4
<span id="line12077"></span>
<span id="line12078"></span>
<span id="line12079"></span>
<span id="line12080"></span>          as the statement function statement.
<span id="line12081"></span>
<span id="line12082"></span>          If a statement function dummy argument name is the same
<span id="line12083"></span>          as  the  name of another entity, the appearance of that
<span id="line12084"></span>          name  in  the  expression  of  a   statement   function
<span id="line12085"></span>          statement  is  a  reference  to  the statement function
<span id="line12086"></span>          dummy argument.  A dummy argument  that  appears  in  a
<span id="line12087"></span>          FUNCTION  or  SUBROUTINE statement may be referenced in
<span id="line12088"></span>          the expression of a statement function statement within
<span id="line12089"></span>          the  subprogram.   A  dummy argument that appears in an
<span id="line12090"></span>          ENTRY statement  that  precedes  a  statement  function
<span id="line12091"></span>          statement  may  be  referenced in the expression of the
<span id="line12092"></span>          statement function statement within the subprogram.
<span id="line12093"></span>
<span id="line12094"></span>          15.4.2  Referencing_a_Statement_Function.  A  statement
<span id="line12095"></span>          function  is referenced by using its function reference
<span id="line12096"></span>          as a primary in an expression.
<span id="line12097"></span>
<span id="line12098"></span>          Execution of a statement function reference results in:
<span id="line12099"></span>
<span id="line12100"></span>             (1) evaluation  of   actual   arguments   that   are
<span id="line12101"></span>                 expressions,
<span id="line12102"></span>
<span id="line12103"></span>             (2) association  of  actual   arguments   with   the
<span id="line12104"></span>                 corresponding dummy arguments,
<span id="line12105"></span>
<span id="line12106"></span>             (3) evaluation of the expression e_, and
<span id="line12107"></span>
<span id="line12108"></span>             (4) conversion,  if  necessary,  of  an   arithmetic
<span id="line12109"></span>                 expression  value  to  the type of the statement
<span id="line12110"></span>                 function according to the  assignment  rules  in
<span id="line12111"></span>                 10.1 or a change, if necessary, in the length of
<span id="line12112"></span>                 a character expression value  according  to  the
<span id="line12113"></span>                 rules in 10.4.
<span id="line12114"></span>
<span id="line12115"></span>          The resulting value is available to the expression that
<span id="line12116"></span>          contains the function reference.
<span id="line12117"></span>
<span id="line12118"></span>          The actual arguments,  which  constitute  the  argument
<span id="line12119"></span>          list,  must  agree  in order, number, and type with the
<span id="line12120"></span>          corresponding dummy arguments.  An actual argument in a
<span id="line12121"></span>          statement  function  reference  may  be  any expression
<span id="line12122"></span>          except a character expression  involving  concatenation
<span id="line12123"></span>          of an operand whose length specification is an asterisk
<span id="line12124"></span>          in parentheses unless the operand is the symbolic  name
<span id="line12125"></span>          of a constant.
<span id="line12126"></span>
<span id="line12127"></span>          When a statement function reference  is  executed,  its
<span id="line12128"></span>          actual arguments must be defined.
<span id="line12129"></span>
<span id="line12130"></span>
<span id="line12131"></span>
<span id="line12132"></span>
<span id="line12133"></span>
<span id="line12134"></span>          FORTRAN 77 Full Language                      Page 15-6
<span id="line12135"></span>
<span id="line12136"></span>
<span id="line12137"></span>
<span id="line12138"></span>
<span id="line12139"></span>
<span id="line12140"></span>
<span id="line12141"></span>
<span id="line12142"></span>          FUNCTIONS AND SUBROUTINES                ANSI X3J3/90.4
<span id="line12143"></span>
<span id="line12144"></span>
<span id="line12145"></span>
<span id="line12146"></span>          15.4.3  Statement_Function_Restrictions.   A  statement
<span id="line12147"></span>          function  may  be  referenced  only in the program unit
<span id="line12148"></span>          that contains the statement function statement.
<span id="line12149"></span>
<span id="line12150"></span>          A statement  function  statement  must  not  contain  a
<span id="line12151"></span>          reference  to  another  statement function that appears
<span id="line12152"></span>          following the reference in the sequence of lines in the
<span id="line12153"></span>          program  unit.   The  symbolic  name used to identify a
<span id="line12154"></span>          statement function must not appear as a  symbolic  name
<span id="line12155"></span>          in  any  specification  statement  except  in  a  type-
<span id="line12156"></span>          statement (to specify the type of the function)  or  as
<span id="line12157"></span>          the name of a common block in the same program unit.
<span id="line12158"></span>
<span id="line12159"></span>          An external function reference in the expression  of  a
<span id="line12160"></span>          statement  function  statement  must  not cause a dummy
<span id="line12161"></span>          argument of the statement function to become  undefined
<span id="line12162"></span>          or redefined.
<span id="line12163"></span>
<span id="line12164"></span>          The symbolic name of a statement function  is  a  local
<span id="line12165"></span>          name  (18.1.2)  and must not be the same as the name of
<span id="line12166"></span>          any other entity in the program unit except the name of
<span id="line12167"></span>          a common block.
<span id="line12168"></span>
<span id="line12169"></span>          The symbolic name of a statement function may not be an
<span id="line12170"></span>          actual  argument.   It  must  not appear in an EXTERNAL
<span id="line12171"></span>          statement.
<span id="line12172"></span>
<span id="line12173"></span>          A statement function statement in a function subprogram
<span id="line12174"></span>          must  not  contain  a function reference to the name of
<span id="line12175"></span>          the  function  subprogram  or  an  entry  name  in  the
<span id="line12176"></span>          function subprogram.
<span id="line12177"></span>
<span id="line12178"></span>          The  length  specification  of  a  character  statement
<span id="line12179"></span>          function  or  statement function dummy argument of type
<span id="line12180"></span>          character must be an integer constant expression.
<span id="line12181"></span>
<span id="line12182"></span>          15.5  External_Functions
<span id="line12183"></span>
<span id="line12184"></span>          An external function is  specified  externally  to  the
<span id="line12185"></span>          program  unit that references it.  An external function
<span id="line12186"></span>          is a procedure and  may  be  specified  in  a  function
<span id="line12187"></span>          subprogram or by some other means.
<span id="line12188"></span>
<span id="line12189"></span>          15.5.1  Function_Subprogram_and_FUNCTION_Statement.   A
<span id="line12190"></span>          function  subprogram  specifies  one  or  more external
<span id="line12191"></span>          functions (15.7).  A function subprogram is  a  program
<span id="line12192"></span>          unit  that  has  a  FUNCTION  statement  as  its  first
<span id="line12193"></span>          statement.  The form of a  function  subprogram  is  as
<span id="line12194"></span>          described in 2.4 and 3.5, except as noted in 15.5.3 and
<span id="line12195"></span>          15.7.4.
<span id="line12196"></span>
<span id="line12197"></span>
<span id="line12198"></span>
<span id="line12199"></span>
<span id="line12200"></span>          FORTRAN 77 Full Language                      Page 15-7
<span id="line12201"></span>
<span id="line12202"></span>
<span id="line12203"></span>
<span id="line12204"></span>
<span id="line12205"></span>
<span id="line12206"></span>
<span id="line12207"></span>
<span id="line12208"></span>          FUNCTIONS AND SUBROUTINES                ANSI X3J3/90.4
<span id="line12209"></span>
<span id="line12210"></span>
<span id="line12211"></span>
<span id="line12212"></span>          The form of a FUNCTION statement is:
<span id="line12213"></span>
<span id="line12214"></span>                               [typ___] FUNCTION fun___ ( [d_ [,d_]...] )
<span id="line12215"></span>
<span id="line12216"></span>          where: typ___ is one of INTEGER, REAL,  DOUBLE  PRECISION,
<span id="line12217"></span>                     COMPLEX, LOGICAL, or CHARACTER [*len___] where len
<span id="line12218"></span>                     ___  is  the  length  specification  of  the
<span id="line12219"></span>                     result  of  the character function.  len___ may
<span id="line12220"></span>                     have any of the forms allowed in a CHARACTER
<span id="line12221"></span>                     statement  (8.4.2)  except  that  an integer
<span id="line12222"></span>                     constant expression  must  not  include  the
<span id="line12223"></span>                     symbolic name of a constant.  If a length is
<span id="line12224"></span>                     not  specified  in  a   CHARACTER   FUNCTION
<span id="line12225"></span>                     statement,  the  character  function  has  a
<span id="line12226"></span>                     length of one.
<span id="line12227"></span>
<span id="line12228"></span>                 fun_ _ _ is  the  symbolic  name  of  the  function
<span id="line12229"></span>                     subprogram  in  which the FUNCTION statement
<span id="line12230"></span>                     appears.  fun___ is an external function name.
<span id="line12231"></span>
<span id="line12232"></span>                 d_   is a variable name,  array  name,  or  dummy
<span id="line12233"></span>                     procedure name.  d_ is a dummy argument.
<span id="line12234"></span>
<span id="line12235"></span>          The symbolic  name  of  a  function  subprogram  or  an
<span id="line12236"></span>          associated entry name of the same type must appear as a
<span id="line12237"></span>          variable name in the function subprogram.  During every
<span id="line12238"></span>          execution  of the external function, this variable must
<span id="line12239"></span>          become defined and, once defined, may be referenced  or
<span id="line12240"></span>          become  redefined.   The  value of this variable when a
<span id="line12241"></span>          RETURN or END statement is executed in  the  subprogram
<span id="line12242"></span>          is  the  value  of the function.  If this variable is a
<span id="line12243"></span>          character variable with a length specification that  is
<span id="line12244"></span>          an  asterisk  in  parentheses, it must not appear as an
<span id="line12245"></span>          operand  for  concatenation  except  in   a   character
<span id="line12246"></span>          assignment statement (10.4).
<span id="line12247"></span>
<span id="line12248"></span>          An external  function  in  a  function  subprogram  may
<span id="line12249"></span>          define  one  or  more  of its dummy arguments to return
<span id="line12250"></span>          values in addition to the value of the function.
<span id="line12251"></span>
<span id="line12252"></span>          15.5.2  Referencing_an_External_Function.  An  external
<span id="line12253"></span>          function  is  referenced  by  using  its reference as a
<span id="line12254"></span>          primary in an expression.
<span id="line12255"></span>
<span id="line12256"></span>          15.5.2.1  Execution_of_an_External_Function_Reference.
<span id="line12257"></span>          Execution of an external function reference results in:
<span id="line12258"></span>
<span id="line12259"></span>             (1) evaluation  of   actual   arguments   that   are
<span id="line12260"></span>                 expressions,
<span id="line12261"></span>
<span id="line12262"></span>
<span id="line12263"></span>
<span id="line12264"></span>
<span id="line12265"></span>
<span id="line12266"></span>          FORTRAN 77 Full Language                      Page 15-8
<span id="line12267"></span>
<span id="line12268"></span>
<span id="line12269"></span>
<span id="line12270"></span>
<span id="line12271"></span>
<span id="line12272"></span>
<span id="line12273"></span>
<span id="line12274"></span>          FUNCTIONS AND SUBROUTINES                ANSI X3J3/90.4
<span id="line12275"></span>
<span id="line12276"></span>
<span id="line12277"></span>
<span id="line12278"></span>             (2) association  of  actual   arguments   with   the
<span id="line12279"></span>                 corresponding dummy arguments, and
<span id="line12280"></span>
<span id="line12281"></span>             (3) the  actions   specified   by   the   referenced
<span id="line12282"></span>                 function.
<span id="line12283"></span>
<span id="line12284"></span>          The type of the function name in the function reference
<span id="line12285"></span>          must  be  the  same as the type of the function name in
<span id="line12286"></span>          the referenced function.  The length of  the  character
<span id="line12287"></span>          function  in a character function reference must be the
<span id="line12288"></span>          same as the length of the  character  function  in  the
<span id="line12289"></span>          referenced function.
<span id="line12290"></span>
<span id="line12291"></span>          When an external function reference  is  executed,  the
<span id="line12292"></span>          function  must  be one of the external functions in the
<span id="line12293"></span>          executable program.
<span id="line12294"></span>
<span id="line12295"></span>          15.5.2.2  Actual_Arguments_for_an_External_Function.
<span id="line12296"></span>          The  actual arguments in an external function reference
<span id="line12297"></span>          must  agree  in  order,  number,  and  type  with   the
<span id="line12298"></span>          corresponding   dummy   arguments   in  the  referenced
<span id="line12299"></span>          function.  The use of a subroutine name  as  an  actual
<span id="line12300"></span>          argument   is   an  exception  to  the  rule  requiring
<span id="line12301"></span>          agreement of type because subroutine names do not  have
<span id="line12302"></span>          a type.
<span id="line12303"></span>
<span id="line12304"></span>          An actual argument in Tan external  function  reference
<span id="line12305"></span>          must be one of the following:
<span id="line12306"></span>
<span id="line12307"></span>             (1) An  expression  except  a  character  expression
<span id="line12308"></span>                 involving  concatenation  of  an  operand  whose
<span id="line12309"></span>                 length   specification   is   an   asterisk   in
<span id="line12310"></span>                 parentheses  unless  the operand is the symbolic
<span id="line12311"></span>                 name of a constant
<span id="line12312"></span>
<span id="line12313"></span>             (2) An array name
<span id="line12314"></span>
<span id="line12315"></span>             (3) An intrinsic function name
<span id="line12316"></span>
<span id="line12317"></span>             (4) An external procedure name
<span id="line12318"></span>
<span id="line12319"></span>             (5) A dummy procedure name
<span id="line12320"></span>
<span id="line12321"></span>          Note that an actual argument in  a  function  reference
<span id="line12322"></span>          may  be  a  dummy  argument  that  appears  in  a dummy
<span id="line12323"></span>          argument list  within  the  subprogram  containing  the
<span id="line12324"></span>          reference.
<span id="line12325"></span>
<span id="line12326"></span>          15.5.3  Function_Subprogram_Restrictions.   A  FUNCTION
<span id="line12327"></span>          statement  must appear only as the first statement of a
<span id="line12328"></span>          function subprogram.  A function subprogram may contain
<span id="line12329"></span>
<span id="line12330"></span>
<span id="line12331"></span>
<span id="line12332"></span>          FORTRAN 77 Full Language                      Page 15-9
<span id="line12333"></span>
<span id="line12334"></span>
<span id="line12335"></span>
<span id="line12336"></span>
<span id="line12337"></span>
<span id="line12338"></span>
<span id="line12339"></span>
<span id="line12340"></span>          FUNCTIONS AND SUBROUTINES                ANSI X3J3/90.4
<span id="line12341"></span>
<span id="line12342"></span>
<span id="line12343"></span>
<span id="line12344"></span>          any other statement except a BLOCK DATA, SUBROUTINE, or
<span id="line12345"></span>          PROGRAM statement.
<span id="line12346"></span>
<span id="line12347"></span>          The symbolic name of an external function is  a  global
<span id="line12348"></span>          name  (18.1.1)  and  must  not be the same as any other
<span id="line12349"></span>          global name or any local name, except a variable  name,
<span id="line12350"></span>          in the function subprogram.
<span id="line12351"></span>
<span id="line12352"></span>          Within a function subprogram, the symbolic  name  of  a
<span id="line12353"></span>          function  specified  by  a  FUNCTION or ENTRY statement
<span id="line12354"></span>          must not appear in any other  nonexecutable  statement,
<span id="line12355"></span>          except  a  type-statement.  In an executable statement,
<span id="line12356"></span>          such a name may appear only as a variable.
<span id="line12357"></span>
<span id="line12358"></span>          If the type of a function is specified  in  a  FUNCTION
<span id="line12359"></span>          statement,  the  function  name  must  not  appear in a
<span id="line12360"></span>          type-statement.  Note that a name  must  not  have  its
<span id="line12361"></span>          type  explicitly  specified more than once in a program
<span id="line12362"></span>          unit.
<span id="line12363"></span>
<span id="line12364"></span>          If the  name  of  a  function  subprogram  is  of  type
<span id="line12365"></span>          character,  each  entry name in the function subprogram
<span id="line12366"></span>          must be of type character.  If the name of the function
<span id="line12367"></span>          subprogram  or any entry in the subprogram has a length
<span id="line12368"></span>          of (*) declared, all such entities must have  a  length
<span id="line12369"></span>          of (*) declared; otherwise, all such entities must have
<span id="line12370"></span>          a length specification of the same integer value.
<span id="line12371"></span>
<span id="line12372"></span>          In a function subprogram, the symbolic name of a  dummy
<span id="line12373"></span>          argument  is  local  to  the  program unit and must not
<span id="line12374"></span>          appear in an EQUIVALENCE, PARAMETER,  SAVE,  INTRINSIC,
<span id="line12375"></span>          DATA,  or  COMMON  statement,  except as a common block
<span id="line12376"></span>          name.
<span id="line12377"></span>
<span id="line12378"></span>          A character dummy argument whose  length  specification
<span id="line12379"></span>          is  an  asterisk  in  parentheses must not appear as an
<span id="line12380"></span>          operand  for  concatenation,  except  in  a   character
<span id="line12381"></span>          assignment statement (10.4).
<span id="line12382"></span>
<span id="line12383"></span>          A function specified in a subprogram may be  referenced
<span id="line12384"></span>          within  any  other  procedure  subprogram  or  the main
<span id="line12385"></span>          program  of  the  executable   program.    A   function
<span id="line12386"></span>          subprogram  must  not reference itself, either directly
<span id="line12387"></span>          or indirectly.
<span id="line12388"></span>
<span id="line12389"></span>          15.6  Subroutines
<span id="line12390"></span>
<span id="line12391"></span>          A subroutine is specified  externally  to  the  program
<span id="line12392"></span>          unit  that  references it.  A subroutine is a procedure
<span id="line12393"></span>          and may be specified in a subroutine subprogram  or  by
<span id="line12394"></span>          some other means.
<span id="line12395"></span>
<span id="line12396"></span>
<span id="line12397"></span>
<span id="line12398"></span>          FORTRAN 77 Full Language                     Page 15-10
<span id="line12399"></span>
<span id="line12400"></span>
<span id="line12401"></span>
<span id="line12402"></span>
<span id="line12403"></span>
<span id="line12404"></span>
<span id="line12405"></span>
<span id="line12406"></span>          FUNCTIONS AND SUBROUTINES                ANSI X3J3/90.4
<span id="line12407"></span>
<span id="line12408"></span>
<span id="line12409"></span>
<span id="line12410"></span>          15.6.1  Subroutine_Subprogram_and_SUBROUTINE_Statement.
<span id="line12411"></span>          A   subroutine   subprogram   specifies   one  or  more
<span id="line12412"></span>          subroutines  (15.7).   A  subroutine  subprogram  is  a
<span id="line12413"></span>          program  unit  that  has  a SUBROUTINE statement as its
<span id="line12414"></span>          first statement.  The form of a  subroutine  subprogram
<span id="line12415"></span>          is  as  described  in  2.4  and 3.5, except as noted in
<span id="line12416"></span>          15.6.3 and 15.7.4.
<span id="line12417"></span>
<span id="line12418"></span>          The form of a SUBROUTINE statement is:
<span id="line12419"></span>
<span id="line12420"></span>                               SUBROUTINE sub___ [( [d_ [,d_]...] )]
<span id="line12421"></span>
<span id="line12422"></span>          where: sub___ is  the  symbolic  name  of  the  subroutine
<span id="line12423"></span>                     subprogram in which the SUBROUTINE statement
<span id="line12424"></span>                     appears.  sub___ is a subroutine name.
<span id="line12425"></span>
<span id="line12426"></span>                 d_   is a variable name,  array  name,  or  dummy
<span id="line12427"></span>                     procedure    name,   or   is   an   asterisk
<span id="line12428"></span>                     (15.9.3.5).  d_ is a dummy argument.
<span id="line12429"></span>
<span id="line12430"></span>          Note that if there are no dummy  arguments,  either  of
<span id="line12431"></span>          the  forms  sub___ or sub___() may be used in the SUBROUTINE
<span id="line12432"></span>          statement.  A subroutine that is  specified  by  either
<span id="line12433"></span>          form  may be referenced by a CALL statement of the form
<span id="line12434"></span>          CALL sub___ or CALL sub___().
<span id="line12435"></span>
<span id="line12436"></span>          One or more  dummy  arguments  of  a  subroutine  in  a
<span id="line12437"></span>          subprogram  may  become  defined or redefined to return
<span id="line12438"></span>          results.
<span id="line12439"></span>
<span id="line12440"></span>          15.6.2  Subroutine_Reference.     A    subroutine    is
<span id="line12441"></span>          referenced by a CALL statement.
<span id="line12442"></span>
<span id="line12443"></span>          15.6.2.1  Form_of_a_CALL_Statement.  The form of a CALL
<span id="line12444"></span>          statement is:
<span id="line12445"></span>
<span id="line12446"></span>                               CALL sub___ [( [a_ [,a_]...] )]
<span id="line12447"></span>
<span id="line12448"></span>          where: sub___ is the symbolic  name  of  a  subroutine  or
<span id="line12449"></span>                     dummy procedure
<span id="line12450"></span>
<span id="line12451"></span>                 a_   is an actual argument
<span id="line12452"></span>
<span id="line12453"></span>          15.6.2.2  Execution_of_a_CALL_Statement.  Execution  of
<span id="line12454"></span>          a CALL statement results in
<span id="line12455"></span>
<span id="line12456"></span>             (1) evaluation  of   actual   arguments   that   are
<span id="line12457"></span>                 expressions,
<span id="line12458"></span>
<span id="line12459"></span>             (2) association  of  actual   arguments   with   the
<span id="line12460"></span>                 corresponding dummy arguments, and
<span id="line12461"></span>
<span id="line12462"></span>
<span id="line12463"></span>
<span id="line12464"></span>          FORTRAN 77 Full Language                     Page 15-11
<span id="line12465"></span>
<span id="line12466"></span>
<span id="line12467"></span>
<span id="line12468"></span>
<span id="line12469"></span>
<span id="line12470"></span>
<span id="line12471"></span>
<span id="line12472"></span>          FUNCTIONS AND SUBROUTINES                ANSI X3J3/90.4
<span id="line12473"></span>
<span id="line12474"></span>
<span id="line12475"></span>
<span id="line12476"></span>             (3) the  actions   specified   by   the   referenced
<span id="line12477"></span>                 subroutine.
<span id="line12478"></span>
<span id="line12479"></span>          Return  of  control  from  the  referenced   subroutine
<span id="line12480"></span>          completes execution of the CALL statement.
<span id="line12481"></span>
<span id="line12482"></span>          A  subroutine  specified  in  a   subprogram   may   be
<span id="line12483"></span>          referenced within any other procedure subprogram or the
<span id="line12484"></span>          main program of the executable program.   A  subprogram
<span id="line12485"></span>          must   not   reference   itself,   either  directly  or
<span id="line12486"></span>          indirectly.
<span id="line12487"></span>
<span id="line12488"></span>          When a  CALL  statement  is  executed,  the  referenced
<span id="line12489"></span>          subroutine  must be one of the subroutines specified in
<span id="line12490"></span>          subroutine  subprograms  or  by  other  means  in   the
<span id="line12491"></span>          executable program.
<span id="line12492"></span>
<span id="line12493"></span>          15.6.2.3  Actual_Arguments_for_a_Subroutine.        The
<span id="line12494"></span>          actual  arguments  in a subroutine reference must agree
<span id="line12495"></span>          in order, number, and type with the corresponding dummy
<span id="line12496"></span>          arguments  in the dummy argument list of the referenced
<span id="line12497"></span>          subroutine.   The  use  of  a  subroutine  name  or  an
<span id="line12498"></span>          alternate  return specifier as an actual argument is an
<span id="line12499"></span>          exception to the rule requiring agreement of type.
<span id="line12500"></span>
<span id="line12501"></span>          An actual argument in a subroutine  reference  must  be
<span id="line12502"></span>          one of the following:
<span id="line12503"></span>
<span id="line12504"></span>             (1) An  expression  except  a  character  expression
<span id="line12505"></span>                 involving  concatenation  of  an  operand  whose
<span id="line12506"></span>                 length   specification   is   an   asterisk   in
<span id="line12507"></span>                 parentheses  unless  the operand is the symbolic
<span id="line12508"></span>                 name of a constant
<span id="line12509"></span>
<span id="line12510"></span>             (2) An array name
<span id="line12511"></span>
<span id="line12512"></span>             (3) An intrinsic function name
<span id="line12513"></span>
<span id="line12514"></span>             (4) An external procedure name
<span id="line12515"></span>
<span id="line12516"></span>             (5) A dummy procedure name
<span id="line12517"></span>
<span id="line12518"></span>             (6) An alternate return specifier, of the form *s_ ,
<span id="line12519"></span>                 where  s_ is the statement label of an executable
<span id="line12520"></span>                 statement that appears in the same program  unit
<span id="line12521"></span>                 as the CALL statement (15.8.3)
<span id="line12522"></span>
<span id="line12523"></span>          Note that an actual argument in a subroutine  reference
<span id="line12524"></span>          may  be  a  dummy argument name that appears in a dummy
<span id="line12525"></span>          argument list  within  the  subprogram  containing  the
<span id="line12526"></span>          reference.  An asterisk dummy argument must not be used
<span id="line12527"></span>
<span id="line12528"></span>
<span id="line12529"></span>
<span id="line12530"></span>          FORTRAN 77 Full Language                     Page 15-12
<span id="line12531"></span>
<span id="line12532"></span>
<span id="line12533"></span>
<span id="line12534"></span>
<span id="line12535"></span>
<span id="line12536"></span>
<span id="line12537"></span>
<span id="line12538"></span>          FUNCTIONS AND SUBROUTINES                ANSI X3J3/90.4
<span id="line12539"></span>
<span id="line12540"></span>
<span id="line12541"></span>
<span id="line12542"></span>          as an actual argument in a subprogram reference.
<span id="line12543"></span>
<span id="line12544"></span>          15.6.3  Subroutine_Subprogram_Restrictions.           A
<span id="line12545"></span>          SUBROUTINE  statement  must  appear  only  as the first
<span id="line12546"></span>          statement of a  subroutine  subprogram.   A  subroutine
<span id="line12547"></span>          subprogram  may  contain  any  other statement except a
<span id="line12548"></span>          BLOCK DATA, FUNCTION, or PROGRAM statement.
<span id="line12549"></span>
<span id="line12550"></span>          The symbolic name of a  subroutine  is  a  global  name
<span id="line12551"></span>          (18.1.1)  and  must not be the same as any other global
<span id="line12552"></span>          name or any local name in the program unit.
<span id="line12553"></span>
<span id="line12554"></span>          In a subroutine subprogram,  the  symbolic  name  of  a
<span id="line12555"></span>          dummy  argument  is  local to the program unit and must
<span id="line12556"></span>          not  appear  in  an   EQUIVALENCE,   PARAMETER,   SAVE,
<span id="line12557"></span>          INTRINSIC,  DATA,  or  COMMON  statement,  except  as a
<span id="line12558"></span>          common block name.
<span id="line12559"></span>
<span id="line12560"></span>          A character dummy argument whose  length  specification
<span id="line12561"></span>          is  an  asterisk  in  parentheses must not appear as an
<span id="line12562"></span>          operand  for  concatenation,  except  in  a   character
<span id="line12563"></span>          assignment statement (10.4).
<span id="line12564"></span>
<span id="line12565"></span>          15.7  ENTRY_Statement
<span id="line12566"></span>
<span id="line12567"></span>          An ENTRY statement permits  a  procedure  reference  to
<span id="line12568"></span>          begin with a particular executable statement within the
<span id="line12569"></span>          function or subroutine subprogram in  which  the  ENTRY
<span id="line12570"></span>          statement  appears.   It  may  appear anywhere within a
<span id="line12571"></span>          function subprogram after  the  FUNCTION  statement  or
<span id="line12572"></span>          within  a  subroutine  subprogram  after the SUBROUTINE
<span id="line12573"></span>          statement, except that  an  ENTRY  statement  must  not
<span id="line12574"></span>          appear   between   a   block   IF   statement  and  its
<span id="line12575"></span>          corresponding  END  IF  statement,  or  between  a   DO
<span id="line12576"></span>          statement and the terminal statement of its DO-loop.
<span id="line12577"></span>
<span id="line12578"></span>          Optionally, a subprogram may have  one  or  more  ENTRY
<span id="line12579"></span>          statements.
<span id="line12580"></span>
<span id="line12581"></span>          An ENTRY statement is  classified  as  a  nonexecutable
<span id="line12582"></span>          statement.
<span id="line12583"></span>
<span id="line12584"></span>          15.7.1  Form_of_an_ENTRY_Statement.   The  form  of  an
<span id="line12585"></span>          ENTRY statement is:
<span id="line12586"></span>
<span id="line12587"></span>                               ENTRY en__ [( [d_ [,d_]...] )]
<span id="line12588"></span>
<span id="line12589"></span>          where: en__  is the  symbolic  name  of  an  entry  in  a
<span id="line12590"></span>                     function  or  subroutine  subprogram  and is
<span id="line12591"></span>                     called  an  entry  name.    If   the   ENTRY
<span id="line12592"></span>                     statement    appears    in    a   subroutine
<span id="line12593"></span>
<span id="line12594"></span>
<span id="line12595"></span>
<span id="line12596"></span>          FORTRAN 77 Full Language                     Page 15-13
<span id="line12597"></span>
<span id="line12598"></span>
<span id="line12599"></span>
<span id="line12600"></span>
<span id="line12601"></span>
<span id="line12602"></span>
<span id="line12603"></span>
<span id="line12604"></span>          FUNCTIONS AND SUBROUTINES                ANSI X3J3/90.4
<span id="line12605"></span>
<span id="line12606"></span>
<span id="line12607"></span>
<span id="line12608"></span>                     subprogram, en__ is a subroutine name.  If the
<span id="line12609"></span>                     ENTRY   statement   appears  in  a  function
<span id="line12610"></span>                     subprogram, en__ is an external function name.
<span id="line12611"></span>
<span id="line12612"></span>                 d_   is  a  variable  name,   array   name,   or
<span id="line12613"></span>                     dummy           procedure  name,  or  is  an
<span id="line12614"></span>                     asterisk.  d_   is  a  dummy  argument.   An
<span id="line12615"></span>                     asterisk  is permitted in an ENTRY statement
<span id="line12616"></span>                     only in a subroutine subprogram.
<span id="line12617"></span>
<span id="line12618"></span>          Note that if there are no dummy  arguments,  either  of
<span id="line12619"></span>          the  forms  en_ _  or  en_ _ ()  may be used in the ENTRY
<span id="line12620"></span>          statement.  A function that is specified by either form
<span id="line12621"></span>          must  be  referenced  by  the  form  en__() (15.2.1).  A
<span id="line12622"></span>          subroutine that is specified  by  either  form  may  be
<span id="line12623"></span>          referenced  by  a CALL statement of the form CALL en__ or
<span id="line12624"></span>          CALL en__().
<span id="line12625"></span>
<span id="line12626"></span>          The entry name en__ in a function subprogram  may  appear
<span id="line12627"></span>          in a type-statement.
<span id="line12628"></span>
<span id="line12629"></span>          15.7.2  Referencing_External_Procedure_by_Entry_Name.
<span id="line12630"></span>          An  entry  name  in  an  ENTRY  statement in a function
<span id="line12631"></span>          subprogram identifies an external function  within  the
<span id="line12632"></span>          executable program and may be referenced as an external
<span id="line12633"></span>          function (15.5.2).  An entry name in an ENTRY statement
<span id="line12634"></span>          in  a  subroutine  subprogram  identifies  a subroutine
<span id="line12635"></span>          within the executable program and may be referenced  as
<span id="line12636"></span>          a subroutine (15.6.2).
<span id="line12637"></span>
<span id="line12638"></span>          When an entry name en__ is used to reference a procedure,
<span id="line12639"></span>          execution  of  the  procedure  begins  with  the  first
<span id="line12640"></span>          executable statement that follows the  ENTRY  statement
<span id="line12641"></span>          whose entry name is en__.
<span id="line12642"></span>
<span id="line12643"></span>          An entry name is available for reference in any program
<span id="line12644"></span>          unit  of  an  executable program, except in the program
<span id="line12645"></span>          unit  that  contains  the  entry  name  in   an   ENTRY
<span id="line12646"></span>          statement.
<span id="line12647"></span>
<span id="line12648"></span>          The  order,  number,  type,  and  names  of  the  dummy
<span id="line12649"></span>          arguments  in  an ENTRY statement may be different from
<span id="line12650"></span>          the  order,  number,  type,  and  names  of  the  dummy
<span id="line12651"></span>          arguments  in  the  FUNCTION  statement  or  SUBROUTINE
<span id="line12652"></span>          statement  and  other  ENTRY  statements  in  the  same
<span id="line12653"></span>          subprogram.   However,  each reference to a function or
<span id="line12654"></span>          subroutine must use an actual argument list that agrees
<span id="line12655"></span>          in order, number, and type with the dummy argument list
<span id="line12656"></span>          in the corresponding  FUNCTION,  SUBROUTINE,  or  ENTRY
<span id="line12657"></span>          statement.    The  use  of  a  subroutine  name  or  an
<span id="line12658"></span>          alternate return specifier as an actual argument is  an
<span id="line12659"></span>
<span id="line12660"></span>
<span id="line12661"></span>
<span id="line12662"></span>          FORTRAN 77 Full Language                     Page 15-14
<span id="line12663"></span>
<span id="line12664"></span>
<span id="line12665"></span>
<span id="line12666"></span>
<span id="line12667"></span>
<span id="line12668"></span>
<span id="line12669"></span>
<span id="line12670"></span>          FUNCTIONS AND SUBROUTINES                ANSI X3J3/90.4
<span id="line12671"></span>
<span id="line12672"></span>
<span id="line12673"></span>
<span id="line12674"></span>          exception to the rule requiring agreement of type.
<span id="line12675"></span>
<span id="line12676"></span>          15.7.3  Entry_Association.     Within    a     function
<span id="line12677"></span>          subprogram,  all  variables  whose  names  are also the
<span id="line12678"></span>          names of entries are associated  with  each  other  and
<span id="line12679"></span>          with  the variable, if any, whose name is also the name
<span id="line12680"></span>          of the function subprogram  (17.1.3).   Therefore,  any
<span id="line12681"></span>          such   variable   that   becomes   defined  causes  all
<span id="line12682"></span>          associated variables of the same type to become defined
<span id="line12683"></span>          and  all  associated  variables  of  different  type to
<span id="line12684"></span>          become undefined.  Such variables are not  required  to
<span id="line12685"></span>          be  of  the same type unless the type is character, but
<span id="line12686"></span>          the variable  whose  name  is  used  to  reference  the
<span id="line12687"></span>          function  must  be  in a defined state when a RETURN or
<span id="line12688"></span>          END  statement  is  executed  in  the  subprogram.   An
<span id="line12689"></span>          associated variable of a different type must not become
<span id="line12690"></span>          defined during the execution of the function reference.
<span id="line12691"></span>
<span id="line12692"></span>          15.7.4  ENTRY_Statement_Restrictions.      Within     a
<span id="line12693"></span>          subprogram,  an  entry  name must not appear both as an
<span id="line12694"></span>          entry name  in  an  ENTRY  statement  and  as  a  dummy
<span id="line12695"></span>          argument  in a FUNCTION, SUBROUTINE, or ENTRY statement
<span id="line12696"></span>          and must not appear in an EXTERNAL statement.
<span id="line12697"></span>
<span id="line12698"></span>          In a function subprogram, a variable name that  is  the
<span id="line12699"></span>          same  as an entry name must not appear in any statement
<span id="line12700"></span>          that precedes the appearance of the entry  name  in  an
<span id="line12701"></span>          ENTRY statement, except in a type-statement.
<span id="line12702"></span>
<span id="line12703"></span>          If an entry name in a function subprogram  is  of  type
<span id="line12704"></span>          character, each entry name and the name of the function
<span id="line12705"></span>          subprogram must be of type character.  If the  name  of
<span id="line12706"></span>          the  function subprogram or any entry in the subprogram
<span id="line12707"></span>          has a length of (*) declared, all  such  entities  must
<span id="line12708"></span>          have  a  length  of  (*)  declared; otherwise, all such
<span id="line12709"></span>          entities must have a length specification of  the  same
<span id="line12710"></span>          integer value.
<span id="line12711"></span>
<span id="line12712"></span>          In a  subprogram,  a  name  that  appears  as  a  dummy
<span id="line12713"></span>          argument  in  an  ENTRY statement must not appear in an
<span id="line12714"></span>          executable statement  preceding  that  ENTRY  statement
<span id="line12715"></span>          unless  it  also  appears in a FUNCTION, SUBROUTINE, or
<span id="line12716"></span>          ENTRY statement that precedes the executable statement.
<span id="line12717"></span>
<span id="line12718"></span>          In a  subprogram,  a  name  that  appears  as  a  dummy
<span id="line12719"></span>          argument  in  an ENTRY statement must not appear in the
<span id="line12720"></span>          expression of a statement function statement unless the
<span id="line12721"></span>          name   is  also  a  dummy  argument  of  the  statement
<span id="line12722"></span>          function,  appears  in   a   FUNCTION   or   SUBROUTINE
<span id="line12723"></span>          statement,  or  appears  in  an  ENTRY  statement  that
<span id="line12724"></span>          precedes the statement function statement.
<span id="line12725"></span>
<span id="line12726"></span>
<span id="line12727"></span>
<span id="line12728"></span>          FORTRAN 77 Full Language                     Page 15-15
<span id="line12729"></span>
<span id="line12730"></span>
<span id="line12731"></span>
<span id="line12732"></span>
<span id="line12733"></span>
<span id="line12734"></span>
<span id="line12735"></span>
<span id="line12736"></span>          FUNCTIONS AND SUBROUTINES                ANSI X3J3/90.4
<span id="line12737"></span>
<span id="line12738"></span>
<span id="line12739"></span>
<span id="line12740"></span>          If a dummy argument appears in an executable statement,
<span id="line12741"></span>          the  execution of the executable statement is permitted
<span id="line12742"></span>          during the execution of a reference to the function  or
<span id="line12743"></span>          subroutine  only  if  the dummy argument appears in the
<span id="line12744"></span>          dummy argument list of the procedure  name  referenced.
<span id="line12745"></span>          Note  that  the  association  of  dummy  arguments with
<span id="line12746"></span>          actual arguments is not retained between references  to
<span id="line12747"></span>          a function or subroutine.
<span id="line12748"></span>
<span id="line12749"></span>          15.8  RETURN_Statement
<span id="line12750"></span>
<span id="line12751"></span>          A RETURN statement causes  return  of  control  to  the
<span id="line12752"></span>          referencing  program  unit  and  may  appear  only in a
<span id="line12753"></span>          function subprogram or subroutine subprogram.
<span id="line12754"></span>
<span id="line12755"></span>          15.8.1  Form_of_a_RETURN_Statement.   The  form  of   a
<span id="line12756"></span>          RETURN statement in a function subprogram is:
<span id="line12757"></span>
<span id="line12758"></span>                               RETURN
<span id="line12759"></span>
<span id="line12760"></span>          The  form  of  a  RETURN  statement  in  a   subroutine
<span id="line12761"></span>          subprogram is:
<span id="line12762"></span>
<span id="line12763"></span>                               RETURN [e_]
<span id="line12764"></span>
<span id="line12765"></span>          where e_ is an integer expression.
<span id="line12766"></span>
<span id="line12767"></span>          15.8.2  Execution_of_a_RETURN_Statement.  Execution  of
<span id="line12768"></span>          a  RETURN  statement  terminates  the  reference  of  a
<span id="line12769"></span>          function or subroutine  subprogram.   Such  subprograms
<span id="line12770"></span>          may  contain more than one RETURN statement; however, a
<span id="line12771"></span>          subprogram  need  not  contain  a   RETURN   statement.
<span id="line12772"></span>          Execution   of  an  END  statement  in  a  function  or
<span id="line12773"></span>          subroutine subprogram has the same effect as  executing
<span id="line12774"></span>          a RETURN statement in the subprogram.
<span id="line12775"></span>
<span id="line12776"></span>          In the execution of an executable program,  a  function
<span id="line12777"></span>          or  subroutine  subprogram  must  not  be  referenced a
<span id="line12778"></span>          second time without the prior execution of a RETURN  or
<span id="line12779"></span>          END statement in that procedure.
<span id="line12780"></span>
<span id="line12781"></span>          Execution  of  a  RETURN  statement   in   a   function
<span id="line12782"></span>          subprogram  causes  return  of control to the currently
<span id="line12783"></span>          referencing program unit.  The value  of  the  function
<span id="line12784"></span>          (15.5)   must  be  defined  and  is  available  to  the
<span id="line12785"></span>          referencing program unit.
<span id="line12786"></span>
<span id="line12787"></span>          Execution  of  a  RETURN  statement  in  a   subroutine
<span id="line12788"></span>          subprogram  causes  return  of control to the currently
<span id="line12789"></span>          referencing program unit.  Return  of  control  to  the
<span id="line12790"></span>          referencing  program  unit  completes  execution of the
<span id="line12791"></span>
<span id="line12792"></span>
<span id="line12793"></span>
<span id="line12794"></span>          FORTRAN 77 Full Language                     Page 15-16
<span id="line12795"></span>
<span id="line12796"></span>
<span id="line12797"></span>
<span id="line12798"></span>
<span id="line12799"></span>
<span id="line12800"></span>
<span id="line12801"></span>
<span id="line12802"></span>          FUNCTIONS AND SUBROUTINES                ANSI X3J3/90.4
<span id="line12803"></span>
<span id="line12804"></span>
<span id="line12805"></span>
<span id="line12806"></span>          CALL statement.
<span id="line12807"></span>
<span id="line12808"></span>          Execution  of  a  RETURN   statement   terminates   the
<span id="line12809"></span>          association between the dummy arguments of the external
<span id="line12810"></span>          procedure in the  subprogram  and  the  current  actual
<span id="line12811"></span>          arguments.
<span id="line12812"></span>
<span id="line12813"></span>          15.8.3  Alternate_Return.  If e_ is not specified  in  a
<span id="line12814"></span>          RETURN statement, or if the value of e_ is less than one
<span id="line12815"></span>          or  greater  than  the  number  of  asterisks  in   the
<span id="line12816"></span>          SUBROUTINE or subroutine ENTRY statement that specifies
<span id="line12817"></span>          the currently referenced name, control returns  to  the
<span id="line12818"></span>          CALL  statement that initiated the subprogram reference
<span id="line12819"></span>          and this completes the execution of the CALL statement.
<span id="line12820"></span>
<span id="line12821"></span>          If 1 <span class="entity"><span>&amp;</span>lt;</span> e_ <span class="entity"><span>&amp;</span>lt;</span> n_, where n_ is the number of asterisks in the
<span id="line12822"></span>          SUBROUTINE or subroutine ENTRY statement that specifies
<span id="line12823"></span>          the  currently  referenced  name,  the  value  of   e _
<span id="line12824"></span>          identifies the e_th asterisk in the dummy argument list.
<span id="line12825"></span>          Control is returned to the statement identified by  the
<span id="line12826"></span>          alternate  return  specifier in the CALL statement that
<span id="line12827"></span>          is associated with the  e_ th  asterisk  in  the  dummy
<span id="line12828"></span>          argument  list  of the currently referenced name.  This
<span id="line12829"></span>          completes the execution of the CALL statement.
<span id="line12830"></span>
<span id="line12831"></span>          15.8.4  Definition_Status.   Execution  of   a   RETURN
<span id="line12832"></span>          statement (or END statement) within a subprogram causes
<span id="line12833"></span>          all entities within the subprogram to become undefined,
<span id="line12834"></span>          except for the following:
<span id="line12835"></span>
<span id="line12836"></span>             (1) Entities specified by SAVE statements
<span id="line12837"></span>
<span id="line12838"></span>             (2) Entities in blank common
<span id="line12839"></span>
<span id="line12840"></span>             (3) Initially defined  entities  that  have  neither
<span id="line12841"></span>                 been redefined or become undefined
<span id="line12842"></span>
<span id="line12843"></span>             (4) Entities in a named common block that appears in
<span id="line12844"></span>                 the subprogram and appears in at least one other
<span id="line12845"></span>                 program  unit  that   is   referencing,   either
<span id="line12846"></span>                 directly or indirectly, the subprogram
<span id="line12847"></span>
<span id="line12848"></span>          Note that if a named common block appears in  the  main
<span id="line12849"></span>          program,  the entities in the named common block do not
<span id="line12850"></span>          become  undefined  at  the  execution  of  any   RETURN
<span id="line12851"></span>          statement in the executable program.
<span id="line12852"></span>
<span id="line12853"></span>
<span id="line12854"></span>
<span id="line12855"></span>
<span id="line12856"></span>
<span id="line12857"></span>
<span id="line12858"></span>
<span id="line12859"></span>
<span id="line12860"></span>          FORTRAN 77 Full Language                     Page 15-17
<span id="line12861"></span>
<span id="line12862"></span>
<span id="line12863"></span>
<span id="line12864"></span>
<span id="line12865"></span>
<span id="line12866"></span>
<span id="line12867"></span>
<span id="line12868"></span>          FUNCTIONS AND SUBROUTINES                ANSI X3J3/90.4
<span id="line12869"></span>
<span id="line12870"></span>
<span id="line12871"></span>
<span id="line12872"></span>          15.9  Arguments_and_Common_Blocks
<span id="line12873"></span>
<span id="line12874"></span>          Arguments  and   common   blocks   provide   means   of
<span id="line12875"></span>          communication  between the referencing program unit and
<span id="line12876"></span>          the referenced procedure.
<span id="line12877"></span>
<span id="line12878"></span>          Data may be communicated to  a  statement  function  or
<span id="line12879"></span>          intrinsic  function  by  an argument list.  Data may be
<span id="line12880"></span>          communicated to and from an external  procedure  by  an
<span id="line12881"></span>          argument list or common blocks.  Procedure names may be
<span id="line12882"></span>          communicated  to  an  external  procedure  only  by  an
<span id="line12883"></span>          argument list.
<span id="line12884"></span>
<span id="line12885"></span>          A dummy argument appears in  the  argument  list  of  a
<span id="line12886"></span>          procedure.   An actual argument appears in the argument
<span id="line12887"></span>          list of a procedure reference.
<span id="line12888"></span>
<span id="line12889"></span>          The number of actual arguments must be the same as  the
<span id="line12890"></span>          number of dummy arguments in the  procedure referenced.
<span id="line12891"></span>
<span id="line12892"></span>          15.9.1  Dummy_Arguments.  Statement functions, function
<span id="line12893"></span>          subprograms,   and  subroutine  subprograms  use  dummy
<span id="line12894"></span>          arguments to indicate the types of actual arguments and
<span id="line12895"></span>          whether  each  argument  is  a  single  value, array of
<span id="line12896"></span>          values, procedure, or statement  label.   Note  that  a
<span id="line12897"></span>          statement   function  dummy  argument  may  be  only  a
<span id="line12898"></span>          variable.
<span id="line12899"></span>
<span id="line12900"></span>          Each dummy argument is classified as a variable, array,
<span id="line12901"></span>          dummy  procedure, or asterisk. Dummy argument names may
<span id="line12902"></span>          appear wherever  an  actual  name  of  the  same  class
<span id="line12903"></span>          (Section 18) and type may appear, except where they are
<span id="line12904"></span>          explicitly prohibited.
<span id="line12905"></span>
<span id="line12906"></span>          Dummy argument names of  type  integer  may  appear  in
<span id="line12907"></span>          adjustable   dimensions   in  dummy  array  declarators
<span id="line12908"></span>          (5.5.1).  Dummy  argument  names  must  not  appear  in
<span id="line12909"></span>          EQUIVALENCE,   DATA,  PARAMETER,  SAVE,  INTRINSIC,  or
<span id="line12910"></span>          COMMON statements, except as  common  block  names.   A
<span id="line12911"></span>          dummy  argument  name  must  not  be  the  same  as the
<span id="line12912"></span>          procedure name appearing  in  a  FUNCTION,  SUBROUTINE,
<span id="line12913"></span>          ENTRY,  or  statement  function  statement  in the same
<span id="line12914"></span>          program unit.
<span id="line12915"></span>
<span id="line12916"></span>          15.9.2  Actual_Arguments.  Actual arguments specify the
<span id="line12917"></span>          entities  that  are  to  be  associated  with the dummy
<span id="line12918"></span>          arguments for a particular reference of a subroutine or
<span id="line12919"></span>          function.  An actual argument must not be the name of a
<span id="line12920"></span>          statement function in the program unit  containing  the
<span id="line12921"></span>          reference.  Actual arguments may be constants, symbolic
<span id="line12922"></span>          names of constants,  function  references,  expressions
<span id="line12923"></span>
<span id="line12924"></span>
<span id="line12925"></span>
<span id="line12926"></span>          FORTRAN 77 Full Language                     Page 15-18
<span id="line12927"></span>
<span id="line12928"></span>
<span id="line12929"></span>
<span id="line12930"></span>
<span id="line12931"></span>
<span id="line12932"></span>
<span id="line12933"></span>
<span id="line12934"></span>          FUNCTIONS AND SUBROUTINES                ANSI X3J3/90.4
<span id="line12935"></span>
<span id="line12936"></span>
<span id="line12937"></span>
<span id="line12938"></span>          involving   operators,   and  expressions  enclosed  in
<span id="line12939"></span>          parentheses  if  and  only  if  the  associated   dummy
<span id="line12940"></span>          argument  is  a  variable  that  is  not defined during
<span id="line12941"></span>          execution of the referenced external procedure.
<span id="line12942"></span>
<span id="line12943"></span>          The type of each actual argument must  agree  with  the
<span id="line12944"></span>          type  of its associated dummy argument, except when the
<span id="line12945"></span>          actual argument is a subroutine name (15.9.3.4)  or  an
<span id="line12946"></span>          alternate return specifier (15.6.2.3).
<span id="line12947"></span>
<span id="line12948"></span>          15.9.3  Association_of_Dummy_and_Actual_Arguments.   At
<span id="line12949"></span>          the execution of a function or subroutine reference, an
<span id="line12950"></span>          association is established  between  the  corresponding
<span id="line12951"></span>          dummy  and  actual arguments.  The first dummy argument
<span id="line12952"></span>          becomes associated with the first actual argument,  the
<span id="line12953"></span>          second  dummy  argument  becomes  associated  with  the
<span id="line12954"></span>          second actual argument, etc.
<span id="line12955"></span>
<span id="line12956"></span>          All  appearances  within  a  function   or   subroutine
<span id="line12957"></span>          subprogram  of  a  dummy argument whose name appears in
<span id="line12958"></span>          the  dummy  argument  list  of   the   procedure   name
<span id="line12959"></span>          referenced  become  associated with the actual argument
<span id="line12960"></span>          when a reference  to  the  function  or  subroutine  is
<span id="line12961"></span>          executed.
<span id="line12962"></span>
<span id="line12963"></span>          A valid association occurs only  if  the  type  of  the
<span id="line12964"></span>          actual  argument  is  the  same  as  the  type  of  the
<span id="line12965"></span>          corresponding dummy argument.  A subroutine name has no
<span id="line12966"></span>          type  and  must  be  associated  with a dummy procedure
<span id="line12967"></span>          name.  An alternate return specifier has  no  type  and
<span id="line12968"></span>          must be associated with an asterisk.
<span id="line12969"></span>
<span id="line12970"></span>          If an actual argument is an expression, it is evaluated
<span id="line12971"></span>          just before the association of arguments takes place.
<span id="line12972"></span>
<span id="line12973"></span>          If an actual argument is an  array  element  name,  its
<span id="line12974"></span>          subscript  is  evaluated just before the association of
<span id="line12975"></span>          arguments takes place.  Note that the  subscript  value
<span id="line12976"></span>          remains   constant  as  long  as  that  association  of
<span id="line12977"></span>          arguments persists,  even  if  the  subscript  contains
<span id="line12978"></span>          variables that are redefined during the association.
<span id="line12979"></span>
<span id="line12980"></span>          If an actual argument is a  character  substring  name,
<span id="line12981"></span>          its substring expressions are evaluated just before the
<span id="line12982"></span>          association of arguments takes place.   Note  that  the
<span id="line12983"></span>          value  of  each  of  the  substring expressions remains
<span id="line12984"></span>          constant as  long  as  that  association  of  arguments
<span id="line12985"></span>          persists,  even  if  the  substring expression contains
<span id="line12986"></span>          variables that are redefined during the association.
<span id="line12987"></span>
<span id="line12988"></span>
<span id="line12989"></span>
<span id="line12990"></span>
<span id="line12991"></span>
<span id="line12992"></span>          FORTRAN 77 Full Language                     Page 15-19
<span id="line12993"></span>
<span id="line12994"></span>
<span id="line12995"></span>
<span id="line12996"></span>
<span id="line12997"></span>
<span id="line12998"></span>
<span id="line12999"></span>
<span id="line13000"></span>          FUNCTIONS AND SUBROUTINES                ANSI X3J3/90.4
<span id="line13001"></span>
<span id="line13002"></span>
<span id="line13003"></span>
<span id="line13004"></span>          If an actual argument is an  external  procedure  name,
<span id="line13005"></span>          the procedure must be available at the time a reference
<span id="line13006"></span>          to it is executed.
<span id="line13007"></span>
<span id="line13008"></span>          If an actual argument becomes associated with  a  dummy
<span id="line13009"></span>          argument   that  appears  in  an  adjustable  dimension
<span id="line13010"></span>          (5.5.1), the actual argument must be  defined  with  an
<span id="line13011"></span>          integer value at the time the procedure is referenced.
<span id="line13012"></span>
<span id="line13013"></span>          A dummy argument is undefined if it  is  not  currently
<span id="line13014"></span>          associated  with  an  actual  argument.   An adjustable
<span id="line13015"></span>          array is undefined if the dummy argument array  is  not
<span id="line13016"></span>          currently  associated  with an actual argument array or
<span id="line13017"></span>          if any  variable  appearing  in  the  adjustable  array
<span id="line13018"></span>          declarator  is  not currently associated with an actual
<span id="line13019"></span>          argument and is not in a common block.
<span id="line13020"></span>
<span id="line13021"></span>          Argument association may be carried through  more  than
<span id="line13022"></span>          one  level of procedure reference.  A valid association
<span id="line13023"></span>          exists at the last level only if  a  valid  association
<span id="line13024"></span>          exists    at   all   intermediate   levels.    Argument
<span id="line13025"></span>          association within a program  unit  terminates  at  the
<span id="line13026"></span>          execution  of  a RETURN or END statement in the program
<span id="line13027"></span>          unit.  Note that there  is  no  retention  of  argument
<span id="line13028"></span>          association  between  one reference of a subprogram and
<span id="line13029"></span>          the next reference of the subprogram.
<span id="line13030"></span>
<span id="line13031"></span>          15.9.3.1  Length  of   Character   Dummy   and   Actual
<span id="line13032"></span>          Arguments.   If  a dummy argument is of type character,
<span id="line13033"></span>          the  associated  actual  argument  must  be   of   type
<span id="line13034"></span>          character  and the length of the dummy argument must be
<span id="line13035"></span>          less  than  or  equal  to  the  length  of  the  actual
<span id="line13036"></span>          argument.   If  the  length  len___ of a dummy argument of
<span id="line13037"></span>          type character is less than the length of an associated
<span id="line13038"></span>          actual  argument,  the  leftmost  len___ characters of the
<span id="line13039"></span>          actual argument are associated with the dummy argument.
<span id="line13040"></span>
<span id="line13041"></span>          If a dummy argument of type character is an array name,
<span id="line13042"></span>          the  restriction  on length is for the entire array and
<span id="line13043"></span>          not for each array element.  The  length  of  an  array
<span id="line13044"></span>          element  in  the  dummy argument array may be different
<span id="line13045"></span>          from the length of an array element  in  an  associated
<span id="line13046"></span>          actual  argument array, array element, or array element
<span id="line13047"></span>          substring, but the dummy argument array must not extend
<span id="line13048"></span>          beyond the end of the associated actual argument array.
<span id="line13049"></span>
<span id="line13050"></span>          If an actual argument is  a  character  substring,  the
<span id="line13051"></span>          length  of  the  actual  argument  is the length of the
<span id="line13052"></span>          substring.  If an actual argument is the  concatenation
<span id="line13053"></span>          of  two  or more operands, its length is the sum of the
<span id="line13054"></span>          lengths of the operands.
<span id="line13055"></span>
<span id="line13056"></span>
<span id="line13057"></span>
<span id="line13058"></span>          FORTRAN 77 Full Language                     Page 15-20
<span id="line13059"></span>
<span id="line13060"></span>
<span id="line13061"></span>
<span id="line13062"></span>
<span id="line13063"></span>
<span id="line13064"></span>
<span id="line13065"></span>
<span id="line13066"></span>          FUNCTIONS AND SUBROUTINES                ANSI X3J3/90.4
<span id="line13067"></span>
<span id="line13068"></span>
<span id="line13069"></span>
<span id="line13070"></span>          15.9.3.2  Variables_as_Dummy_Arguments.     A     dummy
<span id="line13071"></span>          argument  that  is a variable may be associated with an
<span id="line13072"></span>          actual argument that  is  a  variable,  array  element,
<span id="line13073"></span>          substring, or expression.
<span id="line13074"></span>
<span id="line13075"></span>          If the  actual  argument  is  a  variable  name,  array
<span id="line13076"></span>          element  name,  or substring name, the associated dummy
<span id="line13077"></span>          argument  may  be  defined  or  redefined  within   the
<span id="line13078"></span>          subprogram.   If  the  actual argument is a constant, a
<span id="line13079"></span>          symbolic name of a constant, a function  reference,  an
<span id="line13080"></span>          expression   involving   operators,  or  an  expression
<span id="line13081"></span>          enclosed in parentheses, the associated dummy  argument
<span id="line13082"></span>          must not be redefined within the subprogram.
<span id="line13083"></span>
<span id="line13084"></span>          15.9.3.3  Arrays_as_Dummy_Arguments.  Within a  program
<span id="line13085"></span>          unit,  the array declarator given for an array provides
<span id="line13086"></span>          all array declarator information needed for  the  array
<span id="line13087"></span>          in  an  execution  of the program unit.  The number and
<span id="line13088"></span>          size  of  dimensions  in  an  actual   argument   array
<span id="line13089"></span>          declarator may be different from the number and size of
<span id="line13090"></span>          the dimensions in an associated  dummy  argument  array
<span id="line13091"></span>          declarator.
<span id="line13092"></span>
<span id="line13093"></span>          A dummy argument that is an  array  may  be  associated
<span id="line13094"></span>          with  an  actual  argument  that  is  an  array,  array
<span id="line13095"></span>          element, or array element substring.
<span id="line13096"></span>
<span id="line13097"></span>          If the actual argument is a  noncharacter  array  name,
<span id="line13098"></span>          the  size  of  the dummy argument array must not exceed
<span id="line13099"></span>          the size of the actual argument array, and each  actual
<span id="line13100"></span>          argument  array  element  becomes  associated  with the
<span id="line13101"></span>          dummy  argument  array  element  that  has   the   same
<span id="line13102"></span>          subscript  value  as the actual argument array element.
<span id="line13103"></span>          Note that association  by  array  elements  exists  for
<span id="line13104"></span>          character  arrays  if  there  is  agreement  in  length
<span id="line13105"></span>          between the actual  argument  and  the  dummy  argument
<span id="line13106"></span>          array  elements; if the lengths do not agree, the dummy
<span id="line13107"></span>          and actual argument array elements do  not  consist  of
<span id="line13108"></span>          the same characters, but an association still exists.
<span id="line13109"></span>
<span id="line13110"></span>          If the actual argument is a noncharacter array  element
<span id="line13111"></span>          name,  the  size  of  the dummy argument array must not
<span id="line13112"></span>          exceed the size of the actual argument array  plus  one
<span id="line13113"></span>          minus  the  subscript value of the array element.  When
<span id="line13114"></span>          an actual argument is a noncharacter array element name
<span id="line13115"></span>          with  a subscript value of as__, the dummy argument array
<span id="line13116"></span>          element with a subscript value of ds__ becomes associated
<span id="line13117"></span>          with  the  actual  argument  array  element  that has a
<span id="line13118"></span>          subscript value of as__ + ds__ - 1 (Table 1, 5.4.3).
<span id="line13119"></span>
<span id="line13120"></span>
<span id="line13121"></span>
<span id="line13122"></span>
<span id="line13123"></span>
<span id="line13124"></span>          FORTRAN 77 Full Language                     Page 15-21
<span id="line13125"></span>
<span id="line13126"></span>
<span id="line13127"></span>
<span id="line13128"></span>
<span id="line13129"></span>
<span id="line13130"></span>
<span id="line13131"></span>
<span id="line13132"></span>          FUNCTIONS AND SUBROUTINES                ANSI X3J3/90.4
<span id="line13133"></span>
<span id="line13134"></span>
<span id="line13135"></span>
<span id="line13136"></span>          If the actual  argument  is  a  character  array  name,
<span id="line13137"></span>          character   array  element  name,  or  character  array
<span id="line13138"></span>          element substring name and begins at character  storage
<span id="line13139"></span>          unit  acu___ of an array, character storage unit dcu___ of an
<span id="line13140"></span>          associated dummy argument array becomes associated with
<span id="line13141"></span>          character  storage  unit  acu_ __ + dcu___ - 1 of the actual
<span id="line13142"></span>          argument array.
<span id="line13143"></span>
<span id="line13144"></span>          15.9.3.4  Procedures_as_Dummy_Arguments.     A    dummy
<span id="line13145"></span>          argument  that  is  a dummy procedure may be associated
<span id="line13146"></span>          only with an  actual  argument  that  is  an  intrinsic
<span id="line13147"></span>          function,  external  function,  subroutine,  or another
<span id="line13148"></span>          dummy procedure.
<span id="line13149"></span>
<span id="line13150"></span>          If a dummy argument is used as if it were  an  external
<span id="line13151"></span>          function,  the  associated  actual  argument must be an
<span id="line13152"></span>          intrinsic  function,  external   function,   or   dummy
<span id="line13153"></span>          procedure.   A  dummy  argument that becomes associated
<span id="line13154"></span>          with an intrinsic  function  never  has  any  automatic
<span id="line13155"></span>          typing  property,  even  if  the  dummy  argument  name
<span id="line13156"></span>          appears in Table 5 (15.10).  Therefore, the type of the
<span id="line13157"></span>          dummy  argument  must agree with the type of the result
<span id="line13158"></span>          of all specific actual arguments that become associated
<span id="line13159"></span>          with  the  dummy argument.  If a dummy argument name is
<span id="line13160"></span>          used as if it were an external function and  that  name
<span id="line13161"></span>          also   appears  in  Table  5,  the  intrinsic  function
<span id="line13162"></span>          corresponding  to  the  dummy  argument  name  is   not
<span id="line13163"></span>          available for referencing within the subprogram.
<span id="line13164"></span>
<span id="line13165"></span>          A dummy argument that is used as a procedure name in  a
<span id="line13166"></span>          function  reference and is associated with an intrinsic
<span id="line13167"></span>          function must  have  arguments  that  agree  in  order,
<span id="line13168"></span>          number,  and  type  with those specified in Table 5 for
<span id="line13169"></span>          the intrinsic function.
<span id="line13170"></span>
<span id="line13171"></span>          If a dummy argument appears in a type-statement and  an
<span id="line13172"></span>          EXTERNAL  statement,  the  actual  argument must be the
<span id="line13173"></span>          name of an intrinsic function,  external  function,  or
<span id="line13174"></span>          dummy procedure.
<span id="line13175"></span>
<span id="line13176"></span>          If the dummy argument is referenced  as  a  subroutine,
<span id="line13177"></span>          the actual argument must be the name of a subroutine or
<span id="line13178"></span>          dummy procedure and must not appear in a type-statement
<span id="line13179"></span>          or be referenced as a function.
<span id="line13180"></span>
<span id="line13181"></span>          Note that it may not be  possible  to  determine  in  a
<span id="line13182"></span>          given   program  unit  whether  a  dummy  procedure  is
<span id="line13183"></span>          associated with a  function  or  a  subroutine.   If  a
<span id="line13184"></span>          procedure  name  appears only in a dummy argument list,
<span id="line13185"></span>          an EXTERNAL statement, and an actual argument list,  it
<span id="line13186"></span>          is  not possible to determine whether the symbolic name
<span id="line13187"></span>
<span id="line13188"></span>
<span id="line13189"></span>
<span id="line13190"></span>          FORTRAN 77 Full Language                     Page 15-22
<span id="line13191"></span>
<span id="line13192"></span>
<span id="line13193"></span>
<span id="line13194"></span>
<span id="line13195"></span>
<span id="line13196"></span>
<span id="line13197"></span>
<span id="line13198"></span>          FUNCTIONS AND SUBROUTINES                ANSI X3J3/90.4
<span id="line13199"></span>
<span id="line13200"></span>
<span id="line13201"></span>
<span id="line13202"></span>          becomes associated with a  function  or  subroutine  by
<span id="line13203"></span>          examination of the subprogram alone.
<span id="line13204"></span>
<span id="line13205"></span>          15.9.3.5  Asterisks_as_Dummy_Arguments.     A     dummy
<span id="line13206"></span>          argument  that  is  an  asterisk may appear only in the
<span id="line13207"></span>          dummy argument list of a  SUBROUTINE  statement  or  an
<span id="line13208"></span>          ENTRY statement in a subroutine subprogram.
<span id="line13209"></span>
<span id="line13210"></span>          A dummy argument that is an asterisk may be  associated
<span id="line13211"></span>          only  with  an  actual  argument  that  is an alternate
<span id="line13212"></span>          return specifier in the CALL statement that  identifies
<span id="line13213"></span>          the  current  referencing name.  If a dummy argument is
<span id="line13214"></span>          an asterisk, the corresponding actual argument must  be
<span id="line13215"></span>          an alternate return specifier.
<span id="line13216"></span>
<span id="line13217"></span>          15.9.3.6  Restrictions_on_Association_of_Entities.   If
<span id="line13218"></span>          a  subprogram  reference causes a dummy argument in the
<span id="line13219"></span>          referenced subprogram to become associated with another
<span id="line13220"></span>          dummy  argument  in  the referenced subprogram, neither
<span id="line13221"></span>          dummy argument may become defined during  execution  of
<span id="line13222"></span>          that  subprogram.   For  example,  if  a  subroutine is
<span id="line13223"></span>          headed by
<span id="line13224"></span>
<span id="line13225"></span>                               SUBROUTINE XYZ (A,B)
<span id="line13226"></span>
<span id="line13227"></span>          and is referenced by
<span id="line13228"></span>
<span id="line13229"></span>                               CALL XYZ (C,C)
<span id="line13230"></span>
<span id="line13231"></span>          the[n  the  dummy  arguments  A  and  B   each   become
<span id="line13232"></span>          associated   with   the  same  actual  argument  C  and
<span id="line13233"></span>          therefore with each other.  Neither A nor B may  become
<span id="line13234"></span>          defined  during  this execution of subroutine XYZ or by
<span id="line13235"></span>          any procedures referenced by XYZ.
<span id="line13236"></span>
<span id="line13237"></span>          If a subprogram reference causes a  dummy  argument  to
<span id="line13238"></span>          become  associated  with an entity in a common block in
<span id="line13239"></span>          the referenced subprogram or in a subprogram referenced
<span id="line13240"></span>          by   the   referenced  subprogram,  neither  the  dummy
<span id="line13241"></span>          argument nor the entity in the common block may  become
<span id="line13242"></span>          defined  within  the  subprogram or within a subprogram
<span id="line13243"></span>          referenced by the referenced subprogram.  For  example,
<span id="line13244"></span>          if a subroutine contains the statements:
<span id="line13245"></span>
<span id="line13246"></span>                     SUBROUTINE XYZ (A)
<span id="line13247"></span>                     COMMON C
<span id="line13248"></span>
<span id="line13249"></span>          and is referenced by a program unit that  contains  the
<span id="line13250"></span>          statements:
<span id="line13251"></span>
<span id="line13252"></span>                     COMMON B
<span id="line13253"></span>
<span id="line13254"></span>
<span id="line13255"></span>
<span id="line13256"></span>          FORTRAN 77 Full Language                     Page 15-23
<span id="line13257"></span>
<span id="line13258"></span>
<span id="line13259"></span>
<span id="line13260"></span>
<span id="line13261"></span>
<span id="line13262"></span>
<span id="line13263"></span>
<span id="line13264"></span>          FUNCTIONS AND SUBROUTINES                ANSI X3J3/90.4
<span id="line13265"></span>
<span id="line13266"></span>
<span id="line13267"></span>
<span id="line13268"></span>                     CALL XYZ (B)
<span id="line13269"></span>
<span id="line13270"></span>          then the dummy argument A becomes associated  with  the
<span id="line13271"></span>          actual argument B, which is associated with C, which is
<span id="line13272"></span>          in a common block.  Neither A nor C may become  defined
<span id="line13273"></span>          during  execution  of  the  subroutine  XYZ  or  by any
<span id="line13274"></span>          procedures referenced by XYZ.
<span id="line13275"></span>
<span id="line13276"></span>          15.9.4  Common_Blocks.  A common block provides a means
<span id="line13277"></span>          of communication between external procedures or between
<span id="line13278"></span>          a  main  program  and  an  external   procedure.    The
<span id="line13279"></span>          variables  and  arrays in a common block may be defined
<span id="line13280"></span>          and  referenced  in  all  subprograms  that  contain  a
<span id="line13281"></span>          declaration  of that common block.  Because association
<span id="line13282"></span>          is by storage rather than by name,  the  names  of  the
<span id="line13283"></span>          variables  and arrays may be different in the different
<span id="line13284"></span>          subprograms.  A reference to a datum in a common  block
<span id="line13285"></span>          is  proper  if  the  datum is in a defined state of the
<span id="line13286"></span>          same type as the type of the name used to reference the
<span id="line13287"></span>          datum.   However,  an  integer  variable  that has been
<span id="line13288"></span>          assigned a statement label must not  be  referenced  in
<span id="line13289"></span>          any  program  unit  other  than the one in which it was
<span id="line13290"></span>          assigned (10.3).
<span id="line13291"></span>
<span id="line13292"></span>          No difference in data type  is  permitted  between  the
<span id="line13293"></span>          defined  state  and  the  type of the reference, except
<span id="line13294"></span>          that either part of a complex datum may  be  referenced
<span id="line13295"></span>          also as a real datum.
<span id="line13296"></span>
<span id="line13297"></span>          In a subprogram that has declared a named common block,
<span id="line13298"></span>          the  entities  in  the  block  remain defined after the
<span id="line13299"></span>          execution of a RETURN or  END  statement  if  a  common
<span id="line13300"></span>          block of the same name has been declared in any program
<span id="line13301"></span>          unit that  is  currently  referencing  the  subprogram,
<span id="line13302"></span>          either   directly   or   indirectly.   Otherwise,  such
<span id="line13303"></span>          entities become undefined at the execution of a  RETURN
<span id="line13304"></span>          or  END  statement, except for those that are specified
<span id="line13305"></span>          by  SAVE  statements  and  those  that  were  initially
<span id="line13306"></span>          defined  by  DATA  statements  and  have  neither  been
<span id="line13307"></span>          redefined nor become undefined.
<span id="line13308"></span>
<span id="line13309"></span>          Execution of a RETURN or END statement does  not  cause
<span id="line13310"></span>          entities  in  blank common or in any named common block
<span id="line13311"></span>          that appears in the main program to become undefined.
<span id="line13312"></span>
<span id="line13313"></span>          Common blocks may be used  also  to  reduce  the  total
<span id="line13314"></span>          number  of  storage  units  required  for an executable
<span id="line13315"></span>          program by causing two or  more  subprograms  to  share
<span id="line13316"></span>          some  of  the  same  storage  units.   This  sharing of
<span id="line13317"></span>          storage is permitted if  the  rules  for  defining  and
<span id="line13318"></span>          referencing data are not violated.
<span id="line13319"></span>
<span id="line13320"></span>
<span id="line13321"></span>
<span id="line13322"></span>          FORTRAN 77 Full Language                     Page 15-24
<span id="line13323"></span>
<span id="line13324"></span>
<span id="line13325"></span>
<span id="line13326"></span>
<span id="line13327"></span>
<span id="line13328"></span>
<span id="line13329"></span>
<span id="line13330"></span>          FUNCTIONS AND SUBROUTINES                ANSI X3J3/90.4
<span id="line13331"></span>
<span id="line13332"></span>
<span id="line13333"></span>
<span id="line13334"></span>          15.10  Table_of_Intrinsic_Functions
<span id="line13335"></span>
<span id="line13336"></span>
<span id="line13337"></span>
<span id="line13338"></span>
<span id="line13339"></span>
<span id="line13340"></span>
<span id="line13341"></span>
<span id="line13342"></span>
<span id="line13343"></span>
<span id="line13344"></span>
<span id="line13345"></span>
<span id="line13346"></span>
<span id="line13347"></span>
<span id="line13348"></span>
<span id="line13349"></span>
<span id="line13350"></span>
<span id="line13351"></span>
<span id="line13352"></span>
<span id="line13353"></span>
<span id="line13354"></span>
<span id="line13355"></span>
<span id="line13356"></span>
<span id="line13357"></span>
<span id="line13358"></span>
<span id="line13359"></span>
<span id="line13360"></span>
<span id="line13361"></span>
<span id="line13362"></span>
<span id="line13363"></span>
<span id="line13364"></span>
<span id="line13365"></span>
<span id="line13366"></span>
<span id="line13367"></span>
<span id="line13368"></span>
<span id="line13369"></span>
<span id="line13370"></span>
<span id="line13371"></span>
<span id="line13372"></span>
<span id="line13373"></span>
<span id="line13374"></span>
<span id="line13375"></span>
<span id="line13376"></span>
<span id="line13377"></span>
<span id="line13378"></span>
<span id="line13379"></span>
<span id="line13380"></span>
<span id="line13381"></span>
<span id="line13382"></span>
<span id="line13383"></span>
<span id="line13384"></span>
<span id="line13385"></span>
<span id="line13386"></span>
<span id="line13387"></span>
<span id="line13388"></span>          FORTRAN 77 Full Language                     Page 15-25
<span id="line13389"></span>
<span id="line13390"></span>
<span id="line13391"></span>
<span id="line13392"></span>
<span id="line13393"></span>
<span id="line13394"></span>
<span id="line13395"></span>
<span id="line13396"></span>          FUNCTIONS AND SUBROUTINES                ANSI X3J3/90.4
<span id="line13397"></span>
<span id="line13398"></span>
<span id="line13399"></span>
<span id="line13400"></span>
<span id="line13401"></span>
<span id="line13402"></span>
<span id="line13403"></span>
<span id="line13404"></span>
<span id="line13405"></span>
<span id="line13406"></span>
<span id="line13407"></span>
<span id="line13408"></span>
<span id="line13409"></span>
<span id="line13410"></span>
<span id="line13411"></span>
<span id="line13412"></span>
<span id="line13413"></span>
<span id="line13414"></span>
<span id="line13415"></span>
<span id="line13416"></span>
<span id="line13417"></span>
<span id="line13418"></span>
<span id="line13419"></span>
<span id="line13420"></span>
<span id="line13421"></span>
<span id="line13422"></span>
<span id="line13423"></span>
<span id="line13424"></span>
<span id="line13425"></span>
<span id="line13426"></span>
<span id="line13427"></span>
<span id="line13428"></span>
<span id="line13429"></span>
<span id="line13430"></span>
<span id="line13431"></span>
<span id="line13432"></span>
<span id="line13433"></span>
<span id="line13434"></span>
<span id="line13435"></span>
<span id="line13436"></span>
<span id="line13437"></span>
<span id="line13438"></span>
<span id="line13439"></span>
<span id="line13440"></span>
<span id="line13441"></span>
<span id="line13442"></span>
<span id="line13443"></span>
<span id="line13444"></span>
<span id="line13445"></span>
<span id="line13446"></span>
<span id="line13447"></span>
<span id="line13448"></span>
<span id="line13449"></span>
<span id="line13450"></span>
<span id="line13451"></span>
<span id="line13452"></span>
<span id="line13453"></span>
<span id="line13454"></span>          FORTRAN 77 Full Language                     Page 15-26
<span id="line13455"></span>
<span id="line13456"></span>
<span id="line13457"></span>
<span id="line13458"></span>
<span id="line13459"></span>
<span id="line13460"></span>
<span id="line13461"></span>
<span id="line13462"></span>          FUNCTIONS AND SUBROUTINES                ANSI X3J3/90.4
<span id="line13463"></span>
<span id="line13464"></span>
<span id="line13465"></span>
<span id="line13466"></span>
<span id="line13467"></span>
<span id="line13468"></span>
<span id="line13469"></span>
<span id="line13470"></span>
<span id="line13471"></span>
<span id="line13472"></span>
<span id="line13473"></span>
<span id="line13474"></span>
<span id="line13475"></span>
<span id="line13476"></span>
<span id="line13477"></span>
<span id="line13478"></span>
<span id="line13479"></span>
<span id="line13480"></span>
<span id="line13481"></span>
<span id="line13482"></span>
<span id="line13483"></span>
<span id="line13484"></span>
<span id="line13485"></span>
<span id="line13486"></span>
<span id="line13487"></span>
<span id="line13488"></span>
<span id="line13489"></span>
<span id="line13490"></span>
<span id="line13491"></span>
<span id="line13492"></span>
<span id="line13493"></span>
<span id="line13494"></span>
<span id="line13495"></span>
<span id="line13496"></span>
<span id="line13497"></span>
<span id="line13498"></span>
<span id="line13499"></span>
<span id="line13500"></span>
<span id="line13501"></span>
<span id="line13502"></span>
<span id="line13503"></span>
<span id="line13504"></span>
<span id="line13505"></span>
<span id="line13506"></span>
<span id="line13507"></span>
<span id="line13508"></span>
<span id="line13509"></span>
<span id="line13510"></span>
<span id="line13511"></span>
<span id="line13512"></span>
<span id="line13513"></span>
<span id="line13514"></span>
<span id="line13515"></span>
<span id="line13516"></span>
<span id="line13517"></span>
<span id="line13518"></span>
<span id="line13519"></span>
<span id="line13520"></span>          FORTRAN 77 Full Language                     Page 15-27
<span id="line13521"></span>
<span id="line13522"></span>
<span id="line13523"></span>
<span id="line13524"></span>
<span id="line13525"></span>
<span id="line13526"></span>
<span id="line13527"></span>
<span id="line13528"></span>          FUNCTIONS AND SUBROUTINES                ANSI X3J3/90.4
<span id="line13529"></span>
<span id="line13530"></span>
<span id="line13531"></span>
<span id="line13532"></span>
<span id="line13533"></span>
<span id="line13534"></span>
<span id="line13535"></span>
<span id="line13536"></span>
<span id="line13537"></span>
<span id="line13538"></span>
<span id="line13539"></span>
<span id="line13540"></span>
<span id="line13541"></span>
<span id="line13542"></span>
<span id="line13543"></span>
<span id="line13544"></span>
<span id="line13545"></span>
<span id="line13546"></span>
<span id="line13547"></span>
<span id="line13548"></span>
<span id="line13549"></span>
<span id="line13550"></span>
<span id="line13551"></span>
<span id="line13552"></span>
<span id="line13553"></span>
<span id="line13554"></span>
<span id="line13555"></span>
<span id="line13556"></span>
<span id="line13557"></span>
<span id="line13558"></span>
<span id="line13559"></span>
<span id="line13560"></span>
<span id="line13561"></span>
<span id="line13562"></span>
<span id="line13563"></span>
<span id="line13564"></span>
<span id="line13565"></span>
<span id="line13566"></span>
<span id="line13567"></span>
<span id="line13568"></span>
<span id="line13569"></span>
<span id="line13570"></span>
<span id="line13571"></span>
<span id="line13572"></span>
<span id="line13573"></span>
<span id="line13574"></span>
<span id="line13575"></span>
<span id="line13576"></span>
<span id="line13577"></span>
<span id="line13578"></span>
<span id="line13579"></span>
<span id="line13580"></span>
<span id="line13581"></span>
<span id="line13582"></span>
<span id="line13583"></span>
<span id="line13584"></span>
<span id="line13585"></span>
<span id="line13586"></span>          FORTRAN 77 Full Language                     Page 15-28
<span id="line13587"></span>
<span id="line13588"></span>
<span id="line13589"></span>
<span id="line13590"></span>
<span id="line13591"></span>
<span id="line13592"></span>
<span id="line13593"></span>
<span id="line13594"></span>          FUNCTIONS AND SUBROUTINES                ANSI X3J3/90.4
<span id="line13595"></span>
<span id="line13596"></span>
<span id="line13597"></span>
<span id="line13598"></span>          Notes for Table 5:
<span id="line13599"></span>
<span id="line13600"></span>             (1) For a_ of type integer, int(a_)=a_.  For a_ of  type
<span id="line13601"></span>                 real  or  double precision, there are two cases:
<span id="line13602"></span>                 if |a_| <span class="entity"><span>&amp;</span>lt;</span> 1, int(a_)=0; if |a_| <span class="entity"><span>&amp;</span>gt;</span> 1, int(a_) is  the
<span id="line13603"></span>                 integer  whose  magnitude is the largest integer
<span id="line13604"></span>                 that does not exceed the  magnitude  of  a_  and
<span id="line13605"></span>                 whose  sign  is  the same as the sign of a_.  For
<span id="line13606"></span>                 example,
<span id="line13607"></span>
<span id="line13608"></span>                                      int(-3.7) = -3
<span id="line13609"></span>
<span id="line13610"></span>                 For a_ of type complex,  int(a_ )  is  the  value
<span id="line13611"></span>                 obtained  by applying the above rule to the real
<span id="line13612"></span>                 part of a_.
<span id="line13613"></span>
<span id="line13614"></span>                 For a_ of type real, IFIX(a_) is the same as INT(a_
<span id="line13615"></span>                 ).
<span id="line13616"></span>
<span id="line13617"></span>             (2) For a_ of type real, REAL(a_) is a_.  For a_ of type
<span id="line13618"></span>                 integer  or double precision, REAL(a_) is as much
<span id="line13619"></span>                 precision of the significant part of a_ as a real
<span id="line13620"></span>                 datum can contain.  For a_ of type complex, REAL(a
<span id="line13621"></span>                 _) is the real part of a_.
<span id="line13622"></span>
<span id="line13623"></span>                 For a_ of type integer, FLOAT(a_) is the  same  as
<span id="line13624"></span>                 REAL(a_).
<span id="line13625"></span>
<span id="line13626"></span>             (3) For a_ of type double precision, DBLE(a_) is  a_ .
<span id="line13627"></span>                 For  a_  of  type integer or real, DBLE(a_) is as
<span id="line13628"></span>                 much precision of the significant part of a_ as a
<span id="line13629"></span>                 double  precision  datum  can contain.  For a_ of
<span id="line13630"></span>                 type complex, DBLE(a_) is as  much  precision  of
<span id="line13631"></span>                 the  significant part of the real part of a_ as a
<span id="line13632"></span>                 double precision datum can contain.
<span id="line13633"></span>
<span id="line13634"></span>             (4) CMPLX may have one or two arguments.   If  there
<span id="line13635"></span>                 is  one  argument,  it may be of  type  integer,
<span id="line13636"></span>                 real, double precision, or  complex.   If  there
<span id="line13637"></span>                 are two arguments, they must both be of the same
<span id="line13638"></span>                 type and may be of type integer, real, or double
<span id="line13639"></span>                 precision.
<span id="line13640"></span>
<span id="line13641"></span>                 For a_ of type complex, CMPLX(a_) is a_.  For a_  of
<span id="line13642"></span>                 type integer, real, or double precision, CMPLX(a_
<span id="line13643"></span>                 ) is the complex value whose real part is REAL(a_
<span id="line13644"></span>                 ) and whose imaginary part is zero.
<span id="line13645"></span>
<span id="line13646"></span>                 CMPLX(a_918,a_928) is the  complex  value  whose  real
<span id="line13647"></span>                 part  is  REAL(a_918)  and whose imaginary part is
<span id="line13648"></span>                 REAL(a_928).
<span id="line13649"></span>
<span id="line13650"></span>
<span id="line13651"></span>
<span id="line13652"></span>          FORTRAN 77 Full Language                     Page 15-29
<span id="line13653"></span>
<span id="line13654"></span>
<span id="line13655"></span>
<span id="line13656"></span>
<span id="line13657"></span>
<span id="line13658"></span>
<span id="line13659"></span>
<span id="line13660"></span>          FUNCTIONS AND SUBROUTINES                ANSI X3J3/90.4
<span id="line13661"></span>
<span id="line13662"></span>
<span id="line13663"></span>
<span id="line13664"></span>             (5) ICHAR provides a  means  of  converting  from  a
<span id="line13665"></span>                 character  to  an integer, based on the position
<span id="line13666"></span>                 of the  character  in  the  processor  collating
<span id="line13667"></span>                 sequence.   The first character in the collating
<span id="line13668"></span>                 sequence corresponds to position 0 and the  last
<span id="line13669"></span>                 to  position  n_ - 1,  where  n_ is the number of
<span id="line13670"></span>                 characters in the collating sequence.
<span id="line13671"></span>
<span id="line13672"></span>                 The value of ICHAR(a_ )  is  an  integer  in  the
<span id="line13673"></span>                 range:   0  <span class="entity"><span>&amp;</span>lt;</span>  ICHAR(a_ )  <span class="entity"><span>&amp;</span>lt;</span>  n_-1, where a_ is an
<span id="line13674"></span>                 argument of type character of length  one.   The
<span id="line13675"></span>                 value  of  a_  must  be  a  character capable of
<span id="line13676"></span>                 representation in the processor.   The  position
<span id="line13677"></span>                 of  that  character in the collating sequence is
<span id="line13678"></span>                 the value of ICHAR.
<span id="line13679"></span>
<span id="line13680"></span>                 For  any  characters  c_918  and  c_928  capable  of
<span id="line13681"></span>                 representation  in the processor, (c_918 .LE c_928) is
<span id="line13682"></span>                 true if and only if (ICHAR(c_918) .LE. ICHAR(c_928))
<span id="line13683"></span>                 is true, and (c_918 .EQ. c_928) is true if and only if
<span id="line13684"></span>                 (ICHAR(c_918) .EQ. ICHAR(c_928)) is true.
<span id="line13685"></span>
<span id="line13686"></span>                 CHAR(i_)  returns  the  character  in  the  i_ th
<span id="line13687"></span>                 position  of  the  processor collating sequence.
<span id="line13688"></span>                 The value is of type character of length one.  i_
<span id="line13689"></span>                 must  be  an integer expression whose value must
<span id="line13690"></span>                 be in the range 0 <span class="entity"><span>&amp;</span>lt;</span> i_ <span class="entity"><span>&amp;</span>lt;</span> n_-1.
<span id="line13691"></span>
<span id="line13692"></span>                        ICHAR(CHAR(i_)) = i_ for 0 <span class="entity"><span>&amp;</span>lt;</span> i_ </span><span>&lt;<span class="start-tag">n_-1.</span> <span class="attribute-name">char(ichar(c_))</span>="<a class="attribute-value">c_</a>" <span class="attribute-name">for</span>="<a class="attribute-value"></a>" <span class="attribute-name">any</span>="<a class="attribute-value"></a>" <span class="attribute-name">c_</span>="<a class="attribute-value"></a>" <span class="attribute-name">capable</span>="<a class="attribute-value"></a>" <span class="attribute-name">representation</span>="<a class="attribute-value"></a>" <span class="attribute-name">processor.</span>="<a class="attribute-value"></a>" <span class="attribute-name">(6)</span>="<a class="attribute-value"></a>" <span class="attribute-name">as</span>="<a class="attribute-value"></a>" <span class="attribute-name">ordered</span>="<a class="attribute-value"></a>" <span class="attribute-name">pair</span>="<a class="attribute-value"></a>" <span class="attribute-name">reals,</span>="<a class="attribute-value"></a>" <span class="attribute-name">(ar__,ai__),</span>="<a class="attribute-value"></a>" <span class="attribute-name">where</span>="<a class="attribute-value"></a>" <span class="attribute-name">ar__</span>="<a class="attribute-value"></a>" <span class="attribute-name">real</span>="<a class="attribute-value"></a>" <span class="attribute-name">part</span>="<a class="attribute-value"></a>" <span class="attribute-name">ai__</span>="<a class="attribute-value"></a>" <span class="attribute-name">imaginary</span>="<a class="attribute-value"></a>" <span class="attribute-name">part.</span>="<a class="attribute-value"></a>" <span class="attribute-name">(7)</span>="<a class="attribute-value"></a>" <span class="attribute-name">angles</span>="<a class="attribute-value"></a>" <span class="attribute-name">are</span>="<a class="attribute-value"></a>" <span class="attribute-name">expressed</span>="<a class="attribute-value"></a>" <span class="attribute-name">radians.</span>="<a class="attribute-value"></a>" <span class="attribute-name">(8)</span>="<a class="attribute-value"></a>" <span class="attribute-name">result</span>="<a class="attribute-value"></a>" <span class="attribute-name">type</span>="<a class="attribute-value"></a>" <span class="attribute-name">complex</span>="<a class="attribute-value"></a>" <span class="attribute-name">principal</span>="<a class="attribute-value"></a>" <span class="attribute-name">value.</span>="<a class="attribute-value"></a>" <span class="attribute-name">(9)</span>="<a class="attribute-value"></a>" <span class="attribute-name">all</span>="<a class="attribute-value"></a>" <span class="attribute-name">arguments</span>="<a class="attribute-value"></a>" <span class="attribute-name">intrinsic</span>="<a class="attribute-value"></a>" <span class="attribute-name">function</span>="<a class="attribute-value"></a>" <span class="attribute-name">reference</span>="<a class="attribute-value"></a>" <span class="attribute-name">must</span>="<a class="attribute-value"></a>" <span class="attribute-name">be</span>="<a class="attribute-value"></a>" <span class="attribute-name">same</span>="<a class="attribute-value"></a>" <span class="attribute-name">type.</span>="<a class="attribute-value"></a>" <span class="attribute-name">(10)</span>="<a class="attribute-value"></a>" <span class="attribute-name">index(a_918,a_928)</span>="<a class="attribute-value"></a>" <span class="attribute-name">returns</span>="<a class="attribute-value"></a>" <span class="attribute-name">an</span>="<a class="attribute-value"></a>" <span class="attribute-name">integer</span>="<a class="attribute-value"></a>" <span class="attribute-name">indicating</span>="<a class="attribute-value"></a>" <span class="attribute-name">within</span>="<a class="attribute-value"></a>" <span class="attribute-name">character</span>="<a class="attribute-value"></a>" <span class="attribute-name">a_918</span>="<a class="attribute-value"></a>" <span class="attribute-name">a</span>="<a class="attribute-value"></a>" <span class="attribute-name">substring</span>="<a class="attribute-value"></a>" <span class="attribute-name">identical</span>="<a class="attribute-value"></a>" <span class="attribute-name">to</span>="<a class="attribute-value"></a>" <span class="attribute-name">string</span>="<a class="attribute-value"></a>" <span class="attribute-name">a_928.</span>="<a class="attribute-value"></a>" <span class="attribute-name">occurs</span>="<a class="attribute-value"></a>" <span class="attribute-name">more</span>="<a class="attribute-value"></a>" <span class="attribute-name">than</span>="<a class="attribute-value"></a>" <span class="attribute-name">once</span>="<a class="attribute-value"></a>" <span class="attribute-name">starting</span>="<a class="attribute-value"></a>" <span class="attribute-name">fortran</span>="<a class="attribute-value"></a>" <span class="attribute-name">77</span>="<a class="attribute-value"></a>" <span class="attribute-name">full</span>="<a class="attribute-value"></a>" <span class="attribute-name">language</span>="<a class="attribute-value"></a>" <span class="attribute-name">page</span>="<a class="attribute-value"></a>" <span class="attribute-name">15-30</span>="<a class="attribute-value"></a>" <span class="attribute-name">functions</span>="<a class="attribute-value"></a>" <span class="attribute-name">and</span>="<a class="attribute-value"></a>" <span class="attribute-name">subroutines</span>="<a class="attribute-value"></a>" <span class="attribute-name">ansi</span>="<a class="attribute-value"></a>" <span class="attribute-name">x3j3</span>="<a class="attribute-value"></a>" <span class="attribute-name">90.4</span>="<a class="attribute-value"></a>" <span class="attribute-name">position</span>="<a class="attribute-value"></a>" <span class="attribute-name">of</span>="<a class="attribute-value"></a>" <span class="attribute-name">first</span>="<a class="attribute-value"></a>" <span class="attribute-name">occurrence</span>="<a class="attribute-value"></a>" <span class="attribute-name">a_928</span>="<a class="attribute-value"></a>" <span class="attribute-name">does</span>="<a class="attribute-value"></a>" <span class="attribute-name">not</span>="<a class="attribute-value"></a>" <span class="attribute-name">occur</span>="<a class="attribute-value"></a>" <span class="attribute-name">in</span>="<a class="attribute-value"></a>" <span class="attribute-name">a_918,</span>="<a class="attribute-value"></a>" <span class="attribute-name">the</span>="<a class="attribute-value"></a>" <span class="attribute-name">value</span>="<a class="attribute-value"></a>" <span class="attribute-name">returned.</span>="<a class="attribute-value"></a>" <span class="attribute-name">note</span>="<a class="attribute-value"></a>" <span class="attribute-name">that</span>="<a class="attribute-value"></a>" <span class="attribute-name">zero</span>="<a class="attribute-value"></a>" <span class="attribute-name">is</span>="<a class="attribute-value"></a>" <span class="attribute-name">returned</span>="<a class="attribute-value"></a>" <span class="attribute-name">if</span>="<a class="attribute-value"></a>" <span class="attribute-name">len(a</span>="<a class="attribute-value"></a>" <span class="attribute-name">_918)</span>="<a class="attribute-value"></a>"&gt;</span><span><span class="entity"><span>&amp;</span>lt;</span> LEN(a_928).
<span id="line13693"></span>
<span id="line13694"></span>            (11) The value of the argument of  the  LEN  function
<span id="line13695"></span>                 need  not  be  defined  at the time the function
<span id="line13696"></span>                 reference is executed.
<span id="line13697"></span>
<span id="line13698"></span>            (12) LGE(a_918,a_928) returns the value true if a_918=a_928 or if
<span id="line13699"></span>                 a _918  follows  a_928  in  the  collating  sequence
<span id="line13700"></span>                 described in American National Standard Code for
<span id="line13701"></span>                 Information Interchange, ANSI X3.4-1977 (ASCII),
<span id="line13702"></span>                 and otherwise returns the value false.
<span id="line13703"></span>
<span id="line13704"></span>                 LGT(a_918,a_928) returns the value true if a_918 follows a
<span id="line13705"></span>                 _928  in  the collating sequence described in ANSI
<span id="line13706"></span>                 X3.4-1977 (ASCII),  and  otherwise  returns  the
<span id="line13707"></span>                 value false.
<span id="line13708"></span>
<span id="line13709"></span>                 LLE(a_918,a_928) returns the value true if a_918=a_928 or if
<span id="line13710"></span>                 a_918  precedes  a_928  in  the  collating  sequence
<span id="line13711"></span>                 described  in  ANSI   X3.4-1977   (ASCII),   and
<span id="line13712"></span>                 otherwise returns the value false.
<span id="line13713"></span>
<span id="line13714"></span>                 LLT(a_918,a_928) returns the value true if a_918 precedes
<span id="line13715"></span>                 a_928  in the collating sequence described in ANSI
<span id="line13716"></span>                 X3.4-1977 (ASCII),  and  otherwise  returns  the
<span id="line13717"></span>                 value false.
<span id="line13718"></span>
<span id="line13719"></span>                 If the operands for LGE, LGT, LLE, and  LLT  are
<span id="line13720"></span>                 of   unequal  length,  the  shorter  operand  is
<span id="line13721"></span>                 considered as if it were extended on  the  right
<span id="line13722"></span>                 with blanks to the length of the longer operand.
<span id="line13723"></span>
<span id="line13724"></span>                 If  either  of  the  character  entities   being
<span id="line13725"></span>                 compared contains a character that is not in the
<span id="line13726"></span>                 ASCII character set, the  result  is  processor-
<span id="line13727"></span>                 dependent.
<span id="line13728"></span>
<span id="line13729"></span>          15.10.1  Restrictions  on  Range   of   Arguments   and
<span id="line13730"></span>          Results.   Restrictions  on  the range of arguments and
<span id="line13731"></span>          results for  intrinsic  functions  when  referenced  by
<span id="line13732"></span>          their specific names are as follows:
<span id="line13733"></span>
<span id="line13734"></span>             (1) Remaindering: The result for MOD, AMOD, and DMOD
<span id="line13735"></span>                 is  undefined  when  the  value  of  the  second
<span id="line13736"></span>                 argument is zero.
<span id="line13737"></span>
<span id="line13738"></span>
<span id="line13739"></span>
<span id="line13740"></span>
<span id="line13741"></span>
<span id="line13742"></span>          FORTRAN 77 Full Language                     Page 15-31
<span id="line13743"></span>
<span id="line13744"></span>
<span id="line13745"></span>
<span id="line13746"></span>
<span id="line13747"></span>
<span id="line13748"></span>
<span id="line13749"></span>
<span id="line13750"></span>          FUNCTIONS AND SUBROUTINES                ANSI X3J3/90.4
<span id="line13751"></span>
<span id="line13752"></span>
<span id="line13753"></span>
<span id="line13754"></span>             (2) Transfer of Sign: If  the  value  of  the  first
<span id="line13755"></span>                 argument  of  ISIGN, SIGN, or DSIGN is zero, the
<span id="line13756"></span>                 result is zero, which  is  neither  positive  or
<span id="line13757"></span>                 negative (4.1.3).
<span id="line13758"></span>
<span id="line13759"></span>             (3) Square Root: The value of the argument  of  SQRT
<span id="line13760"></span>                 and DSQRT must be greater than or equal to zero.
<span id="line13761"></span>                 The result of CSQRT is the principal value  with
<span id="line13762"></span>                 the  real  part  greater  than or equal to zero.
<span id="line13763"></span>                 When the real part of the result  is  zero,  the
<span id="line13764"></span>                 imaginary part is greater than or equal to zero.
<span id="line13765"></span>
<span id="line13766"></span>             (4) Logarithms: The value of the argument  of  ALOG,
<span id="line13767"></span>                 DLOG,  ALOG10,  and  DLOG10 must be greater than
<span id="line13768"></span>                 zero.  The value of the argument  of  CLOG  must
<span id="line13769"></span>                 not be (0.,0.).  The range of the imaginary part
<span id="line13770"></span>                 of the result of CLOG is: -J <span class="entity"><span>&amp;</span>lt;</span> imaginary part <span class="entity"><span>&amp;</span>lt;</span>
<span id="line13771"></span>                 J.   The  imaginary part of the result is J only
<span id="line13772"></span>                 when the real part of the argument is less  than
<span id="line13773"></span>                 zero  and  the imaginary part of the argument is
<span id="line13774"></span>                 zero.
<span id="line13775"></span>
<span id="line13776"></span>             (5) Sine, Cosine, and Tangent: The absolute value of
<span id="line13777"></span>                 the  argument  of SIN, DSIN, COS, DCOS, TAN, and
<span id="line13778"></span>                 DTAN is not restricted to be less than 2J.
<span id="line13779"></span>
<span id="line13780"></span>             (6) Arcsine: The absolute value of the  argument  of
<span id="line13781"></span>                 ASIN  and  DASIN  must  be less than or equal to
<span id="line13782"></span>                 one.
<span id="line13783"></span>                  The range of the result is: -J/2 <span class="entity"><span>&amp;</span>lt;</span> result <span class="entity"><span>&amp;</span>lt;</span> J /
<span id="line13784"></span>                 2.
<span id="line13785"></span>
<span id="line13786"></span>             (7) Arccosine: The absolute value of the argument of
<span id="line13787"></span>                 ACOS  and  DACOS  must  be less than or equal to
<span id="line13788"></span>                 one.  The range of the result is: 0 <span class="entity"><span>&amp;</span>lt;</span> result <span class="entity"><span>&amp;</span>lt;</span>J.
<span id="line13789"></span>
<span id="line13790"></span>             (8) Arctangent: The range of the result for ATAN and
<span id="line13791"></span>                 DATAN  is: -J/2 <span class="entity"><span>&amp;</span>lt;</span> result <span class="entity"><span>&amp;</span>lt;</span> J/2.  If the value of
<span id="line13792"></span>                 the  first  argument  of  ATAN2  or  DATAN2   is
<span id="line13793"></span>                 positive,  the  result is positive. If the value
<span id="line13794"></span>                 of the first argument is  zero,  the  result  is
<span id="line13795"></span>                 zero if the second argument is positive and J if
<span id="line13796"></span>                 the second argument is negative. If the value of
<span id="line13797"></span>                 the  first  argument  is negative, the result is
<span id="line13798"></span>                 negative.  If the value of the  second  argument
<span id="line13799"></span>                 is  zero, the absolute value of the result is J/
<span id="line13800"></span>                 2.  The arguments must not both have  the  value
<span id="line13801"></span>                 zero.   The  range  of  the result for ATAN2 and
<span id="line13802"></span>                 DATAN2 is: -J <span class="entity"><span>&amp;</span>lt;</span> result <span class="entity"><span>&amp;</span>lt;</span> J.
<span id="line13803"></span>
<span id="line13804"></span>
<span id="line13805"></span>
<span id="line13806"></span>
<span id="line13807"></span>
<span id="line13808"></span>          FORTRAN 77 Full Language                     Page 15-32
<span id="line13809"></span>
<span id="line13810"></span>
<span id="line13811"></span>
<span id="line13812"></span>
<span id="line13813"></span>
<span id="line13814"></span>
<span id="line13815"></span>
<span id="line13816"></span>          FUNCTIONS AND SUBROUTINES                ANSI X3J3/90.4
<span id="line13817"></span>
<span id="line13818"></span>
<span id="line13819"></span>
<span id="line13820"></span>          The above restrictions on arguments  and  results  also
<span id="line13821"></span>          apply  to  the  intrinsic  functions when referenced by
<span id="line13822"></span>          their generic names.
<span id="line13823"></span>
<span id="line13824"></span>
<span id="line13825"></span>
<span id="line13826"></span>
<span id="line13827"></span>
<span id="line13828"></span>
<span id="line13829"></span>
<span id="line13830"></span>
<span id="line13831"></span>
<span id="line13832"></span>
<span id="line13833"></span>
<span id="line13834"></span>
<span id="line13835"></span>
<span id="line13836"></span>
<span id="line13837"></span>
<span id="line13838"></span>
<span id="line13839"></span>
<span id="line13840"></span>
<span id="line13841"></span>
<span id="line13842"></span>
<span id="line13843"></span>
<span id="line13844"></span>
<span id="line13845"></span>
<span id="line13846"></span>
<span id="line13847"></span>
<span id="line13848"></span>
<span id="line13849"></span>
<span id="line13850"></span>
<span id="line13851"></span>
<span id="line13852"></span>
<span id="line13853"></span>
<span id="line13854"></span>
<span id="line13855"></span>
<span id="line13856"></span>
<span id="line13857"></span>
<span id="line13858"></span>
<span id="line13859"></span>
<span id="line13860"></span>
<span id="line13861"></span>
<span id="line13862"></span>
<span id="line13863"></span>
<span id="line13864"></span>
<span id="line13865"></span>
<span id="line13866"></span>
<span id="line13867"></span>
<span id="line13868"></span>
<span id="line13869"></span>
<span id="line13870"></span>
<span id="line13871"></span>
<span id="line13872"></span>
<span id="line13873"></span>
<span id="line13874"></span>          FORTRAN 77 Full Language                     Page 15-33
<span id="line13875"></span>
<span id="line13876"></span>
<span id="line13877"></span>
<span id="line13878"></span>
<span id="line13879"></span>
<span id="line13880"></span>
<span id="line13881"></span>
<span id="line13882"></span>          FUNCTIONS AND SUBROUTINES                ANSI X3J3/90.4
<span id="line13883"></span>
<span id="line13884"></span>
<span id="line13885"></span>
<span id="line13886"></span>                                  Table 5_______
<span id="line13887"></span>                            Intrinsic Functions
<span id="line13888"></span>
<span id="line13889"></span>8          ________________________________________________________________________________________________
<span id="line13890"></span>
<span id="line13891"></span>                                                   Number of   Generic   Specific          Type of
<span id="line13892"></span>           Intrinsic Function   Definition         Arguments    Name     Name       Argument    Function
<span id="line13893"></span>8          ________________________________________________________________________________________________
<span id="line13894"></span>
<span id="line13895"></span>           Type Conversion      Conversion             1       INT       -          Integer     Integer
<span id="line13896"></span>                                to Integer                               INT        Real        Integer
<span id="line13897"></span>                                int(a_)                                   IFIX       Real        Integer
<span id="line13898"></span>                                See Note 1                               IDINT      Double      Integer
<span id="line13899"></span>                                                                         -          Complex     Integer
<span id="line13900"></span>8                               ___________________________________________________________________________
<span id="line13901"></span>
<span id="line13902"></span>                                Conversion             1       REAL      REAL       Integer     Real
<span id="line13903"></span>                                to Real                                  FLOAT      Integer     Real
<span id="line13904"></span>                                See Note 2                               -          Real        Real
<span id="line13905"></span>                                                                         SNGL       Double      Real
<span id="line13906"></span>                                                                         -          Complex     Real
<span id="line13907"></span>8                               ___________________________________________________________________________
<span id="line13908"></span>
<span id="line13909"></span>                                Conversion             1       DBLE      -          Integer     Double
<span id="line13910"></span>                                to Double                                -          Real        Double
<span id="line13911"></span>                                See Note 3                               -          Double      Double
<span id="line13912"></span>                                                                         -          Complex     Double
<span id="line13913"></span>8                               ___________________________________________________________________________
<span id="line13914"></span>
<span id="line13915"></span>                                Conversion          1 or 2     CMPLX     -          Integer     Complex
<span id="line13916"></span>                                to Complex                               -          Real        Complex
<span id="line13917"></span>                                See Note 4                               -          Double      Complex
<span id="line13918"></span>                                                                         -          Complex     Complex
<span id="line13919"></span>8                               ___________________________________________________________________________
<span id="line13920"></span>
<span id="line13921"></span>                                Conversion             1                 ICHAR      Character   Integer
<span id="line13922"></span>                                to Integer
<span id="line13923"></span>                                See Note 5
<span id="line13924"></span>8                               ___________________________________________________________________________
<span id="line13925"></span>
<span id="line13926"></span>                                Conversion             1                 CHAR       Integer     Character
<span id="line13927"></span>                                to Character
<span id="line13928"></span>                                See Note 5
<span id="line13929"></span>8          ________________________________________________________________________________________________
<span id="line13930"></span>
<span id="line13931"></span>           Truncation           int(a_)                 1       AINT      AINT       Real        Real
<span id="line13932"></span>                                See Note 1                               DINT       Double      Double
<span id="line13933"></span>8          ________________________________________________________________________________________________
<span id="line13934"></span>
<span id="line13935"></span>           Nearest Whole        int(a_+.5) if a_<span class="entity"><span>&amp;</span>gt;</span>0       1       ANINT     ANINT      Real        Real
<span id="line13936"></span>             Number             int(a_-.5) if a_<span class="entity"><span>&amp;</span>lt;</span>0                         DNINT      Double      Double
<span id="line13937"></span>8          ________________________________________________________________________________________________
<span id="line13938"></span>
<span id="line13939"></span>           Nearest Integer      int(a_+.5) if a_<span class="entity"><span>&amp;</span>gt;</span>0       1       NINT      NINT       Real        Integer
<span id="line13940"></span>                                int(a_-.5) if a_<span class="entity"><span>&amp;</span>lt;</span>0                         IDNINT     Double      Integer
<span id="line13941"></span>8          ________________________________________________________________________________________________
<span id="line13942"></span>
<span id="line13943"></span>           Absolute Value       |a_|                    1       ABS       IABS       Integer     Integer
<span id="line13944"></span>                                                                         ABS        Real        Real
<span id="line13945"></span>                                See Note 6                               DABS       Double      Double
<span id="line13946"></span>                                (a_r_829+a_i_829)81/29                             CABS       Complex     Real
<span id="line13947"></span>8          ________________________________________________________________________________________________
<span id="line13948"></span>7         
|8|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|
<span id="line13949"></span>
<span id="line13950"></span>
<span id="line13951"></span>
<span id="line13952"></span>
<span id="line13953"></span>
<span id="line13954"></span>
<span id="line13955"></span>
<span id="line13956"></span>
<span id="line13957"></span>
<span id="line13958"></span>
<span id="line13959"></span>
<span id="line13960"></span>
<span id="line13961"></span>
<span id="line13962"></span>
<span id="line13963"></span>
<span id="line13964"></span>
<span id="line13965"></span>
<span id="line13966"></span>
<span id="line13967"></span>
<span id="line13968"></span>
<span id="line13969"></span>
<span id="line13970"></span>
<span id="line13971"></span>
<span id="line13972"></span>
<span id="line13973"></span>
<span id="line13974"></span>
<span id="line13975"></span>
<span id="line13976"></span>
<span id="line13977"></span>
<span id="line13978"></span>
<span id="line13979"></span>
<span id="line13980"></span>
<span id="line13981"></span>
<span id="line13982"></span>
<span id="line13983"></span>
<span id="line13984"></span>
<span id="line13985"></span>
<span id="line13986"></span>
<span id="line13987"></span>
<span id="line13988"></span>
<span id="line13989"></span>
<span id="line13990"></span>
<span id="line13991"></span>
<span id="line13992"></span>
<span id="line13993"></span>
<span id="line13994"></span>
<span id="line13995"></span>
<span id="line13996"></span>
<span id="line13997"></span>
<span id="line13998"></span>
<span id="line13999"></span>9                             
|8|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|
<span id="line14000"></span>
<span id="line14001"></span>
<span id="line14002"></span>
<span id="line14003"></span>
<span id="line14004"></span>
<span id="line14005"></span>
<span id="line14006"></span>
<span id="line14007"></span>
<span id="line14008"></span>
<span id="line14009"></span>
<span id="line14010"></span>
<span id="line14011"></span>
<span id="line14012"></span>
<span id="line14013"></span>
<span id="line14014"></span>
<span id="line14015"></span>
<span id="line14016"></span>
<span id="line14017"></span>
<span id="line14018"></span>
<span id="line14019"></span>
<span id="line14020"></span>
<span id="line14021"></span>
<span id="line14022"></span>
<span id="line14023"></span>
<span id="line14024"></span>
<span id="line14025"></span>
<span id="line14026"></span>
<span id="line14027"></span>
<span id="line14028"></span>
<span id="line14029"></span>
<span id="line14030"></span>
<span id="line14031"></span>
<span id="line14032"></span>
<span id="line14033"></span>
<span id="line14034"></span>
<span id="line14035"></span>
<span id="line14036"></span>
<span id="line14037"></span>
<span id="line14038"></span>
<span id="line14039"></span>
<span id="line14040"></span>
<span id="line14041"></span>
<span id="line14042"></span>
<span id="line14043"></span>
<span id="line14044"></span>
<span id="line14045"></span>
<span id="line14046"></span>
<span id="line14047"></span>
<span id="line14048"></span>
<span id="line14049"></span>
<span id="line14050"></span>9                                          
      
|8|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|
<span id="line14051"></span>
<span id="line14052"></span>
<span id="line14053"></span>
<span id="line14054"></span>
<span id="line14055"></span>
<span id="line14056"></span>
<span id="line14057"></span>
<span id="line14058"></span>
<span id="line14059"></span>
<span id="line14060"></span>
<span id="line14061"></span>
<span id="line14062"></span>
<span id="line14063"></span>
<span id="line14064"></span>
<span id="line14065"></span>
<span id="line14066"></span>
<span id="line14067"></span>
<span id="line14068"></span>
<span id="line14069"></span>
<span id="line14070"></span>
<span id="line14071"></span>
<span id="line14072"></span>
<span id="line14073"></span>
<span id="line14074"></span>
<span id="line14075"></span>
<span id="line14076"></span>
<span id="line14077"></span>
<span id="line14078"></span>
<span id="line14079"></span>
<span id="line14080"></span>
<span id="line14081"></span>
<span id="line14082"></span>
<span id="line14083"></span>
<span id="line14084"></span>
<span id="line14085"></span>
<span id="line14086"></span>
<span id="line14087"></span>
<span id="line14088"></span>
<span id="line14089"></span>
<span id="line14090"></span>
<span id="line14091"></span>
<span id="line14092"></span>
<span id="line14093"></span>
<span id="line14094"></span>
<span id="line14095"></span>
<span id="line14096"></span>
<span id="line14097"></span>
<span id="line14098"></span>
<span id="line14099"></span>
<span id="line14100"></span>
<span id="line14101"></span>9                                          
                  
|8|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|
<span id="line14102"></span>
<span id="line14103"></span>
<span id="line14104"></span>
<span id="line14105"></span>
<span id="line14106"></span>
<span id="line14107"></span>
<span id="line14108"></span>
<span id="line14109"></span>
<span id="line14110"></span>
<span id="line14111"></span>
<span id="line14112"></span>
<span id="line14113"></span>
<span id="line14114"></span>
<span id="line14115"></span>
<span id="line14116"></span>
<span id="line14117"></span>
<span id="line14118"></span>
<span id="line14119"></span>
<span id="line14120"></span>
<span id="line14121"></span>
<span id="line14122"></span>
<span id="line14123"></span>
<span id="line14124"></span>
<span id="line14125"></span>
<span id="line14126"></span>
<span id="line14127"></span>
<span id="line14128"></span>
<span id="line14129"></span>
<span id="line14130"></span>
<span id="line14131"></span>
<span id="line14132"></span>
<span id="line14133"></span>
<span id="line14134"></span>
<span id="line14135"></span>
<span id="line14136"></span>
<span id="line14137"></span>
<span id="line14138"></span>
<span id="line14139"></span>
<span id="line14140"></span>
<span id="line14141"></span>
<span id="line14142"></span>
<span id="line14143"></span>
<span id="line14144"></span>
<span id="line14145"></span>
<span id="line14146"></span>
<span id="line14147"></span>
<span id="line14148"></span>
<span id="line14149"></span>
<span id="line14150"></span>
<span id="line14151"></span>
<span id="line14152"></span>9                                          
                            
|8|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|
<span id="line14153"></span>
<span id="line14154"></span>
<span id="line14155"></span>
<span id="line14156"></span>
<span id="line14157"></span>
<span id="line14158"></span>
<span id="line14159"></span>
<span id="line14160"></span>
<span id="line14161"></span>
<span id="line14162"></span>
<span id="line14163"></span>
<span id="line14164"></span>
<span id="line14165"></span>
<span id="line14166"></span>
<span id="line14167"></span>
<span id="line14168"></span>
<span id="line14169"></span>
<span id="line14170"></span>
<span id="line14171"></span>
<span id="line14172"></span>
<span id="line14173"></span>
<span id="line14174"></span>
<span id="line14175"></span>
<span id="line14176"></span>
<span id="line14177"></span>
<span id="line14178"></span>
<span id="line14179"></span>
<span id="line14180"></span>
<span id="line14181"></span>
<span id="line14182"></span>
<span id="line14183"></span>
<span id="line14184"></span>
<span id="line14185"></span>
<span id="line14186"></span>
<span id="line14187"></span>
<span id="line14188"></span>
<span id="line14189"></span>
<span id="line14190"></span>
<span id="line14191"></span>
<span id="line14192"></span>
<span id="line14193"></span>
<span id="line14194"></span>
<span id="line14195"></span>
<span id="line14196"></span>
<span id="line14197"></span>
<span id="line14198"></span>
<span id="line14199"></span>
<span id="line14200"></span>
<span id="line14201"></span>
<span id="line14202"></span>
<span id="line14203"></span>9                                          
                                       
|8|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|
<span id="line14204"></span>
<span id="line14205"></span>
<span id="line14206"></span>
<span id="line14207"></span>
<span id="line14208"></span>
<span id="line14209"></span>
<span id="line14210"></span>
<span id="line14211"></span>
<span id="line14212"></span>
<span id="line14213"></span>
<span id="line14214"></span>
<span id="line14215"></span>
<span id="line14216"></span>
<span id="line14217"></span>
<span id="line14218"></span>
<span id="line14219"></span>
<span id="line14220"></span>
<span id="line14221"></span>
<span id="line14222"></span>
<span id="line14223"></span>
<span id="line14224"></span>
<span id="line14225"></span>
<span id="line14226"></span>
<span id="line14227"></span>
<span id="line14228"></span>
<span id="line14229"></span>
<span id="line14230"></span>
<span id="line14231"></span>
<span id="line14232"></span>
<span id="line14233"></span>
<span id="line14234"></span>
<span id="line14235"></span>
<span id="line14236"></span>
<span id="line14237"></span>
<span id="line14238"></span>
<span id="line14239"></span>
<span id="line14240"></span>
<span id="line14241"></span>
<span id="line14242"></span>
<span id="line14243"></span>
<span id="line14244"></span>
<span id="line14245"></span>
<span id="line14246"></span>
<span id="line14247"></span>
<span id="line14248"></span>
<span id="line14249"></span>
<span id="line14250"></span>
<span id="line14251"></span>
<span id="line14252"></span>
<span id="line14253"></span>
<span id="line14254"></span>9                                          
                                                   
|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|
<span id="line14255"></span>
<span id="line14256"></span>
<span id="line14257"></span>
<span id="line14258"></span>
<span id="line14259"></span>
<span id="line14260"></span>
<span id="line14261"></span>
<span id="line14262"></span>
<span id="line14263"></span>
<span id="line14264"></span>
<span id="line14265"></span>
<span id="line14266"></span>
<span id="line14267"></span>
<span id="line14268"></span>
<span id="line14269"></span>
<span id="line14270"></span>
<span id="line14271"></span>
<span id="line14272"></span>
<span id="line14273"></span>
<span id="line14274"></span>
<span id="line14275"></span>
<span id="line14276"></span>
<span id="line14277"></span>
<span id="line14278"></span>
<span id="line14279"></span>
<span id="line14280"></span>
<span id="line14281"></span>
<span id="line14282"></span>
<span id="line14283"></span>
<span id="line14284"></span>
<span id="line14285"></span>
<span id="line14286"></span>
<span id="line14287"></span>
<span id="line14288"></span>
<span id="line14289"></span>
<span id="line14290"></span>
<span id="line14291"></span>
<span id="line14292"></span>
<span id="line14293"></span>
<span id="line14294"></span>
<span id="line14295"></span>
<span id="line14296"></span>
<span id="line14297"></span>
<span id="line14298"></span>
<span id="line14299"></span>
<span id="line14300"></span>
<span id="line14301"></span>
<span id="line14302"></span>
<span id="line14303"></span>                                            
                                                             
|8|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|
<span id="line14304"></span>
<span id="line14305"></span>
<span id="line14306"></span>
<span id="line14307"></span>
<span id="line14308"></span>
<span id="line14309"></span>
<span id="line14310"></span>
<span id="line14311"></span>
<span id="line14312"></span>
<span id="line14313"></span>
<span id="line14314"></span>
<span id="line14315"></span>
<span id="line14316"></span>
<span id="line14317"></span>
<span id="line14318"></span>
<span id="line14319"></span>
<span id="line14320"></span>
<span id="line14321"></span>
<span id="line14322"></span>
<span id="line14323"></span>
<span id="line14324"></span>
<span id="line14325"></span>
<span id="line14326"></span>
<span id="line14327"></span>
<span id="line14328"></span>
<span id="line14329"></span>
<span id="line14330"></span>
<span id="line14331"></span>
<span id="line14332"></span>
<span id="line14333"></span>
<span id="line14334"></span>
<span id="line14335"></span>
<span id="line14336"></span>
<span id="line14337"></span>
<span id="line14338"></span>
<span id="line14339"></span>
<span id="line14340"></span>
<span id="line14341"></span>
<span id="line14342"></span>
<span id="line14343"></span>
<span id="line14344"></span>
<span id="line14345"></span>
<span id="line14346"></span>
<span id="line14347"></span>
<span id="line14348"></span>
<span id="line14349"></span>
<span id="line14350"></span>
<span id="line14351"></span>
<span id="line14352"></span>
<span id="line14353"></span>
<span id="line14354"></span>
<span id="line14355"></span>
<span id="line14356"></span>9
<span id="line14357"></span>
<span id="line14358"></span>
<span id="line14359"></span>
<span id="line14360"></span>
<span id="line14361"></span>          FUNCTIONS AND SUBROUTINES                ANSI X3J3/90.4
<span id="line14362"></span>
<span id="line14363"></span>
<span id="line14364"></span>
<span id="line14365"></span>                            Table 5 (continued)
<span id="line14366"></span>                            Intrinsic Functions
<span id="line14367"></span>
<span id="line14368"></span>8          ________________________________________________________________________________________________
<span id="line14369"></span>
<span id="line14370"></span>                                                    Number of   Generic   Specific         Type of
<span id="line14371"></span>           Intrinsic Function    Definition         Arguments    Name     Name       Argument    Function
<span id="line14372"></span>8          ________________________________________________________________________________________________
<span id="line14373"></span>
<span id="line14374"></span>           Remaindering          a_918-int(a_918/a_928)*a_928       2       MOD       MOD        Integer     Integer
<span id="line14375"></span>                                 See Note 1                               AMOD       Real        Real
<span id="line14376"></span>                                                                          DMOD       Double      Double
<span id="line14377"></span>8          ________________________________________________________________________________________________
<span id="line14378"></span>
<span id="line14379"></span>           Transfer of Sign      |a_918|  if a_928 <span class="entity"><span>&amp;</span>gt;</span> 0        2       SIGN      ISIGN      Integer     Integer
<span id="line14380"></span>                                 -|a_918| if a_928 <span class="entity"><span>&amp;</span>lt;</span> 0                          SIGN       Real        Real
<span id="line14381"></span>                                                                          DSIGN      Double      Double
<span id="line14382"></span>8          ________________________________________________________________________________________________
<span id="line14383"></span>
<span id="line14384"></span>           Positive Difference   a_918-a_928 if a_918<span class="entity"><span>&amp;</span>gt;</span>a_928         2       DIM       IDIM       Integer     Integer
<span id="line14385"></span>                                   0   if a_918</span><span>&lt;<span class="start-tag">a_928</span> <span class="attribute-name">dim</span>="<a class="attribute-value"></a>" <span class="attribute-name">ddim</span>="<a class="attribute-value"></a>" <span class="attribute-name">precision</span>="<a class="attribute-value"></a>" <span class="attribute-name">a_918*a_928</span>="<a class="attribute-value"></a>" <span class="attribute-name">2</span>="<a class="attribute-value"></a>" <span class="attribute-name">dprod</span>="<a class="attribute-value"></a>" <span class="attribute-name">real</span>="<a class="attribute-value"></a>" <span class="attribute-name">double</span>="<a class="attribute-value"></a>" <span class="attribute-name">product</span>="<a class="attribute-value"></a>" <span class="attribute-name">8</span>="<a class="attribute-value"></a>" <span class="attribute-name">________________________________________________________________________________________________</span>="<a class="attribute-value"></a>" <span class="attribute-name">choosing</span>="<a class="attribute-value"></a>" <span class="attribute-name">largest</span>="<a class="attribute-value"></a>" <span class="attribute-name">max(a_918,a_928,...)</span>="<a class="attribute-value"></a>"&gt;</span><span>2       Max       MAX0       Integer     Integer
<span id="line14386"></span>             Value                                                        AMAX1      Real        Real
<span id="line14387"></span>                                                                          DMAX1      Double      Double
<span id="line14388"></span>8                                                               ___________________________________________
<span id="line14389"></span>
<span id="line14390"></span>                                                                          AMAX0      Integer     Real
<span id="line14391"></span>                                                                          MAX1       Real        Integer
<span id="line14392"></span>8          ________________________________________________________________________________________________
<span id="line14393"></span>
<span id="line14394"></span>           Choosing Smallest     min(a_918,a_928,...)        <span class="entity"><span>&amp;</span>gt;</span>2       MIN       MIN0       Integer     Integer
<span id="line14395"></span>             Value                                                        AMIN1      Real        Real
<span id="line14396"></span>                                                                          DMIN1      Double      Double
<span id="line14397"></span>8                                                               ___________________________________________
<span id="line14398"></span>
<span id="line14399"></span>                                                                          AMIN0      Integer     Real
<span id="line14400"></span>                                                                          MIN1       Real        Integer
<span id="line14401"></span>8          ________________________________________________________________________________________________
<span id="line14402"></span>
<span id="line14403"></span>           Length                Length of              1                 LEN        Character   Integer
<span id="line14404"></span>                                 Character Entity
<span id="line14405"></span>8          ________________________________________________________________________________________________
<span id="line14406"></span>
<span id="line14407"></span>           Index of              Location of            2                 INDEX      Character   Integer
<span id="line14408"></span>           a Substring           Substring a_92
<span id="line14409"></span>8                                 in String a_91
<span id="line14410"></span>8                                 See Note 10
<span id="line14411"></span>8          ________________________________________________________________________________________________
<span id="line14412"></span>
<span id="line14413"></span>           Imaginary Part of     ai__                     1                 AIMAG      Complex     Real
<span id="line14414"></span>            Complex Argument     See Note 6
<span id="line14415"></span>8          ________________________________________________________________________________________________
<span id="line14416"></span>
<span id="line14417"></span>           Conjugate of a        (ar__,-ai__)               1                 CONJG      Complex     Complex
<span id="line14418"></span>            Complex Argument     See Note 6
<span id="line14419"></span>8          ________________________________________________________________________________________________
<span id="line14420"></span>
<span id="line14421"></span>           Square Root           (a_)81/29                 1       SQRT      SQRT       Real        Real
<span id="line14422"></span>                                                                          DSQRT      Double      Double
<span id="line14423"></span>                                                                          CSQRT      Complex     Complex
<span id="line14424"></span>8          ________________________________________________________________________________________________
<span id="line14425"></span>7         
|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|
<span id="line14426"></span>
<span id="line14427"></span>
<span id="line14428"></span>
<span id="line14429"></span>
<span id="line14430"></span>
<span id="line14431"></span>
<span id="line14432"></span>
<span id="line14433"></span>
<span id="line14434"></span>
<span id="line14435"></span>
<span id="line14436"></span>
<span id="line14437"></span>
<span id="line14438"></span>
<span id="line14439"></span>
<span id="line14440"></span>
<span id="line14441"></span>
<span id="line14442"></span>
<span id="line14443"></span>
<span id="line14444"></span>
<span id="line14445"></span>
<span id="line14446"></span>
<span id="line14447"></span>
<span id="line14448"></span>
<span id="line14449"></span>
<span id="line14450"></span>
<span id="line14451"></span>
<span id="line14452"></span>
<span id="line14453"></span>
<span id="line14454"></span>
<span id="line14455"></span>
<span id="line14456"></span>
<span id="line14457"></span>
<span id="line14458"></span>
<span id="line14459"></span>
<span id="line14460"></span>
<span id="line14461"></span>
<span id="line14462"></span>
<span id="line14463"></span>
<span id="line14464"></span>
<span id="line14465"></span>
<span id="line14466"></span>
<span id="line14467"></span>
<span id="line14468"></span>
<span id="line14469"></span>
<span id="line14470"></span>
<span id="line14471"></span>
<span id="line14472"></span>
<span id="line14473"></span>
<span id="line14474"></span>
<span id="line14475"></span>
<span id="line14476"></span>
<span id="line14477"></span>
<span id="line14478"></span>
<span id="line14479"></span>
<span id="line14480"></span>
<span id="line14481"></span>                              
|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|
<span id="line14482"></span>
<span id="line14483"></span>
<span id="line14484"></span>
<span id="line14485"></span>
<span id="line14486"></span>
<span id="line14487"></span>
<span id="line14488"></span>
<span id="line14489"></span>
<span id="line14490"></span>
<span id="line14491"></span>
<span id="line14492"></span>
<span id="line14493"></span>
<span id="line14494"></span>
<span id="line14495"></span>
<span id="line14496"></span>
<span id="line14497"></span>
<span id="line14498"></span>
<span id="line14499"></span>
<span id="line14500"></span>
<span id="line14501"></span>
<span id="line14502"></span>
<span id="line14503"></span>
<span id="line14504"></span>
<span id="line14505"></span>
<span id="line14506"></span>
<span id="line14507"></span>
<span id="line14508"></span>
<span id="line14509"></span>
<span id="line14510"></span>
<span id="line14511"></span>
<span id="line14512"></span>
<span id="line14513"></span>
<span id="line14514"></span>
<span id="line14515"></span>
<span id="line14516"></span>
<span id="line14517"></span>
<span id="line14518"></span>
<span id="line14519"></span>
<span id="line14520"></span>
<span id="line14521"></span>
<span id="line14522"></span>
<span id="line14523"></span>
<span id="line14524"></span>
<span id="line14525"></span>
<span id="line14526"></span>
<span id="line14527"></span>
<span id="line14528"></span>
<span id="line14529"></span>
<span id="line14530"></span>
<span id="line14531"></span>
<span id="line14532"></span>
<span id="line14533"></span>
<span id="line14534"></span>
<span id="line14535"></span>
<span id="line14536"></span>
<span id="line14537"></span>                                            
     
|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|
<span id="line14538"></span>
<span id="line14539"></span>
<span id="line14540"></span>
<span id="line14541"></span>
<span id="line14542"></span>
<span id="line14543"></span>
<span id="line14544"></span>
<span id="line14545"></span>
<span id="line14546"></span>
<span id="line14547"></span>
<span id="line14548"></span>
<span id="line14549"></span>
<span id="line14550"></span>
<span id="line14551"></span>
<span id="line14552"></span>
<span id="line14553"></span>
<span id="line14554"></span>
<span id="line14555"></span>
<span id="line14556"></span>
<span id="line14557"></span>
<span id="line14558"></span>
<span id="line14559"></span>
<span id="line14560"></span>
<span id="line14561"></span>
<span id="line14562"></span>
<span id="line14563"></span>
<span id="line14564"></span>
<span id="line14565"></span>
<span id="line14566"></span>
<span id="line14567"></span>
<span id="line14568"></span>
<span id="line14569"></span>
<span id="line14570"></span>
<span id="line14571"></span>
<span id="line14572"></span>
<span id="line14573"></span>
<span id="line14574"></span>
<span id="line14575"></span>
<span id="line14576"></span>
<span id="line14577"></span>
<span id="line14578"></span>
<span id="line14579"></span>
<span id="line14580"></span>
<span id="line14581"></span>
<span id="line14582"></span>
<span id="line14583"></span>
<span id="line14584"></span>
<span id="line14585"></span>
<span id="line14586"></span>
<span id="line14587"></span>
<span id="line14588"></span>
<span id="line14589"></span>
<span id="line14590"></span>
<span id="line14591"></span>
<span id="line14592"></span>
<span id="line14593"></span>                                            
                 
|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|
<span id="line14594"></span>
<span id="line14595"></span>
<span id="line14596"></span>
<span id="line14597"></span>
<span id="line14598"></span>
<span id="line14599"></span>
<span id="line14600"></span>
<span id="line14601"></span>
<span id="line14602"></span>
<span id="line14603"></span>
<span id="line14604"></span>
<span id="line14605"></span>
<span id="line14606"></span>
<span id="line14607"></span>
<span id="line14608"></span>
<span id="line14609"></span>
<span id="line14610"></span>
<span id="line14611"></span>
<span id="line14612"></span>
<span id="line14613"></span>
<span id="line14614"></span>
<span id="line14615"></span>
<span id="line14616"></span>
<span id="line14617"></span>
<span id="line14618"></span>
<span id="line14619"></span>
<span id="line14620"></span>
<span id="line14621"></span>
<span id="line14622"></span>
<span id="line14623"></span>
<span id="line14624"></span>
<span id="line14625"></span>
<span id="line14626"></span>
<span id="line14627"></span>
<span id="line14628"></span>
<span id="line14629"></span>
<span id="line14630"></span>
<span id="line14631"></span>
<span id="line14632"></span>
<span id="line14633"></span>
<span id="line14634"></span>
<span id="line14635"></span>
<span id="line14636"></span>
<span id="line14637"></span>
<span id="line14638"></span>
<span id="line14639"></span>
<span id="line14640"></span>
<span id="line14641"></span>
<span id="line14642"></span>
<span id="line14643"></span>
<span id="line14644"></span>
<span id="line14645"></span>
<span id="line14646"></span>
<span id="line14647"></span>
<span id="line14648"></span>
<span id="line14649"></span>                                            
                           
|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|
<span id="line14650"></span>
<span id="line14651"></span>
<span id="line14652"></span>
<span id="line14653"></span>
<span id="line14654"></span>
<span id="line14655"></span>
<span id="line14656"></span>
<span id="line14657"></span>
<span id="line14658"></span>
<span id="line14659"></span>
<span id="line14660"></span>
<span id="line14661"></span>
<span id="line14662"></span>
<span id="line14663"></span>
<span id="line14664"></span>
<span id="line14665"></span>
<span id="line14666"></span>
<span id="line14667"></span>
<span id="line14668"></span>
<span id="line14669"></span>
<span id="line14670"></span>
<span id="line14671"></span>
<span id="line14672"></span>
<span id="line14673"></span>
<span id="line14674"></span>
<span id="line14675"></span>
<span id="line14676"></span>
<span id="line14677"></span>
<span id="line14678"></span>
<span id="line14679"></span>
<span id="line14680"></span>
<span id="line14681"></span>
<span id="line14682"></span>
<span id="line14683"></span>
<span id="line14684"></span>
<span id="line14685"></span>
<span id="line14686"></span>
<span id="line14687"></span>
<span id="line14688"></span>
<span id="line14689"></span>
<span id="line14690"></span>
<span id="line14691"></span>
<span id="line14692"></span>
<span id="line14693"></span>
<span id="line14694"></span>
<span id="line14695"></span>
<span id="line14696"></span>
<span id="line14697"></span>
<span id="line14698"></span>
<span id="line14699"></span>
<span id="line14700"></span>
<span id="line14701"></span>
<span id="line14702"></span>
<span id="line14703"></span>
<span id="line14704"></span>
<span id="line14705"></span>                                            
                                      
|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|
<span id="line14706"></span>
<span id="line14707"></span>
<span id="line14708"></span>
<span id="line14709"></span>
<span id="line14710"></span>
<span id="line14711"></span>
<span id="line14712"></span>
<span id="line14713"></span>
<span id="line14714"></span>
<span id="line14715"></span>
<span id="line14716"></span>
<span id="line14717"></span>
<span id="line14718"></span>
<span id="line14719"></span>
<span id="line14720"></span>
<span id="line14721"></span>
<span id="line14722"></span>
<span id="line14723"></span>
<span id="line14724"></span>
<span id="line14725"></span>
<span id="line14726"></span>
<span id="line14727"></span>
<span id="line14728"></span>
<span id="line14729"></span>
<span id="line14730"></span>
<span id="line14731"></span>
<span id="line14732"></span>
<span id="line14733"></span>
<span id="line14734"></span>
<span id="line14735"></span>
<span id="line14736"></span>
<span id="line14737"></span>
<span id="line14738"></span>
<span id="line14739"></span>
<span id="line14740"></span>
<span id="line14741"></span>
<span id="line14742"></span>
<span id="line14743"></span>
<span id="line14744"></span>
<span id="line14745"></span>
<span id="line14746"></span>
<span id="line14747"></span>
<span id="line14748"></span>
<span id="line14749"></span>
<span id="line14750"></span>
<span id="line14751"></span>
<span id="line14752"></span>
<span id="line14753"></span>
<span id="line14754"></span>
<span id="line14755"></span>
<span id="line14756"></span>
<span id="line14757"></span>
<span id="line14758"></span>
<span id="line14759"></span>
<span id="line14760"></span>
<span id="line14761"></span>                                            
                                                  
|8|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|
<span id="line14762"></span>
<span id="line14763"></span>
<span id="line14764"></span>
<span id="line14765"></span>
<span id="line14766"></span>
<span id="line14767"></span>
<span id="line14768"></span>
<span id="line14769"></span>
<span id="line14770"></span>
<span id="line14771"></span>
<span id="line14772"></span>
<span id="line14773"></span>
<span id="line14774"></span>
<span id="line14775"></span>
<span id="line14776"></span>
<span id="line14777"></span>
<span id="line14778"></span>
<span id="line14779"></span>
<span id="line14780"></span>
<span id="line14781"></span>
<span id="line14782"></span>
<span id="line14783"></span>
<span id="line14784"></span>
<span id="line14785"></span>
<span id="line14786"></span>
<span id="line14787"></span>
<span id="line14788"></span>
<span id="line14789"></span>
<span id="line14790"></span>
<span id="line14791"></span>
<span id="line14792"></span>
<span id="line14793"></span>
<span id="line14794"></span>
<span id="line14795"></span>
<span id="line14796"></span>
<span id="line14797"></span>
<span id="line14798"></span>
<span id="line14799"></span>
<span id="line14800"></span>
<span id="line14801"></span>
<span id="line14802"></span>
<span id="line14803"></span>
<span id="line14804"></span>
<span id="line14805"></span>
<span id="line14806"></span>
<span id="line14807"></span>
<span id="line14808"></span>
<span id="line14809"></span>
<span id="line14810"></span>
<span id="line14811"></span>
<span id="line14812"></span>
<span id="line14813"></span>
<span id="line14814"></span>9                                          
                                                               
|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|
<span id="line14815"></span>
<span id="line14816"></span>
<span id="line14817"></span>
<span id="line14818"></span>
<span id="line14819"></span>
<span id="line14820"></span>
<span id="line14821"></span>
<span id="line14822"></span>
<span id="line14823"></span>
<span id="line14824"></span>
<span id="line14825"></span>
<span id="line14826"></span>
<span id="line14827"></span>
<span id="line14828"></span>
<span id="line14829"></span>
<span id="line14830"></span>
<span id="line14831"></span>
<span id="line14832"></span>
<span id="line14833"></span>
<span id="line14834"></span>
<span id="line14835"></span>
<span id="line14836"></span>
<span id="line14837"></span>
<span id="line14838"></span>
<span id="line14839"></span>
<span id="line14840"></span>
<span id="line14841"></span>
<span id="line14842"></span>
<span id="line14843"></span>
<span id="line14844"></span>
<span id="line14845"></span>
<span id="line14846"></span>
<span id="line14847"></span>
<span id="line14848"></span>
<span id="line14849"></span>
<span id="line14850"></span>
<span id="line14851"></span>
<span id="line14852"></span>
<span id="line14853"></span>
<span id="line14854"></span>
<span id="line14855"></span>
<span id="line14856"></span>
<span id="line14857"></span>
<span id="line14858"></span>
<span id="line14859"></span>
<span id="line14860"></span>
<span id="line14861"></span>
<span id="line14862"></span>
<span id="line14863"></span>
<span id="line14864"></span>
<span id="line14865"></span>
<span id="line14866"></span>
<span id="line14867"></span>
<span id="line14868"></span>
<span id="line14869"></span>
<span id="line14870"></span>
<span id="line14871"></span>
<span id="line14872"></span>
<span id="line14873"></span>
<span id="line14874"></span>
<span id="line14875"></span>          FUNCTIONS AND SUBROUTINES                ANSI X3J3/90.4
<span id="line14876"></span>
<span id="line14877"></span>
<span id="line14878"></span>
<span id="line14879"></span>                            Table 5 (continued)
<span id="line14880"></span>                            Intrinsic Functions
<span id="line14881"></span>
<span id="line14882"></span>8          ___________________________________________________________________________________________
<span id="line14883"></span>
<span id="line14884"></span>                                                Number of   Generic   Specific         Type of
<span id="line14885"></span>           Intrinsic Function   Definition      Arguments    Name     Name       Argument   Function
<span id="line14886"></span>8          ___________________________________________________________________________________________
<span id="line14887"></span>
<span id="line14888"></span>           Exponential          e**a_                1       EXP       EXP        Real       Real
<span id="line14889"></span>                                                                      DEXP       Double     Double
<span id="line14890"></span>                                                                      CEXP       Complex    Complex
<span id="line14891"></span>8          ___________________________________________________________________________________________
<span id="line14892"></span>
<span id="line14893"></span>           Natural Logarithm    log(a_)              1       LOG       ALOG       Real       Real
<span id="line14894"></span>                                                                      DLOG       Double     Double
<span id="line14895"></span>                                                                      CLOG       Complex    Complex
<span id="line14896"></span>8          ___________________________________________________________________________________________
<span id="line14897"></span>
<span id="line14898"></span>           Common Logarithm     log10(a_)            1       LOG10     ALOG10     Real       Real
<span id="line14899"></span>                                                                      DLOG10     Double     Double
<span id="line14900"></span>8          ___________________________________________________________________________________________
<span id="line14901"></span>
<span id="line14902"></span>           Sine                 sin(a_)              1       SIN       SIN        Real       Real
<span id="line14903"></span>                                                                      DSIN       Double     Double
<span id="line14904"></span>                                                                      CSIN       Complex    Complex
<span id="line14905"></span>8          ___________________________________________________________________________________________
<span id="line14906"></span>
<span id="line14907"></span>           Cosine               cos(a_)              1       COS       COS        Real       Real
<span id="line14908"></span>                                                                      DCOS       Double     Double
<span id="line14909"></span>                                                                      CCOS       Complex    Complex
<span id="line14910"></span>8          ___________________________________________________________________________________________
<span id="line14911"></span>
<span id="line14912"></span>           Tangent              tan(a_)              1       TAN       TAN        Real       Real
<span id="line14913"></span>                                                                      DTAN       Double     Double
<span id="line14914"></span>8          ___________________________________________________________________________________________
<span id="line14915"></span>
<span id="line14916"></span>           Arcsine              arcsin(a_)           1       ASIN      ASIN       Real       Real
<span id="line14917"></span>                                                                      DASIN      Double     Double
<span id="line14918"></span>8          ___________________________________________________________________________________________
<span id="line14919"></span>
<span id="line14920"></span>           Arccosine            arccos(a_)           1       ACOS      ACOS       Real       Real
<span id="line14921"></span>                                                                      DACOS      Double     Double
<span id="line14922"></span>8          ___________________________________________________________________________________________
<span id="line14923"></span>
<span id="line14924"></span>           Arctangent           arctan(a_)           1       ATAN      ATAN       Real       Real
<span id="line14925"></span>                                                                      DATAN      Double     Double
<span id="line14926"></span>8                               ______________________________________________________________________
<span id="line14927"></span>
<span id="line14928"></span>                                arctan(a_918/a_928)       2       ATAN2     ATAN2      Real       Real
<span id="line14929"></span>                                                                      DATAN2     Double     Double
<span id="line14930"></span>8          ___________________________________________________________________________________________
<span id="line14931"></span>
<span id="line14932"></span>           Hyperbolic Sine      sinh(a_)             1       SINH      SINH       Real       Real
<span id="line14933"></span>                                                                      DSINH      Double     Double
<span id="line14934"></span>8          ___________________________________________________________________________________________
<span id="line14935"></span>
<span id="line14936"></span>           Hyperbolic Cosine    cosh(a_)             1       COSH      COSH       Real       Real
<span id="line14937"></span>                                                                      DCOSH      Double     Double
<span id="line14938"></span>8          ___________________________________________________________________________________________
<span id="line14939"></span>
<span id="line14940"></span>           Hyperbolic Tangent   tanh(a_)             1       TANH      TANH       Real       Real
<span id="line14941"></span>                                                                      DTANH      Double     Double
<span id="line14942"></span>8          ___________________________________________________________________________________________
<span id="line14943"></span>7         
|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|
<span id="line14944"></span>
<span id="line14945"></span>
<span id="line14946"></span>
<span id="line14947"></span>
<span id="line14948"></span>
<span id="line14949"></span>
<span id="line14950"></span>
<span id="line14951"></span>
<span id="line14952"></span>
<span id="line14953"></span>
<span id="line14954"></span>
<span id="line14955"></span>
<span id="line14956"></span>
<span id="line14957"></span>
<span id="line14958"></span>
<span id="line14959"></span>
<span id="line14960"></span>
<span id="line14961"></span>
<span id="line14962"></span>
<span id="line14963"></span>
<span id="line14964"></span>
<span id="line14965"></span>
<span id="line14966"></span>
<span id="line14967"></span>
<span id="line14968"></span>
<span id="line14969"></span>
<span id="line14970"></span>
<span id="line14971"></span>
<span id="line14972"></span>
<span id="line14973"></span>
<span id="line14974"></span>
<span id="line14975"></span>
<span id="line14976"></span>
<span id="line14977"></span>
<span id="line14978"></span>
<span id="line14979"></span>
<span id="line14980"></span>
<span id="line14981"></span>
<span id="line14982"></span>
<span id="line14983"></span>
<span id="line14984"></span>
<span id="line14985"></span>
<span id="line14986"></span>
<span id="line14987"></span>
<span id="line14988"></span>
<span id="line14989"></span>
<span id="line14990"></span>
<span id="line14991"></span>
<span id="line14992"></span>
<span id="line14993"></span>
<span id="line14994"></span>
<span id="line14995"></span>                             
|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|
<span id="line14996"></span>
<span id="line14997"></span>
<span id="line14998"></span>
<span id="line14999"></span>
<span id="line15000"></span>
<span id="line15001"></span>
<span id="line15002"></span>
<span id="line15003"></span>
<span id="line15004"></span>
<span id="line15005"></span>
<span id="line15006"></span>
<span id="line15007"></span>
<span id="line15008"></span>
<span id="line15009"></span>
<span id="line15010"></span>
<span id="line15011"></span>
<span id="line15012"></span>
<span id="line15013"></span>
<span id="line15014"></span>
<span id="line15015"></span>
<span id="line15016"></span>
<span id="line15017"></span>
<span id="line15018"></span>
<span id="line15019"></span>
<span id="line15020"></span>
<span id="line15021"></span>
<span id="line15022"></span>
<span id="line15023"></span>
<span id="line15024"></span>
<span id="line15025"></span>
<span id="line15026"></span>
<span id="line15027"></span>
<span id="line15028"></span>
<span id="line15029"></span>
<span id="line15030"></span>
<span id="line15031"></span>
<span id="line15032"></span>
<span id="line15033"></span>
<span id="line15034"></span>
<span id="line15035"></span>
<span id="line15036"></span>
<span id="line15037"></span>
<span id="line15038"></span>
<span id="line15039"></span>
<span id="line15040"></span>
<span id="line15041"></span>
<span id="line15042"></span>
<span id="line15043"></span>
<span id="line15044"></span>
<span id="line15045"></span>
<span id="line15046"></span>
<span id="line15047"></span>                                            
 
|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|
<span id="line15048"></span>
<span id="line15049"></span>
<span id="line15050"></span>
<span id="line15051"></span>
<span id="line15052"></span>
<span id="line15053"></span>
<span id="line15054"></span>
<span id="line15055"></span>
<span id="line15056"></span>
<span id="line15057"></span>
<span id="line15058"></span>
<span id="line15059"></span>
<span id="line15060"></span>
<span id="line15061"></span>
<span id="line15062"></span>
<span id="line15063"></span>
<span id="line15064"></span>
<span id="line15065"></span>
<span id="line15066"></span>
<span id="line15067"></span>
<span id="line15068"></span>
<span id="line15069"></span>
<span id="line15070"></span>
<span id="line15071"></span>
<span id="line15072"></span>
<span id="line15073"></span>
<span id="line15074"></span>
<span id="line15075"></span>
<span id="line15076"></span>
<span id="line15077"></span>
<span id="line15078"></span>
<span id="line15079"></span>
<span id="line15080"></span>
<span id="line15081"></span>
<span id="line15082"></span>
<span id="line15083"></span>
<span id="line15084"></span>
<span id="line15085"></span>
<span id="line15086"></span>
<span id="line15087"></span>
<span id="line15088"></span>
<span id="line15089"></span>
<span id="line15090"></span>
<span id="line15091"></span>
<span id="line15092"></span>
<span id="line15093"></span>
<span id="line15094"></span>
<span id="line15095"></span>
<span id="line15096"></span>
<span id="line15097"></span>
<span id="line15098"></span>
<span id="line15099"></span>                                            
             
|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|
<span id="line15100"></span>
<span id="line15101"></span>
<span id="line15102"></span>
<span id="line15103"></span>
<span id="line15104"></span>
<span id="line15105"></span>
<span id="line15106"></span>
<span id="line15107"></span>
<span id="line15108"></span>
<span id="line15109"></span>
<span id="line15110"></span>
<span id="line15111"></span>
<span id="line15112"></span>
<span id="line15113"></span>
<span id="line15114"></span>
<span id="line15115"></span>
<span id="line15116"></span>
<span id="line15117"></span>
<span id="line15118"></span>
<span id="line15119"></span>
<span id="line15120"></span>
<span id="line15121"></span>
<span id="line15122"></span>
<span id="line15123"></span>
<span id="line15124"></span>
<span id="line15125"></span>
<span id="line15126"></span>
<span id="line15127"></span>
<span id="line15128"></span>
<span id="line15129"></span>
<span id="line15130"></span>
<span id="line15131"></span>
<span id="line15132"></span>
<span id="line15133"></span>
<span id="line15134"></span>
<span id="line15135"></span>
<span id="line15136"></span>
<span id="line15137"></span>
<span id="line15138"></span>
<span id="line15139"></span>
<span id="line15140"></span>
<span id="line15141"></span>
<span id="line15142"></span>
<span id="line15143"></span>
<span id="line15144"></span>
<span id="line15145"></span>
<span id="line15146"></span>
<span id="line15147"></span>
<span id="line15148"></span>
<span id="line15149"></span>
<span id="line15150"></span>
<span id="line15151"></span>                                            
                       
|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|
<span id="line15152"></span>
<span id="line15153"></span>
<span id="line15154"></span>
<span id="line15155"></span>
<span id="line15156"></span>
<span id="line15157"></span>
<span id="line15158"></span>
<span id="line15159"></span>
<span id="line15160"></span>
<span id="line15161"></span>
<span id="line15162"></span>
<span id="line15163"></span>
<span id="line15164"></span>
<span id="line15165"></span>
<span id="line15166"></span>
<span id="line15167"></span>
<span id="line15168"></span>
<span id="line15169"></span>
<span id="line15170"></span>
<span id="line15171"></span>
<span id="line15172"></span>
<span id="line15173"></span>
<span id="line15174"></span>
<span id="line15175"></span>
<span id="line15176"></span>
<span id="line15177"></span>
<span id="line15178"></span>
<span id="line15179"></span>
<span id="line15180"></span>
<span id="line15181"></span>
<span id="line15182"></span>
<span id="line15183"></span>
<span id="line15184"></span>
<span id="line15185"></span>
<span id="line15186"></span>
<span id="line15187"></span>
<span id="line15188"></span>
<span id="line15189"></span>
<span id="line15190"></span>
<span id="line15191"></span>
<span id="line15192"></span>
<span id="line15193"></span>
<span id="line15194"></span>
<span id="line15195"></span>
<span id="line15196"></span>
<span id="line15197"></span>
<span id="line15198"></span>
<span id="line15199"></span>
<span id="line15200"></span>
<span id="line15201"></span>
<span id="line15202"></span>
<span id="line15203"></span>                                            
                                  
|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|
<span id="line15204"></span>
<span id="line15205"></span>
<span id="line15206"></span>
<span id="line15207"></span>
<span id="line15208"></span>
<span id="line15209"></span>
<span id="line15210"></span>
<span id="line15211"></span>
<span id="line15212"></span>
<span id="line15213"></span>
<span id="line15214"></span>
<span id="line15215"></span>
<span id="line15216"></span>
<span id="line15217"></span>
<span id="line15218"></span>
<span id="line15219"></span>
<span id="line15220"></span>
<span id="line15221"></span>
<span id="line15222"></span>
<span id="line15223"></span>
<span id="line15224"></span>
<span id="line15225"></span>
<span id="line15226"></span>
<span id="line15227"></span>
<span id="line15228"></span>
<span id="line15229"></span>
<span id="line15230"></span>
<span id="line15231"></span>
<span id="line15232"></span>
<span id="line15233"></span>
<span id="line15234"></span>
<span id="line15235"></span>
<span id="line15236"></span>
<span id="line15237"></span>
<span id="line15238"></span>
<span id="line15239"></span>
<span id="line15240"></span>
<span id="line15241"></span>
<span id="line15242"></span>
<span id="line15243"></span>
<span id="line15244"></span>
<span id="line15245"></span>
<span id="line15246"></span>
<span id="line15247"></span>
<span id="line15248"></span>
<span id="line15249"></span>
<span id="line15250"></span>
<span id="line15251"></span>
<span id="line15252"></span>
<span id="line15253"></span>
<span id="line15254"></span>
<span id="line15255"></span>                                            
                                             
|8|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|
<span id="line15256"></span>
<span id="line15257"></span>
<span id="line15258"></span>
<span id="line15259"></span>
<span id="line15260"></span>
<span id="line15261"></span>
<span id="line15262"></span>
<span id="line15263"></span>
<span id="line15264"></span>
<span id="line15265"></span>
<span id="line15266"></span>
<span id="line15267"></span>
<span id="line15268"></span>
<span id="line15269"></span>
<span id="line15270"></span>
<span id="line15271"></span>
<span id="line15272"></span>
<span id="line15273"></span>
<span id="line15274"></span>
<span id="line15275"></span>
<span id="line15276"></span>
<span id="line15277"></span>
<span id="line15278"></span>
<span id="line15279"></span>
<span id="line15280"></span>
<span id="line15281"></span>
<span id="line15282"></span>
<span id="line15283"></span>
<span id="line15284"></span>
<span id="line15285"></span>
<span id="line15286"></span>
<span id="line15287"></span>
<span id="line15288"></span>
<span id="line15289"></span>
<span id="line15290"></span>
<span id="line15291"></span>
<span id="line15292"></span>
<span id="line15293"></span>
<span id="line15294"></span>
<span id="line15295"></span>
<span id="line15296"></span>
<span id="line15297"></span>
<span id="line15298"></span>
<span id="line15299"></span>
<span id="line15300"></span>
<span id="line15301"></span>
<span id="line15302"></span>
<span id="line15303"></span>
<span id="line15304"></span>9                                          
                                                          
|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|
<span id="line15305"></span>
<span id="line15306"></span>
<span id="line15307"></span>
<span id="line15308"></span>
<span id="line15309"></span>
<span id="line15310"></span>
<span id="line15311"></span>
<span id="line15312"></span>
<span id="line15313"></span>
<span id="line15314"></span>
<span id="line15315"></span>
<span id="line15316"></span>
<span id="line15317"></span>
<span id="line15318"></span>
<span id="line15319"></span>
<span id="line15320"></span>
<span id="line15321"></span>
<span id="line15322"></span>
<span id="line15323"></span>
<span id="line15324"></span>
<span id="line15325"></span>
<span id="line15326"></span>
<span id="line15327"></span>
<span id="line15328"></span>
<span id="line15329"></span>
<span id="line15330"></span>
<span id="line15331"></span>
<span id="line15332"></span>
<span id="line15333"></span>
<span id="line15334"></span>
<span id="line15335"></span>
<span id="line15336"></span>
<span id="line15337"></span>
<span id="line15338"></span>
<span id="line15339"></span>
<span id="line15340"></span>
<span id="line15341"></span>
<span id="line15342"></span>
<span id="line15343"></span>
<span id="line15344"></span>
<span id="line15345"></span>
<span id="line15346"></span>
<span id="line15347"></span>
<span id="line15348"></span>
<span id="line15349"></span>
<span id="line15350"></span>
<span id="line15351"></span>
<span id="line15352"></span>
<span id="line15353"></span>
<span id="line15354"></span>
<span id="line15355"></span>
<span id="line15356"></span>
<span id="line15357"></span>
<span id="line15358"></span>
<span id="line15359"></span>9
<span id="line15360"></span>
<span id="line15361"></span>
<span id="line15362"></span>          FUNCTIONS AND SUBROUTINES                ANSI X3J3/90.4
<span id="line15363"></span>
<span id="line15364"></span>
<span id="line15365"></span>
<span id="line15366"></span>                            Table 5 (continued)
<span id="line15367"></span>                            Intrinsic Functions
<span id="line15368"></span>
<span id="line15369"></span>8          __________________________________________________________________________________________
<span id="line15370"></span>
<span id="line15371"></span>                                              Number of   Generic   Specific         Type of
<span id="line15372"></span>           Intrinsic Function   Definition    Arguments    Name     Name       Argument    Function
<span id="line15373"></span>8          __________________________________________________________________________________________
<span id="line15374"></span>
<span id="line15375"></span>           Lexically Greater    a_918 <span class="entity"><span>&amp;</span>gt;</span> a_928           2                 LGE        Character   Logical
<span id="line15376"></span>             Than or Equal      See Note 12
<span id="line15377"></span>8          __________________________________________________________________________________________
<span id="line15378"></span>
<span id="line15379"></span>           Lexically Greater    a_918 <span class="entity"><span>&amp;</span>gt;</span> a_928           2                 LGT        Character   Logical
<span id="line15380"></span>             Than               See Note 12
<span id="line15381"></span>8          __________________________________________________________________________________________
<span id="line15382"></span>
<span id="line15383"></span>           Lexically Less       a_918 <span class="entity"><span>&amp;</span>lt;</span> a_928           2                 LLE        Character   Logical
<span id="line15384"></span>             Than or Equal      See Note 12
<span id="line15385"></span>8          __________________________________________________________________________________________
<span id="line15386"></span>
<span id="line15387"></span>           Lexically Less       a_918 <span class="entity"><span>&amp;</span>lt;</span> a_928           2                 LLT        Character   Logical
<span id="line15388"></span>             Than               See Note 12
<span id="line15389"></span>8          __________________________________________________________________________________________
<span id="line15390"></span>7         |8|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|
<span id="line15391"></span>
<span id="line15392"></span>
<span id="line15393"></span>
<span id="line15394"></span>
<span id="line15395"></span>
<span id="line15396"></span>
<span id="line15397"></span>
<span id="line15398"></span>
<span id="line15399"></span>
<span id="line15400"></span>
<span id="line15401"></span>
<span id="line15402"></span>
<span id="line15403"></span>
<span id="line15404"></span>
<span id="line15405"></span>
<span id="line15406"></span>9                             |8|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|
<span id="line15407"></span>
<span id="line15408"></span>
<span id="line15409"></span>
<span id="line15410"></span>
<span id="line15411"></span>
<span id="line15412"></span>
<span id="line15413"></span>
<span id="line15414"></span>
<span id="line15415"></span>
<span id="line15416"></span>
<span id="line15417"></span>
<span id="line15418"></span>
<span id="line15419"></span>
<span id="line15420"></span>
<span id="line15421"></span>
<span id="line15422"></span>9                                           |8|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|
<span id="line15423"></span>
<span id="line15424"></span>
<span id="line15425"></span>
<span id="line15426"></span>
<span id="line15427"></span>
<span id="line15428"></span>
<span id="line15429"></span>
<span id="line15430"></span>
<span id="line15431"></span>
<span id="line15432"></span>
<span id="line15433"></span>
<span id="line15434"></span>
<span id="line15435"></span>
<span id="line15436"></span>
<span id="line15437"></span>
<span id="line15438"></span>9                                                       |8|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|
<span id="line15439"></span>
<span id="line15440"></span>
<span id="line15441"></span>
<span id="line15442"></span>
<span id="line15443"></span>
<span id="line15444"></span>
<span id="line15445"></span>
<span id="line15446"></span>
<span id="line15447"></span>
<span id="line15448"></span>
<span id="line15449"></span>
<span id="line15450"></span>
<span id="line15451"></span>
<span id="line15452"></span>
<span id="line15453"></span>
<span id="line15454"></span>9                                          
                       
|8|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|
<span id="line15455"></span>
<span id="line15456"></span>
<span id="line15457"></span>
<span id="line15458"></span>
<span id="line15459"></span>
<span id="line15460"></span>
<span id="line15461"></span>
<span id="line15462"></span>
<span id="line15463"></span>
<span id="line15464"></span>
<span id="line15465"></span>
<span id="line15466"></span>
<span id="line15467"></span>
<span id="line15468"></span>
<span id="line15469"></span>
<span id="line15470"></span>9                                          
                                  
|8|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|
<span id="line15471"></span>
<span id="line15472"></span>
<span id="line15473"></span>
<span id="line15474"></span>
<span id="line15475"></span>
<span id="line15476"></span>
<span id="line15477"></span>
<span id="line15478"></span>
<span id="line15479"></span>
<span id="line15480"></span>
<span id="line15481"></span>
<span id="line15482"></span>
<span id="line15483"></span>
<span id="line15484"></span>
<span id="line15485"></span>
<span id="line15486"></span>9                                          
                                              
|7|7|7|7|7|7|7|7|7|7|7|7|7|7|
<span id="line15487"></span>
<span id="line15488"></span>
<span id="line15489"></span>
<span id="line15490"></span>
<span id="line15491"></span>
<span id="line15492"></span>
<span id="line15493"></span>
<span id="line15494"></span>
<span id="line15495"></span>
<span id="line15496"></span>
<span id="line15497"></span>
<span id="line15498"></span>
<span id="line15499"></span>
<span id="line15500"></span>                                            
                                                       
|8|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|
<span id="line15501"></span>
<span id="line15502"></span>
<span id="line15503"></span>
<span id="line15504"></span>
<span id="line15505"></span>
<span id="line15506"></span>
<span id="line15507"></span>
<span id="line15508"></span>
<span id="line15509"></span>
<span id="line15510"></span>
<span id="line15511"></span>
<span id="line15512"></span>
<span id="line15513"></span>
<span id="line15514"></span>
<span id="line15515"></span>
<span id="line15516"></span>
<span id="line15517"></span>
<span id="line15518"></span>9
<span id="line15519"></span>
<span id="line15520"></span>
<span id="line15521"></span>
<span id="line15522"></span>
<span id="line15523"></span>
<span id="line15524"></span>
<span id="line15525"></span>
<span id="line15526"></span>
<span id="line15527"></span>
<span id="line15528"></span>
<span id="line15529"></span>
<span id="line15530"></span>
<span id="line15531"></span>
<span id="line15532"></span>
<span id="line15533"></span>
<span id="line15534"></span>
<span id="line15535"></span>
<span id="line15536"></span>
<span id="line15537"></span>
<span id="line15538"></span>
<span id="line15539"></span>
<span id="line15540"></span>
<span id="line15541"></span>
<span id="line15542"></span>
<span id="line15543"></span>
<span id="line15544"></span>
<span id="line15545"></span>
<span id="line15546"></span>
<span id="line15547"></span>
<span id="line15548"></span>
<span id="line15549"></span>
<span id="line15550"></span>          FORTRAN 77 Full Language                     Page 15-26
<span id="line15551"></span>
<span id="line15552"></span>
<span id="line15553"></span>
<span id="line15554"></span>
<span id="line15555"></span>
<span id="line15556"></span>
<span id="line15557"></span>
<span id="line15558"></span>          FUNCTIONS AND SUBROUTINES                ANSI X3J3/90.4
<span id="line15559"></span>
<span id="line15560"></span>
<span id="line15561"></span>
<span id="line15562"></span>
<span id="line15563"></span>
<span id="line15564"></span>
<span id="line15565"></span>
<span id="line15566"></span>
<span id="line15567"></span>
<span id="line15568"></span>
<span id="line15569"></span>
<span id="line15570"></span>
<span id="line15571"></span>
<span id="line15572"></span>
<span id="line15573"></span>
<span id="line15574"></span>
<span id="line15575"></span>
<span id="line15576"></span>
<span id="line15577"></span>
<span id="line15578"></span>
<span id="line15579"></span>
<span id="line15580"></span>
<span id="line15581"></span>
<span id="line15582"></span>
<span id="line15583"></span>
<span id="line15584"></span>
<span id="line15585"></span>
<span id="line15586"></span>
<span id="line15587"></span>
<span id="line15588"></span>
<span id="line15589"></span>
<span id="line15590"></span>
<span id="line15591"></span>
<span id="line15592"></span>
<span id="line15593"></span>
<span id="line15594"></span>
<span id="line15595"></span>
<span id="line15596"></span>
<span id="line15597"></span>
<span id="line15598"></span>
<span id="line15599"></span>
<span id="line15600"></span>
<span id="line15601"></span>
<span id="line15602"></span>
<span id="line15603"></span>
<span id="line15604"></span>
<span id="line15605"></span>
<span id="line15606"></span>
<span id="line15607"></span>
<span id="line15608"></span>
<span id="line15609"></span>
<span id="line15610"></span>
<span id="line15611"></span>
<span id="line15612"></span>
<span id="line15613"></span>
<span id="line15614"></span>
<span id="line15615"></span>
<span id="line15616"></span>          FORTRAN 77 Full Language                     Page 15-27
<span id="line15617"></span>
<span id="line15618"></span>
<span id="line15619"></span>
<span id="line15620"></span>
<span id="line15621"></span>
<span id="line15622"></span>
<span id="line15623"></span>
<span id="line15624"></span>
<span id="line15625"></span>
<span id="line15626"></span>
<span id="line15627"></span>
<span id="line15628"></span>                                 CONTENTS
<span id="line15629"></span>
<span id="line15630"></span>
<span id="line15631"></span>          15.  FUNCTIONS AND SUBROUTINES..................   15-1
<span id="line15632"></span>               15.1   Categories of Functions and
<span id="line15633"></span>                      Subroutines.........................   15-1
<span id="line15634"></span>                      15.1.1   Procedures.................   15-1
<span id="line15635"></span>                      15.1.2   External Functions.........   15-1
<span id="line15636"></span>                      15.1.3   Subroutines................   15-1
<span id="line15637"></span>                      15.1.4   Dummy Procedure............   15-1
<span id="line15638"></span>               15.2   Referencing a Function..............   15-1
<span id="line15639"></span>                      15.2.1   Form of a Function
<span id="line15640"></span>                               Reference..................   15-2
<span id="line15641"></span>                      15.2.2   Execution of a Function
<span id="line15642"></span>                               Reference..................   15-2
<span id="line15643"></span>               15.3   Intrinsic Functions.................   15-3
<span id="line15644"></span>                      15.3.1   Specific Names and Generic
<span id="line15645"></span>                               Names......................   15-3
<span id="line15646"></span>                      15.3.2   Referencing an Intrinsic
<span id="line15647"></span>                               Function...................   15-3
<span id="line15648"></span>                      15.3.3   Intrinsic Function
<span id="line15649"></span>                               Restrictions...............   15-4
<span id="line15650"></span>               15.4   Statement Function..................   15-4
<span id="line15651"></span>                      15.4.1   Form of a Statement
<span id="line15652"></span>                               Function Statement.........   15-4
<span id="line15653"></span>                      15.4.2   Referencing a Statement
<span id="line15654"></span>                               Function...................   15-6
<span id="line15655"></span>                      15.4.3   Statement Function
<span id="line15656"></span>                               Restrictions...............   15-7
<span id="line15657"></span>               15.5   External Functions..................   15-7
<span id="line15658"></span>                      15.5.1   Function Subprogram and
<span id="line15659"></span>                               FUNCTION Statement.........   15-7
<span id="line15660"></span>                      15.5.2   Referencing an External
<span id="line15661"></span>                               Function...................   15-8
<span id="line15662"></span>                      15.5.3   Function Subprogram
<span id="line15663"></span>                               Restrictions...............   15-9
<span id="line15664"></span>               15.6   Subroutines.........................  15-10
<span id="line15665"></span>                      15.6.1   Subroutine Subprogram and
<span id="line15666"></span>                               SUBROUTINE
<span id="line15667"></span>                               Statement..................  15-11
<span id="line15668"></span>                      15.6.2   Subroutine
<span id="line15669"></span>                               Reference..................  15-11
<span id="line15670"></span>                      15.6.3   Subroutine Subprogram
<span id="line15671"></span>                               Restrictions...............  15-13
<span id="line15672"></span>               15.7   ENTRY Statement.....................  15-13
<span id="line15673"></span>                      15.7.1   Form of an ENTRY
<span id="line15674"></span>                               Statement..................  15-13
<span id="line15675"></span>                      15.7.2   Referencing External
<span id="line15676"></span>                               Procedure by Entry
<span id="line15677"></span>                               Name.......................  15-14
<span id="line15678"></span>                      15.7.3   Entry Association..........  15-15
<span id="line15679"></span>
<span id="line15680"></span>
<span id="line15681"></span>
<span id="line15682"></span>                                   - i -
<span id="line15683"></span>
<span id="line15684"></span>
<span id="line15685"></span>
<span id="line15686"></span>
<span id="line15687"></span>
<span id="line15688"></span>
<span id="line15689"></span>
<span id="line15690"></span>
<span id="line15691"></span>
<span id="line15692"></span>
<span id="line15693"></span>
<span id="line15694"></span>                      15.7.4   ENTRY Statement
<span id="line15695"></span>                               Restrictions...............  15-15
<span id="line15696"></span>               15.8   RETURN Statement....................  15-16
<span id="line15697"></span>                      15.8.1   Form of a RETURN
<span id="line15698"></span>                               Statement..................  15-16
<span id="line15699"></span>                      15.8.2   Execution of a RETURN
<span id="line15700"></span>                               Statement..................  15-16
<span id="line15701"></span>                      15.8.3   Alternate Return...........  15-17
<span id="line15702"></span>                      15.8.4   Definition Status..........  15-17
<span id="line15703"></span>               15.9   Arguments and Common Blocks.........  15-18
<span id="line15704"></span>                      15.9.1   Dummy Arguments............  15-18
<span id="line15705"></span>                      15.9.2   Actual Arguments...........  15-18
<span id="line15706"></span>                      15.9.3   Association of Dummy and
<span id="line15707"></span>                               Actual Arguments...........  15-19
<span id="line15708"></span>                      15.9.4   Common Blocks..............  15-24
<span id="line15709"></span>               15.10  Table of Intrinsic Functions........  15-25
<span id="line15710"></span>                      15.10.1  Restrictions on Range of
<span id="line15711"></span>                               Arguments and
<span id="line15712"></span>                               Results....................  15-31
<span id="line15713"></span>
<span id="line15714"></span>
<span id="line15715"></span>
<span id="line15716"></span>
<span id="line15717"></span>
<span id="line15718"></span>
<span id="line15719"></span>
<span id="line15720"></span>
<span id="line15721"></span>
<span id="line15722"></span>
<span id="line15723"></span>
<span id="line15724"></span>
<span id="line15725"></span>
<span id="line15726"></span>
<span id="line15727"></span>
<span id="line15728"></span>
<span id="line15729"></span>
<span id="line15730"></span>
<span id="line15731"></span>
<span id="line15732"></span>
<span id="line15733"></span>
<span id="line15734"></span>
<span id="line15735"></span>
<span id="line15736"></span>
<span id="line15737"></span>
<span id="line15738"></span>
<span id="line15739"></span>
<span id="line15740"></span>
<span id="line15741"></span>
<span id="line15742"></span>
<span id="line15743"></span>
<span id="line15744"></span>
<span id="line15745"></span>
<span id="line15746"></span>
<span id="line15747"></span>
<span id="line15748"></span>                                  - ii -
<span id="line15749"></span>
<span id="line15750"></span>
<span id="line15751"></span>
<span id="line15752"></span>
<span id="line15753"></span>
<span id="line15754"></span>
<span id="line15755"></span>
<span id="line15756"></span>                                                   ANSI X3J3/90.4
<span id="line15757"></span>
<span id="line15758"></span>
<span id="line15759"></span>
<span id="line15760"></span>                        16.  BLOCK_DATA_SUBPROGRAM
<span id="line15761"></span>
<span id="line15762"></span>          Block data subprograms  are  used  to  provide  initial
<span id="line15763"></span>          values for variables and array elements in named common
<span id="line15764"></span>          blocks.
<span id="line15765"></span>
<span id="line15766"></span>          A block data subprogram is a program unit  that  has  a
<span id="line15767"></span>          BLOCK  DATA  statement as its first statement.  A block
<span id="line15768"></span>          data subprogram is nonexecutable.  There  may  be  more
<span id="line15769"></span>          than   one  block  data  subprogram  in  an  executable
<span id="line15770"></span>          program.
<span id="line15771"></span>
<span id="line15772"></span>          16.1  BLOCK_DATA_Statement
<span id="line15773"></span>
<span id="line15774"></span>          The form of a BLOCK DATA statement is:
<span id="line15775"></span>
<span id="line15776"></span>                               BLOCK DATA [sub___]
<span id="line15777"></span>
<span id="line15778"></span>          where sub is  the  symbolic  name  of  the  block  data
<span id="line15779"></span>          subprogram in which the BLOCK DATA statement appears.
<span id="line15780"></span>
<span id="line15781"></span>          The optional name sub is a  global  name  (18.1.1)  and
<span id="line15782"></span>          must  not  be  the  same  as  the  name  of an external
<span id="line15783"></span>          procedure, main program, common block, or  other  block
<span id="line15784"></span>          data  subprogram  in  the same executable program.  The
<span id="line15785"></span>          name sub must not be the same as any local name in  the
<span id="line15786"></span>          subprogram.
<span id="line15787"></span>
<span id="line15788"></span>          16.2  Block_Data_Subprogram_Restrictions
<span id="line15789"></span>
<span id="line15790"></span>          The BLOCK DATA statement must appear only as the  first
<span id="line15791"></span>          statement  of  a block data subprogram.  The only other
<span id="line15792"></span>          statements that may appear in a block  data  subprogram
<span id="line15793"></span>          are   IMPLICIT,  PARAMETER,  DIMENSION,  COMMON,  SAVE,
<span id="line15794"></span>          EQUIVALENCE, DATA, END, and type-statements.  Note that
<span id="line15795"></span>          comment lines are permitted.
<span id="line15796"></span>
<span id="line15797"></span>          If an entity in  a  named  common  block  is  initially
<span id="line15798"></span>          defined,  all  entities  having  storage  units  in the
<span id="line15799"></span>          common block storage sequence must be specified even if
<span id="line15800"></span>          they  are  not  all  initially  defined.  More than one
<span id="line15801"></span>          named common block may have entities initially  defined
<span id="line15802"></span>          in a single block data subprogram.
<span id="line15803"></span>
<span id="line15804"></span>          Only an entity in a named common block may be initially
<span id="line15805"></span>          defined in a block data subprogram.  Note that entities
<span id="line15806"></span>          associated  with  an  entity  in  a  common  block  are
<span id="line15807"></span>          considered to be in that common block.
<span id="line15808"></span>
<span id="line15809"></span>          The same named common block may  not  be  specified  in
<span id="line15810"></span>          more  than  one  block  data  subprogram  in  the  same
<span id="line15811"></span>
<span id="line15812"></span>
<span id="line15813"></span>
<span id="line15814"></span>          FORTRAN 77 Full Language                      Page 16-1
<span id="line15815"></span>
<span id="line15816"></span>
<span id="line15817"></span>
<span id="line15818"></span>
<span id="line15819"></span>
<span id="line15820"></span>
<span id="line15821"></span>
<span id="line15822"></span>          BLOCK DATA SUBPROGRAM                    ANSI X3J3/90.4
<span id="line15823"></span>
<span id="line15824"></span>
<span id="line15825"></span>
<span id="line15826"></span>          executable program.
<span id="line15827"></span>
<span id="line15828"></span>          There must not be more  than  one  unnamed  block  data
<span id="line15829"></span>          subprogram in an executable program.
<span id="line15830"></span>
<span id="line15831"></span>
<span id="line15832"></span>
<span id="line15833"></span>
<span id="line15834"></span>
<span id="line15835"></span>
<span id="line15836"></span>
<span id="line15837"></span>
<span id="line15838"></span>
<span id="line15839"></span>
<span id="line15840"></span>
<span id="line15841"></span>
<span id="line15842"></span>
<span id="line15843"></span>
<span id="line15844"></span>
<span id="line15845"></span>
<span id="line15846"></span>
<span id="line15847"></span>
<span id="line15848"></span>
<span id="line15849"></span>
<span id="line15850"></span>
<span id="line15851"></span>
<span id="line15852"></span>
<span id="line15853"></span>
<span id="line15854"></span>
<span id="line15855"></span>
<span id="line15856"></span>
<span id="line15857"></span>
<span id="line15858"></span>
<span id="line15859"></span>
<span id="line15860"></span>
<span id="line15861"></span>
<span id="line15862"></span>
<span id="line15863"></span>
<span id="line15864"></span>
<span id="line15865"></span>
<span id="line15866"></span>
<span id="line15867"></span>
<span id="line15868"></span>
<span id="line15869"></span>
<span id="line15870"></span>
<span id="line15871"></span>
<span id="line15872"></span>
<span id="line15873"></span>
<span id="line15874"></span>
<span id="line15875"></span>
<span id="line15876"></span>
<span id="line15877"></span>
<span id="line15878"></span>
<span id="line15879"></span>
<span id="line15880"></span>          FORTRAN 77 Full Language                      Page 16-2
<span id="line15881"></span>
<span id="line15882"></span>
<span id="line15883"></span>
<span id="line15884"></span>
<span id="line15885"></span>
<span id="line15886"></span>
<span id="line15887"></span>
<span id="line15888"></span>
<span id="line15889"></span>
<span id="line15890"></span>
<span id="line15891"></span>
<span id="line15892"></span>                                 CONTENTS
<span id="line15893"></span>
<span id="line15894"></span>
<span id="line15895"></span>          16.  BLOCK DATA SUBPROGRAM.......................  16-1
<span id="line15896"></span>               16.1  BLOCK DATA Statement..................  16-1
<span id="line15897"></span>               16.2  Block Data Subprogram
<span id="line15898"></span>                     Restrictions..........................  16-1
<span id="line15899"></span>
<span id="line15900"></span>
<span id="line15901"></span>
<span id="line15902"></span>
<span id="line15903"></span>
<span id="line15904"></span>
<span id="line15905"></span>
<span id="line15906"></span>
<span id="line15907"></span>
<span id="line15908"></span>
<span id="line15909"></span>
<span id="line15910"></span>
<span id="line15911"></span>
<span id="line15912"></span>
<span id="line15913"></span>
<span id="line15914"></span>
<span id="line15915"></span>
<span id="line15916"></span>
<span id="line15917"></span>
<span id="line15918"></span>
<span id="line15919"></span>
<span id="line15920"></span>
<span id="line15921"></span>
<span id="line15922"></span>
<span id="line15923"></span>
<span id="line15924"></span>
<span id="line15925"></span>
<span id="line15926"></span>
<span id="line15927"></span>
<span id="line15928"></span>
<span id="line15929"></span>
<span id="line15930"></span>
<span id="line15931"></span>
<span id="line15932"></span>
<span id="line15933"></span>
<span id="line15934"></span>
<span id="line15935"></span>
<span id="line15936"></span>
<span id="line15937"></span>
<span id="line15938"></span>
<span id="line15939"></span>
<span id="line15940"></span>
<span id="line15941"></span>
<span id="line15942"></span>
<span id="line15943"></span>
<span id="line15944"></span>
<span id="line15945"></span>
<span id="line15946"></span>                                   - i -
<span id="line15947"></span>
<span id="line15948"></span>
<span id="line15949"></span>
<span id="line15950"></span>
<span id="line15951"></span>
<span id="line15952"></span>
<span id="line15953"></span>
<span id="line15954"></span>                                                   ANSI X3J3/90.4
<span id="line15955"></span>
<span id="line15956"></span>
<span id="line15957"></span>
<span id="line15958"></span>                      17.  ASSOCIATION_AND_DEFINITION
<span id="line15959"></span>
<span id="line15960"></span>          17.1  Storage_and_Association
<span id="line15961"></span>
<span id="line15962"></span>          Storage sequences are used  to  describe  relationships
<span id="line15963"></span>          that exist among variables, array elements, substrings,
<span id="line15964"></span>          common blocks, and arguments.
<span id="line15965"></span>
<span id="line15966"></span>          17.1.1  Storage_Sequence.   A  storage  sequence  is  a
<span id="line15967"></span>          sequence (2.1) of storage units.  The size of a storage
<span id="line15968"></span>          sequence is the number of storage units in the  storage
<span id="line15969"></span>          sequence.   A  storage unit is a character storage unit
<span id="line15970"></span>          or a numeric storage unit.
<span id="line15971"></span>
<span id="line15972"></span>          A variable or array element of type integer,  real,  or
<span id="line15973"></span>          logical  has  a storage sequence of one numeric storage
<span id="line15974"></span>          unit.
<span id="line15975"></span>
<span id="line15976"></span>          A variable or array element of type double precision or
<span id="line15977"></span>          complex  has  a storage sequence of two numeric storage
<span id="line15978"></span>          units.  In a complex storage sequence,  the  real  part
<span id="line15979"></span>          has  the  first storage unit and the imaginary part has
<span id="line15980"></span>          the second storage unit.
<span id="line15981"></span>
<span id="line15982"></span>          A  variable,  array  element,  or  substring  of   type
<span id="line15983"></span>          character  has  a storage sequence of character storage
<span id="line15984"></span>          units.  The number of character storage  units  in  the
<span id="line15985"></span>          storage sequence is the length of the character entity.
<span id="line15986"></span>          The order of the sequence corresponds to  the  ordering
<span id="line15987"></span>          of character positions (4.8).
<span id="line15988"></span>
<span id="line15989"></span>          Each array and common  block  has  a  storage  sequence
<span id="line15990"></span>          (5.2.5 and 8.3.2).
<span id="line15991"></span>
<span id="line15992"></span>          17.1.2  Association_of_Storage_Sequences.  Two  storage
<span id="line15993"></span>          sequences  s_918 and s_928 are associated if the ith storage
<span id="line15994"></span>          unit of s_918 is the same as the jth storage unit of  s_928.
<span id="line15995"></span>          This  causes  the  (i+k)th storage unit of s_918 to be the
<span id="line15996"></span>          same as the (j+k)th  storage  unit  of  s_928,  for  each
<span id="line15997"></span>          integer  k such that 1 <span class="entity"><span>&amp;</span>lt;</span> i+k <span class="entity"><span>&amp;</span>lt;</span> size of s_918 and 1 <span class="entity"><span>&amp;</span>lt;</span> j+k <span class="entity"><span>&amp;</span>lt;</span>
<span id="line15998"></span>           size of s_928.
<span id="line15999"></span>
<span id="line16000"></span>          17.1.3  Association_of_Entities.  Two variables,  array
<span id="line16001"></span>          elements, or substrings are associated if their storage
<span id="line16002"></span>          sequences are associated.   Two  entities  are  totally
<span id="line16003"></span>          associated if they have the same storage sequence.  Two
<span id="line16004"></span>          entities  are  partially   associated   if   they   are
<span id="line16005"></span>          associated but not totally associated.
<span id="line16006"></span>
<span id="line16007"></span>          The definition status and value of  an  entity  affects
<span id="line16008"></span>          the  definition  status  and  value  of  any associated
<span id="line16009"></span>
<span id="line16010"></span>
<span id="line16011"></span>
<span id="line16012"></span>          FORTRAN 77 Full Language                      Page 17-1
<span id="line16013"></span>
<span id="line16014"></span>
<span id="line16015"></span>
<span id="line16016"></span>
<span id="line16017"></span>
<span id="line16018"></span>
<span id="line16019"></span>
<span id="line16020"></span>          ASSOCIATION AND DEFINITION               ANSI X3J3/90.4
<span id="line16021"></span>
<span id="line16022"></span>
<span id="line16023"></span>
<span id="line16024"></span>          entity.  An EQUIVALENCE statement, a COMMON  statement,
<span id="line16025"></span>          an  ENTRY  statement (15.7.3), or a procedure reference
<span id="line16026"></span>          (argument association) may cause association of storage
<span id="line16027"></span>          sequences.
<span id="line16028"></span>
<span id="line16029"></span>          An EQUIVALENCE statement causes association of entities
<span id="line16030"></span>          only  within  one  program  unit,  unless  one  of  the
<span id="line16031"></span>          equivalenced entities is also in a common block (8.3).
<span id="line16032"></span>
<span id="line16033"></span>          Arguments and COMMON statements cause entities  in  one
<span id="line16034"></span>          program  unit  to  become  associated  with entities in
<span id="line16035"></span>          another  program  unit  (8.3  and  15.9).   Note   that
<span id="line16036"></span>          association between actual and dummy arguments does not
<span id="line16037"></span>          imply association of storage sequences except when  the
<span id="line16038"></span>          actual  argument  is  the  name  of  a  variable, array
<span id="line16039"></span>          element, array, or substring.
<span id="line16040"></span>
<span id="line16041"></span>          In a function subprogram, an ENTRY statement causes the
<span id="line16042"></span>          entry  name  to  become associated with the name of the
<span id="line16043"></span>          function  subprogram  which  appears  in  the  FUNCTION
<span id="line16044"></span>          statement.
<span id="line16045"></span>
<span id="line16046"></span>          Partial  association  may  exist   only   between   two
<span id="line16047"></span>          character  entities  or  between  a double precision or
<span id="line16048"></span>          complex entity and an entity  of  type  integer,  real,
<span id="line16049"></span>          logical, double precision, or complex.
<span id="line16050"></span>
<span id="line16051"></span>          Except for character entities, partial association  may
<span id="line16052"></span>          occur  only  through the use of COMMON, EQUIVALENCE, or
<span id="line16053"></span>          ENTRY statements.  Partial association must  not  occur
<span id="line16054"></span>          through  argument  association, except for arguments of
<span id="line16055"></span>          type character.
<span id="line16056"></span>
<span id="line16057"></span>          In the example:
<span id="line16058"></span>
<span id="line16059"></span>                     REAL A(4)a,B
<span id="line16060"></span>                     COMPLEX C(2)
<span id="line16061"></span>                     DOUBLE PRECISION D
<span id="line16062"></span>                     EQUIVALENCE (C(2),A(2),B), (A,D)
<span id="line16063"></span>
<span id="line16064"></span>          the third storage unit of C, the second storage unit of
<span id="line16065"></span>          A,  the  storage unit of B, and the second storage unit
<span id="line16066"></span>          of D are specified as the same.  The storage  sequences
<span id="line16067"></span>          may be illustrated as:
<span id="line16068"></span>
<span id="line16069"></span>            storage unit     1  |   2       3  |   4      5  |
<span id="line16070"></span>                        |7|99  ----C(1)----   ----C(2)----
<span id="line16071"></span>                                |  A(1)   A(2)    A(3)|7|7|9999  A(4)|
<span id="line16072"></span>                                       |7|7|7|999999  --B--
<span id="line16073"></span>                                   -----D-----
<span id="line16074"></span>7                                |
<span id="line16075"></span>7                                               |8|7|
<span id="line16076"></span>
<span id="line16077"></span>
<span id="line16078"></span>9
<span id="line16079"></span>
<span id="line16080"></span>
<span id="line16081"></span>          FORTRAN 77 Full Language                      Page 17-2
<span id="line16082"></span>
<span id="line16083"></span>
<span id="line16084"></span>
<span id="line16085"></span>
<span id="line16086"></span>
<span id="line16087"></span>
<span id="line16088"></span>
<span id="line16089"></span>          ASSOCIATION AND DEFINITION               ANSI X3J3/90.4
<span id="line16090"></span>
<span id="line16091"></span>
<span id="line16092"></span>
<span id="line16093"></span>          A(2) and B are totally associated.  The  following  are
<span id="line16094"></span>          partially  associated:  A(1)  and  C(1), A(2) and C(2),
<span id="line16095"></span>          A(3) and C(2), B and C(2), A(1) and D, A(2)  and  D,  B
<span id="line16096"></span>          and  D, C(1) and D, and C(2) and D.  Note that although
<span id="line16097"></span>          C(1) and C(2) are each associated with D, C(1) and C(2)
<span id="line16098"></span>          are not associated with each other.
<span id="line16099"></span>
<span id="line16100"></span>          Partial association of character entities  occurs  when
<span id="line16101"></span>          some, but not all, of the storage units of the entities
<span id="line16102"></span>          are the same.  In the example:
<span id="line16103"></span>
<span id="line16104"></span>                     CHARACTER A*4,B*4,C*3
<span id="line16105"></span>                     EQUIVALENCE (A(2:3),B,C)
<span id="line16106"></span>
<span id="line16107"></span>          A, B, and C are partially associated.
<span id="line16108"></span>
<span id="line16109"></span>          17.2  Events_That_Cause_Entities_to_Become_Defined
<span id="line16110"></span>
<span id="line16111"></span>          Variables,  array  elements,  and   substrings   become
<span id="line16112"></span>          defined as follows:
<span id="line16113"></span>
<span id="line16114"></span>             (1) Execution  of   an   arithmetic,   logical,   or
<span id="line16115"></span>                 character assignment statement causes the entity
<span id="line16116"></span>                 that precedes the equals to become defined.
<span id="line16117"></span>
<span id="line16118"></span>             (2) As execution of  an  input  statement  proceeds,
<span id="line16119"></span>                 each  entity  that  is  assigned  a value of its
<span id="line16120"></span>                 corresponding type from the input medium becomes
<span id="line16121"></span>                 defined at the time of such assignment.
<span id="line16122"></span>
<span id="line16123"></span>             (3) Execution of  a  DO  statement  causes  the  DO-
<span id="line16124"></span>                 variable to become defined.
<span id="line16125"></span>
<span id="line16126"></span>             (4) Beginning of execution of action specified by an
<span id="line16127"></span>                 implied-DO  list  in  an  input/output statement
<span id="line16128"></span>                 causes   the   implied-DO-variable   to   become
<span id="line16129"></span>                 defined.
<span id="line16130"></span>
<span id="line16131"></span>             (5) A  DATA  statement  causes  entities  to  become
<span id="line16132"></span>                 initially  defined at the beginning of execution
<span id="line16133"></span>                 of an executable program.
<span id="line16134"></span>
<span id="line16135"></span>             (6) Execution of  an  ASSIGN  statement  causes  the
<span id="line16136"></span>                 variable in the statement to become defined with
<span id="line16137"></span>                 a statement label value.
<span id="line16138"></span>
<span id="line16139"></span>             (7) When an entity of a given type becomes  defined,
<span id="line16140"></span>                 all totally associated entities of the same type
<span id="line16141"></span>                 become  defined  except  that  entities  totally
<span id="line16142"></span>                 associated   with  the  variable  in  an  ASSIGN
<span id="line16143"></span>                 statement  become  undefined  when  the   ASSIGN
<span id="line16144"></span>
<span id="line16145"></span>
<span id="line16146"></span>
<span id="line16147"></span>          FORTRAN 77 Full Language                      Page 17-3
<span id="line16148"></span>
<span id="line16149"></span>
<span id="line16150"></span>
<span id="line16151"></span>
<span id="line16152"></span>
<span id="line16153"></span>
<span id="line16154"></span>
<span id="line16155"></span>          ASSOCIATION AND DEFINITION               ANSI X3J3/90.4
<span id="line16156"></span>
<span id="line16157"></span>
<span id="line16158"></span>
<span id="line16159"></span>                 statement is executed.
<span id="line16160"></span>
<span id="line16161"></span>             (8) A reference  to  a  subprogram  causes  a  dummy
<span id="line16162"></span>                 argument  to become defined if the corresponding
<span id="line16163"></span>                 actual argument is defined with a value that  is
<span id="line16164"></span>                 not  a  statement  label value.  Note that there
<span id="line16165"></span>                 must be agreement between  the  actual  argument
<span id="line16166"></span>                 and the dummy argument (15.9.3).
<span id="line16167"></span>
<span id="line16168"></span>             (9) Execution   of   an    input/output    statement
<span id="line16169"></span>                 containing   an  input/output  status  specifier
<span id="line16170"></span>                 causes the specified integer variable  or  array
<span id="line16171"></span>                 element to become defined.
<span id="line16172"></span>
<span id="line16173"></span>            (10) Execution of an  INQUIRE  statement  causes  any
<span id="line16174"></span>                 entity  that  is  assigned  a  value  during the
<span id="line16175"></span>                 execution of the statement to become defined  if
<span id="line16176"></span>                 no error condition exists.
<span id="line16177"></span>
<span id="line16178"></span>            (11) When  a  complex  entity  becomes  defined,  all
<span id="line16179"></span>                 partially   associated   real   entities  become
<span id="line16180"></span>                 defined.
<span id="line16181"></span>
<span id="line16182"></span>            (12) When both  parts  of  a  complex  entity  become
<span id="line16183"></span>                 defined as a result of partially associated real
<span id="line16184"></span>                 or  complex  entities  becoming   defined,   the
<span id="line16185"></span>                 complex entity becomes defined.
<span id="line16186"></span>
<span id="line16187"></span>            (13) When all characters of a character entity become
<span id="line16188"></span>                 defined, the character entity becomes defined.
<span id="line16189"></span>
<span id="line16190"></span>          17.3  Events_That_Caused_Entities_to_Become_Undefined
<span id="line16191"></span>
<span id="line16192"></span>          Variables,  array  elements,  and   substrings   become
<span id="line16193"></span>          undefined as follows:
<span id="line16194"></span>
<span id="line16195"></span>             (1) All entities are undefined at the  beginning  of
<span id="line16196"></span>                 execution  of an executable program except those
<span id="line16197"></span>                 entities initially defined by DATA statements.
<span id="line16198"></span>
<span id="line16199"></span>             (2) When an entity of a given type becomes  defined,
<span id="line16200"></span>                 all  totally  associated  entities  of different
<span id="line16201"></span>                 type become undefined.
<span id="line16202"></span>
<span id="line16203"></span>             (3) Execution of  an  ASSIGN  statement  causes  the
<span id="line16204"></span>                 variable in the statement to become undefined as
<span id="line16205"></span>                 an integer.  Entities that are  associated  with
<span id="line16206"></span>                 the variable become undefined.
<span id="line16207"></span>
<span id="line16208"></span>             (4) When an entity  of  type  other  than  character
<span id="line16209"></span>                 becomes   defined,   all   partially  associated
<span id="line16210"></span>
<span id="line16211"></span>
<span id="line16212"></span>
<span id="line16213"></span>          FORTRAN 77 Full Language                      Page 17-4
<span id="line16214"></span>
<span id="line16215"></span>
<span id="line16216"></span>
<span id="line16217"></span>
<span id="line16218"></span>
<span id="line16219"></span>
<span id="line16220"></span>
<span id="line16221"></span>          ASSOCIATION AND DEFINITION               ANSI X3J3/90.4
<span id="line16222"></span>
<span id="line16223"></span>
<span id="line16224"></span>
<span id="line16225"></span>                 entities become  undefined.   However,  when  an
<span id="line16226"></span>                 entity of type real is partially associated with
<span id="line16227"></span>                 an entity of type complex,  the  complex  entity
<span id="line16228"></span>                 does  not  become undefined when the real entity
<span id="line16229"></span>                 becomes defined and the  real  entity  does  not
<span id="line16230"></span>                 become undefined when the complex entity becomes
<span id="line16231"></span>                 defined.  When an  entity  of  type  complex  is
<span id="line16232"></span>                 partially associated with another entity of type
<span id="line16233"></span>                 complex, definition of one entity does not cause
<span id="line16234"></span>                 the other to become undefined.
<span id="line16235"></span>
<span id="line16236"></span>             (5) When the evaluation  of  a  function  causes  an
<span id="line16237"></span>                 argument  of the function or an entity in common
<span id="line16238"></span>                 to become defined and  if  a  reference  to  the
<span id="line16239"></span>                 function  appears  in an expression in which the
<span id="line16240"></span>                 value of the function is not needed to determine
<span id="line16241"></span>                 the  value  of the expression, then the argument
<span id="line16242"></span>                 or the entity in common becomes  undefined  when
<span id="line16243"></span>                 the expression is evaluated (6.6.1).
<span id="line16244"></span>
<span id="line16245"></span>             (6) The execution of a RETURN statement  or  an  END
<span id="line16246"></span>                 statement   within   a   subprogram  causes  all
<span id="line16247"></span>                 entities  within  the   subprogram   to   become
<span id="line16248"></span>                 undefined except for the following:
<span id="line16249"></span>
<span id="line16250"></span>                (a) Entities in blank common
<span id="line16251"></span>
<span id="line16252"></span>                (b) Initially defined entities that have  neither
<span id="line16253"></span>                    been redefined nor become undefined
<span id="line16254"></span>
<span id="line16255"></span>                (c) Entities specified by SAVE statements
<span id="line16256"></span>
<span id="line16257"></span>                (d) Entities in a named common block that appears
<span id="line16258"></span>                    in the subprogram and appears in at least one
<span id="line16259"></span>                    other program unit that is either directly or
<span id="line16260"></span>                    indirectly referencing the subprogram
<span id="line16261"></span>
<span id="line16262"></span>             (7) When an error condition or end-of-file condition
<span id="line16263"></span>                 occurs  during  execution of an input statement,
<span id="line16264"></span>                 all of the  entities specified by the input list
<span id="line16265"></span>                 of the statement become undefined.
<span id="line16266"></span>
<span id="line16267"></span>             (8) Execution of a  direct  access  input  statement
<span id="line16268"></span>                 that  specifies  a  record  that  has  not  been
<span id="line16269"></span>                 previously written causes all  of  the  entities
<span id="line16270"></span>                 specified  by the input list of the statement to
<span id="line16271"></span>                 become undefined.
<span id="line16272"></span>
<span id="line16273"></span>             (9) Execution of  an  INQUIRE  statement  may  cause
<span id="line16274"></span>                 entities to become undefined (12.10.3).
<span id="line16275"></span>
<span id="line16276"></span>
<span id="line16277"></span>
<span id="line16278"></span>
<span id="line16279"></span>          FORTRAN 77 Full Language                      Page 17-5
<span id="line16280"></span>
<span id="line16281"></span>
<span id="line16282"></span>
<span id="line16283"></span>
<span id="line16284"></span>
<span id="line16285"></span>
<span id="line16286"></span>
<span id="line16287"></span>          ASSOCIATION AND DEFINITION               ANSI X3J3/90.4
<span id="line16288"></span>
<span id="line16289"></span>
<span id="line16290"></span>
<span id="line16291"></span>            (10) When any character of a character entity becomes
<span id="line16292"></span>                 undefined,    the   character   entity   becomes
<span id="line16293"></span>                 undefined.
<span id="line16294"></span>
<span id="line16295"></span>            (11) When an entity becomes undefined as a result  of
<span id="line16296"></span>                 conditions  described  in  (5) through (10), all
<span id="line16297"></span>                 totally associated entities become undefined and
<span id="line16298"></span>                 all  partially associated entities of type other
<span id="line16299"></span>                 than character become undefined.
<span id="line16300"></span>
<span id="line16301"></span>
<span id="line16302"></span>
<span id="line16303"></span>
<span id="line16304"></span>
<span id="line16305"></span>
<span id="line16306"></span>
<span id="line16307"></span>
<span id="line16308"></span>
<span id="line16309"></span>
<span id="line16310"></span>
<span id="line16311"></span>
<span id="line16312"></span>
<span id="line16313"></span>
<span id="line16314"></span>
<span id="line16315"></span>
<span id="line16316"></span>
<span id="line16317"></span>
<span id="line16318"></span>
<span id="line16319"></span>
<span id="line16320"></span>
<span id="line16321"></span>
<span id="line16322"></span>
<span id="line16323"></span>
<span id="line16324"></span>
<span id="line16325"></span>
<span id="line16326"></span>
<span id="line16327"></span>
<span id="line16328"></span>
<span id="line16329"></span>
<span id="line16330"></span>
<span id="line16331"></span>
<span id="line16332"></span>
<span id="line16333"></span>
<span id="line16334"></span>
<span id="line16335"></span>
<span id="line16336"></span>
<span id="line16337"></span>
<span id="line16338"></span>
<span id="line16339"></span>
<span id="line16340"></span>
<span id="line16341"></span>
<span id="line16342"></span>
<span id="line16343"></span>
<span id="line16344"></span>
<span id="line16345"></span>          FORTRAN 77 Full Language                      Page 17-6
<span id="line16346"></span>
<span id="line16347"></span>
<span id="line16348"></span>
<span id="line16349"></span>
<span id="line16350"></span>
<span id="line16351"></span>
<span id="line16352"></span>
<span id="line16353"></span>
<span id="line16354"></span>
<span id="line16355"></span>
<span id="line16356"></span>
<span id="line16357"></span>                                 CONTENTS
<span id="line16358"></span>
<span id="line16359"></span>
<span id="line16360"></span>          17.  ASSOCIATION AND DEFINITION..................  17-1
<span id="line16361"></span>               17.1  Storage and Association...............  17-1
<span id="line16362"></span>                     17.1.1  Storage Sequence..............  17-1
<span id="line16363"></span>                     17.1.2  Association of Storage
<span id="line16364"></span>                             Sequences.....................  17-1
<span id="line16365"></span>                     17.1.3  Association of
<span id="line16366"></span>                             Entities......................  17-1
<span id="line16367"></span>               17.2  Events That Cause Entities to Become
<span id="line16368"></span>                     Defined...............................  17-3
<span id="line16369"></span>               17.3  Events That Caused Entities to Become
<span id="line16370"></span>                     Undefined.............................  17-4
<span id="line16371"></span>
<span id="line16372"></span>
<span id="line16373"></span>
<span id="line16374"></span>
<span id="line16375"></span>
<span id="line16376"></span>
<span id="line16377"></span>
<span id="line16378"></span>
<span id="line16379"></span>
<span id="line16380"></span>
<span id="line16381"></span>
<span id="line16382"></span>
<span id="line16383"></span>
<span id="line16384"></span>
<span id="line16385"></span>
<span id="line16386"></span>
<span id="line16387"></span>
<span id="line16388"></span>
<span id="line16389"></span>
<span id="line16390"></span>
<span id="line16391"></span>
<span id="line16392"></span>
<span id="line16393"></span>
<span id="line16394"></span>
<span id="line16395"></span>
<span id="line16396"></span>
<span id="line16397"></span>
<span id="line16398"></span>
<span id="line16399"></span>
<span id="line16400"></span>
<span id="line16401"></span>
<span id="line16402"></span>
<span id="line16403"></span>
<span id="line16404"></span>
<span id="line16405"></span>
<span id="line16406"></span>
<span id="line16407"></span>
<span id="line16408"></span>
<span id="line16409"></span>
<span id="line16410"></span>
<span id="line16411"></span>                                   - i -
<span id="line16412"></span>
<span id="line16413"></span>
<span id="line16414"></span>
<span id="line16415"></span>
<span id="line16416"></span>
<span id="line16417"></span>
<span id="line16418"></span>
<span id="line16419"></span>                                                   ANSI X3J3/90.4
<span id="line16420"></span>
<span id="line16421"></span>
<span id="line16422"></span>
<span id="line16423"></span>                 18.  SCOPES_AND_CLASSES_OF_SYMBOLIC_NAMES
<span id="line16424"></span>
<span id="line16425"></span>          A symbolic name consists of  one  to  six  alphanumeric
<span id="line16426"></span>          characters,  the first of which must be a letter.  Some
<span id="line16427"></span>          sequences  of   characters,   such   as   format   edit
<span id="line16428"></span>          descriptors and keywords that uniquely identify certain
<span id="line16429"></span>          statements, for example, GO TO, READ, FORMAT, etc,  are
<span id="line16430"></span>          not symbolic names in such occurrences nor do they form
<span id="line16431"></span>          the  first  characters  of  symbolic  names   in   such
<span id="line16432"></span>          occurrences.
<span id="line16433"></span>
<span id="line16434"></span>          18.1  Scope_of_Symbolic_Names
<span id="line16435"></span>
<span id="line16436"></span>          The scope of a symbolic name is an executable  program,
<span id="line16437"></span>          a  program unit, a statement function statement,  or an
<span id="line16438"></span>          implied-DO list in a DATA statement.
<span id="line16439"></span>
<span id="line16440"></span>          The name of the main program and  the  names  of  block
<span id="line16441"></span>          data  subprograms, external functions, subroutines, and
<span id="line16442"></span>          common blocks have a scope of an executable program.
<span id="line16443"></span>
<span id="line16444"></span>          The names of variables,  arrays,  constants,  statement
<span id="line16445"></span>          functions,  intrinsic  functions,  and dummy procedures
<span id="line16446"></span>          have a scope of a program unit.
<span id="line16447"></span>
<span id="line16448"></span>          The names of variables that appear as  dummy  arguments
<span id="line16449"></span>          in  a statement function statement have a scope of that
<span id="line16450"></span>          statement.
<span id="line16451"></span>
<span id="line16452"></span>          The names of variables that appear as  the  DO-variable
<span id="line16453"></span>          of  an  implied-DO  in a DATA statement have a scope of
<span id="line16454"></span>          the implied-DO list.
<span id="line16455"></span>
<span id="line16456"></span>          18.1.1  Global_Entities.   The  main  program,   common
<span id="line16457"></span>          blocks, subprograms, and external procedures are global
<span id="line16458"></span>          entities of an executable  program.   A  symbolic  name
<span id="line16459"></span>          that  identifies  a  global  entity must not be used to
<span id="line16460"></span>          identify any other global entity in the same executable
<span id="line16461"></span>          program.
<span id="line16462"></span>
<span id="line16463"></span>          18.1.1.1  Classes_of_Global_Entities.  A symbolic  name
<span id="line16464"></span>          in  one  of the following classes is a global entity in
<span id="line16465"></span>          an executable program:
<span id="line16466"></span>
<span id="line16467"></span>             (1) Common block
<span id="line16468"></span>
<span id="line16469"></span>             (2) External function
<span id="line16470"></span>
<span id="line16471"></span>             (3) Subroutine
<span id="line16472"></span>
<span id="line16473"></span>
<span id="line16474"></span>
<span id="line16475"></span>
<span id="line16476"></span>
<span id="line16477"></span>          FORTRAN 77 Full Language                      Page 18-1
<span id="line16478"></span>
<span id="line16479"></span>
<span id="line16480"></span>
<span id="line16481"></span>
<span id="line16482"></span>
<span id="line16483"></span>
<span id="line16484"></span>
<span id="line16485"></span>          SCOPES AND CLASSES OF SYMBOLIC NAMES     ANSI X3J3/90.4
<span id="line16486"></span>
<span id="line16487"></span>
<span id="line16488"></span>
<span id="line16489"></span>             (4) Main program
<span id="line16490"></span>
<span id="line16491"></span>             (5) Block data subprogram
<span id="line16492"></span>
<span id="line16493"></span>          18.1.2  Local_Entities.  The symbolic name of  a  local
<span id="line16494"></span>          entity identifies that entity in a single program unit.
<span id="line16495"></span>          Within a program unit, a symbolic name that is  in  one
<span id="line16496"></span>          class  of  entities  local to the program unit must not
<span id="line16497"></span>          also be in another  class  of  entities  local  to  the
<span id="line16498"></span>          program unit.  However, a symbolic name that identifies
<span id="line16499"></span>          a local  entity  may,  in  a  different  program  unit,
<span id="line16500"></span>          identify an entity of any class that is either local to
<span id="line16501"></span>          that program unit or global to the executable  program.
<span id="line16502"></span>          A  symbolic  name  that identifies a global entity in a
<span id="line16503"></span>          program unit must not  be  used  to  identify  a  local
<span id="line16504"></span>          entity  in that program unit, except for a common block
<span id="line16505"></span>          name and an external function name (18.2.1 and 18.2.2).
<span id="line16506"></span>
<span id="line16507"></span>          18.1.2.1  Classes_of_Local_Entities.  A  symbolic  name
<span id="line16508"></span>          in  one of the following classes is a local entity in a
<span id="line16509"></span>          program unit.
<span id="line16510"></span>
<span id="line16511"></span>             (1) Array
<span id="line16512"></span>
<span id="line16513"></span>             (2) Variable
<span id="line16514"></span>
<span id="line16515"></span>             (3) Constant
<span id="line16516"></span>
<span id="line16517"></span>             (4) Statement function
<span id="line16518"></span>
<span id="line16519"></span>             (5) Intrinsic function
<span id="line16520"></span>
<span id="line16521"></span>             (6) Dummy procedure
<span id="line16522"></span>
<span id="line16523"></span>          A symbolic name that is a dummy argument of a procedure
<span id="line16524"></span>          is classified as a variable, array, or dummy procedure.
<span id="line16525"></span>          The  specification  and  usage  must  not  violate  the
<span id="line16526"></span>          respective class rules.
<span id="line16527"></span>
<span id="line16528"></span>          18.2  Classes_of_Symbolic_Names
<span id="line16529"></span>
<span id="line16530"></span>          In a program unit, a symbolic name must not be in  more
<span id="line16531"></span>          than  one  class  except  as  noted  in  the  following
<span id="line16532"></span>          paragraphs of this section.  There are no  restrictions
<span id="line16533"></span>          on  the  appearances  of  the  same  symbolic  name  in
<span id="line16534"></span>          different program units of an executable program  other
<span id="line16535"></span>          than those noted in this section.
<span id="line16536"></span>
<span id="line16537"></span>          18.2.1  Common_block.  A symbolic name is the name of a
<span id="line16538"></span>          common  block if and only if it appears as a block name
<span id="line16539"></span>          in a COMMON statement (8.3).
<span id="line16540"></span>
<span id="line16541"></span>
<span id="line16542"></span>
<span id="line16543"></span>          FORTRAN 77 Full Language                      Page 18-2
<span id="line16544"></span>
<span id="line16545"></span>
<span id="line16546"></span>
<span id="line16547"></span>
<span id="line16548"></span>
<span id="line16549"></span>
<span id="line16550"></span>
<span id="line16551"></span>          SCOPES AND CLASSES OF SYMBOLIC NAMES     ANSI X3J3/90.4
<span id="line16552"></span>
<span id="line16553"></span>
<span id="line16554"></span>
<span id="line16555"></span>          A  common  block  name  is  global  to  the  executable
<span id="line16556"></span>          program.
<span id="line16557"></span>
<span id="line16558"></span>          A common block name in a program unit may also  be  the
<span id="line16559"></span>          name  of  any  local  entity  other  than  a  constant,
<span id="line16560"></span>          intrinsic function, or a local variable that is also an
<span id="line16561"></span>          external  function in a function subprogram.  If a name
<span id="line16562"></span>          is used for both a common block and a local entity, the
<span id="line16563"></span>          appearance  of that name in any context other than as a
<span id="line16564"></span>          common  block  name  in  a  COMMON  or  SAVE  statement
<span id="line16565"></span>          identifies   only  the  local  entity.   Note  that  an
<span id="line16566"></span>          intrinsic function name may be a common block name in a
<span id="line16567"></span>          program  unit  that  does  not  reference the intrinsic
<span id="line16568"></span>          function.
<span id="line16569"></span>
<span id="line16570"></span>          18.2.2  External_Function.  A symbolic name is the name
<span id="line16571"></span>          of  an  external  function  if  it  meets either of the
<span id="line16572"></span>          following conditions:
<span id="line16573"></span>
<span id="line16574"></span>             (1) The name appears immediately following the  word
<span id="line16575"></span>                 FUNCTION  in  a  FUNCTION  statement or the word
<span id="line16576"></span>                 ENTRY in an ENTRY statement  within  a  function
<span id="line16577"></span>                 subprogram.
<span id="line16578"></span>
<span id="line16579"></span>             (2) It is not  an  array  name,  character  variable
<span id="line16580"></span>                 name,   statement   function   name,   intrinsic
<span id="line16581"></span>                 function name,  dummy  argument,  or  subroutine
<span id="line16582"></span>                 name,   and   every  appearance  is  immediately
<span id="line16583"></span>                 followed by  a  left  parenthesis  except  in  a
<span id="line16584"></span>                 type-statement,  in an EXTERNAL statement, or as
<span id="line16585"></span>                 an actual argument.
<span id="line16586"></span>
<span id="line16587"></span>          In a function subprogram, the name of a  function  that
<span id="line16588"></span>          appears  immediately  after  the  word  FUNCTION  in  a
<span id="line16589"></span>          FUNCTION statement or immediately after the word  ENTRY
<span id="line16590"></span>          in  an  ENTRY  statement  may  also  be  the  name of a
<span id="line16591"></span>          variable in that subprogram  (15.5.1).   At  least  one
<span id="line16592"></span>          such  function name must be the name of a variable in a
<span id="line16593"></span>          function subprogram.
<span id="line16594"></span>
<span id="line16595"></span>          An external function name is global to  the  executable
<span id="line16596"></span>          program.
<span id="line16597"></span>
<span id="line16598"></span>          18.2.3  Subroutine.  A symbolic name is the name  of  a
<span id="line16599"></span>          subroutine   if   it  meets  either  of  the  following
<span id="line16600"></span>          conditions:
<span id="line16601"></span>
<span id="line16602"></span>             (1) The name appears immediately following the  word
<span id="line16603"></span>                 SUBROUTINE in a SUBROUTINE statement or the word
<span id="line16604"></span>                 ENTRY in an ENTRY statement within a  subroutine
<span id="line16605"></span>                 subprogram.
<span id="line16606"></span>
<span id="line16607"></span>
<span id="line16608"></span>
<span id="line16609"></span>          FORTRAN 77 Full Language                      Page 18-3
<span id="line16610"></span>
<span id="line16611"></span>
<span id="line16612"></span>
<span id="line16613"></span>
<span id="line16614"></span>
<span id="line16615"></span>
<span id="line16616"></span>
<span id="line16617"></span>          SCOPES AND CLASSES OF SYMBOLIC NAMES     ANSI X3J3/90.4
<span id="line16618"></span>
<span id="line16619"></span>
<span id="line16620"></span>
<span id="line16621"></span>             (2) The name appears immediately following the  word
<span id="line16622"></span>                 CALL  in  a  CALL  statement  and is not a dummy
<span id="line16623"></span>                 argument.
<span id="line16624"></span>
<span id="line16625"></span>          A subroutine name is global to the executable program.
<span id="line16626"></span>
<span id="line16627"></span>          18.2.4  Main_Program.  A symbolic name is the name of a
<span id="line16628"></span>          main  program  if  and  only if it appears in a PROGRAM
<span id="line16629"></span>          statement in the main program.
<span id="line16630"></span>
<span id="line16631"></span>          A  main  program  name  is  global  to  the  executable
<span id="line16632"></span>          program.
<span id="line16633"></span>
<span id="line16634"></span>          18.2.5  Block_Data_Subprogram.  A symbolic name is  the
<span id="line16635"></span>          name  of  a  block  data  subprogram  if and only if it
<span id="line16636"></span>          appears in a BLOCK DATA statement.
<span id="line16637"></span>
<span id="line16638"></span>          A  block  data  subprogram  name  is  global   to   the
<span id="line16639"></span>          executable program.
<span id="line16640"></span>
<span id="line16641"></span>          18.2.6  Array.  A symbolic name is the name of an array
<span id="line16642"></span>          if  it appears as the array name in an array declarator
<span id="line16643"></span>          (5.1) in a DIMENSION, COMMON, or type-statement.
<span id="line16644"></span>
<span id="line16645"></span>          An array name is local to a program unit.
<span id="line16646"></span>
<span id="line16647"></span>          An array name may be the same as a common block name.
<span id="line16648"></span>
<span id="line16649"></span>          18.2.7  Variable.  A symbolic name is  the  name  of  a
<span id="line16650"></span>          variable if it meets all of the following conditions:
<span id="line16651"></span>
<span id="line16652"></span>             (1) It does not appear in a PARAMETER, INTRINSIC, or
<span id="line16653"></span>                 EXTERNAL statement.
<span id="line16654"></span>
<span id="line16655"></span>             (2) It is not the name of an array, subroutine, main
<span id="line16656"></span>                 program, or block data subprogram.
<span id="line16657"></span>
<span id="line16658"></span>             (3) It appears other than as the name  of  a  common
<span id="line16659"></span>                 block,  the  name  of  an external function in a
<span id="line16660"></span>                 FUNCTION statement, or an entry name in an ENTRY
<span id="line16661"></span>                 statement in an external function.
<span id="line16662"></span>
<span id="line16663"></span>             (4) It is  never  immediately  followed  by  a  left
<span id="line16664"></span>                 parenthesis unless it is immediately preceded by
<span id="line16665"></span>                 the word FUNCTION in a  FUNCTION  statement,  is
<span id="line16666"></span>                 immediately  preceded  by  the  word ENTRY in an
<span id="line16667"></span>                 ENTRY statement, or is at  the  beginning  of  a
<span id="line16668"></span>                 character substring name (5.7.1).
<span id="line16669"></span>
<span id="line16670"></span>          A variable  name  in  the  dummy  argument  list  of  a
<span id="line16671"></span>          statement  function statement is local to the statement
<span id="line16672"></span>
<span id="line16673"></span>
<span id="line16674"></span>
<span id="line16675"></span>          FORTRAN 77 Full Language                      Page 18-4
<span id="line16676"></span>
<span id="line16677"></span>
<span id="line16678"></span>
<span id="line16679"></span>
<span id="line16680"></span>
<span id="line16681"></span>
<span id="line16682"></span>
<span id="line16683"></span>          SCOPES AND CLASSES OF SYMBOLIC NAMES     ANSI X3J3/90.4
<span id="line16684"></span>
<span id="line16685"></span>
<span id="line16686"></span>
<span id="line16687"></span>          function statement in which it occurs.  Note  that  the
<span id="line16688"></span>          use  of  a  name  that  appears  in  Table 5 as a dummy
<span id="line16689"></span>          argument of a statement function removes  it  from  the
<span id="line16690"></span>          class  of  intrinsic  functions.   A variable name that
<span id="line16691"></span>          appears as an implied-DO-variable in a  DATA  statement
<span id="line16692"></span>          is  local  to  the implied-DO list.  All other variable
<span id="line16693"></span>          names are local to a program unit.
<span id="line16694"></span>
<span id="line16695"></span>          A statement function dummy argument name  may  also  be
<span id="line16696"></span>          the  name  of a variable or common block in the program
<span id="line16697"></span>          unit.  The appearance of the name in any context  other
<span id="line16698"></span>          than  as  a  dummy  argument  of the statement function
<span id="line16699"></span>          identifies the local variable  or  common  block.   The
<span id="line16700"></span>          statement   function  dummy  argument  name  and  local
<span id="line16701"></span>          variable name have  the  same  type  and,  if  of  type
<span id="line16702"></span>          character, both have the same constant length.
<span id="line16703"></span>
<span id="line16704"></span>          The name of an implied-DO-variable in a DATA  statement
<span id="line16705"></span>          may  also  be the name of a variable or common block in
<span id="line16706"></span>          the program unit.  The appearance of the  name  in  any
<span id="line16707"></span>          context  other  than  as  an implied-DO-variable in the
<span id="line16708"></span>          DATA statement identifies the local variable or  common
<span id="line16709"></span>          block.  The implied- DO-variable and the local variable
<span id="line16710"></span>          have the same type.
<span id="line16711"></span>
<span id="line16712"></span>          18.2.8  Constant.  A symbolic name is  the  name  of  a
<span id="line16713"></span>          constant  if  it  appears  as  a  symbolic  name  in  a
<span id="line16714"></span>          PARAMETER statement.
<span id="line16715"></span>
<span id="line16716"></span>          The symbolic name of a constant is local to  a  program
<span id="line16717"></span>          unit.
<span id="line16718"></span>
<span id="line16719"></span>          18.2.9  Statement_Function.  A  symbolic  name  is  the
<span id="line16720"></span>          name  of  a  statement function if a statement function
<span id="line16721"></span>          statement (15.4) is present for that symbolic name  and
<span id="line16722"></span>          it is not an array name.
<span id="line16723"></span>
<span id="line16724"></span>          A statement function name is local to a  program  unit.
<span id="line16725"></span>          A  statement  function name may be the same as a common
<span id="line16726"></span>          block name.
<span id="line16727"></span>
<span id="line16728"></span>          18.2.10  Intrinsic_Function.  A symbolic  name  is  the
<span id="line16729"></span>          name  of  an  intrinsic function if it meets all of the
<span id="line16730"></span>          following  conditions:
<span id="line16731"></span>
<span id="line16732"></span>             (1) The name appears in the Specific Name column  or
<span id="line16733"></span>                 the Generic Name column of Table 5.
<span id="line16734"></span>
<span id="line16735"></span>             (2) It is not  an  array  name,  statement  function
<span id="line16736"></span>                 name, subroutine name, or dummy argument name.
<span id="line16737"></span>
<span id="line16738"></span>
<span id="line16739"></span>
<span id="line16740"></span>
<span id="line16741"></span>          FORTRAN 77 Full Language                      Page 18-5
<span id="line16742"></span>
<span id="line16743"></span>
<span id="line16744"></span>
<span id="line16745"></span>
<span id="line16746"></span>
<span id="line16747"></span>
<span id="line16748"></span>
<span id="line16749"></span>          SCOPES AND CLASSES OF SYMBOLIC NAMES     ANSI X3J3/90.4
<span id="line16750"></span>
<span id="line16751"></span>
<span id="line16752"></span>
<span id="line16753"></span>             (3) Every appearance of the symbolic name, except in
<span id="line16754"></span>                 an  INTRINSIC statement, a type-statement, or as
<span id="line16755"></span>                 an actual argument, is immediately  followed  by
<span id="line16756"></span>                 an actual argument list enclosed in parentheses.
<span id="line16757"></span>
<span id="line16758"></span>          An intrinsic function name is local to a program unit.
<span id="line16759"></span>
<span id="line16760"></span>          18.2.11  Dummy_Procedure.  A symbolic name is the  name
<span id="line16761"></span>          of  a  dummy procedure if the name appears in the dummy
<span id="line16762"></span>          argument list  of  a  FUNCTION,  SUBROUTINE,  or  ENTRY
<span id="line16763"></span>          statement  and  meets  one  or  more  of  the following
<span id="line16764"></span>          conditions:
<span id="line16765"></span>
<span id="line16766"></span>             (1) It appears in an EXTERNAL statement.
<span id="line16767"></span>
<span id="line16768"></span>             (2) It appears immediately following the  word  CALL
<span id="line16769"></span>                 in a CALL statement.
<span id="line16770"></span>
<span id="line16771"></span>             (3) It is not an array name  or  character  variable
<span id="line16772"></span>                 name,   and   every  appearance  is  immediately
<span id="line16773"></span>                 followed by  a  left  parenthesis  except  in  a
<span id="line16774"></span>                 type-statement,  in  an EXTERNAL statement, in a
<span id="line16775"></span>                 CALL statement,  as  a  dummy  argument,  as  an
<span id="line16776"></span>                 actual  argument, or as a common block name in a
<span id="line16777"></span>                 COMMON or SAVE statement.
<span id="line16778"></span>
<span id="line16779"></span>          A dummy procedure name is local to a program unit.
<span id="line16780"></span>
<span id="line16781"></span>
<span id="line16782"></span>
<span id="line16783"></span>
<span id="line16784"></span>
<span id="line16785"></span>
<span id="line16786"></span>
<span id="line16787"></span>
<span id="line16788"></span>
<span id="line16789"></span>
<span id="line16790"></span>
<span id="line16791"></span>
<span id="line16792"></span>
<span id="line16793"></span>
<span id="line16794"></span>
<span id="line16795"></span>
<span id="line16796"></span>
<span id="line16797"></span>
<span id="line16798"></span>
<span id="line16799"></span>
<span id="line16800"></span>
<span id="line16801"></span>
<span id="line16802"></span>
<span id="line16803"></span>
<span id="line16804"></span>
<span id="line16805"></span>
<span id="line16806"></span>
<span id="line16807"></span>          FORTRAN 77 Full Language                      Page 18-6
<span id="line16808"></span>
<span id="line16809"></span>
<span id="line16810"></span>
<span id="line16811"></span>
<span id="line16812"></span>
<span id="line16813"></span>
<span id="line16814"></span>
<span id="line16815"></span>
<span id="line16816"></span>
<span id="line16817"></span>
<span id="line16818"></span>
<span id="line16819"></span>                                 CONTENTS
<span id="line16820"></span>
<span id="line16821"></span>
<span id="line16822"></span>          18.  SCOPES AND CLASSES OF SYMBOLIC NAMES........  18-1
<span id="line16823"></span>               18.1  Scope of Symbolic Names...............  18-1
<span id="line16824"></span>                     18.1.1   Global Entities..............  18-1
<span id="line16825"></span>                     18.1.2   Local Entities...............  18-2
<span id="line16826"></span>               18.2  Classes of Symbolic Names.............  18-2
<span id="line16827"></span>                     18.2.1   Common block.................  18-2
<span id="line16828"></span>                     18.2.2   External Function............  18-3
<span id="line16829"></span>                     18.2.3   Subroutine...................  18-3
<span id="line16830"></span>                     18.2.4   Main Program.................  18-4
<span id="line16831"></span>                     18.2.5   Block Data Subprogram........  18-4
<span id="line16832"></span>                     18.2.6   Array........................  18-4
<span id="line16833"></span>                     18.2.7   Variable.....................  18-4
<span id="line16834"></span>                     18.2.8   Constant.....................  18-5
<span id="line16835"></span>                     18.2.9   Statement Function...........  18-5
<span id="line16836"></span>                     18.2.10  Intrinsic Function...........  18-5
<span id="line16837"></span>                     18.2.11  Dummy Procedure..............  18-6
<span id="line16838"></span>
<span id="line16839"></span>
<span id="line16840"></span>
<span id="line16841"></span>
<span id="line16842"></span>
<span id="line16843"></span>
<span id="line16844"></span>
<span id="line16845"></span>
<span id="line16846"></span>
<span id="line16847"></span>
<span id="line16848"></span>
<span id="line16849"></span>
<span id="line16850"></span>
<span id="line16851"></span>
<span id="line16852"></span>
<span id="line16853"></span>
<span id="line16854"></span>
<span id="line16855"></span>
<span id="line16856"></span>
<span id="line16857"></span>
<span id="line16858"></span>
<span id="line16859"></span>
<span id="line16860"></span>
<span id="line16861"></span>
<span id="line16862"></span>
<span id="line16863"></span>
<span id="line16864"></span>
<span id="line16865"></span>
<span id="line16866"></span>
<span id="line16867"></span>
<span id="line16868"></span>
<span id="line16869"></span>
<span id="line16870"></span>
<span id="line16871"></span>
<span id="line16872"></span>
<span id="line16873"></span>                                   - i -
<span id="line16874"></span>
<span id="line16875"></span>
<span id="line16876"></span>
<span id="line16877"></span>
<span id="line16878"></span>
<span id="line16879"></span>
<span id="line16880"></span>
<span id="line16881"></span>                                                   ANSI X3J3/90.4
<span id="line16882"></span>
<span id="line16883"></span>
<span id="line16884"></span>
<span id="line16885"></span>             APPENDIX_A:_CRITERIA,_CONFLICTS,_AND_PORTABILITY
<span id="line16886"></span>
<span id="line16887"></span>
<span id="line16888"></span>          A1.  Criteria
<span id="line16889"></span>
<span id="line16890"></span>          The principal criteria used in developing this  FORTRAN
<span id="line16891"></span>          standard were:
<span id="line16892"></span>
<span id="line16893"></span>             (1) Interchangeability of FORTRAN  programs  between
<span id="line16894"></span>                 processors
<span id="line16895"></span>
<span id="line16896"></span>             (2) Compatibility  with   ANSI   X3.9-1966,   allied
<span id="line16897"></span>                 standards, and existing practices
<span id="line16898"></span>
<span id="line16899"></span>             (3) Consistency and simplicity to user
<span id="line16900"></span>
<span id="line16901"></span>             (4) Suitability for  efficient  processor  operation
<span id="line16902"></span>                 for  a  wide  range  of  computing  equipment of
<span id="line16903"></span>                 varying structure and power
<span id="line16904"></span>
<span id="line16905"></span>             (5) Allowance for future growth in the language
<span id="line16906"></span>
<span id="line16907"></span>             (6) Achievement  of   capabilities   not   currently
<span id="line16908"></span>                 available,     but    needed    for    processes
<span id="line16909"></span>                 appropriately expressed in FORTRAN
<span id="line16910"></span>
<span id="line16911"></span>             (7) Acceptability by a significant portion of users
<span id="line16912"></span>
<span id="line16913"></span>             (8) Improved ability to  use  FORTRAN  programs  and
<span id="line16914"></span>                 data  in  conjunction  with  other languages and
<span id="line16915"></span>                 environments
<span id="line16916"></span>
<span id="line16917"></span>
<span id="line16918"></span>          A2.  Conflicts_with_ANSI_X3.9-1966
<span id="line16919"></span>
<span id="line16920"></span>          An extremely important consideration in the preparation
<span id="line16921"></span>          of this standard was the minimization of conflicts with
<span id="line16922"></span>          the previous standard, ANSI X3.9-1966.   This  standard
<span id="line16923"></span>          includes  changes that create conflicts with ANSI X3.9-
<span id="line16924"></span>          1966 only when such changes were necessary  to  correct
<span id="line16925"></span>          an  error  in  the  previous  standard or to add to the
<span id="line16926"></span>          power of the FORTRAN language in a significant  manner.
<span id="line16927"></span>          The following is a list of known conflicts:
<span id="line16928"></span>
<span id="line16929"></span>             (1) A line that contains only  blank  characters  in
<span id="line16930"></span>                 columns  1  through  72 is a comment line.  ANSI
<span id="line16931"></span>                 X3.9-1966 allowed such a line to be the  initial
<span id="line16932"></span>                 line of a statement.
<span id="line16933"></span>
<span id="line16934"></span>             (2) Columns 1 through 5 of a continuation line  must
<span id="line16935"></span>                 contain  blanks.   A published interpretation of
<span id="line16936"></span>
<span id="line16937"></span>
<span id="line16938"></span>
<span id="line16939"></span>          FORTRAN 77 Full Language                       Page A-1
<span id="line16940"></span>
<span id="line16941"></span>
<span id="line16942"></span>
<span id="line16943"></span>
<span id="line16944"></span>
<span id="line16945"></span>
<span id="line16946"></span>
<span id="line16947"></span>          APPENDIX A: CRITERIA, CONFLICTS, AND PORTABILITYANSI X3J3/90.4
<span id="line16948"></span>
<span id="line16949"></span>
<span id="line16950"></span>
<span id="line16951"></span>                 ANSI X3.9-1966 specified that columns 1-5  of  a
<span id="line16952"></span>                 continuation line may contain any character from
<span id="line16953"></span>                 the FORTRAN character set except that  column  1
<span id="line16954"></span>                 must not contain a C.
<span id="line16955"></span>
<span id="line16956"></span>             (3) Hollerith constants and Hollerith data  are  not
<span id="line16957"></span>                 permitted  in  this  standard.   ANSI  X3.9-1966
<span id="line16958"></span>                 permitted the use of Hollerith constants in DATA
<span id="line16959"></span>                 and  CALL  statements,  the  use of noncharacter
<span id="line16960"></span>                 list items in formatted input/output  statements
<span id="line16961"></span>                 with  A edit descriptors, and the referencing of
<span id="line16962"></span>                 noncharacter arrays as formats.  Note that the H
<span id="line16963"></span>                 edit  (field) descriptor is permitted; it is not
<span id="line16964"></span>                 a Hollerith constant.
<span id="line16965"></span>
<span id="line16966"></span>             (4) The  value  of  each  comma-separated  subscript
<span id="line16967"></span>                 expression  in  a  subscript must not exceed its
<span id="line16968"></span>                 corresponding upper bound declared for the array
<span id="line16969"></span>                 name in the program unit.  In the example:
<span id="line16970"></span>
<span id="line16971"></span>                    DIMENSION A(10,5)
<span id="line16972"></span>                    Y=A(11,1)
<span id="line16973"></span>
<span id="line16974"></span>                 The reference to A(11,1) is  not  permitted  for
<span id="line16975"></span>                 the  array  A(10,5).  ANSI X3.9-1966 permitted a
<span id="line16976"></span>                 subscript expression to exceed its corresponding
<span id="line16977"></span>                 upper  bound  if the maximum subscript value for
<span id="line16978"></span>                 the array was not exceeded.
<span id="line16979"></span>
<span id="line16980"></span>             (5) Only  an  array  that  is  declared  as  a  one-
<span id="line16981"></span>                 dimensional array in the program unit may have a
<span id="line16982"></span>                 one-dimensional  subscript  in  an   EQUIVALENCE
<span id="line16983"></span>                 statement.  In the example:
<span id="line16984"></span>
<span id="line16985"></span>                    DIMENSION B(2,3,4), C(4,8)
<span id="line16986"></span>                    EQUIVALENCE (B(23), C(1,1))
<span id="line16987"></span>
<span id="line16988"></span>                 B(23)  is   not   permitted.    ANSI   X3.9-1966
<span id="line16989"></span>                 permitted  arrays  that were declared as two- or
<span id="line16990"></span>                 three-dimensional  arrays  to   appear   in   an
<span id="line16991"></span>                 EQUIVALENCE  statement  with  a  one-dimensional
<span id="line16992"></span>                 subscript.
<span id="line16993"></span>
<span id="line16994"></span>             (6) A  name  must  not  have  its  type   explicitly
<span id="line16995"></span>                 specified  more  than  once  in  a program unit.
<span id="line16996"></span>                 ANSI X3.9-1966 did not explicitly  have  such  a
<span id="line16997"></span>                 prohibition.
<span id="line16998"></span>
<span id="line16999"></span>             (7) This standard does  not  permit  a  transfer  of
<span id="line17000"></span>                 control into the range of a DO-loop from outside
<span id="line17001"></span>                 the range.   The  range  of  a  DO-loop  may  be
<span id="line17002"></span>
<span id="line17003"></span>
<span id="line17004"></span>
<span id="line17005"></span>          FORTRAN 77 Full Language                       Page A-2
<span id="line17006"></span>
<span id="line17007"></span>
<span id="line17008"></span>
<span id="line17009"></span>
<span id="line17010"></span>
<span id="line17011"></span>
<span id="line17012"></span>
<span id="line17013"></span>          APPENDIX A: CRITERIA, CONFLICTS, AND PORTABILITYANSI X3J3/90.4
<span id="line17014"></span>
<span id="line17015"></span>
<span id="line17016"></span>
<span id="line17017"></span>                 entered only by the execution of a DO statement.
<span id="line17018"></span>                 ANSI X3.9-1966  permitted  transfer  of  control
<span id="line17019"></span>                 into  the  range  of  a  DO-loop  under  certain
<span id="line17020"></span>                 conditions.  This involved the concept  referred
<span id="line17021"></span>                 to as "extended range of a DO."
<span id="line17022"></span>
<span id="line17023"></span>             (8) A labeled END statement could conflict with  the
<span id="line17024"></span>                 initial line of a statement in an ANSI X3.9-1966
<span id="line17025"></span>                 standard-conforming program.
<span id="line17026"></span>
<span id="line17027"></span>             (9) A record must not be written  after  an  endfile
<span id="line17028"></span>                 record in a sequential file.  ANSI X3.9-1966 did
<span id="line17029"></span>                 not   prohibit    this,    but    provided    no
<span id="line17030"></span>                 interpretation  for  the  reading  of an endfile
<span id="line17031"></span>                 record.
<span id="line17032"></span>
<span id="line17033"></span>            (10) A sequential file may not contain both formatted
<span id="line17034"></span>                 and    unformatted    records.     A   published
<span id="line17035"></span>                 interpretation of ANSI X3.9-1966 specified  that
<span id="line17036"></span>                 this was permitted.
<span id="line17037"></span>
<span id="line17038"></span>            (11) Negative   values    for    input/output    unit
<span id="line17039"></span>                 identifiers  are  prohibited  in  this standard.
<span id="line17040"></span>                 ANSI X3.9-1966 did not explicitly prohibit  them
<span id="line17041"></span>                 for variable unit identifiers.
<span id="line17042"></span>
<span id="line17043"></span>            (12) A simple I/O list  enclosed  in  parentheses  is
<span id="line17044"></span>                 prohibited from appearing in an I/O list.
<span id="line17045"></span>
<span id="line17046"></span>                 This requires that  parentheses  enclosing  more
<span id="line17047"></span>                 than  one I/O list item must mark an implied DO-
<span id="line17048"></span>                 loop.  The restriction was imposed to  eliminate
<span id="line17049"></span>                 potential  syntactic  ambiguities  introduced by
<span id="line17050"></span>                 complex constants in list-directed output lists.
<span id="line17051"></span>                 As   all   the   parentheses   referred  to  are
<span id="line17052"></span>                 redundant, a program can be made conforming with
<span id="line17053"></span>                 this  standard by deleting redundant parentheses
<span id="line17054"></span>                 enclosing more than one  list  item  in  an  I/O
<span id="line17055"></span>                 list.
<span id="line17056"></span>
<span id="line17057"></span>            (13) The definition of an entity associated  with  an
<span id="line17058"></span>                 entity  in an input list occurs at the same time
<span id="line17059"></span>                 as the definition  of  the  list  entity.   ANSI
<span id="line17060"></span>                 X3.9-1966  delayed  the  definition  of  such an
<span id="line17061"></span>                 associated entity until the end of execution  of
<span id="line17062"></span>                 the input statement.
<span id="line17063"></span>
<span id="line17064"></span>            (14) Reading into an H edit (field) descriptor  in  a
<span id="line17065"></span>                 FORMAT statement is prohibited in this standard.
<span id="line17066"></span>
<span id="line17067"></span>
<span id="line17068"></span>
<span id="line17069"></span>
<span id="line17070"></span>
<span id="line17071"></span>          FORTRAN 77 Full Language                       Page A-3
<span id="line17072"></span>
<span id="line17073"></span>
<span id="line17074"></span>
<span id="line17075"></span>
<span id="line17076"></span>
<span id="line17077"></span>
<span id="line17078"></span>
<span id="line17079"></span>          APPENDIX A: CRITERIA, CONFLICTS, AND PORTABILITYANSI X3J3/90.4
<span id="line17080"></span>
<span id="line17081"></span>
<span id="line17082"></span>
<span id="line17083"></span>            (15) The range of a scale factor  for  E,  D,  and  G
<span id="line17084"></span>                 output   fields   is  restricted  to  reasonable
<span id="line17085"></span>                 values.  ANSI X3.9-1966 had no such restriction,
<span id="line17086"></span>                 but  did  not  provide a clear interpretation of
<span id="line17087"></span>                 the meaning of the unreasonable values.
<span id="line17088"></span>
<span id="line17089"></span>            (16) A processor must not produce  a  numeric  output
<span id="line17090"></span>                 field  containing  a  negative zero.  ANSI X3.9-
<span id="line17091"></span>                 1966 required this if the internal  value  of  a
<span id="line17092"></span>                 real or double precision datum was negative.
<span id="line17093"></span>
<span id="line17094"></span>            (17) On  output,  the  I  edit  descriptor  must  not
<span id="line17095"></span>                 produce unnecessary leading zeros.
<span id="line17096"></span>
<span id="line17097"></span>            (18) On  output,  the  F  edit  descriptor  must  not
<span id="line17098"></span>                 produce  unnecessary  leading  zeros, other than
<span id="line17099"></span>                 the optional leading zero for a value less  than
<span id="line17100"></span>                 one.
<span id="line17101"></span>
<span id="line17102"></span>            (19) Following the E or D in an E or D output  field,
<span id="line17103"></span>                 a  +  or  - is required immediately prior to the
<span id="line17104"></span>                 exponent  field.   This  improves  compatibility
<span id="line17105"></span>                 with   American   National   Standard   for  the
<span id="line17106"></span>                 Representation of Numeric  Values  in  Character
<span id="line17107"></span>                 Strings   for   Information   Interchange,  ANSI
<span id="line17108"></span>                 X3.42-1975.  ANSI X3.9-1966 permitted a blank as
<span id="line17109"></span>                 a replacement for + in the exponent sign.
<span id="line17110"></span>
<span id="line17111"></span>            (20) An intrinsic function name that is  used  as  an
<span id="line17112"></span>                 actual  argument  must  appear  in  an INTRINSIC
<span id="line17113"></span>                 statement rather  than  an  EXTERNAL  statement.
<span id="line17114"></span>                 Note  that the intrinsic function class includes
<span id="line17115"></span>                 the basic external function class of ANSI  X3.9-
<span id="line17116"></span>                 1966.
<span id="line17117"></span>
<span id="line17118"></span>            (21) The appearance of an intrinsic function name  in
<span id="line17119"></span>                 a  type-statement  that  conflicts with the type
<span id="line17120"></span>                 specified in Table 5 is not sufficient to remove
<span id="line17121"></span>                 the  name from the intrinsic function class.  In
<span id="line17122"></span>                 ANSI X3.9-1966, this condition was sufficient to
<span id="line17123"></span>                 remove  the  name  from  the  intrinsic function
<span id="line17124"></span>                 class.
<span id="line17125"></span>
<span id="line17126"></span>            (22) More intrinsic function names  have  been  added
<span id="line17127"></span>                 and   could   conflict   with   the   names   of
<span id="line17128"></span>                 subprograms.  These names are ACOS, ANINT, ASIN,
<span id="line17129"></span>                 CHAR,  COSH,  DACOS,  DASIN,  DCOSH, DDIM, DINT,
<span id="line17130"></span>                 DNINT, DPROD, DSINH, DTAN, DTANH, ICHAR, IDNINT,
<span id="line17131"></span>                 INDEX, LEN, LGE, LGT, LLE, LLT, LOG, LOG10, MAX,
<span id="line17132"></span>                 MIN, NINT, SINH, and TAN.
<span id="line17133"></span>
<span id="line17134"></span>
<span id="line17135"></span>
<span id="line17136"></span>
<span id="line17137"></span>          FORTRAN 77 Full Language                       Page A-4
<span id="line17138"></span>
<span id="line17139"></span>
<span id="line17140"></span>
<span id="line17141"></span>
<span id="line17142"></span>
<span id="line17143"></span>
<span id="line17144"></span>
<span id="line17145"></span>          APPENDIX A: CRITERIA, CONFLICTS, AND PORTABILITYANSI X3J3/90.4
<span id="line17146"></span>
<span id="line17147"></span>
<span id="line17148"></span>
<span id="line17149"></span>            (23) The units of the arguments and  results  of  the
<span id="line17150"></span>                 intrinsic    functions   (and   basic   external
<span id="line17151"></span>                 functions) were not specified in ANSI  X3.9-1966
<span id="line17152"></span>                 and  are  specified in this standard.  The range
<span id="line17153"></span>                 of the  arguments  and  results  has  also  been
<span id="line17154"></span>                 specified.     These   specifications   may   be
<span id="line17155"></span>                 different from those  used  on  some  processors
<span id="line17156"></span>                 conforming to ANSI X3.9-1966.
<span id="line17157"></span>
<span id="line17158"></span>            (24) An executable program must not contain more than
<span id="line17159"></span>                 one  unnamed  block data subprogram.  ANSI X3.9-
<span id="line17160"></span>                 1966 did not have this prohibition and could  be
<span id="line17161"></span>                 interpreted to permit more than one.
<span id="line17162"></span>
<span id="line17163"></span>
<span id="line17164"></span>          A3.  Standard_Items_That_Inhibit_Portability
<span id="line17165"></span>
<span id="line17166"></span>          Although the primary purpose of  this  standard  is  to
<span id="line17167"></span>          promote portability of FORTRAN programs, there are some
<span id="line17168"></span>          items in it that tend to inhibit portability.
<span id="line17169"></span>
<span id="line17170"></span>             (1) Procedures  written  in  languages  other   than
<span id="line17171"></span>                 FORTRAN may not be portable.
<span id="line17172"></span>
<span id="line17173"></span>             (2) Because the  collating  sequence  has  not  been
<span id="line17174"></span>                 completely   specified,   character   relational
<span id="line17175"></span>                 expressions do not  necessarily  have  the  same
<span id="line17176"></span>                 value on all processors.  However, the intrinsic
<span id="line17177"></span>                 functions LGE, LGT, LLE, and LLT can be used  to
<span id="line17178"></span>                 provide  a more portable comparison of character
<span id="line17179"></span>                 entities.
<span id="line17180"></span>
<span id="line17181"></span>             (3) Character data, H edit  descriptors,  apostrophe
<span id="line17182"></span>                 edit  descriptors, and comment lines may include
<span id="line17183"></span>                 characters that are acceptable to one  processor
<span id="line17184"></span>                 but unacceptable to another processor.
<span id="line17185"></span>
<span id="line17186"></span>             (4) No explicit requirements are specified for  file
<span id="line17187"></span>                 names.   A  file  name that is acceptable to one
<span id="line17188"></span>                 processor  may  be   unacceptable   to   another
<span id="line17189"></span>                 processor.
<span id="line17190"></span>
<span id="line17191"></span>             (5) Input/output unit numbers and unit  capabilities
<span id="line17192"></span>                 may vary among processors.
<span id="line17193"></span>
<span id="line17194"></span>
<span id="line17195"></span>
<span id="line17196"></span>
<span id="line17197"></span>
<span id="line17198"></span>
<span id="line17199"></span>
<span id="line17200"></span>
<span id="line17201"></span>
<span id="line17202"></span>
<span id="line17203"></span>          FORTRAN 77 Full Language                       Page A-5
<span id="line17204"></span>
<span id="line17205"></span>
<span id="line17206"></span>
<span id="line17207"></span>
<span id="line17208"></span>
<span id="line17209"></span>
<span id="line17210"></span>
<span id="line17211"></span>          APPENDIX A: CRITERIA, CONFLICTS, AND PORTABILITYANSI X3J3/90.4
<span id="line17212"></span>
<span id="line17213"></span>
<span id="line17214"></span>
<span id="line17215"></span>          A4.  Recommendation_for_Enhancing_Portability
<span id="line17216"></span>
<span id="line17217"></span>          To  enhance  the  development   of   portable   FORTRAN
<span id="line17218"></span>          programs,  a  producer  should  provide  some  means of
<span id="line17219"></span>          identifying  nonstandard  syntax   supported   by   his
<span id="line17220"></span>          processor.    Alternatives   for   doing  this  include
<span id="line17221"></span>          appropriate documentation, features of  the  processor,
<span id="line17222"></span>          and other means.
<span id="line17223"></span>
<span id="line17224"></span>
<span id="line17225"></span>
<span id="line17226"></span>
<span id="line17227"></span>
<span id="line17228"></span>
<span id="line17229"></span>
<span id="line17230"></span>
<span id="line17231"></span>
<span id="line17232"></span>
<span id="line17233"></span>
<span id="line17234"></span>
<span id="line17235"></span>
<span id="line17236"></span>
<span id="line17237"></span>
<span id="line17238"></span>
<span id="line17239"></span>
<span id="line17240"></span>
<span id="line17241"></span>
<span id="line17242"></span>
<span id="line17243"></span>
<span id="line17244"></span>
<span id="line17245"></span>
<span id="line17246"></span>
<span id="line17247"></span>
<span id="line17248"></span>
<span id="line17249"></span>
<span id="line17250"></span>
<span id="line17251"></span>
<span id="line17252"></span>
<span id="line17253"></span>
<span id="line17254"></span>
<span id="line17255"></span>
<span id="line17256"></span>
<span id="line17257"></span>
<span id="line17258"></span>
<span id="line17259"></span>
<span id="line17260"></span>
<span id="line17261"></span>
<span id="line17262"></span>
<span id="line17263"></span>
<span id="line17264"></span>
<span id="line17265"></span>
<span id="line17266"></span>
<span id="line17267"></span>
<span id="line17268"></span>
<span id="line17269"></span>          FORTRAN 77 Full Language                       Page A-6
<span id="line17270"></span>
<span id="line17271"></span>
<span id="line17272"></span>
<span id="line17273"></span>
<span id="line17274"></span>
<span id="line17275"></span>
<span id="line17276"></span>
<span id="line17277"></span>
<span id="line17278"></span>
<span id="line17279"></span>
<span id="line17280"></span>
<span id="line17281"></span>                                 CONTENTS
<span id="line17282"></span>
<span id="line17283"></span>          APPENDIX A: CRITERIA, CONFLICTS, AND PORTABILITY..  A
<span id="line17284"></span>          -1
<span id="line17285"></span>          A1.     Criteria..................................  A-1
<span id="line17286"></span>          A2.     Conflicts with ANSI X3.9-1966.............  A-1
<span id="line17287"></span>          A3.     Standard Items That Inhibit
<span id="line17288"></span>          Portability.......................................  A-5
<span id="line17289"></span>          A4.     Recommendation for Enhancing
<span id="line17290"></span>          Portability.......................................  A-6
<span id="line17291"></span>
<span id="line17292"></span>
<span id="line17293"></span>
<span id="line17294"></span>
<span id="line17295"></span>
<span id="line17296"></span>
<span id="line17297"></span>
<span id="line17298"></span>
<span id="line17299"></span>
<span id="line17300"></span>
<span id="line17301"></span>
<span id="line17302"></span>
<span id="line17303"></span>
<span id="line17304"></span>
<span id="line17305"></span>
<span id="line17306"></span>
<span id="line17307"></span>
<span id="line17308"></span>
<span id="line17309"></span>
<span id="line17310"></span>
<span id="line17311"></span>
<span id="line17312"></span>
<span id="line17313"></span>
<span id="line17314"></span>
<span id="line17315"></span>
<span id="line17316"></span>
<span id="line17317"></span>
<span id="line17318"></span>
<span id="line17319"></span>
<span id="line17320"></span>
<span id="line17321"></span>
<span id="line17322"></span>
<span id="line17323"></span>
<span id="line17324"></span>
<span id="line17325"></span>
<span id="line17326"></span>
<span id="line17327"></span>
<span id="line17328"></span>
<span id="line17329"></span>
<span id="line17330"></span>
<span id="line17331"></span>
<span id="line17332"></span>
<span id="line17333"></span>
<span id="line17334"></span>
<span id="line17335"></span>                                   - i -
<span id="line17336"></span>
<span id="line17337"></span>
<span id="line17338"></span>
<span id="line17339"></span>
<span id="line17340"></span>
<span id="line17341"></span>
<span id="line17342"></span>
<span id="line17343"></span>                                                   ANSI X3J3/90.4
<span id="line17344"></span>
<span id="line17345"></span>
<span id="line17346"></span>
<span id="line17347"></span>                         APPENDIX_B:_SECTION_NOTES
<span id="line17348"></span>
<span id="line17349"></span>
<span id="line17350"></span>          B1.  Section_1_Notes
<span id="line17351"></span>
<span id="line17352"></span>          What this standard calls a "processor" is any mechanism
<span id="line17353"></span>          that can carry out the actions of a program.  Commonly,
<span id="line17354"></span>          this may be any of these:
<span id="line17355"></span>
<span id="line17356"></span>             (1) The combined actions of a  computer  (hardware),
<span id="line17357"></span>                 its operating system, a compiler, and a loader
<span id="line17358"></span>
<span id="line17359"></span>             (2) An interpreter
<span id="line17360"></span>
<span id="line17361"></span>             (3) The mind of a human, perhaps with  the  help  of
<span id="line17362"></span>                 paper and pencil
<span id="line17363"></span>
<span id="line17364"></span>          When you read this standard, it is  important  to  keep
<span id="line17365"></span>          its  point  of  view  in mind.  The standard is written
<span id="line17366"></span>          from the point  of  view  of  a  programmer  using  the
<span id="line17367"></span>          language,  and  not  from  the  point  of  view  of the
<span id="line17368"></span>          implementation of a  processor.   This  point  of  view
<span id="line17369"></span>          affects the way you should interpret the standard.  For
<span id="line17370"></span>          example, in 3.3 the assertion is made:
<span id="line17371"></span>
<span id="line17372"></span>                 "... a statement must contain no more than  1320
<span id="line17373"></span>                 characters."
<span id="line17374"></span>
<span id="line17375"></span>          This  means  that  if  a  programmer  writes  a  longer
<span id="line17376"></span>          statement,  his  program  is  not  standard conforming.
<span id="line17377"></span>          Therefore, it will get different treatment on different
<span id="line17378"></span>          processors.   Some  processors will accept the program,
<span id="line17379"></span>          and some will not.  Some may even seemingly accept  the
<span id="line17380"></span>          program  but  process  it  incorrectly.   The assertion
<span id="line17381"></span>          means  that  all  standard-conforming  processors  must
<span id="line17382"></span>          accept  statements up to 1320 characters long.  That is
<span id="line17383"></span>          the  only   inference   about   a   standard-conforming
<span id="line17384"></span>          processor that can be made from the assertion.
<span id="line17385"></span>
<span id="line17386"></span>          The assertion does not mean that a  standard-conforming
<span id="line17387"></span>          processor   is   prohibited   from   accepting   longer
<span id="line17388"></span>          statements.  Accepting longer statements  would  be  an
<span id="line17389"></span>          extension.
<span id="line17390"></span>
<span id="line17391"></span>          The assertion does not mean that a  standard-conforming
<span id="line17392"></span>          processor  must  diagnose  statements  longer than 1320
<span id="line17393"></span>          characters, although it may do so.
<span id="line17394"></span>
<span id="line17395"></span>          In general, a standard-conforming processor is one that
<span id="line17396"></span>          accepts  all standard-conforming programs and processes
<span id="line17397"></span>          them according to the rules of  this  standard.   Thus,
<span id="line17398"></span>
<span id="line17399"></span>
<span id="line17400"></span>
<span id="line17401"></span>          FORTRAN 77 Full Language                       Page B-1
<span id="line17402"></span>
<span id="line17403"></span>
<span id="line17404"></span>
<span id="line17405"></span>
<span id="line17406"></span>
<span id="line17407"></span>
<span id="line17408"></span>
<span id="line17409"></span>          APPENDIX B: SECTION NOTES                ANSI X3J3/90.4
<span id="line17410"></span>
<span id="line17411"></span>
<span id="line17412"></span>
<span id="line17413"></span>          the  specification  of  a standard-conforming processor
<span id="line17414"></span>          must be inferred from this document.
<span id="line17415"></span>
<span id="line17416"></span>          In some places, explicit prohibitions  or  restrictions
<span id="line17417"></span>          are   stated,   such   as  the  above  statement-length
<span id="line17418"></span>          restriction.  Such assertions restrict what programmers
<span id="line17419"></span>          can  write  in standard-conforming programs and have no
<span id="line17420"></span>          more weight in the standard than  an  omitted  feature.
<span id="line17421"></span>          For  example,  there  is  no  mention  anywhere  in the
<span id="line17422"></span>          standard of double precision integers.  Because  it  is
<span id="line17423"></span>          omitted,  programmers  must  not  use  this  feature in
<span id="line17424"></span>          standard-conforming  programs.   A  standard-conforming
<span id="line17425"></span>          processor  may  or  may  not provide it or diagnose its
<span id="line17426"></span>          use.  Thus, an explicit prohibition (such as statements
<span id="line17427"></span>          longer  than  1320 characters) and an omission (such as
<span id="line17428"></span>          double  precision  integers)  are  equivalent  in  this
<span id="line17429"></span>          standard.
<span id="line17430"></span>
<span id="line17431"></span>
<span id="line17432"></span>          B2.  Section_2_Notes
<span id="line17433"></span>
<span id="line17434"></span>          Some of  the  terminology  used  in  this  document  is
<span id="line17435"></span>          different  from that used to describe other programming
<span id="line17436"></span>          languages.  The following indicates  terms  from  other
<span id="line17437"></span>          languages  that  are  approximately  equivalent to some
<span id="line17438"></span>          FORTRAN terms.
<span id="line17439"></span>
<span id="line17440"></span>              FORTRAN_______                Other Languages_______________
<span id="line17441"></span>
<span id="line17442"></span>              Variable               Simple Variable
<span id="line17443"></span>              Array Element          Subscripted Variable
<span id="line17444"></span>              Subscript Expression   Subscript
<span id="line17445"></span>              Subscript              (none)
<span id="line17446"></span>              Dummy Argument         Formal Argument, Formal
<span id="line17447"></span>                                       Parameter
<span id="line17448"></span>              Actual Argument        Actual Parameter
<span id="line17449"></span>
<span id="line17450"></span>          In  particular,  the  FORTRAN  terms  "subscript"   and
<span id="line17451"></span>          "subscript  expression"  should be studied carefully by
<span id="line17452"></span>          readers who are unfamiliar with this standard (5.4).
<span id="line17453"></span>
<span id="line17454"></span>          The term "symbolic name"  is  frequently  shortened  to
<span id="line17455"></span>          "name" throughout the standard.
<span id="line17456"></span>
<span id="line17457"></span>
<span id="line17458"></span>          B3.  Section_3_Notes
<span id="line17459"></span>
<span id="line17460"></span>          A  partial  collating  sequence   is   specified.    If
<span id="line17461"></span>          possible,  a processor should use the American National
<span id="line17462"></span>          Standard Code for Information Interchange,  ANSI  X3.4-
<span id="line17463"></span>          1977   (ASCII),   sequence  for  the  complete  FORTRAN
<span id="line17464"></span>
<span id="line17465"></span>
<span id="line17466"></span>
<span id="line17467"></span>          FORTRAN 77 Full Language                       Page B-2
<span id="line17468"></span>
<span id="line17469"></span>
<span id="line17470"></span>
<span id="line17471"></span>
<span id="line17472"></span>
<span id="line17473"></span>
<span id="line17474"></span>
<span id="line17475"></span>          APPENDIX B: SECTION NOTES                ANSI X3J3/90.4
<span id="line17476"></span>
<span id="line17477"></span>
<span id="line17478"></span>
<span id="line17479"></span>          character set.
<span id="line17480"></span>
<span id="line17481"></span>          When a continuation line follows a  comment  line,  the
<span id="line17482"></span>          continuation  line is part of the current statement; it
<span id="line17483"></span>          is not a continuation of the comment line.   A  comment
<span id="line17484"></span>          line is not part of a statement.
<span id="line17485"></span>
<span id="line17486"></span>          The  standard  does  not   restrict   the   number   of
<span id="line17487"></span>          consecutive   comment   lines.    The   limit   of   19
<span id="line17488"></span>          continuation lines permitted for a statement should not
<span id="line17489"></span>          be  construed  as  being  a limitation on the number of
<span id="line17490"></span>          consecutive comment lines.
<span id="line17491"></span>
<span id="line17492"></span>          There are 99999 unique statement labels and a processor
<span id="line17493"></span>          must  accept  99999  as  a statement label.  However, a
<span id="line17494"></span>          processor may have an implementation limit on the total
<span id="line17495"></span>          number  of  unique statement labels in one program unit
<span id="line17496"></span>          (3.4).
<span id="line17497"></span>
<span id="line17498"></span>          Blanks  and  leading  zeros  are  not  significant   in
<span id="line17499"></span>          distinguishing  between statement labels.  For example,
<span id="line17500"></span>          123, 1 23, and 0123 are all forms of the same statement
<span id="line17501"></span>          label.
<span id="line17502"></span>
<span id="line17503"></span>
<span id="line17504"></span>          B4.  Section_4_Notes
<span id="line17505"></span>
<span id="line17506"></span>          A processor must not consider a  negative  zero  to  be
<span id="line17507"></span>          different from a positive zero.
<span id="line17508"></span>
<span id="line17509"></span>          ANSI X3.9-1966 used the  term  "constant"  to  mean  an
<span id="line17510"></span>          unsigned   constant.    This  standard  uses  the  term
<span id="line17511"></span>          "constant" to  have  its  more  normal  meaning  of  an
<span id="line17512"></span>          optionally  signed  constant when describing arithmetic
<span id="line17513"></span>          constants.   The  term  "unsigned  constant"  is   used
<span id="line17514"></span>          wherever   a  leading  sign  is  not  permitted  on  an
<span id="line17515"></span>          arithmetic constant.
<span id="line17516"></span>
<span id="line17517"></span>          A character constant is a representation of a character
<span id="line17518"></span>          value.   The  delimiting  apostrophes  are  part of the
<span id="line17519"></span>          representation  but  not  part  of  the  value;  double
<span id="line17520"></span>          apostrophes  are  used  to  represent a single embedded
<span id="line17521"></span>          apostrophe.  For example:
<span id="line17522"></span>
<span id="line17523"></span>
<span id="line17524"></span>
<span id="line17525"></span>
<span id="line17526"></span>
<span id="line17527"></span>
<span id="line17528"></span>
<span id="line17529"></span>
<span id="line17530"></span>
<span id="line17531"></span>
<span id="line17532"></span>
<span id="line17533"></span>          FORTRAN 77 Full Language                       Page B-3
<span id="line17534"></span>
<span id="line17535"></span>
<span id="line17536"></span>
<span id="line17537"></span>
<span id="line17538"></span>
<span id="line17539"></span>
<span id="line17540"></span>
<span id="line17541"></span>          APPENDIX B: SECTION NOTES                ANSI X3J3/90.4
<span id="line17542"></span>
<span id="line17543"></span>
<span id="line17544"></span>
<span id="line17545"></span>8                       ____________________________
<span id="line17546"></span>
<span id="line17547"></span>                          Character      Character
<span id="line17548"></span>                          Constant         Value
<span id="line17549"></span>8                       ____________________________
<span id="line17550"></span>
<span id="line17551"></span>                            'CAT'           CAT
<span id="line17552"></span>                           'ISN''T'        ISN'T
<span id="line17553"></span>                        '''ISN''''T'''   'ISN''T'
<span id="line17554"></span>8                       ____________________________
<span id="line17555"></span>7                      |7|7|7|7|7|7|7|
<span id="line17556"></span>
<span id="line17557"></span>
<span id="line17558"></span>
<span id="line17559"></span>
<span id="line17560"></span>
<span id="line17561"></span>
<span id="line17562"></span>                                      |7|7|7|7|7|7|7|
<span id="line17563"></span>
<span id="line17564"></span>
<span id="line17565"></span>
<span id="line17566"></span>
<span id="line17567"></span>
<span id="line17568"></span>
<span id="line17569"></span>                                                  |7|7|7|7|7|7|7|
<span id="line17570"></span>
<span id="line17571"></span>
<span id="line17572"></span>
<span id="line17573"></span>
<span id="line17574"></span>
<span id="line17575"></span>
<span id="line17576"></span>
<span id="line17577"></span>
<span id="line17578"></span>          Note  that  the  value  of   the   character   constant
<span id="line17579"></span>          '''ISN''''T''' is a representation of another character
<span id="line17580"></span>          constant.
<span id="line17581"></span>
<span id="line17582"></span>          Some programs that used an extension to ANSI  X3.9-1966
<span id="line17583"></span>          that   permitted  a  Hollerith  constant  delimited  by
<span id="line17584"></span>          apostrophes instead of the n_H form do  not  conform  to
<span id="line17585"></span>          this standard.
<span id="line17586"></span>
<span id="line17587"></span>
<span id="line17588"></span>          B5.  Section_5_Notes
<span id="line17589"></span>
<span id="line17590"></span>          For the array declarator A(2,3), the use of  the  array
<span id="line17591"></span>          name   A   in   the  proper  context,  such  as  in  an
<span id="line17592"></span>          input/output list, specifies the  following  order  for
<span id="line17593"></span>          the  array  elements:   A(1,1), A(2,1), A(1,2), A(2,2),
<span id="line17594"></span>          A(1,3), A(2,3).
<span id="line17595"></span>
<span id="line17596"></span>
<span id="line17597"></span>          B6.  Section_6_Notes
<span id="line17598"></span>
<span id="line17599"></span>          If V is a variable name, the interpretation  and  value
<span id="line17600"></span>          of  V,  +V,  and  (V) are the same.  However, the three
<span id="line17601"></span>          forms may not  always  be  used  interchangeably.   For
<span id="line17602"></span>          example,  the  forms +V and (V) may not be used as list
<span id="line17603"></span>          items of a READ statement or as actual arguments  of  a
<span id="line17604"></span>          procedure   reference  if  the  procedure  defines  the
<span id="line17605"></span>          corresponding dummy argument.
<span id="line17606"></span>
<span id="line17607"></span>
<span id="line17608"></span>          B7.  Section_7_Notes
<span id="line17609"></span>
<span id="line17610"></span>          Although  DIMENSION  statements,  type-statements,  and
<span id="line17611"></span>          statement   function   statements   are  classified  as
<span id="line17612"></span>          nonexecutable statements, they may  contain  references
<span id="line17613"></span>          that are executed.  Expressions containing variables in
<span id="line17614"></span>          DIMENSION  statements  and   type-statements   may   be
<span id="line17615"></span>          evaluated  whenever  a reference to the program unit is
<span id="line17616"></span>          executed.   The  expression  in  a  statement  function
<span id="line17617"></span>          statement is evaluated whenever a function reference to
<span id="line17618"></span>          the statement function is executed.
<span id="line17619"></span>9
<span id="line17620"></span>
<span id="line17621"></span>
<span id="line17622"></span>          FORTRAN 77 Full Language                       Page B-4
<span id="line17623"></span>
<span id="line17624"></span>
<span id="line17625"></span>
<span id="line17626"></span>
<span id="line17627"></span>
<span id="line17628"></span>
<span id="line17629"></span>
<span id="line17630"></span>          APPENDIX B: SECTION NOTES                ANSI X3J3/90.4
<span id="line17631"></span>
<span id="line17632"></span>
<span id="line17633"></span>
<span id="line17634"></span>          B8.  Section_8_Notes
<span id="line17635"></span>
<span id="line17636"></span>          If a processor allows a one-dimensional subscript for a
<span id="line17637"></span>          multidimensional array in an EQUIVALENCE statement, the
<span id="line17638"></span>          interpretation  should  be  as  though  the   subscript
<span id="line17639"></span>          expression  were  the  leftmost  one  and  the  missing
<span id="line17640"></span>          subscript expressions each have their respective  lower
<span id="line17641"></span>          dimension bound value.
<span id="line17642"></span>
<span id="line17643"></span>          ANSI X3.9-1966  permitted  two-  and  three-dimensional
<span id="line17644"></span>          arrays  to  have  a  one-dimensional  subscript  in  an
<span id="line17645"></span>          EQUIVALENCE statement.  The following table can be used
<span id="line17646"></span>          to   convert   a   one-dimensional   subscript  to  the
<span id="line17647"></span>          corresponding multidimensional subscript:
<span id="line17648"></span>
<span id="line17649"></span>8            ___________________________________________________
<span id="line17650"></span>
<span id="line17651"></span>             n_   Dimension    Subscript   Subscript
<span id="line17652"></span>                                Value
<span id="line17653"></span>8            ___________________________________________________
<span id="line17654"></span>
<span id="line17655"></span>             1      (d918)          s       (s)
<span id="line17656"></span>8            ___________________________________________________
<span id="line17657"></span>
<span id="line17658"></span>             2    (d918,d928)         s       (1+MOD(s-1,d918),
<span id="line17659"></span>                                           1+(s-1)/d91
<span id="line17660"></span>7            ___________________________________________________
<span id="line17661"></span>
<span id="line17662"></span>             3   (d918,d928,d938)       s       (1+MOD(s-1,d918),
<span id="line17663"></span>                                           1+MOD((s-1)/d918,d928),
<span id="line17664"></span>                                           1+(s-1)/(d918*d928))
<span id="line17665"></span>8            ___________________________________________________
<span id="line17666"></span>7           |7|7|7|7|7|7|7|7|7|7|7|7|7|
<span id="line17667"></span>
<span id="line17668"></span>
<span id="line17669"></span>
<span id="line17670"></span>
<span id="line17671"></span>
<span id="line17672"></span>
<span id="line17673"></span>
<span id="line17674"></span>
<span id="line17675"></span>
<span id="line17676"></span>
<span id="line17677"></span>
<span id="line17678"></span>
<span id="line17679"></span>              |7|7|7|7|7|7|7|7|7|7|7|7|7|
<span id="line17680"></span>
<span id="line17681"></span>
<span id="line17682"></span>
<span id="line17683"></span>
<span id="line17684"></span>
<span id="line17685"></span>
<span id="line17686"></span>
<span id="line17687"></span>
<span id="line17688"></span>
<span id="line17689"></span>
<span id="line17690"></span>
<span id="line17691"></span>
<span id="line17692"></span>                           |7|7|7|7|7|7|7|7|7|7|7|7|7|
<span id="line17693"></span>
<span id="line17694"></span>
<span id="line17695"></span>
<span id="line17696"></span>
<span id="line17697"></span>
<span id="line17698"></span>
<span id="line17699"></span>
<span id="line17700"></span>
<span id="line17701"></span>
<span id="line17702"></span>
<span id="line17703"></span>
<span id="line17704"></span>
<span id="line17705"></span>                                       |7|7|7|7|7|7|7|7|7|7|7|7|7|
<span id="line17706"></span>
<span id="line17707"></span>
<span id="line17708"></span>
<span id="line17709"></span>
<span id="line17710"></span>
<span id="line17711"></span>
<span id="line17712"></span>
<span id="line17713"></span>
<span id="line17714"></span>
<span id="line17715"></span>
<span id="line17716"></span>
<span id="line17717"></span>
<span id="line17718"></span>                                                              |7|7|7|7|7|7|7|7|7|7|7|7|7|
<span id="line17719"></span>
<span id="line17720"></span>
<span id="line17721"></span>
<span id="line17722"></span>
<span id="line17723"></span>
<span id="line17724"></span>
<span id="line17725"></span>
<span id="line17726"></span>
<span id="line17727"></span>
<span id="line17728"></span>
<span id="line17729"></span>
<span id="line17730"></span>
<span id="line17731"></span>
<span id="line17732"></span>
<span id="line17733"></span>          Each expression in the last  column  of  the  table  is
<span id="line17734"></span>          evaluated   according   to   the   rules   for  integer
<span id="line17735"></span>          expressions.
<span id="line17736"></span>
<span id="line17737"></span>          A processor that allows additional intrinsic  functions
<span id="line17738"></span>          should  allow  their  names  to  appear in an INTRINSIC
<span id="line17739"></span>          statement.
<span id="line17740"></span>
<span id="line17741"></span>          As an extension  to  ANSI  X3.9-1966,  many  processors
<span id="line17742"></span>          permitted  the  retention  of  certain  values  at  the
<span id="line17743"></span>          completion of execution of a subprogram, such as  local
<span id="line17744"></span>          variables  and  arrays, initially defined data that had
<span id="line17745"></span>          been changed, and named common blocks not specified  in
<span id="line17746"></span>          the  main  program, whereas other processors prohibited
<span id="line17747"></span>          the retention of such values.  In ANSI  X3.9-1966  such
<span id="line17748"></span>          entities  were undefined at the completion of execution
<span id="line17749"></span>          of the subprogram, and therefore a  standard-conforming
<span id="line17750"></span>          program  could  not  retain  these  values.   The  SAVE
<span id="line17751"></span>          statement provides a facility for data retention.
<span id="line17752"></span>
<span id="line17753"></span>9
<span id="line17754"></span>
<span id="line17755"></span>
<span id="line17756"></span>          FORTRAN 77 Full Language                       Page B-5
<span id="line17757"></span>
<span id="line17758"></span>
<span id="line17759"></span>
<span id="line17760"></span>
<span id="line17761"></span>
<span id="line17762"></span>
<span id="line17763"></span>
<span id="line17764"></span>          APPENDIX B: SECTION NOTES                ANSI X3J3/90.4
<span id="line17765"></span>
<span id="line17766"></span>
<span id="line17767"></span>
<span id="line17768"></span>          B9.  Section_9_Notes
<span id="line17769"></span>
<span id="line17770"></span>          An  entity  is  "initially  defined"  only  by  a  DATA
<span id="line17771"></span>          statement.   An  assignment  statement  may  define  or
<span id="line17772"></span>          redefine an entity but it does not  "initially  define"
<span id="line17773"></span>          the entity.
<span id="line17774"></span>
<span id="line17775"></span>          Initially defined entities in a subprogram  may  become
<span id="line17776"></span>          undefined at the execution of a RETURN or END statement
<span id="line17777"></span>          if they are assigned any value, including their initial
<span id="line17778"></span>          value,  during  the execution of the executable program
<span id="line17779"></span>          (see 8.9 and 15.8.4).
<span id="line17780"></span>
<span id="line17781"></span>
<span id="line17782"></span>          B10.  Section_10_Notes
<span id="line17783"></span>
<span id="line17784"></span>          All four types of  implied  arithmetic  conversion  are
<span id="line17785"></span>          permitted in an arithmetic assignment statement.
<span id="line17786"></span>
<span id="line17787"></span>
<span id="line17788"></span>          B11.  Section_11_Notes
<span id="line17789"></span>
<span id="line17790"></span>          A logical IF statement must not contain another logical
<span id="line17791"></span>          IF  statement  or a block IF statement; however, it may
<span id="line17792"></span>          contain an arithmetic IF statement.  The  following  is
<span id="line17793"></span>          allowed:
<span id="line17794"></span>
<span id="line17795"></span>                    IF (logical expr.) IF (arithmetic expr.) s_918,s_928,s_93
<span id="line17796"></span>9          A processor is not required to evaluate  the  iteration
<span id="line17797"></span>          count  in  a  DO-loop  if  the  same effect is achieved
<span id="line17798"></span>          without evaluation.  However, the processor must  allow
<span id="line17799"></span>          redefinition  of  variables  and  array  elements  that
<span id="line17800"></span>          appear after the equals in a DO  statement  during  the
<span id="line17801"></span>          execution  of  the DO-loop without affecting the number
<span id="line17802"></span>          of times the DO-loop is executed and without  affecting
<span id="line17803"></span>          the value by which the DO-variable is incremented.
<span id="line17804"></span>
<span id="line17805"></span>          If J1 <span class="entity"><span>&amp;</span>gt;</span> J2, ANSI X3.9-1966 does not allow execution  of
<span id="line17806"></span>          the following DO statement:
<span id="line17807"></span>
<span id="line17808"></span>                               DO 100 J=J1,J2
<span id="line17809"></span>
<span id="line17810"></span>          Some processors that allowed such a case  executed  the
<span id="line17811"></span>          range of the DO-loop once, whereas other processors did
<span id="line17812"></span>          not execute the range of the  DO-loop.   This  standard
<span id="line17813"></span>          allows  such  a  case  and  requires that the processor
<span id="line17814"></span>          execute the range  of  the  DO-loop  zero  times.   The
<span id="line17815"></span>          following  change to the DO statement will require that
<span id="line17816"></span>          the processor execute the range at least once:
<span id="line17817"></span>
<span id="line17818"></span>
<span id="line17819"></span>
<span id="line17820"></span>
<span id="line17821"></span>          FORTRAN 77 Full Language                       Page B-6
<span id="line17822"></span>
<span id="line17823"></span>
<span id="line17824"></span>
<span id="line17825"></span>
<span id="line17826"></span>
<span id="line17827"></span>
<span id="line17828"></span>
<span id="line17829"></span>          APPENDIX B: SECTION NOTES                ANSI X3J3/90.4
<span id="line17830"></span>
<span id="line17831"></span>
<span id="line17832"></span>
<span id="line17833"></span>                               DO 100 J=J1,MAX(J1,J2)
<span id="line17834"></span>
<span id="line17835"></span>          References  to  function  procedures   and   subroutine
<span id="line17836"></span>          procedures  may appear within the range of a DO-loop or
<span id="line17837"></span>          within  an  IF-block,  ELSE  IF-block,  or  ELSE-block.
<span id="line17838"></span>          Execution  of  a function reference or a CALL statement
<span id="line17839"></span>          is not considered a transfer of control in the  program
<span id="line17840"></span>          unit  that  contains the reference, except when control
<span id="line17841"></span>          is returned to a statement identified by  an  alternate
<span id="line17842"></span>          return  specifier  in a CALL statement.  Execution of a
<span id="line17843"></span>          RETURN or END statement in a referenced  procedure,  or
<span id="line17844"></span>          execution  of a transfer of control within a referenced
<span id="line17845"></span>          procedure, is not considered a transfer of  control  in
<span id="line17846"></span>          the program unit that contains the reference.
<span id="line17847"></span>
<span id="line17848"></span>          The CONTINUE statement is an executable statement  that
<span id="line17849"></span>          has no effect of itself.  It can serve as an executable
<span id="line17850"></span>          statement on which to place a statement label  when  no
<span id="line17851"></span>          effect  of  execution  is desired.  For example, it can
<span id="line17852"></span>          serve as the statement referred to by a GO TO statement
<span id="line17853"></span>          or  as<span class="entity"><span>&amp;</span>amp;</span>  the terminal statement of a DO-loop.  Although
<span id="line17854"></span>          the CONTINUE statement has  no  effect  of  itself,  it
<span id="line17855"></span>          causes   execution   to  continue  with  incrementation
<span id="line17856"></span>          processing when it is the terminal statement of  a  DO-
<span id="line17857"></span>          loop.
<span id="line17858"></span>
<span id="line17859"></span>          The standard does not define the term  "accessible"  in
<span id="line17860"></span>          the  STOP  or  PAUSE statement in order to allow a wide
<span id="line17861"></span>          latitude in adapting to a processor environment.   Some
<span id="line17862"></span>          processors  may  use  the n_ the PAUSE or STOP statement
<span id="line17863"></span>          for documentation only.  Other processors  may  display
<span id="line17864"></span>          the  n_ to the user or to the operator.  In order not to
<span id="line17865"></span>          confine  its  use,  the  meaning  of  "accessible"   is
<span id="line17866"></span>          purposely left vague.
<span id="line17867"></span>
<span id="line17868"></span>
<span id="line17869"></span>          B12.  Section_12_Notes
<span id="line17870"></span>
<span id="line17871"></span>          What is called a "record" in FORTRAN is commonly called
<span id="line17872"></span>          a  "logical record."  There is no concept in FORTRAN of
<span id="line17873"></span>          a "physical record."
<span id="line17874"></span>
<span id="line17875"></span>          An  endfile  record  does  not  necessarily  have   any
<span id="line17876"></span>          physical  embodiment.   The  processor may use a record
<span id="line17877"></span>          count or other  means to register the position  of  the
<span id="line17878"></span>          file at the  time an ENDFILE statement is executed,  so
<span id="line17879"></span>          that it can take appropriate action when that  position
<span id="line17880"></span>          is  again reached during a read operation.  The endfile
<span id="line17881"></span>          record, however it is  implemented,  is  considered  to
<span id="line17882"></span>          exist for the BACKSPACE statement.
<span id="line17883"></span>
<span id="line17884"></span>
<span id="line17885"></span>
<span id="line17886"></span>
<span id="line17887"></span>          FORTRAN 77 Full Language                       Page B-7
<span id="line17888"></span>
<span id="line17889"></span>
<span id="line17890"></span>
<span id="line17891"></span>
<span id="line17892"></span>
<span id="line17893"></span>
<span id="line17894"></span>
<span id="line17895"></span>          APPENDIX B: SECTION NOTES                ANSI X3J3/90.4
<span id="line17896"></span>
<span id="line17897"></span>
<span id="line17898"></span>
<span id="line17899"></span>          An internal file permits data to  be  transferred  with
<span id="line17900"></span>          conversion  between  internal  storage  areas using the
<span id="line17901"></span>          READ  and  WRITE   statements.    This   facility   was
<span id="line17902"></span>          implemented  as  an extension to ANSI X3.9-1966 on many
<span id="line17903"></span>          processors as ENCODE and DECODE statements.  Specifying
<span id="line17904"></span>          the  READ  and WRITE statements to perform this process
<span id="line17905"></span>          avoids such confusion as:  "Is ENCODE like READ  or  is
<span id="line17906"></span>          it like WRITE?"
<span id="line17907"></span>
<span id="line17908"></span>          This standard accommodates, but it  does  not  require,
<span id="line17909"></span>          file  cataloging.   To  do  this,  several concepts are
<span id="line17910"></span>          introduced.
<span id="line17911"></span>
<span id="line17912"></span>          In ANSI X3.9-1966 many properties were given to a  unit
<span id="line17913"></span>          that  in this standard are given to the connection of a
<span id="line17914"></span>          file  to  a  unit.   Also,  additional  properties  are
<span id="line17915"></span>          introduced.
<span id="line17916"></span>
<span id="line17917"></span>          Before any input/output can be performed on a file,  it
<span id="line17918"></span>          must be connected to a unit.  The unit then serves as a
<span id="line17919"></span>          designator for that file as long as  it  is  connected.
<span id="line17920"></span>          To  be  connected does not imply that "buffers" have or
<span id="line17921"></span>          have not been  allocated,  that  "file-control  tables"
<span id="line17922"></span>          have  or  have  not  been filled out, or that any other
<span id="line17923"></span>          method of implementation  has  been  used.   Connection
<span id="line17924"></span>          means  that  (barring some other fault) a READ or WRITE
<span id="line17925"></span>          statement can be executed on the  unit,  hence  on  the
<span id="line17926"></span>          file.   Without a connection, a READ or WRITE statement
<span id="line17927"></span>          cannot be executed.
<span id="line17928"></span>
<span id="line17929"></span>          Totally independent of  the  connection  state  is  the
<span id="line17930"></span>          property of existence, this being a file property.  The
<span id="line17931"></span>          processor "knows" of a set of files  that  exist  at  a
<span id="line17932"></span>          given  time  for  a given executable program.  This set
<span id="line17933"></span>          would include tapes ready to read, files in a  catalog,
<span id="line17934"></span>          a  keyboard, a printer, etc.  The set may exclude files
<span id="line17935"></span>          inaccessible  to  the  executable  program  because  of
<span id="line17936"></span>          security,  because  they  are already in use by another
<span id="line17937"></span>          executable  program,  etc.   This  standard  does   not
<span id="line17938"></span>          specify  which  files  exist,  hence  wide  latitude is
<span id="line17939"></span>          available to a processor to implement security,  locks,
<span id="line17940"></span>          privilege  techniques,  etc.  Existence is a convenient
<span id="line17941"></span>          concept  to  designate  all  of  the  files   that   an
<span id="line17942"></span>          executable program can potentially process.
<span id="line17943"></span>
<span id="line17944"></span>          All four combinations of connection and  existence  may
<span id="line17945"></span>          occur:
<span id="line17946"></span>
<span id="line17947"></span>
<span id="line17948"></span>
<span id="line17949"></span>
<span id="line17950"></span>
<span id="line17951"></span>
<span id="line17952"></span>
<span id="line17953"></span>          FORTRAN 77 Full Language                       Page B-8
<span id="line17954"></span>
<span id="line17955"></span>
<span id="line17956"></span>
<span id="line17957"></span>
<span id="line17958"></span>
<span id="line17959"></span>
<span id="line17960"></span>
<span id="line17961"></span>          APPENDIX B: SECTION NOTES                ANSI X3J3/90.4
<span id="line17962"></span>
<span id="line17963"></span>
<span id="line17964"></span>
<span id="line17965"></span>8              ______________________________________________
<span id="line17966"></span>
<span id="line17967"></span>               Connect   Exist            Examples
<span id="line17968"></span>8              ______________________________________________
<span id="line17969"></span>
<span id="line17970"></span>                 Yes      Yes    A card reader loaded and
<span id="line17971"></span>                                 ready to be read
<span id="line17972"></span>8              ______________________________________________
<span id="line17973"></span>
<span id="line17974"></span>                 Yes      No     A printer before the first
<span id="line17975"></span>                                 line is written
<span id="line17976"></span>8              ______________________________________________
<span id="line17977"></span>
<span id="line17978"></span>                 No       Yes    A file named 'JOE' in
<span id="line17979"></span>                                 the catalog
<span id="line17980"></span>8              ______________________________________________
<span id="line17981"></span>
<span id="line17982"></span>                 No       No     A reel of tape destroyed
<span id="line17983"></span>                                 in the fire last week
<span id="line17984"></span>8              ______________________________________________
<span id="line17985"></span>7             |8|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|
<span id="line17986"></span>
<span id="line17987"></span>
<span id="line17988"></span>
<span id="line17989"></span>
<span id="line17990"></span>
<span id="line17991"></span>
<span id="line17992"></span>
<span id="line17993"></span>
<span id="line17994"></span>
<span id="line17995"></span>
<span id="line17996"></span>
<span id="line17997"></span>
<span id="line17998"></span>
<span id="line17999"></span>
<span id="line18000"></span>9                      |8|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|
<span id="line18001"></span>
<span id="line18002"></span>
<span id="line18003"></span>
<span id="line18004"></span>
<span id="line18005"></span>
<span id="line18006"></span>
<span id="line18007"></span>
<span id="line18008"></span>
<span id="line18009"></span>
<span id="line18010"></span>
<span id="line18011"></span>
<span id="line18012"></span>
<span id="line18013"></span>
<span id="line18014"></span>
<span id="line18015"></span>9                              |8|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|
<span id="line18016"></span>
<span id="line18017"></span>
<span id="line18018"></span>
<span id="line18019"></span>
<span id="line18020"></span>
<span id="line18021"></span>
<span id="line18022"></span>
<span id="line18023"></span>
<span id="line18024"></span>
<span id="line18025"></span>
<span id="line18026"></span>
<span id="line18027"></span>
<span id="line18028"></span>
<span id="line18029"></span>
<span id="line18030"></span>9                                                           |8|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|
<span id="line18031"></span>
<span id="line18032"></span>
<span id="line18033"></span>
<span id="line18034"></span>
<span id="line18035"></span>
<span id="line18036"></span>
<span id="line18037"></span>
<span id="line18038"></span>
<span id="line18039"></span>
<span id="line18040"></span>
<span id="line18041"></span>
<span id="line18042"></span>
<span id="line18043"></span>
<span id="line18044"></span>
<span id="line18045"></span>
<span id="line18046"></span>
<span id="line18047"></span>9          Means are provided  to  create,  delete,  connect,  and
<span id="line18048"></span>          disconnect files.
<span id="line18049"></span>
<span id="line18050"></span>          A file may have a name.  The form of a file name is not
<span id="line18051"></span>          specified.   If  a  system  does  not have some form of
<span id="line18052"></span>          cataloging or tape labeling for at least  some  of  its
<span id="line18053"></span>          files, all file names will disappear at the termination
<span id="line18054"></span>          of execution.  This is a valid implementation.  Nowhere
<span id="line18055"></span>          does  this  standard  require  names to survive for any
<span id="line18056"></span>          period of time longer than the execution time  span  of
<span id="line18057"></span>          an  executable  program.  Therefore, this standard does
<span id="line18058"></span>          not impose cataloging as a  prerequisite.   The  naming
<span id="line18059"></span>          feature is intended to allow use of a cataloging system
<span id="line18060"></span>          where one exists.
<span id="line18061"></span>
<span id="line18062"></span>          A file may become connected to a unit in either of  two
<span id="line18063"></span>          ways:  preconnection or execution of an OPEN statement.
<span id="line18064"></span>          Preconnection is performed prior to  the  beginning  of
<span id="line18065"></span>          execution of an executable program by means external to
<span id="line18066"></span>          FORTRAN.  For example, it may be done  by  job  control
<span id="line18067"></span>          action or by processor established defaults.  Execution
<span id="line18068"></span>          of  an  OPEN  statement  is  not  required  to   access
<span id="line18069"></span>          preconnected files.
<span id="line18070"></span>
<span id="line18071"></span>          The OPEN statement provides a means to access  existing
<span id="line18072"></span>          files that are not preconnected.  An OPEN statement may
<span id="line18073"></span>          be used in either of two ways: with a file  name  (open
<span id="line18074"></span>          by  name)  and  without  a file name (open by unit).  A
<span id="line18075"></span>          unit is given in either case.  Open  by  name  connects
<span id="line18076"></span>          the specified file to the specified unit.  Open by unit
<span id="line18077"></span>          connects a processor-determined  default  file  to  the
<span id="line18078"></span>          specified  unit.  (The default file may or may not have
<span id="line18079"></span>          a name.)
<span id="line18080"></span>
<span id="line18081"></span>
<span id="line18082"></span>
<span id="line18083"></span>          FORTRAN 77 Full Language                       Page B-9
<span id="line18084"></span>
<span id="line18085"></span>
<span id="line18086"></span>
<span id="line18087"></span>
<span id="line18088"></span>
<span id="line18089"></span>
<span id="line18090"></span>
<span id="line18091"></span>          APPENDIX B: SECTION NOTES                ANSI X3J3/90.4
<span id="line18092"></span>
<span id="line18093"></span>
<span id="line18094"></span>
<span id="line18095"></span>          Therefore, there are  three  ways  a  file  may  become
<span id="line18096"></span>          connected  and  hence processed: preconnection, open by
<span id="line18097"></span>          name, and open by unit.   Once  a  file  is  connected,
<span id="line18098"></span>          there  is no means in standard FORTRAN to determine how
<span id="line18099"></span>          it became connected.
<span id="line18100"></span>
<span id="line18101"></span>          In subset FORTRAN, sequential access may  be  performed
<span id="line18102"></span>          only  on  preconnected files, and direct access only on
<span id="line18103"></span>          files that are opened by unit.
<span id="line18104"></span>
<span id="line18105"></span>          An OPEN statement may also be  used  to  create  a  new
<span id="line18106"></span>          file.   In  fact, any of the foregoing three connection
<span id="line18107"></span>          methods may be performed on a file that does not exist.
<span id="line18108"></span>          When  a  unit is preconnected, writing the first record
<span id="line18109"></span>          creates  the  file.   With  the  other   two   methods,
<span id="line18110"></span>          execution of the OPEN statement creates the file.
<span id="line18111"></span>
<span id="line18112"></span>          When a unit becomes connected  to  a  file,  either  by
<span id="line18113"></span>          execution of an OPEN statement or by preconnection, the
<span id="line18114"></span>          following connection properties may be established:
<span id="line18115"></span>
<span id="line18116"></span>             (1) An access method, which is sequential or direct,
<span id="line18117"></span>                 is established for the connection.
<span id="line18118"></span>
<span id="line18119"></span>             (2) A form, which is formatted  or  unformatted,  is
<span id="line18120"></span>                 established  for  a  connection  to  a file that
<span id="line18121"></span>                 exists or is created by the connection.   For  a
<span id="line18122"></span>                 connection  that  results  from  execution of an
<span id="line18123"></span>                 OPEN statement, a default form (which depends on
<span id="line18124"></span>                 the  access  method, as described in 12.10.1) is
<span id="line18125"></span>                 established if no  form  is  specified.   For  a
<span id="line18126"></span>                 preconnected   file   that  exists,  a  form  is
<span id="line18127"></span>                 established    by    preconnection.     For    a
<span id="line18128"></span>                 preconnected  file  that  does not exist, a form
<span id="line18129"></span>                 may be established, or the  establishment  of  a
<span id="line18130"></span>                 form  may  be  delayed until the file is created
<span id="line18131"></span>                 (for example, by execution  of  a  formatted  or
<span id="line18132"></span>                 unformatted WRITE statement).
<span id="line18133"></span>
<span id="line18134"></span>             (3) A record length  may  be  established.   If  the
<span id="line18135"></span>                 access   method   is   direct,   the  connection
<span id="line18136"></span>                 establishes a record length, which specifies the
<span id="line18137"></span>                 length of each record of the file.  A connection
<span id="line18138"></span>                 for  sequential  access  does  not   have   this
<span id="line18139"></span>                 property.
<span id="line18140"></span>
<span id="line18141"></span>             (4) A blank significance property, which is ZERO  or
<span id="line18142"></span>                 NULL,  is established for a connection for which
<span id="line18143"></span>                 the form is formatted.   This  property  has  no
<span id="line18144"></span>                 effect on output.  For a connection that results
<span id="line18145"></span>                 from execution of an OPEN statement,  the  blank
<span id="line18146"></span>
<span id="line18147"></span>
<span id="line18148"></span>
<span id="line18149"></span>          FORTRAN 77 Full Language                      Page B-10
<span id="line18150"></span>
<span id="line18151"></span>
<span id="line18152"></span>
<span id="line18153"></span>
<span id="line18154"></span>
<span id="line18155"></span>
<span id="line18156"></span>
<span id="line18157"></span>          APPENDIX B: SECTION NOTES                ANSI X3J3/90.4
<span id="line18158"></span>
<span id="line18159"></span>
<span id="line18160"></span>
<span id="line18161"></span>                 significance  property  is NULL by default if no
<span id="line18162"></span>                 blank significance property is specified.  For a
<span id="line18163"></span>                 preconnected  file,  the property is established
<span id="line18164"></span>                 by preconnection.
<span id="line18165"></span>
<span id="line18166"></span>                 The   blank   significance   property   of   the
<span id="line18167"></span>                 connection is effective at the beginning of each
<span id="line18168"></span>                 formatted input statement.  During execution  of
<span id="line18169"></span>                 the  statement,  any  BN  or BZ edit descriptors
<span id="line18170"></span>                 encountered may temporarily change the effect of
<span id="line18171"></span>                 embedded and trailing blanks.
<span id="line18172"></span>
<span id="line18173"></span>          A  processor  has  wide  latitude  in  adapting   these
<span id="line18174"></span>          concepts  and  actions  to  its  own cataloging and job
<span id="line18175"></span>          control conventions.  Some processors may  require  job
<span id="line18176"></span>          control  action  to specify the set of files that exist
<span id="line18177"></span>          or that will be created by an executable program.  Some
<span id="line18178"></span>          processors  may  require no job control action prior to
<span id="line18179"></span>          execution.  This standard enables processors to perform
<span id="line18180"></span>          a  dynamic  open, close, and file creation, but it does
<span id="line18181"></span>          not require such capabilities of the processor.
<span id="line18182"></span>
<span id="line18183"></span>          The meaning of "open" in contexts  other  than  FORTRAN
<span id="line18184"></span>          may  include  such  things  as mounting a tape, console
<span id="line18185"></span>          messages, spooling, label checking, security  checking,
<span id="line18186"></span>          etc.   These  actions may occur upon job control action
<span id="line18187"></span>          external  to  FORTRAN,  upon  execution  of   an   OPEN
<span id="line18188"></span>          statement, or upon execution of the first read or write
<span id="line18189"></span>          of the file.  The OPEN statement  describes  properties
<span id="line18190"></span>          of  the connection to the file and may or may not cause
<span id="line18191"></span>          physical activities to take place.  It is a  place  for
<span id="line18192"></span>          an implementation to define properties of a file beyond
<span id="line18193"></span>          those required in standard FORTRAN.
<span id="line18194"></span>
<span id="line18195"></span>          Similarly,  the  actions   of   dismounting   a   tape,
<span id="line18196"></span>          protection,  etc.   of a "close" may be implicit at the
<span id="line18197"></span>          end of a run.  The CLOSE statement may or may not cause
<span id="line18198"></span>          such actions to occur.  This is another place to extend
<span id="line18199"></span>          file  properties  beyond  those  of  standard  FORTRAN.
<span id="line18200"></span>          Note,  however, that the execution of a CLOSE statement
<span id="line18201"></span>          on unit 10 followed by an OPEN statement  on  the  same
<span id="line18202"></span>          unit  to  the  same  file  or  to a different file is a
<span id="line18203"></span>          permissible sequence of events.  The processor may  not
<span id="line18204"></span>          deny  this  sequence  solely because the implementation
<span id="line18205"></span>          chooses to do the physical act of closing the  file  at
<span id="line18206"></span>          the termination of execution of the program.
<span id="line18207"></span>
<span id="line18208"></span>          This standard does not address  problems  of  security,
<span id="line18209"></span>          protection,  locking,  and many other concepts that may
<span id="line18210"></span>          be part of the concept  of  "right  of  access."   Such
<span id="line18211"></span>          concepts  are  considered  to  be in the province of an
<span id="line18212"></span>
<span id="line18213"></span>
<span id="line18214"></span>
<span id="line18215"></span>          FORTRAN 77 Full Language                      Page B-11
<span id="line18216"></span>
<span id="line18217"></span>
<span id="line18218"></span>
<span id="line18219"></span>
<span id="line18220"></span>
<span id="line18221"></span>
<span id="line18222"></span>
<span id="line18223"></span>          APPENDIX B: SECTION NOTES                ANSI X3J3/90.4
<span id="line18224"></span>
<span id="line18225"></span>
<span id="line18226"></span>
<span id="line18227"></span>          operating system.  The OPEN and INQUIRE statements  can
<span id="line18228"></span>          be extended naturally to consider these things.
<span id="line18229"></span>
<span id="line18230"></span>          Possible access methods for a file are:  sequential and
<span id="line18231"></span>          direct.   The  processor  may  implement  two different
<span id="line18232"></span>          types of files, each with its own  access  method.   It
<span id="line18233"></span>          may  also implement one type of file with two different
<span id="line18234"></span>          access methods.
<span id="line18235"></span>
<span id="line18236"></span>          Direct access to files is  of  a  simple  and  commonly
<span id="line18237"></span>          available type, that is, fixed-length records.  The key
<span id="line18238"></span>          is a positive integer.
<span id="line18239"></span>
<span id="line18240"></span>          Keyword forms of specifiers are used because there  are
<span id="line18241"></span>          many  specifiers and a positional notation is difficult
<span id="line18242"></span>          to  remember.   The  keyword  form  sets  a  style  for
<span id="line18243"></span>          processor  extensions.  The UNIT= and FMT= keywords are
<span id="line18244"></span>          offered for completeness, but their  use  is  optional.
<span id="line18245"></span>          Thus, compatibility with ANSI X3.9-1966 is achieved.
<span id="line18246"></span>
<span id="line18247"></span>          Format specifications may be included in READ and WRITE
<span id="line18248"></span>          statements, as in:
<span id="line18249"></span>
<span id="line18250"></span>                    READ ( UNIT=10, FMT='(I3,A4,F10.2)' ) K,ALPH,X
<span id="line18251"></span>
<span id="line18252"></span>          ANSI X3.9-1966 allowed a standard-conforming program to
<span id="line18253"></span>          write  an  endfile record but did not allow the reading
<span id="line18254"></span>          of an endfile  record.   In  this  standard,  the  END=
<span id="line18255"></span>          specifier allows end-of-file detection and continuation
<span id="line18256"></span>          of execution of the program.
<span id="line18257"></span>
<span id="line18258"></span>          List-directed   input/output   allows   data    editing
<span id="line18259"></span>          according  to the type of the list item instead of by a
<span id="line18260"></span>          format specifier.  It also  allows  data  to  be  free-
<span id="line18261"></span>          field, that is, separated by commas or blanks.
<span id="line18262"></span>
<span id="line18263"></span>          List-directed input/output is  record  oriented  to  or
<span id="line18264"></span>          from  a  formatted sequential file.  Each read or write
<span id="line18265"></span>          begins with a new record.  The  form  of  list-directed
<span id="line18266"></span>          data  on  a  sequential  output file is not necessarily
<span id="line18267"></span>          suitable for list-directed input.  However,  there  are
<span id="line18268"></span>          no mandatory errors specified for reading list-directed
<span id="line18269"></span>          data  previously  written.   The  results  may  not  be
<span id="line18270"></span>          guaranteed  because of the syntax using apostrophes for
<span id="line18271"></span>          character data or the r_*c_ form of a repeated  constant.
<span id="line18272"></span>          All  other  applications should work, and attempting to
<span id="line18273"></span>          read previously written  list-directed  output  is  not
<span id="line18274"></span>          prohibited in a standard-conforming program.
<span id="line18275"></span>
<span id="line18276"></span>          If no list  items  are  specified  in  a  list-directed
<span id="line18277"></span>          input/output  statement, one input record is skipped or
<span id="line18278"></span>
<span id="line18279"></span>
<span id="line18280"></span>
<span id="line18281"></span>          FORTRAN 77 Full Language                      Page B-12
<span id="line18282"></span>
<span id="line18283"></span>
<span id="line18284"></span>
<span id="line18285"></span>
<span id="line18286"></span>
<span id="line18287"></span>
<span id="line18288"></span>
<span id="line18289"></span>          APPENDIX B: SECTION NOTES                ANSI X3J3/90.4
<span id="line18290"></span>
<span id="line18291"></span>
<span id="line18292"></span>
<span id="line18293"></span>          one empty output record is written.
<span id="line18294"></span>
<span id="line18295"></span>          An example of a restriction on input/output  statements
<span id="line18296"></span>          (12.12) is that an input statement may not specify that
<span id="line18297"></span>          data are to be read from a printer.
<span id="line18298"></span>
<span id="line18299"></span>
<span id="line18300"></span>          B13.  Section_13_Notes
<span id="line18301"></span>
<span id="line18302"></span>          The term "edit descriptor" in this standard was  "field
<span id="line18303"></span>          descriptor" in ANSI X3.9-1966.
<span id="line18304"></span>
<span id="line18305"></span>          If a character constant is used as a format  identifier
<span id="line18306"></span>          in  an  input/output statement, care must be taken that
<span id="line18307"></span>          the value of the character constant is a  valid  format
<span id="line18308"></span>          specification.     In   particular,   if   the   format
<span id="line18309"></span>          specification contains an apostrophe  edit  descriptor,
<span id="line18310"></span>          two   apostrophes   must  be  written  to  delimit  the
<span id="line18311"></span>          apostrophe edit descriptor and four apostrophes must be
<span id="line18312"></span>          written  for  each  apostrophe  that  occurs within the
<span id="line18313"></span>          apostrophe edit descriptor.  For example, the text:
<span id="line18314"></span>
<span id="line18315"></span>                               2 ISN'T 3
<span id="line18316"></span>
<span id="line18317"></span>          may  be  written  by  various  combinations  of  output
<span id="line18318"></span>          statements and format specifications:
<span id="line18319"></span>
<span id="line18320"></span>                     WRITE(6,100) 2,3
<span id="line18321"></span>                 100 FORMAT(1X,I1,1X,'ISN''T',1X,I1)
<span id="line18322"></span>
<span id="line18323"></span>                     WRITE(6,'(1X,I1,1X,''ISN''''T'',1X,I1)'    )
<span id="line18324"></span>                     2,3
<span id="line18325"></span>
<span id="line18326"></span>                     WRITE(6,200) 2,3
<span id="line18327"></span>                 200 FORMAT(1X,I1,1X,5HISN'T,1X,I1)
<span id="line18328"></span>
<span id="line18329"></span>                     WRITE(6,'(1X,I1,1X,5HISN''T,1X,I1)' ) 2,3
<span id="line18330"></span>
<span id="line18331"></span>                     WRITE(6,'(A)') ' 2 ISN''T 3'
<span id="line18332"></span>
<span id="line18333"></span>                     WRITE(6,'(1X,I1,A,I1)') 2, ' ISN''T ', 3
<span id="line18334"></span>
<span id="line18335"></span>          Note that two consecutive  apostrophes  in  an  H  edit
<span id="line18336"></span>          descriptor  within  a character constant are counted as
<span id="line18337"></span>          only one Hollerith character.
<span id="line18338"></span>
<span id="line18339"></span>          The T edit descriptor  includes  the  carriage  control
<span id="line18340"></span>          character   in  lines  that  are  to  be  printed.   T1
<span id="line18341"></span>          specifies  the  carriage  control  character,  and   T2
<span id="line18342"></span>          specifies the first character that is printed.
<span id="line18343"></span>
<span id="line18344"></span>
<span id="line18345"></span>
<span id="line18346"></span>
<span id="line18347"></span>          FORTRAN 77 Full Language                      Page B-13
<span id="line18348"></span>
<span id="line18349"></span>
<span id="line18350"></span>
<span id="line18351"></span>
<span id="line18352"></span>
<span id="line18353"></span>
<span id="line18354"></span>
<span id="line18355"></span>          APPENDIX B: SECTION NOTES                ANSI X3J3/90.4
<span id="line18356"></span>
<span id="line18357"></span>
<span id="line18358"></span>
<span id="line18359"></span>          The length of a record is not always specified  exactly
<span id="line18360"></span>          and may be processor dependent.
<span id="line18361"></span>
<span id="line18362"></span>          The  number  of  records  read  by  a  formatted  input
<span id="line18363"></span>          statement can be determined from the following rule:  A
<span id="line18364"></span>          record is read at the  beginning  of  the  format  scan
<span id="line18365"></span>          (even  if  the input list is empty), at each slash edit
<span id="line18366"></span>          descriptor encountered in the format, and when a format
<span id="line18367"></span>          rescan occurs at the end of the format.
<span id="line18368"></span>
<span id="line18369"></span>          The number of records written  by  a  formatted  output
<span id="line18370"></span>          statement can be determined from the following rule:  A
<span id="line18371"></span>          record is written  when  a  slash  edit  descriptor  is
<span id="line18372"></span>          encountered  in the format, when a format rescan occurs
<span id="line18373"></span>          at  the  end  of  the  format,  and  at  completion  of
<span id="line18374"></span>          execution  of  the output statement (even if the output
<span id="line18375"></span>          list is empty).  Thus, the occurrence of n_  successive
<span id="line18376"></span>          slashes between two other edit descriptors causes n_ - 1
<span id="line18377"></span>          blank lines if the records are printed.  The occurrence
<span id="line18378"></span>          of  n_  slashes  at  the beginning or end of a complete
<span id="line18379"></span>          format specification  causes  n_  blank  lines  if  the
<span id="line18380"></span>          records   are  printed.   However,  a  complete  format
<span id="line18381"></span>          specification containing n_ slashes (n_ <span class="entity"><span>&amp;</span>gt;</span> 0) and no other
<span id="line18382"></span>          edit  descriptors  causes  n_   +  1 blank lines if the
<span id="line18383"></span>          records are printed.  For example, the statements
<span id="line18384"></span>
<span id="line18385"></span>                     PRINT 3
<span id="line18386"></span>                 3   FORMAT(/)
<span id="line18387"></span>
<span id="line18388"></span>          will write two records that cause two  blank  lines  if
<span id="line18389"></span>          the records are printed.
<span id="line18390"></span>
<span id="line18391"></span>          The following examples illustrate list-directed  input.
<span id="line18392"></span>          A blank character is represented by b_.
<span id="line18393"></span>          Example 1:
<span id="line18394"></span>
<span id="line18395"></span>             Program:    J=3
<span id="line18396"></span>                         READ *,I
<span id="line18397"></span>                         READ *,J
<span id="line18398"></span>
<span id="line18399"></span>             Sequential input file:
<span id="line18400"></span>
<span id="line18401"></span>                 record 1: b_1b_,4bbbbb_____
<span id="line18402"></span>                 record 2: ,2bbbbbbbb________
<span id="line18403"></span>
<span id="line18404"></span>             Result: I=1,
<span id="line18405"></span>
<span id="line18406"></span>          Explanation: The second READ statement reads the second
<span id="line18407"></span>          record.   The  initial comma in the record designates a
<span id="line18408"></span>          null value; therefore, J is not redefined.
<span id="line18409"></span>          Example 2:
<span id="line18410"></span>
<span id="line18411"></span>
<span id="line18412"></span>
<span id="line18413"></span>          FORTRAN 77 Full Language                      Page B-14
<span id="line18414"></span>
<span id="line18415"></span>
<span id="line18416"></span>
<span id="line18417"></span>
<span id="line18418"></span>
<span id="line18419"></span>
<span id="line18420"></span>
<span id="line18421"></span>          APPENDIX B: SECTION NOTES                ANSI X3J3/90.4
<span id="line18422"></span>
<span id="line18423"></span>
<span id="line18424"></span>
<span id="line18425"></span>             Program:    CHARACTER A*8, B*1
<span id="line18426"></span>                         READ *, A, B
<span id="line18427"></span>
<span id="line18428"></span>             Sequential input file:
<span id="line18429"></span>
<span id="line18430"></span>                 record 1: 'bbbbbbbb________'
<span id="line18431"></span>                 record 2: 'QXY'b_'Z'
<span id="line18432"></span>
<span id="line18433"></span>             Result: A='bbbbbbbb________', B='Q'
<span id="line18434"></span>
<span id="line18435"></span>          Explanation: The end of a record cannot  occur  between
<span id="line18436"></span>          two  apostrophes representing an embedded apostrophe in
<span id="line18437"></span>          a character  constant;  therefore,  A  is  set  to  the
<span id="line18438"></span>          character  constant   ' bbbbbbbb________'.  The end of a record
<span id="line18439"></span>          acts as  a  blank,  which  in  this  case  is  a  value
<span id="line18440"></span>          separator because it occurs between two constants.
<span id="line18441"></span>
<span id="line18442"></span>
<span id="line18443"></span>          B14.  Section_14_Notes
<span id="line18444"></span>
<span id="line18445"></span>          The name of a main program has no explicit  use  within
<span id="line18446"></span>          the    FORTRAN   language.    It   is   available   for
<span id="line18447"></span>          documentation and for possible use  within  a  computer
<span id="line18448"></span>          environment.
<span id="line18449"></span>
<span id="line18450"></span>
<span id="line18451"></span>          B15.  Section_15_Notes
<span id="line18452"></span>
<span id="line18453"></span>          A FUNCTION statement specifies the name of an  external
<span id="line18454"></span>          function,  and  each  ENTRY  statement  in  a  function
<span id="line18455"></span>          subprogram specifies an  additional  external  function
<span id="line18456"></span>          name.   A  SUBROUTINE statement specifies the name of a
<span id="line18457"></span>          subroutine, and each ENTRY statement  in  a  subroutine
<span id="line18458"></span>          subprogram specifies an additional subroutine name.
<span id="line18459"></span>
<span id="line18460"></span>          The intrinsic function names IFIX,  IDINT,  FLOAT,  and
<span id="line18461"></span>          SNGL  have  been  retained  to  support  programs  that
<span id="line18462"></span>          conform to ANSI  X3.9-1966.   However,  future  use  of
<span id="line18463"></span>          these intrinsic function names is not recommended.
<span id="line18464"></span>
<span id="line18465"></span>          For the specific functions that define the maximum  and
<span id="line18466"></span>          minimum  values with a function type different from the
<span id="line18467"></span>          argument type (AMAX0, MAX1, AMIN0,  and  MIN1),  it  is
<span id="line18468"></span>          recommended  that  an expression containing the generic
<span id="line18469"></span>          name preceded by a type conversion  function  be  used,
<span id="line18470"></span>          for  example,  REAL(MAX(a_918, a_928,...))  for  AMAX0(a_918, a
<span id="line18471"></span>          _928,...), so that these specific function names  may  be
<span id="line18472"></span>          deleted in a future revision of this standard.
<span id="line18473"></span>
<span id="line18474"></span>          This  standard  provides  that  a   standard-conforming
<span id="line18475"></span>          processor may supply intrinsic functions in addition to
<span id="line18476"></span>
<span id="line18477"></span>
<span id="line18478"></span>
<span id="line18479"></span>          FORTRAN 77 Full Language                      Page B-15
<span id="line18480"></span>
<span id="line18481"></span>
<span id="line18482"></span>
<span id="line18483"></span>
<span id="line18484"></span>
<span id="line18485"></span>
<span id="line18486"></span>
<span id="line18487"></span>          APPENDIX B: SECTION NOTES                ANSI X3J3/90.4
<span id="line18488"></span>
<span id="line18489"></span>
<span id="line18490"></span>
<span id="line18491"></span>          those defined in Table 5  (15.10).   Because  of  this,
<span id="line18492"></span>          care  must be taken when a program is used on more than
<span id="line18493"></span>          one processor because a function name not  in  Table  5
<span id="line18494"></span>          may  be  classified as an external function name on one
<span id="line18495"></span>          processor and as an intrinsic function name on  another
<span id="line18496"></span>          processor in the absence of a declaration for that name
<span id="line18497"></span>          in an EXTERNAL or INTRINSIC statement.
<span id="line18498"></span>
<span id="line18499"></span>          To guard against this possibility, it is suggested that
<span id="line18500"></span>          any  external  functions referenced in a program should
<span id="line18501"></span>          appear in an EXTERNAL statement in every  program  unit
<span id="line18502"></span>          in  which  a  reference to that function appears.  If a
<span id="line18503"></span>          program unit references a processor-supplied  intrinsic
<span id="line18504"></span>          function  that  does not appear in Table 5, the name of
<span id="line18505"></span>          the function should appear in an INTRINSIC statement in
<span id="line18506"></span>          the program unit.
<span id="line18507"></span>
<span id="line18508"></span>          The  distinction  between  external   functions   (user
<span id="line18509"></span>          defined)  and  intrinsic  functions (processor defined)
<span id="line18510"></span>          may be clarified by the following table:
<span id="line18511"></span>
<span id="line18512"></span>
<span id="line18513"></span>
<span id="line18514"></span>
<span id="line18515"></span>
<span id="line18516"></span>
<span id="line18517"></span>
<span id="line18518"></span>
<span id="line18519"></span>
<span id="line18520"></span>
<span id="line18521"></span>
<span id="line18522"></span>
<span id="line18523"></span>
<span id="line18524"></span>
<span id="line18525"></span>
<span id="line18526"></span>
<span id="line18527"></span>
<span id="line18528"></span>
<span id="line18529"></span>
<span id="line18530"></span>
<span id="line18531"></span>
<span id="line18532"></span>
<span id="line18533"></span>
<span id="line18534"></span>
<span id="line18535"></span>
<span id="line18536"></span>
<span id="line18537"></span>
<span id="line18538"></span>
<span id="line18539"></span>
<span id="line18540"></span>
<span id="line18541"></span>
<span id="line18542"></span>
<span id="line18543"></span>
<span id="line18544"></span>
<span id="line18545"></span>          FORTRAN 77 Full Language                      Page B-16
<span id="line18546"></span>
<span id="line18547"></span>
<span id="line18548"></span>
<span id="line18549"></span>
<span id="line18550"></span>
<span id="line18551"></span>
<span id="line18552"></span>
<span id="line18553"></span>          APPENDIX B: SECTION NOTES                ANSI X3J3/90.4
<span id="line18554"></span>
<span id="line18555"></span>
<span id="line18556"></span>
<span id="line18557"></span>8                           _________________________________________
<span id="line18558"></span>
<span id="line18559"></span>                                Different Processor Definitions
<span id="line18560"></span>                                      (Table 5 extended)
<span id="line18561"></span>8                           _________________________________________
<span id="line18562"></span>
<span id="line18563"></span>                            Processor 1   Processor 2   Processor 3
<span id="line18564"></span>8          __________________________________________________________
<span id="line18565"></span>
<span id="line18566"></span>
<span id="line18567"></span>           Different        Intrinsic     Intrinsic
<span id="line18568"></span>           User             Integer       Complex        (none)
<span id="line18569"></span>           Specifications   FROG          FROG
<span id="line18570"></span>8          __________________________________________________________
<span id="line18571"></span>
<span id="line18572"></span>8          __________________________________________________________
<span id="line18573"></span>
<span id="line18574"></span>           Y=FROG(A)        Intrinsic     Intrinsic     External
<span id="line18575"></span>                            Integer       Complex       Real
<span id="line18576"></span>                            FROG          FROG          FROG
<span id="line18577"></span>8          __________________________________________________________
<span id="line18578"></span>
<span id="line18579"></span>           INTRINSIC FROG   Intrinsic     Intrinsic
<span id="line18580"></span>           Y=FROG(A)        Integer       Complex       Undefined
<span id="line18581"></span>                            FROG          FROG
<span id="line18582"></span>8          __________________________________________________________
<span id="line18583"></span>
<span id="line18584"></span>           INTEGER FROG     Intrinsic                   External
<span id="line18585"></span>           Y=FROG(A)        Integer       Undefined     Integer
<span id="line18586"></span>                            FROG                        FROG
<span id="line18587"></span>8          __________________________________________________________
<span id="line18588"></span>
<span id="line18589"></span>           INTRINSIC FROG   Intrinsic
<span id="line18590"></span>           INTEGER FROG     Integer       Undefined     Undefined
<span id="line18591"></span>           Y-FROG(A)        FROG
<span id="line18592"></span>8          __________________________________________________________
<span id="line18593"></span>
<span id="line18594"></span>           EXTERNAL FROG    External      External      External
<span id="line18595"></span>           Y=FROG(A)        Real          Real          Real
<span id="line18596"></span>                            FROG          FROG          FROG
<span id="line18597"></span>8          __________________________________________________________
<span id="line18598"></span>
<span id="line18599"></span>           EXTERNAL FROG    External      External      External
<span id="line18600"></span>           INTEGER FROG     Integer       Integer       Integer
<span id="line18601"></span>           Y=FROG(A)        FROG          FROG          FROG
<span id="line18602"></span>8          __________________________________________________________
<span id="line18603"></span>7         
|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|
<span id="line18604"></span>
<span id="line18605"></span>
<span id="line18606"></span>
<span id="line18607"></span>
<span id="line18608"></span>
<span id="line18609"></span>
<span id="line18610"></span>
<span id="line18611"></span>
<span id="line18612"></span>
<span id="line18613"></span>
<span id="line18614"></span>
<span id="line18615"></span>
<span id="line18616"></span>
<span id="line18617"></span>
<span id="line18618"></span>
<span id="line18619"></span>
<span id="line18620"></span>
<span id="line18621"></span>
<span id="line18622"></span>
<span id="line18623"></span>
<span id="line18624"></span>
<span id="line18625"></span>
<span id="line18626"></span>
<span id="line18627"></span>
<span id="line18628"></span>
<span id="line18629"></span>
<span id="line18630"></span>
<span id="line18631"></span>
<span id="line18632"></span>
<span id="line18633"></span>
<span id="line18634"></span>
<span id="line18635"></span>
<span id="line18636"></span>                         
|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|
<span id="line18637"></span>
<span id="line18638"></span>
<span id="line18639"></span>
<span id="line18640"></span>
<span id="line18641"></span>
<span id="line18642"></span>
<span id="line18643"></span>
<span id="line18644"></span>
<span id="line18645"></span>
<span id="line18646"></span>
<span id="line18647"></span>
<span id="line18648"></span>
<span id="line18649"></span>
<span id="line18650"></span>
<span id="line18651"></span>
<span id="line18652"></span>
<span id="line18653"></span>
<span id="line18654"></span>
<span id="line18655"></span>
<span id="line18656"></span>
<span id="line18657"></span>
<span id="line18658"></span>
<span id="line18659"></span>
<span id="line18660"></span>
<span id="line18661"></span>
<span id="line18662"></span>
<span id="line18663"></span>
<span id="line18664"></span>
<span id="line18665"></span>
<span id="line18666"></span>
<span id="line18667"></span>
<span id="line18668"></span>
<span id="line18669"></span>
<span id="line18670"></span>
<span id="line18671"></span>
<span id="line18672"></span>
<span id="line18673"></span>
<span id="line18674"></span>
<span id="line18675"></span>                                       
|8|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|
<span id="line18676"></span>
<span id="line18677"></span>
<span id="line18678"></span>
<span id="line18679"></span>
<span id="line18680"></span>
<span id="line18681"></span>
<span id="line18682"></span>
<span id="line18683"></span>
<span id="line18684"></span>
<span id="line18685"></span>
<span id="line18686"></span>
<span id="line18687"></span>
<span id="line18688"></span>
<span id="line18689"></span>
<span id="line18690"></span>
<span id="line18691"></span>
<span id="line18692"></span>
<span id="line18693"></span>
<span id="line18694"></span>
<span id="line18695"></span>
<span id="line18696"></span>
<span id="line18697"></span>
<span id="line18698"></span>
<span id="line18699"></span>
<span id="line18700"></span>
<span id="line18701"></span>
<span id="line18702"></span>
<span id="line18703"></span>
<span id="line18704"></span>
<span id="line18705"></span>
<span id="line18706"></span>
<span id="line18707"></span>
<span id="line18708"></span>
<span id="line18709"></span>
<span id="line18710"></span>9                                          
           
|8|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|
<span id="line18711"></span>
<span id="line18712"></span>
<span id="line18713"></span>
<span id="line18714"></span>
<span id="line18715"></span>
<span id="line18716"></span>
<span id="line18717"></span>
<span id="line18718"></span>
<span id="line18719"></span>
<span id="line18720"></span>
<span id="line18721"></span>
<span id="line18722"></span>
<span id="line18723"></span>
<span id="line18724"></span>
<span id="line18725"></span>
<span id="line18726"></span>
<span id="line18727"></span>
<span id="line18728"></span>
<span id="line18729"></span>
<span id="line18730"></span>
<span id="line18731"></span>
<span id="line18732"></span>
<span id="line18733"></span>
<span id="line18734"></span>
<span id="line18735"></span>
<span id="line18736"></span>
<span id="line18737"></span>
<span id="line18738"></span>
<span id="line18739"></span>
<span id="line18740"></span>
<span id="line18741"></span>
<span id="line18742"></span>
<span id="line18743"></span>
<span id="line18744"></span>
<span id="line18745"></span>9                                          
                         
|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|
<span id="line18746"></span>
<span id="line18747"></span>
<span id="line18748"></span>
<span id="line18749"></span>
<span id="line18750"></span>
<span id="line18751"></span>
<span id="line18752"></span>
<span id="line18753"></span>
<span id="line18754"></span>
<span id="line18755"></span>
<span id="line18756"></span>
<span id="line18757"></span>
<span id="line18758"></span>
<span id="line18759"></span>
<span id="line18760"></span>
<span id="line18761"></span>
<span id="line18762"></span>
<span id="line18763"></span>
<span id="line18764"></span>
<span id="line18765"></span>
<span id="line18766"></span>
<span id="line18767"></span>
<span id="line18768"></span>
<span id="line18769"></span>
<span id="line18770"></span>
<span id="line18771"></span>
<span id="line18772"></span>
<span id="line18773"></span>
<span id="line18774"></span>
<span id="line18775"></span>
<span id="line18776"></span>
<span id="line18777"></span>
<span id="line18778"></span>
<span id="line18779"></span>
<span id="line18780"></span>
<span id="line18781"></span>
<span id="line18782"></span>
<span id="line18783"></span>
<span id="line18784"></span>
<span id="line18785"></span>
<span id="line18786"></span>          If a generic name is the same as the specific  name  of
<span id="line18787"></span>          an intrinsic function for a specified type of argument,
<span id="line18788"></span>          a reference to the function with an  argument  of  that
<span id="line18789"></span>          type  may  be  considered  to  be  either a specific or
<span id="line18790"></span>          generic function reference.
<span id="line18791"></span>
<span id="line18792"></span>          The use of the concatenation operator with operands  of
<span id="line18793"></span>          nonconstant   length   has   been   restricted  to  the
<span id="line18794"></span>          assignment statement  so  that  a  processor  need  not
<span id="line18795"></span>          implement dynamic storage allocation.
<span id="line18796"></span>
<span id="line18797"></span>9
<span id="line18798"></span>          FORTRAN 77 Full Language                      Page B-17
<span id="line18799"></span>
<span id="line18800"></span>
<span id="line18801"></span>
<span id="line18802"></span>
<span id="line18803"></span>
<span id="line18804"></span>
<span id="line18805"></span>
<span id="line18806"></span>          APPENDIX B: SECTION NOTES                ANSI X3J3/90.4
<span id="line18807"></span>
<span id="line18808"></span>
<span id="line18809"></span>
<span id="line18810"></span>          When a character array is an actual argument, the array
<span id="line18811"></span>          is  considered to be one string of characters and there
<span id="line18812"></span>          need not be correspondence  between  the  actual  array
<span id="line18813"></span>          elements  and  the  dummy  array elements.  Only subset
<span id="line18814"></span>          FORTRAN requires such correspondence.
<span id="line18815"></span>
<span id="line18816"></span>          The intrinsic functions ICHAR and CHAR provide a  means
<span id="line18817"></span>          of converting between a character and an integer, based
<span id="line18818"></span>          on the position  of  the  character  in  the  processor
<span id="line18819"></span>          collating   sequence.    The  first  character  in  the
<span id="line18820"></span>          collating sequence corresponds to position  0  and  the
<span id="line18821"></span>          last  to  position  n_   -  1, where n_ is the number of
<span id="line18822"></span>          characters in the collating sequence.
<span id="line18823"></span>
<span id="line18824"></span>          Many processors provide a collating  sequence  that  is
<span id="line18825"></span>          the same as the ordering of the internal representation
<span id="line18826"></span>          of the character (where the internal representation may
<span id="line18827"></span>          be  regarded  as either a representation of a character
<span id="line18828"></span>          or of some integer).   For  example,  for  a  seven-bit
<span id="line18829"></span>          character,  the  internal  representation  of the first
<span id="line18830"></span>          character is '0000000' binary (0 decimal) and the  last
<span id="line18831"></span>          character  is '1111111' binary (127 decimal).  For such
<span id="line18832"></span>          a processor, ICHAR returns the  value  of  an  internal
<span id="line18833"></span>          character  representation,  considered  as  an integer.
<span id="line18834"></span>          CHAR takes an appropriate small integer and returns the
<span id="line18835"></span>          character having the same internal representation.
<span id="line18836"></span>
<span id="line18837"></span>
<span id="line18838"></span>          B16.  Section_16_Notes
<span id="line18839"></span>
<span id="line18840"></span>          The name of a block data subprogram has no explicit use
<span id="line18841"></span>          within  the  FORTRAN  language.   It  is  available for
<span id="line18842"></span>          documentation and for possible use  within  a  computer
<span id="line18843"></span>          environment.
<span id="line18844"></span>
<span id="line18845"></span>
<span id="line18846"></span>          B17.  Section_17_Notes
<span id="line18847"></span>
<span id="line18848"></span>          The size of an array is the number of elements (5.2.3),
<span id="line18849"></span>          but  the storage sequence of the array also has a size,
<span id="line18850"></span>          which may be different  from  the  number  of  elements
<span id="line18851"></span>          (17.1.1).
<span id="line18852"></span>
<span id="line18853"></span>          The  definition  of  character  entities  occurs  on  a
<span id="line18854"></span>          character-by-character basis.  The use of substrings or
<span id="line18855"></span>          partially  associated   entities   permits   individual
<span id="line18856"></span>          characters  or groups of characters within an entity to
<span id="line18857"></span>          become defined or undefined.
<span id="line18858"></span>
<span id="line18859"></span>
<span id="line18860"></span>
<span id="line18861"></span>
<span id="line18862"></span>
<span id="line18863"></span>
<span id="line18864"></span>          FORTRAN 77 Full Language                      Page B-18
<span id="line18865"></span>
<span id="line18866"></span>
<span id="line18867"></span>
<span id="line18868"></span>
<span id="line18869"></span>
<span id="line18870"></span>
<span id="line18871"></span>
<span id="line18872"></span>          APPENDIX B: SECTION NOTES                ANSI X3J3/90.4
<span id="line18873"></span>
<span id="line18874"></span>
<span id="line18875"></span>
<span id="line18876"></span>          B18.  Section_18_Notes
<span id="line18877"></span>
<span id="line18878"></span>          There is no explicit means for declaring an  entity  to
<span id="line18879"></span>          be  a  variable.  An entity becomes a variable if it is
<span id="line18880"></span>          used  in  a  manner  that  does  not  cause  it  to  be
<span id="line18881"></span>          exclusively  something  else.   Note that the name of a
<span id="line18882"></span>          variable may also be the name of a common block, except
<span id="line18883"></span>          when  the  name  of  the variable is also the name of a
<span id="line18884"></span>          function.
<span id="line18885"></span>
<span id="line18886"></span>
<span id="line18887"></span>
<span id="line18888"></span>
<span id="line18889"></span>
<span id="line18890"></span>
<span id="line18891"></span>
<span id="line18892"></span>
<span id="line18893"></span>
<span id="line18894"></span>
<span id="line18895"></span>
<span id="line18896"></span>
<span id="line18897"></span>
<span id="line18898"></span>
<span id="line18899"></span>
<span id="line18900"></span>
<span id="line18901"></span>
<span id="line18902"></span>
<span id="line18903"></span>
<span id="line18904"></span>
<span id="line18905"></span>
<span id="line18906"></span>
<span id="line18907"></span>
<span id="line18908"></span>
<span id="line18909"></span>
<span id="line18910"></span>
<span id="line18911"></span>
<span id="line18912"></span>
<span id="line18913"></span>
<span id="line18914"></span>
<span id="line18915"></span>
<span id="line18916"></span>
<span id="line18917"></span>
<span id="line18918"></span>
<span id="line18919"></span>
<span id="line18920"></span>
<span id="line18921"></span>
<span id="line18922"></span>
<span id="line18923"></span>
<span id="line18924"></span>
<span id="line18925"></span>
<span id="line18926"></span>
<span id="line18927"></span>
<span id="line18928"></span>
<span id="line18929"></span>
<span id="line18930"></span>          FORTRAN 77 Full Language                      Page B-19
<span id="line18931"></span>
<span id="line18932"></span>
<span id="line18933"></span>
<span id="line18934"></span>
<span id="line18935"></span>
<span id="line18936"></span>
<span id="line18937"></span>
<span id="line18938"></span>
<span id="line18939"></span>
<span id="line18940"></span>
<span id="line18941"></span>
<span id="line18942"></span>                                 CONTENTS
<span id="line18943"></span>
<span id="line18944"></span>          APPENDIX B: SECTION NOTES........................   B-1
<span id="line18945"></span>          B1.     Section 1 Notes..........................   B-1
<span id="line18946"></span>          B2.     Section 2 Notes..........................   B-2
<span id="line18947"></span>          B3.     Section 3 Notes..........................   B-2
<span id="line18948"></span>          B4.     Section 4 Notes..........................   B-3
<span id="line18949"></span>          B5.     Section 5 Notes..........................   B-4
<span id="line18950"></span>          B6.     Section 6 Notes..........................   B-4
<span id="line18951"></span>          B7.     Section 7 Notes..........................   B-4
<span id="line18952"></span>          B8.     Section 8 Notes..........................   B-5
<span id="line18953"></span>          B9.     Section 9 Notes..........................   B-6
<span id="line18954"></span>          B10.     Section 10 Notes........................   B-6
<span id="line18955"></span>          B11.     Section 11 Notes........................   B-6
<span id="line18956"></span>          B12.     Section 12 Notes........................   B-7
<span id="line18957"></span>          B13.     Section 13 Notes........................  B-13
<span id="line18958"></span>          B14.     Section 14 Notes........................  B-15
<span id="line18959"></span>          B15.     Section 15 Notes........................  B-15
<span id="line18960"></span>          B16.     Section 16 Notes........................  B-18
<span id="line18961"></span>          B17.     Section 17 Notes........................  B-18
<span id="line18962"></span>          B18.     Section 18 Notes........................  B-19
<span id="line18963"></span>
<span id="line18964"></span>
<span id="line18965"></span>
<span id="line18966"></span>
<span id="line18967"></span>
<span id="line18968"></span>
<span id="line18969"></span>
<span id="line18970"></span>
<span id="line18971"></span>
<span id="line18972"></span>
<span id="line18973"></span>
<span id="line18974"></span>
<span id="line18975"></span>
<span id="line18976"></span>
<span id="line18977"></span>
<span id="line18978"></span>
<span id="line18979"></span>
<span id="line18980"></span>
<span id="line18981"></span>
<span id="line18982"></span>
<span id="line18983"></span>
<span id="line18984"></span>
<span id="line18985"></span>
<span id="line18986"></span>
<span id="line18987"></span>
<span id="line18988"></span>
<span id="line18989"></span>
<span id="line18990"></span>
<span id="line18991"></span>
<span id="line18992"></span>
<span id="line18993"></span>
<span id="line18994"></span>
<span id="line18995"></span>
<span id="line18996"></span>                                   - i -
<span id="line18997"></span>
<span id="line18998"></span>
<span id="line18999"></span>
<span id="line19000"></span>
<span id="line19001"></span>
<span id="line19002"></span>
<span id="line19003"></span>
<span id="line19004"></span>                                                   ANSI X3J3/90.4
<span id="line19005"></span>
<span id="line19006"></span>
<span id="line19007"></span>
<span id="line19008"></span>                           APPENDIX_C:_HOLLERITH
<span id="line19009"></span>
<span id="line19010"></span>          The  character  data  type  was  added  to  provide   a
<span id="line19011"></span>          character  data  processing capability that is superior
<span id="line19012"></span>          to the Hollerith data capability that existed  in  ANSI
<span id="line19013"></span>          X3.9-1966.
<span id="line19014"></span>
<span id="line19015"></span>          The  Hollerith  data  type  has  been   deleted.    For
<span id="line19016"></span>          processors   that   extend  the  standard  by  allowing
<span id="line19017"></span>          Hollerith data, the following rules  for  programs  are
<span id="line19018"></span>          recommended:
<span id="line19019"></span>
<span id="line19020"></span>
<span id="line19021"></span>          C1.  Hollerith_Data_Type
<span id="line19022"></span>
<span id="line19023"></span>          Hollerith is a data type; however, a symbolic name must
<span id="line19024"></span>          not  be  of type Hollerith.  Hollerith data, other than
<span id="line19025"></span>          constants, are identified under the guise of a name  of
<span id="line19026"></span>          type  integer,  real,  or  logical.   They  must not be
<span id="line19027"></span>          identified under  the  guise  of  type  character.   No
<span id="line19028"></span>          recommendation  is  made  regarding Hollerith under the
<span id="line19029"></span>          guise of double precision or complex.
<span id="line19030"></span>
<span id="line19031"></span>          A Hollerith datum  is  a  string  of  characters.   The
<span id="line19032"></span>          string   may  consist  of  any  characters  capable  of
<span id="line19033"></span>          representation in the processor.  The  blank  character
<span id="line19034"></span>          is  significant  in  a Hollerith datum.  Hollerith data
<span id="line19035"></span>          may have an internal representation that  is  different
<span id="line19036"></span>          from that of other data types.
<span id="line19037"></span>
<span id="line19038"></span>          An entity of type integer,  real,  or  logical  may  be
<span id="line19039"></span>          defined  with  a  Hollerith  value  by  means of a DATA
<span id="line19040"></span>          statement (C4) or READ statement (C6).  When an  entity
<span id="line19041"></span>          is   defined   with  a  Hollerith  value,  its  totally
<span id="line19042"></span>          associated  entities  are  also   defined   with   that
<span id="line19043"></span>          Hollerith value.  When an entity of type integer, real,
<span id="line19044"></span>          or logical is  defined  with  a  Hollerith  value,  the
<span id="line19045"></span>          entity  and  its associates become undefined for use as
<span id="line19046"></span>          an integer, real, or logical datum.
<span id="line19047"></span>
<span id="line19048"></span>
<span id="line19049"></span>          C2.  Hollerith_Constant
<span id="line19050"></span>
<span id="line19051"></span>          The  form  of  a  Hollerith  constant  is  a   nonzero,
<span id="line19052"></span>          unsigned,  integer constant n_ followed by the letter H,
<span id="line19053"></span>          followed  by  a  string  of  exactly   n _   contiguous
<span id="line19054"></span>          characters.   The  string may consist of any characters
<span id="line19055"></span>          capable of representation in the processor.  The string
<span id="line19056"></span>          of n_ characters is the Hollerith datum.
<span id="line19057"></span>
<span id="line19058"></span>
<span id="line19059"></span>
<span id="line19060"></span>
<span id="line19061"></span>
<span id="line19062"></span>          FORTRAN 77 Full Language                       Page C-1
<span id="line19063"></span>
<span id="line19064"></span>
<span id="line19065"></span>
<span id="line19066"></span>
<span id="line19067"></span>
<span id="line19068"></span>
<span id="line19069"></span>
<span id="line19070"></span>          APPENDIX C: HOLLERITH                    ANSI X3J3/90.4
<span id="line19071"></span>
<span id="line19072"></span>
<span id="line19073"></span>
<span id="line19074"></span>          In a Hollerith constant, blanks are significant only in
<span id="line19075"></span>          the n_ characters following the letter H.
<span id="line19076"></span>
<span id="line19077"></span>
<span id="line19078"></span>          C3.  Restrictions_on_Hollerith_Constants
<span id="line19079"></span>
<span id="line19080"></span>          A  Hollerith  constant  may  appear  only  in  a   DATA
<span id="line19081"></span>          statement and in the argument list of a CALL statement.
<span id="line19082"></span>
<span id="line19083"></span>
<span id="line19084"></span>          C4.  Hollerith_Constantin
<span id="line19085"></span>
<span id="line19086"></span>          An integer, real, or logical entity  may  be  initially
<span id="line19087"></span>          defined with a Hollerith datum by a DATA statement.
<span id="line19088"></span>
<span id="line19089"></span>          A Hollerith constant may appear in the list clist_____,  and
<span id="line19090"></span>          the  corresponding  entity  in the list nlist_____ may be of
<span id="line19091"></span>          type integer, real, or logical.
<span id="line19092"></span>
<span id="line19093"></span>          For an entity of type integer, real,  or  logical,  the
<span id="line19094"></span>          number  of  characters n_ in the corresponding Hollerith
<span id="line19095"></span>          constant must be less than or equal to g_, where  g_  is
<span id="line19096"></span>          the  maximum number of characters that can be stored in
<span id="line19097"></span>          a single numeric storage unit at one time.   If  n_  is
<span id="line19098"></span>          less than g_, the entity is initially defined with the n_
<span id="line19099"></span>          Hollerith characters extended on the right with g_ -  n_
<span id="line19100"></span>          blank characters.
<span id="line19101"></span>
<span id="line19102"></span>          Note that each  Hollerith  constant  initially  defines
<span id="line19103"></span>          exactly one variable or array element.  Also note that g
<span id="line19104"></span>          _ is processor dependent.
<span id="line19105"></span>
<span id="line19106"></span>
<span id="line19107"></span>          C5.  Hollerith_Format_Specification
<span id="line19108"></span>
<span id="line19109"></span>          A format specification may be an  array  name  of  type
<span id="line19110"></span>          integer, real, or logical.
<span id="line19111"></span>
<span id="line19112"></span>          The leftmost characters of the  specified  entity  must
<span id="line19113"></span>          contain   Hollerith   data  that  constitute  a  format
<span id="line19114"></span>          specification when the statement is executed.
<span id="line19115"></span>
<span id="line19116"></span>          The format specification must be of the form  described
<span id="line19117"></span>          in  13.2.   It  must  begin with a left parenthesis and
<span id="line19118"></span>          must end with a right parenthesis.  Data may follow the
<span id="line19119"></span>          right  parenthesis  that  ends the format specification
<span id="line19120"></span>          and have no effect.  Blank characters may  precede  the
<span id="line19121"></span>          format specification.
<span id="line19122"></span>
<span id="line19123"></span>          A Hollerith format specification must  not  contain  an
<span id="line19124"></span>          apostrophe edit descriptor or an H edit descriptor.
<span id="line19125"></span>
<span id="line19126"></span>
<span id="line19127"></span>
<span id="line19128"></span>          FORTRAN 77 Full Language                       Page C-2
<span id="line19129"></span>
<span id="line19130"></span>
<span id="line19131"></span>
<span id="line19132"></span>
<span id="line19133"></span>
<span id="line19134"></span>
<span id="line19135"></span>
<span id="line19136"></span>          APPENDIX C: HOLLERITH                    ANSI X3J3/90.4
<span id="line19137"></span>
<span id="line19138"></span>
<span id="line19139"></span>
<span id="line19140"></span>          C6.  A_Editing_of_Hollerith_Data
<span id="line19141"></span>
<span id="line19142"></span>          The Aw_ edit descriptor may be used with Hollerith  data
<span id="line19143"></span>          when  the  input/output  list  item is of type integer,
<span id="line19144"></span>          real, or logical.  On input, the input list  item  will
<span id="line19145"></span>          become  defined  with  Hollerith  data.  On output, the
<span id="line19146"></span>          list item must be defined with Hollerith data.
<span id="line19147"></span>
<span id="line19148"></span>          Editing is as described for Aw_  editing  of  character
<span id="line19149"></span>          data  except  that  len_ _ _  is  the  maximum  number of
<span id="line19150"></span>          characters that can  be  stored  in  a  single  numeric
<span id="line19151"></span>          storage unit.
<span id="line19152"></span>
<span id="line19153"></span>
<span id="line19154"></span>          C7.  Hollerith_Constant_in_a_Subroutine_Reference
<span id="line19155"></span>
<span id="line19156"></span>          An actual argument in a subroutine reference may  be  a
<span id="line19157"></span>          Hollerith  constant.   The corresponding dummy argument
<span id="line19158"></span>          must be of type integer, real, or logical.   Note  that
<span id="line19159"></span>          this is an exception to the rule that requires that the
<span id="line19160"></span>          type of the actual and dummy argument must agree.
<span id="line19161"></span>
<span id="line19162"></span>
<span id="line19163"></span>
<span id="line19164"></span>
<span id="line19165"></span>
<span id="line19166"></span>
<span id="line19167"></span>
<span id="line19168"></span>
<span id="line19169"></span>
<span id="line19170"></span>
<span id="line19171"></span>
<span id="line19172"></span>
<span id="line19173"></span>
<span id="line19174"></span>
<span id="line19175"></span>
<span id="line19176"></span>
<span id="line19177"></span>
<span id="line19178"></span>
<span id="line19179"></span>
<span id="line19180"></span>
<span id="line19181"></span>
<span id="line19182"></span>
<span id="line19183"></span>
<span id="line19184"></span>
<span id="line19185"></span>
<span id="line19186"></span>
<span id="line19187"></span>
<span id="line19188"></span>
<span id="line19189"></span>
<span id="line19190"></span>
<span id="line19191"></span>
<span id="line19192"></span>
<span id="line19193"></span>
<span id="line19194"></span>          FORTRAN 77 Full Language                       Page C-3
<span id="line19195"></span>
<span id="line19196"></span>
<span id="line19197"></span>
<span id="line19198"></span>
<span id="line19199"></span>
<span id="line19200"></span>
<span id="line19201"></span>
<span id="line19202"></span>
<span id="line19203"></span>
<span id="line19204"></span>
<span id="line19205"></span>
<span id="line19206"></span>                                 CONTENTS
<span id="line19207"></span>
<span id="line19208"></span>          APPENDIX C: HOLLERITH.............................  C-1
<span id="line19209"></span>          C1.     Hollerith Data Type.......................  C-1
<span id="line19210"></span>          C2.     Hollerith Constant........................  C-1
<span id="line19211"></span>          C3.     Restrictions on Hollerith Constants.......  C-2
<span id="line19212"></span>          C4.     Hollerith Constant........................  C-2
<span id="line19213"></span>          C5.     Hollerith Format Specification............  C-2
<span id="line19214"></span>          C6.     A Editing of Hollerith Data...............  C-3
<span id="line19215"></span>          C7.     Hollerith Constant in a Subroutine
<span id="line19216"></span>          Reference.........................................  C-3
<span id="line19217"></span>
<span id="line19218"></span>
<span id="line19219"></span>
<span id="line19220"></span>
<span id="line19221"></span>
<span id="line19222"></span>
<span id="line19223"></span>
<span id="line19224"></span>
<span id="line19225"></span>
<span id="line19226"></span>
<span id="line19227"></span>
<span id="line19228"></span>
<span id="line19229"></span>
<span id="line19230"></span>
<span id="line19231"></span>
<span id="line19232"></span>
<span id="line19233"></span>
<span id="line19234"></span>
<span id="line19235"></span>
<span id="line19236"></span>
<span id="line19237"></span>
<span id="line19238"></span>
<span id="line19239"></span>
<span id="line19240"></span>
<span id="line19241"></span>
<span id="line19242"></span>
<span id="line19243"></span>
<span id="line19244"></span>
<span id="line19245"></span>
<span id="line19246"></span>
<span id="line19247"></span>
<span id="line19248"></span>
<span id="line19249"></span>
<span id="line19250"></span>
<span id="line19251"></span>
<span id="line19252"></span>
<span id="line19253"></span>
<span id="line19254"></span>
<span id="line19255"></span>
<span id="line19256"></span>
<span id="line19257"></span>
<span id="line19258"></span>
<span id="line19259"></span>
<span id="line19260"></span>                                   - i -
<span id="line19261"></span>
<span id="line19262"></span>
<span id="line19263"></span>
<span id="line19264"></span>
<span id="line19265"></span>
<span id="line19266"></span>
<span id="line19267"></span>
<span id="line19268"></span>                                                   ANSI X3J3/90.4
<span id="line19269"></span>
<span id="line19270"></span>
<span id="line19271"></span>
<span id="line19272"></span>                        APPENDIX_D:_SUBSET_OVERVIEW
<span id="line19273"></span>
<span id="line19274"></span>          This Appendix provides an overview of the two levels of
<span id="line19275"></span>          FORTRAN  specified  in  this  standard,  including  the
<span id="line19276"></span>          general criteria used  for  including  or  excluding  a
<span id="line19277"></span>          feature  at  a  given  level,  and a section-by-section
<span id="line19278"></span>          summary of the principal differences between  the  full
<span id="line19279"></span>          language and the subset.
<span id="line19280"></span>
<span id="line19281"></span>
<span id="line19282"></span>          D1.  Background
<span id="line19283"></span>
<span id="line19284"></span>          The full FORTRAN language described in this document is
<span id="line19285"></span>          a  superset  of  the FORTRAN language described in ANSI
<span id="line19286"></span>          X3.9-1966, with the exceptions  previously  noted.   In
<span id="line19287"></span>          formulating a subset philosophy, the following existing
<span id="line19288"></span>          FORTRAN standards were considered:
<span id="line19289"></span>
<span id="line19290"></span>             (1) American National Standard FORTRAN,  ANSI  X3.9-
<span id="line19291"></span>                 1966
<span id="line19292"></span>
<span id="line19293"></span>             (2) American National Standard Basic  FORTRAN,  ANSI
<span id="line19294"></span>                 X3.10-1966
<span id="line19295"></span>
<span id="line19296"></span>             (3) International  Standard   Programming   Language
<span id="line19297"></span>                 FORTRAN, ISO R1539
<span id="line19298"></span>
<span id="line19299"></span>          The ISO R1539 document describes three  levels:  basic,
<span id="line19300"></span>          intermediate,  and  full.   The  ISO  R1539 basic level
<span id="line19301"></span>          corresponds closely with ANSI X3.10-1966; the ISO R1539
<span id="line19302"></span>          full level corresponds closely with ANSI X3.9-1966; and
<span id="line19303"></span>          the ISO R1539 intermediate level is in between.
<span id="line19304"></span>
<span id="line19305"></span>          It was thought that the ISO R1539 basic level  and  the
<span id="line19306"></span>          ANSI X3.10-1966 had not been sufficiently used, even on
<span id="line19307"></span>          small   computer   systems,   to   warrant   a   subset
<span id="line19308"></span>          corresponding to that level.
<span id="line19309"></span>
<span id="line19310"></span>          The ISO R1539 intermediate level has been  sufficiently
<span id="line19311"></span>          used to warrant a subset of similar capability.
<span id="line19312"></span>
<span id="line19313"></span>          However,  it  was  also  thought  that  some   of   the
<span id="line19314"></span>          capabilities  in  the full language described here, but
<span id="line19315"></span>          not part of any current standard or recommendation, are
<span id="line19316"></span>          so  important  for the general use of the language that
<span id="line19317"></span>          they should be present in the subset, at least to  some
<span id="line19318"></span>          degree.
<span id="line19319"></span>
<span id="line19320"></span>          Furthermore, it was thought that the  specification  of
<span id="line19321"></span>          ANSI  X3.10-1966  in  such  a  manner  that it is not a
<span id="line19322"></span>          subset of ANSI  X3.9-1966  was  inconsistent  with  the
<span id="line19323"></span>
<span id="line19324"></span>
<span id="line19325"></span>
<span id="line19326"></span>          FORTRAN 77 Full Language                       Page D-1
<span id="line19327"></span>
<span id="line19328"></span>
<span id="line19329"></span>
<span id="line19330"></span>
<span id="line19331"></span>
<span id="line19332"></span>
<span id="line19333"></span>
<span id="line19334"></span>          APPENDIX D: SUBSET OVERVIEW              ANSI X3J3/90.4
<span id="line19335"></span>
<span id="line19336"></span>
<span id="line19337"></span>
<span id="line19338"></span>          primary   goal   of   promoting   program  interchange.
<span id="line19339"></span>          Consequently,  careful  attention  has  been  given  to
<span id="line19340"></span>          ensuring  that a program that conforms to the subset of
<span id="line19341"></span>          this standard will also conform to the full language.
<span id="line19342"></span>
<span id="line19343"></span>
<span id="line19344"></span>          D2.  Criteria
<span id="line19345"></span>
<span id="line19346"></span>          The criteria in D2.1 and D2.2 were adopted for the  two
<span id="line19347"></span>          levels of FORTRAN within this standard.
<span id="line19348"></span>
<span id="line19349"></span>          D2.1  Full_Language.
<span id="line19350"></span>
<span id="line19351"></span>          The most notable new elements of the full language that
<span id="line19352"></span>          have  been  included at both levels are: character data
<span id="line19353"></span>          type, mixed-type arithmetic, INTRINSIC statement,  SAVE
<span id="line19354"></span>          statement, and direct access I/O statements.
<span id="line19355"></span>
<span id="line19356"></span>          D2.2  Subset_Language.
<span id="line19357"></span>
<span id="line19358"></span>             (1) The subset must be a proper subset of  the  full
<span id="line19359"></span>                 language.
<span id="line19360"></span>
<span id="line19361"></span>             (2) The  subset  must  be   based   on   ISO   R1539
<span id="line19362"></span>                 intermediate level FORTRAN.
<span id="line19363"></span>
<span id="line19364"></span>             (3) The subset must include, at a fundamental level,
<span id="line19365"></span>                 those   features   of  the  full  language  that
<span id="line19366"></span>                 significantly  increase   the   scope   of   the
<span id="line19367"></span>                 language.
<span id="line19368"></span>
<span id="line19369"></span>             (4) The elements of the subset must make  a  minimum
<span id="line19370"></span>                 demand  on  storage  requirements,  particularly
<span id="line19371"></span>                 during execution.
<span id="line19372"></span>
<span id="line19373"></span>             (5) The subset must require a minimum of effort  for
<span id="line19374"></span>                 the  development  and  maintenance  of  a viable
<span id="line19375"></span>                 FORTRAN processor.
<span id="line19376"></span>
<span id="line19377"></span>
<span id="line19378"></span>          D3.  Summary_of_Subset_Differences
<span id="line19379"></span>
<span id="line19380"></span>          This section summarizes  the  differences  between  the
<span id="line19381"></span>          full  language  and the subset in this standard.  It is
<span id="line19382"></span>          organized  primarily  on  the  basis  of  the  standard
<span id="line19383"></span>          itself.    The  differences  are  discussed  under  the
<span id="line19384"></span>          section  where  each  language  element  is   primarily
<span id="line19385"></span>          presented.   Of course, a difference in one section may
<span id="line19386"></span>          cause changes in other sections.  Such changes are  not
<span id="line19387"></span>          noted here.
<span id="line19388"></span>
<span id="line19389"></span>
<span id="line19390"></span>
<span id="line19391"></span>
<span id="line19392"></span>          FORTRAN 77 Full Language                       Page D-2
<span id="line19393"></span>
<span id="line19394"></span>
<span id="line19395"></span>
<span id="line19396"></span>
<span id="line19397"></span>
<span id="line19398"></span>
<span id="line19399"></span>
<span id="line19400"></span>          APPENDIX D: SUBSET OVERVIEW              ANSI X3J3/90.4
<span id="line19401"></span>
<span id="line19402"></span>
<span id="line19403"></span>
<span id="line19404"></span>          An exception to the above practice is the subsetting of
<span id="line19405"></span>          the  character data type.  The description of character
<span id="line19406"></span>          data type and its usage is  so  distributed  throughout
<span id="line19407"></span>          the standard that a more meaningful summary is produced
<span id="line19408"></span>          by  collecting  the  relevant  items  into   a   single
<span id="line19409"></span>          presentation.
<span id="line19410"></span>
<span id="line19411"></span>          D3.1  Section_1:_Introduction.
<span id="line19412"></span>
<span id="line19413"></span>          The subset is the same as the full language  (see  also
<span id="line19414"></span>          D4).
<span id="line19415"></span>
<span id="line19416"></span>          D3.2  Section_2:_FORTRAN_Terms_and_Concepts.
<span id="line19417"></span>
<span id="line19418"></span>          The subset is the same as the full language.
<span id="line19419"></span>
<span id="line19420"></span>          D3.3  Section 3: Characters, Lines, and Execution
<span id="line19421"></span>                Sequence.
<span id="line19422"></span>
<span id="line19423"></span>          The subset is the same  as  the  full  language  except
<span id="line19424"></span>          that:
<span id="line19425"></span>
<span id="line19426"></span>             (1) The character set does not include the  currency
<span id="line19427"></span>                 symbol ($) or the colon (:).
<span id="line19428"></span>
<span id="line19429"></span>             (2) Statements may  have  up  to  nine  continuation
<span id="line19430"></span>                 lines.
<span id="line19431"></span>
<span id="line19432"></span>             (3) DATA statements must  follow  all  specification
<span id="line19433"></span>                 statements  and  precede  all statement function
<span id="line19434"></span>                 statements and executable statements.
<span id="line19435"></span>
<span id="line19436"></span>             (4) A comment line must not precede  a  continuation
<span id="line19437"></span>                 line.
<span id="line19438"></span>
<span id="line19439"></span>          D3.4  Section_4:_Data_Types_and_Constants.
<span id="line19440"></span>
<span id="line19441"></span>          The subset is the same as the full language except that
<span id="line19442"></span>          double   precision  and  complex  data  types  are  not
<span id="line19443"></span>          included.  Note that each entity of type character must
<span id="line19444"></span>          have a constant length.
<span id="line19445"></span>
<span id="line19446"></span>          D3.5  Section_5:_Arrays_and_Substrings.
<span id="line19447"></span>
<span id="line19448"></span>          The subset is the same  as  the  full  language  except
<span id="line19449"></span>          that:
<span id="line19450"></span>
<span id="line19451"></span>             (1) An array declarator must not  have  an  explicit
<span id="line19452"></span>                 lower bound.
<span id="line19453"></span>
<span id="line19454"></span>
<span id="line19455"></span>
<span id="line19456"></span>
<span id="line19457"></span>
<span id="line19458"></span>          FORTRAN 77 Full Language                       Page D-3
<span id="line19459"></span>
<span id="line19460"></span>
<span id="line19461"></span>
<span id="line19462"></span>
<span id="line19463"></span>
<span id="line19464"></span>
<span id="line19465"></span>
<span id="line19466"></span>          APPENDIX D: SUBSET OVERVIEW              ANSI X3J3/90.4
<span id="line19467"></span>
<span id="line19468"></span>
<span id="line19469"></span>
<span id="line19470"></span>             (2) A dimension declarator must be either an integer
<span id="line19471"></span>                 constant or an integer variable.  (This excludes
<span id="line19472"></span>                 integer expressions, but allows  a  variable  in
<span id="line19473"></span>                 common.)
<span id="line19474"></span>
<span id="line19475"></span>             (3) An array may have up to three dimensions.
<span id="line19476"></span>
<span id="line19477"></span>             (4) A subscript  expression  may  be  an  expression
<span id="line19478"></span>                 containing only integer variables and constants.
<span id="line19479"></span>                 (This  excludes  function  and   array   element
<span id="line19480"></span>                 references.)
<span id="line19481"></span>
<span id="line19482"></span>          D3.6  Section_6:_Expressions.
<span id="line19483"></span>
<span id="line19484"></span>          The subset is the same as the full language except that
<span id="line19485"></span>          a  constant  expression is allowed only where a general
<span id="line19486"></span>          expression is allowed, the logical operators .EQV.  and
<span id="line19487"></span>          .NEQV.  are not included, and there are restrictions on
<span id="line19488"></span>          character expressions as described in D3.19.
<span id="line19489"></span>
<span id="line19490"></span>          D3.7  Section 7: Executable and Nonexecutable Statement
<span id="line19491"></span>                Classification.
<span id="line19492"></span>
<span id="line19493"></span>          The classification of a statement in the subset is  the
<span id="line19494"></span>          same as in the full language.  However, the subset does
<span id="line19495"></span>          not include PRINT, CLOSE, INQUIRE, ENTRY,  BLOCK  DATA,
<span id="line19496"></span>          PARAMETER, DOUBLE PRECISION, and COMPLEX statements.
<span id="line19497"></span>
<span id="line19498"></span>          D3.8  Section_8:_Specification_Statements.
<span id="line19499"></span>
<span id="line19500"></span>          The subset is the same  as  the  full  language  except
<span id="line19501"></span>          that:
<span id="line19502"></span>
<span id="line19503"></span>             (1) The PARAMETER statement is not included.
<span id="line19504"></span>
<span id="line19505"></span>             (2) Only the names of  common  blocks  (enclosed  in
<span id="line19506"></span>                 slashes)  may  appear  in  the  list  of  a SAVE
<span id="line19507"></span>                 statement.   The  form  of  the  SAVE  statement
<span id="line19508"></span>                 without a list is not included.
<span id="line19509"></span>
<span id="line19510"></span>          D3.9  Section_9:_DATA_Statement.
<span id="line19511"></span>
<span id="line19512"></span>          The subset is the same  as  the  full  language  except
<span id="line19513"></span>          that:
<span id="line19514"></span>
<span id="line19515"></span>             (1) Only  names  of  variables,  arrays,  and  array
<span id="line19516"></span>                 elements  are  allowed  in  the  list  nlist_ _ ___.
<span id="line19517"></span>                 Implied-DO lists are not included.
<span id="line19518"></span>
<span id="line19519"></span>             (2) Values in the list clist_____ must agree in type with
<span id="line19520"></span>                 the  corresponding item in the list nlist_____.  Type
<span id="line19521"></span>
<span id="line19522"></span>
<span id="line19523"></span>
<span id="line19524"></span>          FORTRAN 77 Full Language                       Page D-4
<span id="line19525"></span>
<span id="line19526"></span>
<span id="line19527"></span>
<span id="line19528"></span>
<span id="line19529"></span>
<span id="line19530"></span>
<span id="line19531"></span>
<span id="line19532"></span>          APPENDIX D: SUBSET OVERVIEW              ANSI X3J3/90.4
<span id="line19533"></span>
<span id="line19534"></span>
<span id="line19535"></span>
<span id="line19536"></span>                 conversion is not included.
<span id="line19537"></span>
<span id="line19538"></span>          Note that DATA statements must follow all specification
<span id="line19539"></span>          statements   and   precede   all   statement   function
<span id="line19540"></span>          statements and executable statements.
<span id="line19541"></span>
<span id="line19542"></span>          D3.10  Section_10:_Assignment_Statements.
<span id="line19543"></span>
<span id="line19544"></span>          The subset is the same as the full language except  for
<span id="line19545"></span>          restrictions on character type presented in D3.19.
<span id="line19546"></span>
<span id="line19547"></span>          D3.11  Section_11:_Control_Statements.
<span id="line19548"></span>
<span id="line19549"></span>          The subset is the same  as  the  full  language  except
<span id="line19550"></span>          that:
<span id="line19551"></span>
<span id="line19552"></span>             (1) A DO-variable must be an integer variable and DO
<span id="line19553"></span>                 parameters  must be integer constants or integer
<span id="line19554"></span>                 variables.
<span id="line19555"></span>
<span id="line19556"></span>             (2) In  a  computed  GOTO   statement,   the   index
<span id="line19557"></span>                 expression must be an integer variable.
<span id="line19558"></span>
<span id="line19559"></span>          D3.12  Section_12:_Input/Output_Statements.
<span id="line19560"></span>
<span id="line19561"></span>          The subset is the same  as  the  full  language  except
<span id="line19562"></span>          that:
<span id="line19563"></span>
<span id="line19564"></span>             (1) The CLOSE statement is not included.
<span id="line19565"></span>
<span id="line19566"></span>             (2) The INQUIRE statement is not included.
<span id="line19567"></span>
<span id="line19568"></span>             (3) List-directed READ and WRITE statements are  not
<span id="line19569"></span>                 included.
<span id="line19570"></span>
<span id="line19571"></span>             (4) An internal file identifier must be a  character
<span id="line19572"></span>                 variable or character array element.
<span id="line19573"></span>
<span id="line19574"></span>             (5) Formatted direct access files and statements are
<span id="line19575"></span>                 not included.
<span id="line19576"></span>
<span id="line19577"></span>             (6) External unit identifiers  must  be  an  integer
<span id="line19578"></span>                 constant or integer variable.
<span id="line19579"></span>
<span id="line19580"></span>             (7) A format identifier  must  be  the  label  of  a
<span id="line19581"></span>                 FORMAT  statement,  an integer variable that has
<span id="line19582"></span>                 been assigned the label of a  FORMAT  statement,
<span id="line19583"></span>                 or a character constant.
<span id="line19584"></span>
<span id="line19585"></span>             (8) The UNIT= and FMT=  forms  of  unit  and  format
<span id="line19586"></span>                 specifiers are not included.
<span id="line19587"></span>
<span id="line19588"></span>
<span id="line19589"></span>
<span id="line19590"></span>          FORTRAN 77 Full Language                       Page D-5
<span id="line19591"></span>
<span id="line19592"></span>
<span id="line19593"></span>
<span id="line19594"></span>
<span id="line19595"></span>
<span id="line19596"></span>
<span id="line19597"></span>
<span id="line19598"></span>          APPENDIX D: SUBSET OVERVIEW              ANSI X3J3/90.4
<span id="line19599"></span>
<span id="line19600"></span>
<span id="line19601"></span>
<span id="line19602"></span>             (9) The ERR= specifier is not included.
<span id="line19603"></span>
<span id="line19604"></span>            (10) The forms READ f [,iolist______] and PRINT f [,iolist______]
<span id="line19605"></span>                 are not included.
<span id="line19606"></span>
<span id="line19607"></span>            (11) In input/output lists, the implied-DO parameters
<span id="line19608"></span>                 must   be   integer   constants  and  variables.
<span id="line19609"></span>                 Implied-DO-variables must be of type integer.
<span id="line19610"></span>
<span id="line19611"></span>            (12) Variable names, array element names,  and  array
<span id="line19612"></span>                 names  may  appear  as  input/output list items;
<span id="line19613"></span>                 constants, character substring  references,  and
<span id="line19614"></span>                 general expressions are not included.
<span id="line19615"></span>
<span id="line19616"></span>            (13) A limited form of  OPEN  statement  is  included
<span id="line19617"></span>                 with  the  following  olist_____ specifiers required,
<span id="line19618"></span>                 and no others are allowed:
<span id="line19619"></span>
<span id="line19620"></span>                (a) An integer constant unit identifier
<span id="line19621"></span>
<span id="line19622"></span>                (b) The keyword specifier ACCESS= 'DIRECT'
<span id="line19623"></span>
<span id="line19624"></span>                (c) The record length specifier RECL= rl__, where rl_
<span id="line19625"></span>                    _ is an integer constant
<span id="line19626"></span>
<span id="line19627"></span>                 The OPEN statement is  included  in  the  subset
<span id="line19628"></span>                 only to the extent needed to connect a unit to a
<span id="line19629"></span>                 direct access unformatted file.  Once a unit has
<span id="line19630"></span>                 been  connected  to a direct access file, it may
<span id="line19631"></span>                 not be reconnected to any other file.
<span id="line19632"></span>
<span id="line19633"></span>            (14) Named files are not included.
<span id="line19634"></span>
<span id="line19635"></span>          D3.13  Section_13:_Format_Specification.
<span id="line19636"></span>
<span id="line19637"></span>          The subset is the same  as  the  full  language  except
<span id="line19638"></span>          that:
<span id="line19639"></span>
<span id="line19640"></span>             (1) The following edit descriptors are not included:
<span id="line19641"></span>
<span id="line19642"></span>                                Iw_.m_     Tc_    S
<span id="line19643"></span>                                Dw_.d_     TLc_   SP
<span id="line19644"></span>                                Gw_.d_     TRc_   SS
<span id="line19645"></span>                                Gw_.d_Ee_
<span id="line19646"></span>
<span id="line19647"></span>             (2) At  most  three  levels   of   parentheses   are
<span id="line19648"></span>                 permitted.
<span id="line19649"></span>
<span id="line19650"></span>             (3) The  format  scan  terminator  (colon)  is   not
<span id="line19651"></span>                 included.
<span id="line19652"></span>
<span id="line19653"></span>
<span id="line19654"></span>
<span id="line19655"></span>
<span id="line19656"></span>          FORTRAN 77 Full Language                       Page D-6
<span id="line19657"></span>
<span id="line19658"></span>
<span id="line19659"></span>
<span id="line19660"></span>
<span id="line19661"></span>
<span id="line19662"></span>
<span id="line19663"></span>
<span id="line19664"></span>          APPENDIX D: SUBSET OVERVIEW              ANSI X3J3/90.4
<span id="line19665"></span>
<span id="line19666"></span>
<span id="line19667"></span>
<span id="line19668"></span>          D3.14  Section_14:_Main_Program.
<span id="line19669"></span>
<span id="line19670"></span>          The subset is the same as the full language.
<span id="line19671"></span>
<span id="line19672"></span>          D3.15  Section_15:_Functions_and_Subroutines.
<span id="line19673"></span>
<span id="line19674"></span>          The subset is the same as the full language except that
<span id="line19675"></span>          the following are not included:
<span id="line19676"></span>
<span id="line19677"></span>             (1) The ENTRY statement
<span id="line19678"></span>
<span id="line19679"></span>             (2) Alternate return specifier
<span id="line19680"></span>
<span id="line19681"></span>             (3) Generic function references
<span id="line19682"></span>
<span id="line19683"></span>             (4) Intrinsic  functions  involving   arguments   or
<span id="line19684"></span>                 results of type double precision or complex
<span id="line19685"></span>
<span id="line19686"></span>          Other exclusions are presented in D3.19,  most  notably
<span id="line19687"></span>          an   asterisk  character  length  specifier,  character
<span id="line19688"></span>          functions,  the  intrinsic  functions  LEN,  CHAR,  and
<span id="line19689"></span>          INDEX, and partial association.
<span id="line19690"></span>
<span id="line19691"></span>          D3.16  Section_16:_Block_Data_Subprogram.
<span id="line19692"></span>
<span id="line19693"></span>          Block data subprograms are not included in the subset.
<span id="line19694"></span>
<span id="line19695"></span>          D3.17  Section_17:_Association_and_Definition.
<span id="line19696"></span>
<span id="line19697"></span>          The subset is the same as the full language except that
<span id="line19698"></span>          the  concept  of  partial association does not apply to
<span id="line19699"></span>          the subset.
<span id="line19700"></span>
<span id="line19701"></span>          D3.18  Section_18:_Scope_and_Classes_of_Symbolic_Names.
<span id="line19702"></span>
<span id="line19703"></span>          The subset is the same as the full language.
<span id="line19704"></span>
<span id="line19705"></span>          D3.19  Section_1_to_18:_Character_Type.
<span id="line19706"></span>
<span id="line19707"></span>          The primary intent of the the subset character facility
<span id="line19708"></span>          is  to  provide  a minimal character capability that is
<span id="line19709"></span>          functionally comparable to what is possible  with  most
<span id="line19710"></span>          extensions of Hollerith data.
<span id="line19711"></span>
<span id="line19712"></span>          D3.19.1  Character_Features_in_the_Subset.  The  subset
<span id="line19713"></span>          includes the following character data type features:
<span id="line19714"></span>
<span id="line19715"></span>             (1) Character constants, variables, and arrays,  but
<span id="line19716"></span>                 not character functions
<span id="line19717"></span>
<span id="line19718"></span>
<span id="line19719"></span>
<span id="line19720"></span>
<span id="line19721"></span>
<span id="line19722"></span>          FORTRAN 77 Full Language                       Page D-7
<span id="line19723"></span>
<span id="line19724"></span>
<span id="line19725"></span>
<span id="line19726"></span>
<span id="line19727"></span>
<span id="line19728"></span>
<span id="line19729"></span>
<span id="line19730"></span>          APPENDIX D: SUBSET OVERVIEW              ANSI X3J3/90.4
<span id="line19731"></span>
<span id="line19732"></span>
<span id="line19733"></span>
<span id="line19734"></span>             (2) CHARACTER and IMPLICIT statements for  declaring
<span id="line19735"></span>                 character  entities  and their lengths; a length
<span id="line19736"></span>                 specification must be an integer  constant  (not
<span id="line19737"></span>                 an asterisk)
<span id="line19738"></span>
<span id="line19739"></span>             (3) Character assignment  statements  in  which  the
<span id="line19740"></span>                 right-hand side is a variable, array element, or
<span id="line19741"></span>                 constant
<span id="line19742"></span>
<span id="line19743"></span>             (4) Character relational expressions  in  which  the
<span id="line19744"></span>                 operands   are  variables,  array  elements,  or
<span id="line19745"></span>                 constants
<span id="line19746"></span>
<span id="line19747"></span>             (5) Initialization of character  variables,  arrays,
<span id="line19748"></span>                 and array elements in a DATA statement
<span id="line19749"></span>
<span id="line19750"></span>             (6) Character variables, arrays, and array  elements
<span id="line19751"></span>                 in output lists
<span id="line19752"></span>
<span id="line19753"></span>             (7) Character variables, arrays, array elements, and
<span id="line19754"></span>                 constants as arguments in subprogram references
<span id="line19755"></span>
<span id="line19756"></span>             (8) Character constants (but not variables or  array
<span id="line19757"></span>                 elements) as a format specification
<span id="line19758"></span>
<span id="line19759"></span>             (9) Total, but not partial, association of character
<span id="line19760"></span>                 entities  (that  is,  association  of  character
<span id="line19761"></span>                 entities only of the same  length  by  means  of
<span id="line19762"></span>                 COMMON and EQUIVALENCE statements or by argument
<span id="line19763"></span>                 association)
<span id="line19764"></span>
<span id="line19765"></span>            (10) Input/output of character data,  both  formatted
<span id="line19766"></span>                 (using    character    edit   descriptors)   and
<span id="line19767"></span>                 unformatted
<span id="line19768"></span>
<span id="line19769"></span>          D3.19.2  Character_Features_Not_in_the_Subset.      The
<span id="line19770"></span>          subset  does  not  include the following character data
<span id="line19771"></span>          type features:
<span id="line19772"></span>
<span id="line19773"></span>             (1) Substring reference and definition
<span id="line19774"></span>
<span id="line19775"></span>             (2) Concatenation operator
<span id="line19776"></span>
<span id="line19777"></span>             (3) Use of character variables or array elements  as
<span id="line19778"></span>                 format specifications
<span id="line19779"></span>
<span id="line19780"></span>             (4) Partial association of character entities
<span id="line19781"></span>
<span id="line19782"></span>             (5) Character functions
<span id="line19783"></span>
<span id="line19784"></span>
<span id="line19785"></span>
<span id="line19786"></span>
<span id="line19787"></span>
<span id="line19788"></span>          FORTRAN 77 Full Language                       Page D-8
<span id="line19789"></span>
<span id="line19790"></span>
<span id="line19791"></span>
<span id="line19792"></span>
<span id="line19793"></span>
<span id="line19794"></span>
<span id="line19795"></span>
<span id="line19796"></span>          APPENDIX D: SUBSET OVERVIEW              ANSI X3J3/90.4
<span id="line19797"></span>
<span id="line19798"></span>
<span id="line19799"></span>
<span id="line19800"></span>             (6) The intrinsic functions LEN, CHAR, and INDEX
<span id="line19801"></span>
<span id="line19802"></span>             (7) Character length specification consisting of  an
<span id="line19803"></span>                 asterisk or any expression other than a constant
<span id="line19804"></span>
<span id="line19805"></span>
<span id="line19806"></span>          D4.  Subset_Conformance.
<span id="line19807"></span>
<span id="line19808"></span>          Conformance  at  the  subset  level  of  this  standard
<span id="line19809"></span>          involves  requirements that relate to the full language
<span id="line19810"></span>          for both processors and programs.
<span id="line19811"></span>
<span id="line19812"></span>          D4.1  Subset_Processor_Conformance.
<span id="line19813"></span>
<span id="line19814"></span>          A standard-conforming subset processor may  include  an
<span id="line19815"></span>          extension   to   the   subset   language  that  has  an
<span id="line19816"></span>          interpretation  in  the  full  language  only  if   the
<span id="line19817"></span>          processor provides the interpretation described for the
<span id="line19818"></span>          full language.  That is, a  standard-conforming  subset
<span id="line19819"></span>          processor  may  not provide an extension that conflicts
<span id="line19820"></span>          with the full language.  Extensions that  do  not  have
<span id="line19821"></span>          forms  and interpretations in the full language are not
<span id="line19822"></span>          precluded by this requirement.
<span id="line19823"></span>
<span id="line19824"></span>          As an example, a standard-conforming  subset  processor
<span id="line19825"></span>          may  provide a double precision data type provided that
<span id="line19826"></span>          the requirements for double precision are fulfilled.
<span id="line19827"></span>
<span id="line19828"></span>          D4.2  Subset_Program_Performance.
<span id="line19829"></span>
<span id="line19830"></span>          A program that conforms to the  subset  level  of  this
<span id="line19831"></span>          standard  must have the same interpretation at both the
<span id="line19832"></span>          subset  level  and  the  full  language   level.    The
<span id="line19833"></span>          principal  implication of this requirement concerns the
<span id="line19834"></span>          use of function names that are identified  as  specific
<span id="line19835"></span>          or   generic  intrinsic  function  names  at  the  full
<span id="line19836"></span>          language level but  which  are  not  available  at  the
<span id="line19837"></span>          subset  level.   Examples  of such names are DSIN, MIN,
<span id="line19838"></span>          and CABS.
<span id="line19839"></span>
<span id="line19840"></span>          A subset-conforming program may not use such  names  as
<span id="line19841"></span>          intrinsic functions because these names are not defined
<span id="line19842"></span>          as  intrinsic  functions  in   the   subset   language.
<span id="line19843"></span>          Moreover,  a subset-conforming program may not use such
<span id="line19844"></span>          names as external function names unless such names  are
<span id="line19845"></span>          identified  as  external function names by appearing in
<span id="line19846"></span>          an  EXTERNAL  statement.   If  such   names   are   not
<span id="line19847"></span>          explicitly  declared  as  external,  the names would be
<span id="line19848"></span>          classified as external by a  subset  processor  and  as
<span id="line19849"></span>          intrinsic  by a full language processor.  Note that the
<span id="line19850"></span>          burden of avoiding this situation rests on the program.
<span id="line19851"></span>
<span id="line19852"></span>
<span id="line19853"></span>
<span id="line19854"></span>          FORTRAN 77 Full Language                       Page D-9
<span id="line19855"></span>
<span id="line19856"></span>
<span id="line19857"></span>
<span id="line19858"></span>
<span id="line19859"></span>
<span id="line19860"></span>
<span id="line19861"></span>
<span id="line19862"></span>          APPENDIX D: SUBSET OVERVIEW              ANSI X3J3/90.4
<span id="line19863"></span>
<span id="line19864"></span>
<span id="line19865"></span>
<span id="line19866"></span>          A   subset-conforming  processor  is  not  required  to
<span id="line19867"></span>          recognize that a full language intrinsic name is  being
<span id="line19868"></span>          used  without  being  declared as external.  In effect,
<span id="line19869"></span>          the full set of names  described  in  Table  5  may  be
<span id="line19870"></span>          considered  as reserved intrinsic function names in the
<span id="line19871"></span>          subset even though only a  subset  of  those  names  is
<span id="line19872"></span>          available for use.
<span id="line19873"></span>
<span id="line19874"></span>
<span id="line19875"></span>
<span id="line19876"></span>
<span id="line19877"></span>
<span id="line19878"></span>
<span id="line19879"></span>
<span id="line19880"></span>
<span id="line19881"></span>
<span id="line19882"></span>
<span id="line19883"></span>
<span id="line19884"></span>
<span id="line19885"></span>
<span id="line19886"></span>
<span id="line19887"></span>
<span id="line19888"></span>
<span id="line19889"></span>
<span id="line19890"></span>
<span id="line19891"></span>
<span id="line19892"></span>
<span id="line19893"></span>
<span id="line19894"></span>
<span id="line19895"></span>
<span id="line19896"></span>
<span id="line19897"></span>
<span id="line19898"></span>
<span id="line19899"></span>
<span id="line19900"></span>
<span id="line19901"></span>
<span id="line19902"></span>
<span id="line19903"></span>
<span id="line19904"></span>
<span id="line19905"></span>
<span id="line19906"></span>
<span id="line19907"></span>
<span id="line19908"></span>
<span id="line19909"></span>
<span id="line19910"></span>
<span id="line19911"></span>
<span id="line19912"></span>
<span id="line19913"></span>
<span id="line19914"></span>
<span id="line19915"></span>
<span id="line19916"></span>
<span id="line19917"></span>
<span id="line19918"></span>
<span id="line19919"></span>
<span id="line19920"></span>          FORTRAN 77 Full Language                      Page D-10
<span id="line19921"></span>
<span id="line19922"></span>
<span id="line19923"></span>
<span id="line19924"></span>
<span id="line19925"></span>
<span id="line19926"></span>
<span id="line19927"></span>
<span id="line19928"></span>
<span id="line19929"></span>
<span id="line19930"></span>
<span id="line19931"></span>
<span id="line19932"></span>                                 CONTENTS
<span id="line19933"></span>
<span id="line19934"></span>          APPENDIX D: SUBSET OVERVIEW.......................  D-1
<span id="line19935"></span>          D1.     Background................................  D-1
<span id="line19936"></span>          D2.     Criteria..................................  D-2
<span id="line19937"></span>          D2.1    Full Language.............................  D-2
<span id="line19938"></span>          D2.2    Subset Language...........................  D-2
<span id="line19939"></span>          D3.     Summary of Subset Differences.............  D-2
<span id="line19940"></span>          D3.1    Section 1: Introduction...................  D-3
<span id="line19941"></span>          D3.2    Section 2: FORTRAN Terms and Concepts.....  D
<span id="line19942"></span>          -3
<span id="line19943"></span>          D3.3    Section 3: Characters, Lines, and
<span id="line19944"></span>          Execution Sequence................................  D-3
<span id="line19945"></span>          D3.4    Section 4: Data Types and Constants.......  D-3
<span id="line19946"></span>          D3.5    Section 5: Arrays and Substrings..........  D-3
<span id="line19947"></span>          D3.6    Section 6: Expressions....................  D-4
<span id="line19948"></span>          D3.7    Section 7: Executable and Nonexecutable
<span id="line19949"></span>          Statement Classification..........................  D-4
<span id="line19950"></span>          D3.8    Section 8: Specification Statements.......  D-4
<span id="line19951"></span>          D3.9    Section 9: DATA Statement.................  D-4
<span id="line19952"></span>          D3.10    Section 10: Assignment Statements........  D-5
<span id="line19953"></span>          D3.11    Section 11: Control Statements...........  D-5
<span id="line19954"></span>          D3.12    Section 12: Input/Output Statements......  D-
<span id="line19955"></span>          5
<span id="line19956"></span>          D3.13    Section 13: Format Specification.........  D-6
<span id="line19957"></span>          D3.14    Section 14: Main Program.................  D-7
<span id="line19958"></span>          D3.15    Section 15: Functions and
<span id="line19959"></span>          Subroutines.......................................  D-7
<span id="line19960"></span>          D3.16    Section 16: Block Data Subprogram........  D-7
<span id="line19961"></span>          D3.17    Section 17: Association and
<span id="line19962"></span>          Definition........................................  D-7
<span id="line19963"></span>          D3.18    Section 18: Scope and Classes of
<span id="line19964"></span>          Symbolic Names....................................  D-7
<span id="line19965"></span>          D3.19    Section 1 to 18: Character Type..........  D-7
<span id="line19966"></span>          D4.     Subset Conformance........................  D-9
<span id="line19967"></span>          D4.1    Subset Processor Conformance..............  D-9
<span id="line19968"></span>          D4.2    Subset Program Performance................  D-9
<span id="line19969"></span>
<span id="line19970"></span>
<span id="line19971"></span>
<span id="line19972"></span>
<span id="line19973"></span>
<span id="line19974"></span>
<span id="line19975"></span>
<span id="line19976"></span>
<span id="line19977"></span>
<span id="line19978"></span>
<span id="line19979"></span>
<span id="line19980"></span>
<span id="line19981"></span>
<span id="line19982"></span>
<span id="line19983"></span>
<span id="line19984"></span>
<span id="line19985"></span>
<span id="line19986"></span>                                   - i -
<span id="line19987"></span>
<span id="line19988"></span>
<span id="line19989"></span>
<span id="line19990"></span>
<span id="line19991"></span>
<span id="line19992"></span>
<span id="line19993"></span>
<span id="line19994"></span>                                                   ANSI X3J3/90.4
<span id="line19995"></span>
<span id="line19996"></span>
<span id="line19997"></span>
<span id="line19998"></span>                      APPENDIX_E:_FORTRAN_STATEMENTS
<span id="line19999"></span>
<span id="line20000"></span>
<span id="line20001"></span>
<span id="line20002"></span>          Form____                                      Descriptive Heading___________________
<span id="line20003"></span>
<span id="line20004"></span>          ASSIGN s TO i                             Statement Label
<span id="line20005"></span>                                                    Assignment Statement
<span id="line20006"></span>
<span id="line20007"></span>          BACKSPACE u                               File Positioning
<span id="line20008"></span>          BACKSPACE (alist)                         Statements
<span id="line20009"></span>
<span id="line20010"></span>          BLOCK DATA [sub]                          BLOCK DATA Statement
<span id="line20011"></span>
<span id="line20012"></span>          CALL sub [([a [,a]...])]                  Subroutine Reference:
<span id="line20013"></span>                                                    CALL Statement
<span id="line20014"></span>
<span id="line20015"></span>          CHARACTER [*len[,]] nam [,nam]...         Character Type-
<span id="line20016"></span>                                                    Statement
<span id="line20017"></span>
<span id="line20018"></span>          CLOSE (cllist)                            CLOSE Statement
<span id="line20019"></span>
<span id="line20020"></span>          COMMON [/[cb]/]nlist[[,]/[cb]/nlist]...   COMMON Statement
<span id="line20021"></span>
<span id="line20022"></span>          COMPLEX v [,v]...                         Complex Type-
<span id="line20023"></span>                                                    Statement
<span id="line20024"></span>
<span id="line20025"></span>          CONTINUE                                  CONTINUE Statement
<span id="line20026"></span>
<span id="line20027"></span>          DATA nlist/clist/ [[,]nlist/clist/]...    DATA Statement
<span id="line20028"></span>
<span id="line20029"></span>          DIMENSION a(d) [,a(d)]...                 DIMENSION Statement
<span id="line20030"></span>
<span id="line20031"></span>          DO s [,] i=e918,e928[,e938]                     DO Statement
<span id="line20032"></span>
<span id="line20033"></span>          DOUBLE PRECISION v [,v]...                Double Precision
<span id="line20034"></span>                                                    Type-Statement
<span id="line20035"></span>
<span id="line20036"></span>          ELSE                                      ELSE Statement
<span id="line20037"></span>
<span id="line20038"></span>          ELSE IF (e) THEN                          ELSE IF Statement
<span id="line20039"></span>
<span id="line20040"></span>          END                                       END Statement
<span id="line20041"></span>
<span id="line20042"></span>          END IF                                    END IF Statement
<span id="line20043"></span>
<span id="line20044"></span>          ENDFILE u                                 File Positioning
<span id="line20045"></span>          ENDFILE (alist)                           Statements
<span id="line20046"></span>
<span id="line20047"></span>
<span id="line20048"></span>
<span id="line20049"></span>
<span id="line20050"></span>
<span id="line20051"></span>
<span id="line20052"></span>          FORTRAN 77 Full Language                       Page E-1
<span id="line20053"></span>
<span id="line20054"></span>
<span id="line20055"></span>
<span id="line20056"></span>
<span id="line20057"></span>
<span id="line20058"></span>
<span id="line20059"></span>
<span id="line20060"></span>          APPENDIX E: FORTRAN STATEMENTS           ANSI X3J3/90.4
<span id="line20061"></span>
<span id="line20062"></span>
<span id="line20063"></span>
<span id="line20064"></span>
<span id="line20065"></span>          ENTRY en [([d [,d]...])]                  ENTRY Statement
<span id="line20066"></span>
<span id="line20067"></span>          EQUIVALENCE (nlist) [,(nlist)]...         EQUIVALENCE Statement
<span id="line20068"></span>
<span id="line20069"></span>          EXTERNAL proc [,proc]...                  EXTERNAL Statement
<span id="line20070"></span>
<span id="line20071"></span>
<span id="line20072"></span>
<span id="line20073"></span>
<span id="line20074"></span>
<span id="line20075"></span>
<span id="line20076"></span>
<span id="line20077"></span>
<span id="line20078"></span>
<span id="line20079"></span>
<span id="line20080"></span>
<span id="line20081"></span>
<span id="line20082"></span>
<span id="line20083"></span>
<span id="line20084"></span>
<span id="line20085"></span>
<span id="line20086"></span>
<span id="line20087"></span>
<span id="line20088"></span>
<span id="line20089"></span>
<span id="line20090"></span>
<span id="line20091"></span>
<span id="line20092"></span>
<span id="line20093"></span>
<span id="line20094"></span>
<span id="line20095"></span>
<span id="line20096"></span>
<span id="line20097"></span>
<span id="line20098"></span>
<span id="line20099"></span>
<span id="line20100"></span>
<span id="line20101"></span>
<span id="line20102"></span>
<span id="line20103"></span>
<span id="line20104"></span>
<span id="line20105"></span>
<span id="line20106"></span>
<span id="line20107"></span>
<span id="line20108"></span>
<span id="line20109"></span>
<span id="line20110"></span>
<span id="line20111"></span>
<span id="line20112"></span>
<span id="line20113"></span>
<span id="line20114"></span>
<span id="line20115"></span>
<span id="line20116"></span>
<span id="line20117"></span>
<span id="line20118"></span>          FORTRAN 77 Full Language                       Page E-2
<span id="line20119"></span>
<span id="line20120"></span>
<span id="line20121"></span>
<span id="line20122"></span>
<span id="line20123"></span>
<span id="line20124"></span>
<span id="line20125"></span>
<span id="line20126"></span>          APPENDIX E: FORTRAN STATEMENTS           ANSI X3J3/90.4
<span id="line20127"></span>
<span id="line20128"></span>
<span id="line20129"></span>
<span id="line20130"></span>          Form____                               Descriptive Heading___________________
<span id="line20131"></span>
<span id="line20132"></span>          FORMAT fs                          FORMAT Statement
<span id="line20133"></span>          fun ([d [,d]...]) = e              Statement Function
<span id="line20134"></span>                                             Statement
<span id="line20135"></span>
<span id="line20136"></span>          [typ] FUNCTION fun ([d [,d]...])   FUNCTION Statement
<span id="line20137"></span>
<span id="line20138"></span>          GO TO i [[,](s [,s]...)]           Assigned GO TO
<span id="line20139"></span>                                             Statement
<span id="line20140"></span>
<span id="line20141"></span>          GO TO s                            Unconditional GO TO
<span id="line20142"></span>                                             Statement
<span id="line20143"></span>
<span id="line20144"></span>          GO TO (s [,s]...)[,] i             Computed GO TO
<span id="line20145"></span>                                             Statement
<span id="line20146"></span>
<span id="line20147"></span>          IF (e) st                          Logical IF Statement
<span id="line20148"></span>
<span id="line20149"></span>          IF (e) s918, s928, s938                  Arithmetic IF
<span id="line20150"></span>                                             Statement
<span id="line20151"></span>
<span id="line20152"></span>          IF (e) THEN                        Block IF Statement
<span id="line20153"></span>
<span id="line20154"></span>          IMPLICIT typ (a [,s]...)           IMPLICIT Statement
<span id="line20155"></span>            [,typ (a [,a]...)]...
<span id="line20156"></span>
<span id="line20157"></span>          INQUIRE (iflist)                   INQUIRE by File
<span id="line20158"></span>                                             Statement
<span id="line20159"></span>
<span id="line20160"></span>          INQUIRE (iulist)                   INQUIRE by Unit
<span id="line20161"></span>                                             Statement
<span id="line20162"></span>
<span id="line20163"></span>          INTEGER v [,v]...                  Integer Type-
<span id="line20164"></span>                                             Statement
<span id="line20165"></span>
<span id="line20166"></span>          INTRINSIC fun [,fun]...            INTRINSIC Statement
<span id="line20167"></span>
<span id="line20168"></span>          LOGICAL v [,v]...                  Logical Type-
<span id="line20169"></span>                                             Statement
<span id="line20170"></span>
<span id="line20171"></span>          OPEN (olist)                       OPEN Statement
<span id="line20172"></span>
<span id="line20173"></span>          PARAMETER (p=e [,p=e]...)          PARAMETER Statement
<span id="line20174"></span>
<span id="line20175"></span>          PAUSE [n]                          PAUSE Statement
<span id="line20176"></span>
<span id="line20177"></span>          PRINT f [,iolist]                  Data Transfer Output
<span id="line20178"></span>
<span id="line20179"></span>
<span id="line20180"></span>
<span id="line20181"></span>
<span id="line20182"></span>
<span id="line20183"></span>
<span id="line20184"></span>          FORTRAN 77 Full Language                       Page E-3
<span id="line20185"></span>
<span id="line20186"></span>
<span id="line20187"></span>
<span id="line20188"></span>
<span id="line20189"></span>
<span id="line20190"></span>
<span id="line20191"></span>
<span id="line20192"></span>          APPENDIX E: FORTRAN STATEMENTS           ANSI X3J3/90.4
<span id="line20193"></span>
<span id="line20194"></span>
<span id="line20195"></span>
<span id="line20196"></span>                                             Statement
<span id="line20197"></span>
<span id="line20198"></span>          PROGRAM pgm                        PROGRAM Statement
<span id="line20199"></span>
<span id="line20200"></span>
<span id="line20201"></span>
<span id="line20202"></span>
<span id="line20203"></span>
<span id="line20204"></span>
<span id="line20205"></span>
<span id="line20206"></span>
<span id="line20207"></span>
<span id="line20208"></span>
<span id="line20209"></span>
<span id="line20210"></span>
<span id="line20211"></span>
<span id="line20212"></span>
<span id="line20213"></span>
<span id="line20214"></span>
<span id="line20215"></span>
<span id="line20216"></span>
<span id="line20217"></span>
<span id="line20218"></span>
<span id="line20219"></span>
<span id="line20220"></span>
<span id="line20221"></span>
<span id="line20222"></span>
<span id="line20223"></span>
<span id="line20224"></span>
<span id="line20225"></span>
<span id="line20226"></span>
<span id="line20227"></span>
<span id="line20228"></span>
<span id="line20229"></span>
<span id="line20230"></span>
<span id="line20231"></span>
<span id="line20232"></span>
<span id="line20233"></span>
<span id="line20234"></span>
<span id="line20235"></span>
<span id="line20236"></span>
<span id="line20237"></span>
<span id="line20238"></span>
<span id="line20239"></span>
<span id="line20240"></span>
<span id="line20241"></span>
<span id="line20242"></span>
<span id="line20243"></span>
<span id="line20244"></span>
<span id="line20245"></span>
<span id="line20246"></span>
<span id="line20247"></span>
<span id="line20248"></span>
<span id="line20249"></span>
<span id="line20250"></span>          FORTRAN 77 Full Language                       Page E-4
<span id="line20251"></span>
<span id="line20252"></span>
<span id="line20253"></span>
<span id="line20254"></span>
<span id="line20255"></span>
<span id="line20256"></span>
<span id="line20257"></span>
<span id="line20258"></span>          APPENDIX E: FORTRAN STATEMENTS           ANSI X3J3/90.4
<span id="line20259"></span>
<span id="line20260"></span>
<span id="line20261"></span>
<span id="line20262"></span>          Form____                              Descriptive Heading___________________
<span id="line20263"></span>
<span id="line20264"></span>          READ (cilist) [iolist]            Data Transfer Input
<span id="line20265"></span>                                            Statement
<span id="line20266"></span>
<span id="line20267"></span>          READ f [,iolist]                  Data Transfer Input
<span id="line20268"></span>                                            Statement
<span id="line20269"></span>          REAL v [,v]...                    Real Type-Statement
<span id="line20270"></span>
<span id="line20271"></span>          RETURN [e]                        RETURN Statement
<span id="line20272"></span>
<span id="line20273"></span>          REWIND u                          File Positioning
<span id="line20274"></span>          REWIND (alist)                    Statements
<span id="line20275"></span>
<span id="line20276"></span>          SAVE [a [,a]...]                  SAVE Statement
<span id="line20277"></span>
<span id="line20278"></span>          STOP [n]                          STOP Statement
<span id="line20279"></span>
<span id="line20280"></span>          SUBROUTINE sub [([d [,d]...])]    Subroutine Subprogram
<span id="line20281"></span>                                            and SUBROUTINE
<span id="line20282"></span>                                            Statement
<span id="line20283"></span>
<span id="line20284"></span>          v = e                             Arithmetic Assignment
<span id="line20285"></span>                                            Statement
<span id="line20286"></span>
<span id="line20287"></span>          v = e                             Logical Assignment
<span id="line20288"></span>                                            Statement
<span id="line20289"></span>
<span id="line20290"></span>          v = e                             Character Assignment
<span id="line20291"></span>                                            Statement
<span id="line20292"></span>
<span id="line20293"></span>          WRITE (cilist) [iolist]           Data Transfer Output
<span id="line20294"></span>                                            Statement
<span id="line20295"></span>
<span id="line20296"></span>
<span id="line20297"></span>
<span id="line20298"></span>
<span id="line20299"></span>
<span id="line20300"></span>
<span id="line20301"></span>
<span id="line20302"></span>
<span id="line20303"></span>
<span id="line20304"></span>
<span id="line20305"></span>
<span id="line20306"></span>
<span id="line20307"></span>
<span id="line20308"></span>
<span id="line20309"></span>
<span id="line20310"></span>
<span id="line20311"></span>
<span id="line20312"></span>
<span id="line20313"></span>
<span id="line20314"></span>
<span id="line20315"></span>
<span id="line20316"></span>          FORTRAN 77 Full Language                       Page E-5
<span id="line20317"></span>
<span id="line20318"></span>
<span id="line20319"></span>
<span id="line20320"></span>
<span id="line20321"></span>
<span id="line20322"></span>
<span id="line20323"></span>
<span id="line20324"></span>
<span id="line20325"></span>
<span id="line20326"></span>
<span id="line20327"></span>
<span id="line20328"></span>                                 CONTENTS
<span id="line20329"></span>
<span id="line20330"></span>          APPENDIX E: FORTRAN STATEMENTS....................  E-1
<span id="line20331"></span>
<span id="line20332"></span>
<span id="line20333"></span>
<span id="line20334"></span>
<span id="line20335"></span>
<span id="line20336"></span>
<span id="line20337"></span>
<span id="line20338"></span>
<span id="line20339"></span>
<span id="line20340"></span>
<span id="line20341"></span>
<span id="line20342"></span>
<span id="line20343"></span>
<span id="line20344"></span>
<span id="line20345"></span>
<span id="line20346"></span>
<span id="line20347"></span>
<span id="line20348"></span>
<span id="line20349"></span>
<span id="line20350"></span>
<span id="line20351"></span>
<span id="line20352"></span>
<span id="line20353"></span>
<span id="line20354"></span>
<span id="line20355"></span>
<span id="line20356"></span>
<span id="line20357"></span>
<span id="line20358"></span>
<span id="line20359"></span>
<span id="line20360"></span>
<span id="line20361"></span>
<span id="line20362"></span>
<span id="line20363"></span>
<span id="line20364"></span>
<span id="line20365"></span>
<span id="line20366"></span>
<span id="line20367"></span>
<span id="line20368"></span>
<span id="line20369"></span>
<span id="line20370"></span>
<span id="line20371"></span>
<span id="line20372"></span>
<span id="line20373"></span>
<span id="line20374"></span>
<span id="line20375"></span>
<span id="line20376"></span>
<span id="line20377"></span>
<span id="line20378"></span>
<span id="line20379"></span>
<span id="line20380"></span>
<span id="line20381"></span>
<span id="line20382"></span>                                   - i -
<span id="line20383"></span>
<span id="line20384"></span>
<span id="line20385"></span>
<span id="line20386"></span>
<span id="line20387"></span>
<span id="line20388"></span>
<span id="line20389"></span>
<span id="line20390"></span>                                                   ANSI X3J3/90.4
<span id="line20391"></span>
<span id="line20392"></span>
<span id="line20393"></span>
<span id="line20394"></span>                         APPENDIX_F:_SYNTAX_CHARTS
<span id="line20395"></span>
<span id="line20396"></span>
<span id="line20397"></span>
<span id="line20398"></span>                  Appendix F is temporarily unavailable.
<span id="line20399"></span>
<span id="line20400"></span>
<span id="line20401"></span>
<span id="line20402"></span>
<span id="line20403"></span>
<span id="line20404"></span>
<span id="line20405"></span>
<span id="line20406"></span>
<span id="line20407"></span>
<span id="line20408"></span>
<span id="line20409"></span>
<span id="line20410"></span>
<span id="line20411"></span>
<span id="line20412"></span>
<span id="line20413"></span>
<span id="line20414"></span>
<span id="line20415"></span>
<span id="line20416"></span>
<span id="line20417"></span>
<span id="line20418"></span>
<span id="line20419"></span>
<span id="line20420"></span>
<span id="line20421"></span>
<span id="line20422"></span>
<span id="line20423"></span>
<span id="line20424"></span>
<span id="line20425"></span>
<span id="line20426"></span>
<span id="line20427"></span>
<span id="line20428"></span>
<span id="line20429"></span>
<span id="line20430"></span>
<span id="line20431"></span>
<span id="line20432"></span>
<span id="line20433"></span>
<span id="line20434"></span>
<span id="line20435"></span>
<span id="line20436"></span>
<span id="line20437"></span>
<span id="line20438"></span>
<span id="line20439"></span>
<span id="line20440"></span>
<span id="line20441"></span>
<span id="line20442"></span>
<span id="line20443"></span>
<span id="line20444"></span>
<span id="line20445"></span>
<span id="line20446"></span>
<span id="line20447"></span>
<span id="line20448"></span>          FORTRAN 77 Full Language                       Page F-1
<span id="line20449"></span>
<span id="line20450"></span>
<span id="line20451"></span>
<span id="line20452"></span>
<span id="line20453"></span>
<span id="line20454"></span>
<span id="line20455"></span>
<span id="line20456"></span>
<span id="line20457"></span>
<span id="line20458"></span>
<span id="line20459"></span>
<span id="line20460"></span>                                 CONTENTS
<span id="line20461"></span>
<span id="line20462"></span>          APPENDIX F: SYNTAX CHARTS.........................  F-1
<span id="line20463"></span>
<span id="line20464"></span>
<span id="line20465"></span>
<span id="line20466"></span>
<span id="line20467"></span>
<span id="line20468"></span>
<span id="line20469"></span>
<span id="line20470"></span>
<span id="line20471"></span>
<span id="line20472"></span>
<span id="line20473"></span>
<span id="line20474"></span>
<span id="line20475"></span>
<span id="line20476"></span>
<span id="line20477"></span>
<span id="line20478"></span>
<span id="line20479"></span>
<span id="line20480"></span>
<span id="line20481"></span>
<span id="line20482"></span>
<span id="line20483"></span>
<span id="line20484"></span>
<span id="line20485"></span>
<span id="line20486"></span>
<span id="line20487"></span>
<span id="line20488"></span>
<span id="line20489"></span>
<span id="line20490"></span>
<span id="line20491"></span>
<span id="line20492"></span>
<span id="line20493"></span>
<span id="line20494"></span>
<span id="line20495"></span>
<span id="line20496"></span>
<span id="line20497"></span>
<span id="line20498"></span>
<span id="line20499"></span>
<span id="line20500"></span>
<span id="line20501"></span>
<span id="line20502"></span>
<span id="line20503"></span>
<span id="line20504"></span>
<span id="line20505"></span>
<span id="line20506"></span>
<span id="line20507"></span>
<span id="line20508"></span>
<span id="line20509"></span>
<span id="line20510"></span>
<span id="line20511"></span>
<span id="line20512"></span>
<span id="line20513"></span>
<span id="line20514"></span>                                   - i -
<span id="line20515"></span></span><span>&lt;/<span class="end-tag">a_928</span>&gt;</span><span></span><span>&lt;/<span class="end-tag">n_-1.</span>&gt;</span><span></span><span>&lt;/<span class="end-tag">one</span>&gt;</span><span></span><span>&lt;/<span class="end-tag">n</span>&gt;</span><span></span><span>&lt;/<span class="end-tag">n</span>&gt;</span><span></span><span>&lt;/<span class="end-tag">n</span>&gt;</span><span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line20516"></span>
<span id="line20517"></span>
<span id="line20518"></span></span><span>&lt;/<span class="end-tag">body</span>&gt;</span><span></span><span>&lt;/<span class="end-tag">html</span>&gt;</span><span></span></pre><menu type="context" id="actions"><menuitem id="goToLine" label="Go to Line…" accesskey="L"></menuitem><menuitem id="wrapLongLines" label="Wrap Long Lines" type="checkbox"></menuitem><menuitem id="highlightSyntax" label="Syntax Highlighting" type="checkbox" checked="true"></menuitem></menu></body></html>