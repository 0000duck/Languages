use EyeOnProd

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spAcceptLicenseAgreement' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spAcceptLicenseAgreement

   go

create procedure spAcceptLicenseAgreement( @MemberUserId          integer,
                                           @MemberUserFName       varchar(50),
                                           @MemberUserLName       varchar(50),
                                           @AgreementId           integer,
                                           @AgreementText         text,
                                           @AgreementDateTime     datetime,
                                           @MemberUserAgreementId integer output ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @RowsAffected integer /* Number of rows affected by the previously executed statement */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Insert the new row. */
   insert into MEMBER_USER_AGREEMENT
   ( MEMBER_USER_ID,
     MEMBER_USER_FNAME,
     MEMBER_USER_LNAME,
     AGREEMENT_ID,
     AGREEMENT_TEXT,
     MEMBER_USER_AGREEMENT_DATETIME )
   values
   ( @MemberUserId,
     @MemberUserFName,
     @MemberUserLName,
     @AgreementId,
     @AgreementText,
     @AgreementDateTime )

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* Set the value of the new primary key to return. */
   select @MemberUserAgreementId = @@Identity

   /* If there was an error... */
   if ( @@Error <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spAddCustomerToProviderSystem' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spAddCustomerToProviderSystem

   go

create procedure spAddCustomerToProviderSystem( @ProviderCustomerId        integer,
                                                @ProviderSystemId          integer,
                                                @ProviderCustomerServiceId integer output ) as

   declare @ReturnCode integer /* Result code returned by the execution of the stored procedure */

   execute @ReturnCode = spInsertProviderCustomerService @ProviderCustomerId,
                                                         @ProviderSystemId,
                                                         @ProviderCustomerServiceId output

    /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spAddCustomerUnitToProviderGroup' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spAddCustomerUnitToProviderGroup

   go

create procedure spAddCustomerUnitToProviderGroup( @MemberGroupId  integer,
                                                   @CustomerUnitId integer ) as

   declare @ReturnCode integer /* Result code returned by the execution of the stored procedure */

   execute @ReturnCode = spInsertJoinMemberGroupCustomerUnit @MemberGroupId,
                                                             @CustomerUnitId

    /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spAddCustomerUserToCustomerGroup' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spAddCustomerUserToCustomerGroup

   go

create procedure spAddCustomerUserToCustomerGroup( @MemberUserId  integer,
                                                   @MemberGroupId integer ) as

   declare @ReturnCode integer /* Result code returned by the execution of the stored procedure */

   -- new stored procedure
   execute @ReturnCode = spInsertJoinMemberGroupUser @MemberGroupId,
                                                     @MemberUserId

    /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end


   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spAddNewCustomerAndUnitToProviderSystemAndGroup' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spAddNewCustomerAndUnitToProviderSystemAndGroup

   go

create procedure spAddNewCustomerAndUnitToProviderSystemAndGroup( @CustomerName       varchar(100),
                                                                  @ProviderId         integer,
                                                                  @ProviderSystemId   integer,
                                                                  @CustomerUnitName   varchar(100),
                                                                  @CustomerUnitNumber varchar(50),
                                                                  @MemberGroupId      integer ) as

   declare @ErrorCode                 integer      /* Error code returned by the execution of the last statement    */
   declare @RowsAffected              integer      /* Number of rows affected by the previously executed statement  */
   declare @Transactions              integer      /* Number of active transactions at the start of this procedure  */
   declare @ReturnCode                integer      /* Result code returned by the execution of the stored procedure */
   declare @MemberTypeId              integer      /* Identifier for the customer member type                       */
   declare @CustomerId                integer      /* Identifier for the new customer                               */
   declare @ProviderCustomerId        integer      /* Identifier for the new provider customer association          */
   declare @ProviderCustomerServiceId integer      /* Identifier for the new provider customer service association  */
   declare @CustomerUnitId            integer      /* Identifier for the new customer unit (property)               */
   declare @BarCodeCount              integer      /* Number of barcodes that match the passed customer unit number */
   declare @CustomerUnitTypeId        integer      /* Identifier for the type of the customer unit being created    */
   declare @UnitParentId              integer      /* Parent identifier for the new customer unit                   */
   declare @InstallDate               datetime /* Current system date and time used for the unit installation   */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /*=========================================================================*/
   /*============================= Insert Customer ===========================*/
   /*=========================================================================*/

   /* Set the member type for a customer. */
   set @MemberTypeId = 02

   /* Insert a new row in the member table for the customer. */
   execute @ReturnCode = spInsertMember @MemberTypeId,
                                        @CustomerName,
                                        @CustomerId output

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   /*=========================================================================*/
   /*================== Insert Provider Customer Association =================*/
   /*=========================================================================*/

   /* Insert a new row in the provider customer table to associate the
      customer with the passed provider. */
   execute @ReturnCode = spInsertProviderCustomer @ProviderId,
                                                  @CustomerId,
                                                  @ProviderCustomerId output

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   /*=========================================================================*/
   /*========== Insert Provider Customer Service Program Association =========*/
   /*=========================================================================*/

   /* Insert a new row in the provider customer service table to associate the
      customer with the passed provider service program. */
   execute @ReturnCode = spInsertProviderCustomerService @ProviderCustomerId,
                                                         @ProviderSystemId,
                                                         @ProviderCustomerServiceId output

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   /*=========================================================================*/
   /*================ Validate Customer Unit Number (Barcode) ================*/
   /*=========================================================================*/

   /* If a customer unit number (barcode identifier) has been specified by the
      user... */
   if ( @CustomerUnitNumber is not null ) begin

      /* Execute the stored procedure that verifies that the passed barcode
         identifier is uniquie for the new customer. */
      execute spGetCustomerUnitBarCodeIdIsUniqueByCustomer @CustomerId,
                                                           @CustomerUnitNumber,
                                                           null,
                                                           @BarCodeCount output

      /* If there was an error... */
      if ( @@Error <> 00 ) begin

         /* Rollback the transaction. */
         rollback transaction

         /* Return the failure. */
         return 01

      end

      /* If the specified unit barcode identifier is not unique... */
      if ( @BarCodeCount > 00 ) begin

         /* Rollback the transaction. */
         rollback transaction

         /* Return the failure. */
         return 01

      end

   end

   /*=========================================================================*/
   /*================= Insert Parent Customer Unit (Property) ================*/
   /*=========================================================================*/

   /* Set the unit parent for the new unit. */
   set @UnitParentId = -1

   /* Set the date of installation for the new unit as the current system date
      and time. */
   set @InstallDate = GetDate()

   /* Insert a new row in the customer unit table for the parent customer unit
      (property). */
   execute @ReturnCode = spInsertCustomerUnit @CustomerId,
                                              @CustomerUnitName,
                                              @CustomerUnitNumber,
                                              @UnitParentId,
                                              @InstallDate,
                                              @CustomerUnitId output

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   /*=========================================================================*/
   /*======== Get Service Program Parent Customer Unit Type (Property) =======*/
   /*=========================================================================*/

   /* Get the customer unit type identifier for the parent unit type in the
      passed service program.  Currently, a service program can have only one
      parent unit type.  If this changes, then this value will have to be
      specified by the user and passed to this stored procedure. */
   select @CustomerUnitTypeId = CUSTOMER_UNIT_TYPE_ID
   from CUSTOMER_UNIT_TYPE a
   where PROVIDER_SYSTEM_ID           = @ProviderSystemId and
         CUSTOMER_UNIT_TYPE_PARENT_ID = -1

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /*=========================================================================*/
   /*============ Insert Customer Unit Service Program Association ===========*/
   /*=========================================================================*/

   /* Insert a new row in the customer unit type customer unit table to
      associate the customer unit with the parent customer unit type which will
      also associate it with the passed provider service program. */
   execute @ReturnCode = spInsertJoinCustomerUnitTypeCustomerUnit @CustomerUnitTypeId,
                                                                  @CustomerUnitId,
                                                                  null

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   /*=========================================================================*/
   /*========== Insert Default Child Service Program Customer Units ==========*/
   /*=========================================================================*/

   /* Execute the stored procedure that will generate child units for all of the
      default units defined in the associated service program. */
   execute @ReturnCode = spCreateNewCustomerUnitsByParentType @CustomerUnitTypeId,
                                                              @CustomerUnitId,
                                                              @CustomerId

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   /*=========================================================================*/
   /*======== Insert Parent Customer Unit (Property) Group Association =======*/
   /*=========================================================================*/

   /* Insert a new row in the member group customer unit table to associate the
      customer unit with the passed provider group (route or branch). */
   execute @ReturnCode = spInsertJoinMemberGroupCustomerUnit @MemberGroupId,
                                                             @CustomerUnitId

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spAddNewCustomerUnitToProviderSystemAndGroup' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spAddNewCustomerUnitToProviderSystemAndGroup

   go

create procedure spAddNewCustomerUnitToProviderSystemAndGroup( @CustomerId         integer,
                                                               @ProviderSystemId   integer,
                                                               @CustomerUnitName   varchar(100),
                                                               @CustomerUnitNumber varchar(50),
                                                               @MemberGroupId      integer ) as

   declare @ErrorCode          integer      /* Error code returned by the execution of the last statement    */
   declare @RowsAffected       integer      /* Number of rows affected by the previously executed statement  */
   declare @Transactions       integer      /* Number of active transactions at the start of this procedure  */
   declare @ReturnCode         integer      /* Result code returned by the execution of the stored procedure */
   declare @CustomerUnitId     integer      /* Identifier for the new customer unit (property)               */
   declare @BarCodeCount       integer      /* Number of barcodes that match the passed customer unit number */
   declare @CustomerUnitTypeId integer      /* Identifier for the type of the customer unit being created    */
   declare @UnitParentId       integer      /* Parent identifier for the new customer unit                   */
   declare @InstallDate        datetime /* Current system date and time used for the unit installation   */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /*=========================================================================*/
   /*================ Validate Customer Unit Number (Barcode) ================*/
   /*=========================================================================*/

   /* If a customer unit number (barcode identifier) has been specified by the
      user... */
   if ( @CustomerUnitNumber is not null ) begin

      /* Execute the stored procedure that verifies that the passed barcode
         identifier is uniquie for the new customer. */
      execute spGetCustomerUnitBarCodeIdIsUniqueByCustomer @CustomerId,
                                                           @CustomerUnitNumber,
                                                           null,
                                                           @BarCodeCount output

      /* If there was an error... */
      if ( @@Error <> 00 ) begin

         /* Rollback the transaction. */
         rollback transaction

         /* Return the failure. */
         return 01

      end

      /* If the specified unit barcode identifier is not unique... */
      if ( @BarCodeCount > 00 ) begin

         /* Rollback the transaction. */
         rollback transaction

         /* Return the failure. */
         return 01

      end

   end

   /*=========================================================================*/
   /*================= Insert Parent Customer Unit (Property) ================*/
   /*=========================================================================*/

   /* Set the unit parent for the new unit. */
   set @UnitParentId = -1

   /* Set the date of installation for the new unit as the current system date
      and time. */
   set @InstallDate = GetDate()

   /* Insert a new row in the customer unit table for the parent customer unit
      (property). */
   execute @ReturnCode = spInsertCustomerUnit @CustomerId,
                                              @CustomerUnitName,
                                              @CustomerUnitNumber,
                                              @UnitParentId,
                                              @InstallDate,
                                              @CustomerUnitId output

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   /*=========================================================================*/
   /*======== Get Service Program Parent Customer Unit Type (Property) =======*/
   /*=========================================================================*/

   /* Get the customer unit type identifier for the parent unit type in the
      passed service program.  Currently, a service program can have only one
      parent unit type.  If this changes, then this value will have to be
      specified by the user and passed to this stored procedure. */
   select @CustomerUnitTypeId = CUSTOMER_UNIT_TYPE_ID
   from CUSTOMER_UNIT_TYPE a
   where PROVIDER_SYSTEM_ID           = @ProviderSystemId and
         CUSTOMER_UNIT_TYPE_PARENT_ID = -1

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /*=========================================================================*/
   /*============ Insert Customer Unit Service Program Association ===========*/
   /*=========================================================================*/

   /* Insert a new row in the customer unit type customer unit table to
      associate the customer unit with the parent customer unit type which will
      also associate it with the passed provider service program. */
   execute @ReturnCode = spInsertJoinCustomerUnitTypeCustomerUnit @CustomerUnitTypeId,
                                                                  @CustomerUnitId,
                                                                  null

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   /*=========================================================================*/
   /*========== Insert Default Child Service Program Customer Units ==========*/
   /*=========================================================================*/

   /* Execute the stored procedure that will generate child units for all of the
      default units defined in the associated service program. */
   execute @ReturnCode = spCreateNewCustomerUnitsByParentType @CustomerUnitTypeId,
                                                              @CustomerUnitId,
                                                              @CustomerId

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   /*=========================================================================*/
   /*======== Insert Parent Customer Unit (Property) Group Association =======*/
   /*=========================================================================*/

   /* Insert a new row in the member group customer unit table to associate the
      customer unit with the passed provider group (route or branch). */
   execute @ReturnCode = spInsertJoinMemberGroupCustomerUnit @MemberGroupId,
                                                             @CustomerUnitId

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spAddParentUnitToSystem' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spAddParentUnitToSystem

   go

create procedure spAddParentUnitToSystem( @CustomerId         integer,
                                          @CustomerUnitTypeId integer,
                                          @CustomerUnitId     integer ) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */
   declare @Transactions       integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   execute @ReturnCode = spInsertJoinCustomerUnitTypeCustomerUnit @CustomerUnitTypeId,
                                                                  @CustomerUnitId,
                                                                  null

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   -- new stored proc
   execute @ReturnCode = spCreateNewCustomerUnitsByParentType @CustomerUnitTypeId,
                                                              @CustomerUnitId,
                                                              @CustomerId

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spAddProviderGroupToProviderUser' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spAddProviderGroupToProviderUser

   go

create procedure spAddProviderGroupToProviderUser( @MemberUserId  integer,
                                                   @MemberGroupId integer ) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   -- new procedure
   execute @ReturnCode = spInsertJoinMemberGroupUser @MemberGroupId,
                                                     @MemberUserId

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spChangeProviderUserSecurityGroup' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spChangeProviderUserSecurityGroup

   go

create procedure spChangeProviderUserSecurityGroup as
-- may not be used

   --spDeleteJoinMemberUserSecurityGroup
   --spInsertJoinMemberUserSecurityGroup

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spCreateBarcodingProviderAccount' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spCreateBarcodingProviderAccount

   go

create procedure spCreateBarcodingProviderAccount( @ProviderName varchar(50),
                                                   @FirstName    varchar(25),
                                                   @LastName     varchar(25),
                                                   @UserName     varchar(50),
                                                   @Password     varchar(15),
                                                   @UserEmail    varchar(50) ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement    */
   declare @RowsAffected integer /* Number of rows affected by the previously executed statement  */
   declare @ReturnCode   integer /* Result code returned by the execution of the stored procedure */
   declare @ProviderId   integer /* Identifier for the new provider                               */
   declare @UserId       integer /* Identifier for the new provider user                          */
   declare @Transactions integer /* Number of active transactions at the start of this procedure  */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Insert a new row in the member table for the provider. */
   insert into MEMBER
   ( MEMBER_TYPE_ID,
     MEMBER_NAME )
   values
   ( 07,
     @ProviderName )

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* Set the value of the new primary key for the provider. */
   select @ProviderId = @@Identity

   /* If there was an error... */
   if ( @@Error <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* Insert a new row in the member user table for the administrative provider
      user. */
   insert into MEMBER_USER
   ( MEMBER_ID,
     MEMBER_USER_NAME,
     MEMBER_USER_PWD,
     MEMBER_USER_FNAME,
     MEMBER_USER_LNAME,
     MEMBER_USER_EMAIL )
   values
   ( @ProviderId,
     @UserName,
     @Password,
     @FirstName,
     @LastName,
     @UserEmail )

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction


      /* Return the failure. */
      return 01

   end

   /* Set the value of the new primary key for the provider user. */
   select @UserId = @@Identity

   /* If there was an error... */
   if ( @@Error <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* Insert a new row in the table that joins the provider user to the
      security group that makes them the administrator for their account. */
   insert into JOIN_MEMBER_USER_SECURITY_GROUP
   ( MEMBER_USER_ID,
     SECURITY_GROUP_ID )
   values
   ( @UserId,
     13 )

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* Insert a new row in the table that joins the provider to the templates
      that they can use to configure their service programs. */
   insert JOIN_PROVIDER_TEMPLATE_PROVIDER_SYSTEM
   ( TEMPLATE_PROVIDER_SYSTEM_ID,
     PROVIDER_ID )
   values
   ( 1,
     @ProviderId )

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spCreateBasicProviderAccount' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spCreateBasicProviderAccount

   go

create procedure spCreateBasicProviderAccount( @ProviderName varchar(50),
                                               @FirstName    varchar(25),
                                               @LastName     varchar(25),
                                               @UserName     varchar(50),
                                               @Password     varchar(15),
                                               @UserEmail    varchar(50) ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement    */
   declare @RowsAffected integer /* Number of rows affected by the previously executed statement  */
   declare @ReturnCode   integer /* Result code returned by the execution of the stored procedure */
   declare @ProviderId   integer /* Identifier for the new provider                               */
   declare @UserId       integer /* Identifier for the new provider user                          */
   declare @Transactions integer /* Number of active transactions at the start of this procedure  */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Insert a new row in the member table for the provider. */
   insert into MEMBER
   ( MEMBER_TYPE_ID,
     MEMBER_NAME )
   values
   ( 01,
     @ProviderName )

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* Set the value of the new primary key for the provider. */
   select @ProviderId = @@Identity

   /* If there was an error... */
   if ( @@Error <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* Insert a new row in the member user table for the administrative provider
      user. */
   insert into MEMBER_USER
   ( MEMBER_ID,
     MEMBER_USER_NAME,
     MEMBER_USER_PWD,
     MEMBER_USER_FNAME,
     MEMBER_USER_LNAME,
     MEMBER_USER_EMAIL )
   values
   ( @ProviderId,
     @UserName,
     @Password,
     @FirstName,
     @LastName,
     @UserEmail )

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* Set the value of the new primary key for the provider user. */
   select @UserId = @@Identity

   /* If there was an error... */
   if ( @@Error <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* Insert a new row in the table that joins the provider user to the
      security group that makes them the administrator for their account. */
   insert into JOIN_MEMBER_USER_SECURITY_GROUP
   ( MEMBER_USER_ID,
     SECURITY_GROUP_ID )
   values
   ( @UserId,
     13 )

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* Insert a new row in the table that joins the provider to the templates
      that they can use to configure their service programs. */
   insert JOIN_PROVIDER_TEMPLATE_PROVIDER_SYSTEM
   ( TEMPLATE_PROVIDER_SYSTEM_ID,
     PROVIDER_ID )
   values
   ( 15,
     @ProviderId )

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* Insert a new row in the table that contains the provider group types that
      they can use to add units to their groups. */
   insert MEMBER_GROUP_TYPE
   ( MEMBER_GROUP_TYPE_NAME,
     MEMBER_ID )
   values
   ( 'Routes',
     @ProviderId )

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* Insert a new row in the table that contains the provider group types that
      they can use to add units to their groups. */
   insert MEMBER_GROUP_TYPE
   ( MEMBER_GROUP_TYPE_NAME,
     MEMBER_ID )
   values
   ( 'Branches',
     @ProviderId )

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* Generate the training service program along with its associaterd customer
      and parent unit from the specified training template. */
   execute @ReturnCode = spCreateTrainingProviderSystemCustomerUnit 12,
                                                                    @ProviderId,
                                                                    'Triple Js Restaurant',
                                                                    '101 Main Street',
                                                                    null

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spCreateLegacyProviderAccount' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spCreateLegacyProviderAccount

   go

create procedure spCreateLegacyProviderAccount( @ProviderName varchar(50),
                                                @FirstName    varchar(25),
                                                @LastName     varchar(25),
                                                @UserName     varchar(50),
                                                @Password     varchar(15),
                                                @UserEmail    varchar(50) ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement    */
   declare @RowsAffected integer /* Number of rows affected by the previously executed statement  */
   declare @ReturnCode   integer /* Result code returned by the execution of the stored procedure */
   declare @ProviderId   integer /* Identifier for the new provider                               */
   declare @UserId       integer /* Identifier for the new provider user                          */
   declare @Transactions integer /* Number of active transactions at the start of this procedure  */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Insert a new row in the member table for the provider. */
   insert into MEMBER
   ( MEMBER_TYPE_ID,
     MEMBER_NAME )
   values
   ( 01,
     @ProviderName )

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* Set the value of the new primary key for the provider. */
   select @ProviderId = @@Identity

   /* If there was an error... */
   if ( @@Error <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* Insert a new row in the member user table for the administrative provider
      user. */
   insert into MEMBER_USER
   ( MEMBER_ID,
     MEMBER_USER_NAME,
     MEMBER_USER_PWD,
     MEMBER_USER_FNAME,
     MEMBER_USER_LNAME,
     MEMBER_USER_EMAIL )
   values
   ( @ProviderId,
     @UserName,
     @Password,
     @FirstName,
     @LastName,
     @UserEmail )

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* Set the value of the new primary key for the provider user. */
   select @UserId = @@Identity

   /* If there was an error... */
   if ( @@Error <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* Insert a new row in the table that joins the provider user to the
      security group that makes them the administrator for their account. */
   insert into JOIN_MEMBER_USER_SECURITY_GROUP
   ( MEMBER_USER_ID,
     SECURITY_GROUP_ID )
   values
   ( @UserId,
     13 )

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* Insert a new row in the table that joins the provider to the templates
      that they can use to configure their service programs. */
   insert JOIN_PROVIDER_TEMPLATE_PROVIDER_SYSTEM
   ( TEMPLATE_PROVIDER_SYSTEM_ID,
     PROVIDER_ID )
   values
   ( 01,
     @ProviderId )

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* Insert a new row in the table that joins the provider to the templates
      that they can use to configure their service programs. */
   insert JOIN_PROVIDER_TEMPLATE_PROVIDER_SYSTEM
   ( TEMPLATE_PROVIDER_SYSTEM_ID,
     PROVIDER_ID )
   values
   ( 04,
     @ProviderId )

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* Insert a new row in the table that joins the provider to the templates
      that they can use to configure their service programs. */
   insert JOIN_PROVIDER_TEMPLATE_PROVIDER_SYSTEM
   ( TEMPLATE_PROVIDER_SYSTEM_ID,
     PROVIDER_ID )
   values
   ( 05,
     @ProviderId )

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* Insert a new row in the table that joins the provider to the templates
      that they can use to configure their service programs. */
   insert JOIN_PROVIDER_TEMPLATE_PROVIDER_SYSTEM
   ( TEMPLATE_PROVIDER_SYSTEM_ID,
     PROVIDER_ID )
   values
   ( 06,
     @ProviderId )

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* Insert a new row in the table that joins the provider to the templates
      that they can use to configure their service programs. */
   insert JOIN_PROVIDER_TEMPLATE_PROVIDER_SYSTEM
   ( TEMPLATE_PROVIDER_SYSTEM_ID,
     PROVIDER_ID )
   values
   ( 07,
     @ProviderId )

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* Insert a new row in the table that joins the provider to the templates
      that they can use to configure their service programs. */
   insert JOIN_PROVIDER_TEMPLATE_PROVIDER_SYSTEM
   ( TEMPLATE_PROVIDER_SYSTEM_ID,
     PROVIDER_ID )
   values
   ( 09,
     @ProviderId )

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* Insert a new row in the table that joins the provider to the templates
      that they can use to configure their service programs. */
   insert JOIN_PROVIDER_TEMPLATE_PROVIDER_SYSTEM
   ( TEMPLATE_PROVIDER_SYSTEM_ID,
     PROVIDER_ID )
   values
   ( 10,
     @ProviderId )

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* Insert a new row in the table that joins the provider to the templates
      that they can use to configure their service programs. */
   insert JOIN_PROVIDER_TEMPLATE_PROVIDER_SYSTEM
   ( TEMPLATE_PROVIDER_SYSTEM_ID,
     PROVIDER_ID )
   values
   ( 11,
     @ProviderId )

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* Insert a new row in the table that contains the provider group types that
      they can use to add units to their groups. */
   insert MEMBER_GROUP_TYPE
   ( MEMBER_GROUP_TYPE_NAME,
     MEMBER_ID )
   values
   ( 'Routes',
     @ProviderId )

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* Insert a new row in the table that contains the provider group types that
      they can use to add units to their groups. */
   insert MEMBER_GROUP_TYPE
   ( MEMBER_GROUP_TYPE_NAME,
     MEMBER_ID )
   values
   ( 'Branches',
     @ProviderId )

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* Generate the training service program along with its associaterd customer
      and parent unit from the specified training template. */
   execute @ReturnCode = spCreateTrainingProviderSystemCustomerUnit 12,
                                                                    @ProviderId,
                                                                    'Triple Js Restaurant',
                                                                    '101 Main Street',
                                                                    null

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spCreateNewComService' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spCreateNewComService

   go

create procedure spCreateNewComService( @ServiceDate    datetime,
                                        @CustomerUnitId integer,
                                        @ServiceTypeId  integer,
                                        @TechnicianId   integer,
                                        @TimeIn         datetime,
                                        @TimeOut        datetime,
                                        @Contact        varchar(25),
                                        @Comment        varchar(255),
                                        @InputUserId    integer,
                                        @InputDate      datetime,
                                        @ComServiceId   integer out ) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   execute @ReturnCode = spInsertComService @ServiceDate,
                                            @CustomerUnitId,
                                            @ServiceTypeId,
                                            @TimeIn,
                                            @TimeOut,
                                            @TechnicianId,
                                            @Contact,
                                            @Comment,
                                            @InputUserId,
                                            @InputDate,
                                            null,
                                            null,
                                            @ComServiceId output

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spCreateNewComServiceData' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spCreateNewComServiceData

   go

create procedure spCreateNewComServiceData( @ComServiceUnitValueId     integer,
                                            @ProviderServiceDataTypeId integer,
                                            @ProviderServiceDataId     integer,
                                            @ComServiceDataAltText     varchar(255),
                                            @RowId                     integer,
                                            @ComServiceDataId          integer out ) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   execute @ReturnCode = spInsertComServiceData @ComServiceUnitValueId,
                                                @ProviderServiceDataTypeId,
                                                @ProviderServiceDataId,
                                                @ComServiceDataAltText,
                                                @RowId,
                                                @ComServiceDataId output

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spCreateNewComServiceUnitValue' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spCreateNewComServiceUnitValue

   go

create procedure spCreateNewComServiceUnitValue(  @ComServiceId           integer,
                                                  @ProviderServiceValueId integer,
                                                  @CustomerUnitId         integer,
                                                  @Timestamp              datetime,
                                                  @ComServiceUnitValueId  integer out ) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   execute @ReturnCode = spInsertComServiceUnitValue @ComServiceId,
                                                     @ProviderServiceValueId,
                                                     @CustomerUnitId,
                                                     @Timestamp,
                                                     @ComServiceUnitValueId output

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spCreateNewContact' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spCreateNewContact

   go

create procedure spCreateNewContact( @ContactInfo   varchar(255),
                                     @EntityId      integer,
                                     @EntityTypeId  integer,
                                     @ContactTypeId integer ) as

   set nocount on

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement    */
   declare @RowsAffected integer /* Number of rows affected by the 
previously executed statement  */
   declare @Transactions integer /* Number of active transactions at the start of this procedure  */
   declare @ReturnCode   integer /* Result code returned by the execution of the stored procedure */
   declare @ContactId    integer /* Identifier to store CONTACT_ID when contact info is inserted  */
   declare @ContactCount integer /* Count of contact records for this ENTITY_ID/ENTITY_TYPE_ID    */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   select @ContactCount = count(*)
   from contact, contact_join
   where ( contact.contact_id          = contact_join.contact_id ) and
         ( contact_join.entity_id      = @EntityId               ) and
         ( contact_join.entity_type_id = @EntityTypeId           ) and
         ( contact.contact_type_id     = @ContactTypeId          )

   /* If the contact information for the passed entity does NOT already
      exist... */
   if ( @ContactCount < 1 ) begin

      /* If there was an error... */
      if ( @@Error <> 00 ) begin

         /* Rollback the transaction. */
         rollback transaction

         /* Return the failure. */
         return 01

      end

      /* Insert Contact_Info */
      execute @ReturnCode = spInsertContact @ContactTypeId,
                                            @ContactInfo,
                                            @ContactId output

      /* If there was an error... */
      if ( @ReturnCode <> 00 ) begin

         /* Return the failure. */
         return @ReturnCode

      end

      /* Insert Contact_Join */
      execute @ReturnCode = spInsertContactJoin @ContactId,
                                                @EntityId,
                                                @EntityTypeId, 00

      /* If there was an error... */
      if ( @ReturnCode <> 00 ) begin

         /* Return the failure. */
         return @ReturnCode

      end

   end

   else begin

      /* Get the identifier for the contact information for the passed
         entity.  We need this to update the contact information. */
      select @ContactId = contact.contact_id
      from contact, contact_join
      where ( contact.contact_id          = contact_join.contact_id ) and
            ( contact_join.entity_id      = @EntityId               ) and
            ( contact_join.entity_type_id = @EntityTypeId           ) and
            ( contact.contact_type_id     = @ContactTypeId          )

      /* Get the rows affected and the error code for the previous statement.
         Error checking MUST be done this way since any single statement executed
         will affect both of the global functions, @@RowCount and @@Error. */
      select @RowsAffected = @@RowCount, @ErrorCode = @@Error

      /* If there was an error... */
      if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

         /* Rollback the transaction. */
         rollback transaction

         /* Return the failure. */
         return 01

      end

      /* Update Contact_Info */
      execute @ReturnCode = spUpdateContact @ContactId,
                                            @ContactTypeId,
                                            @ContactInfo

      /* If there was an error... */
      if ( @ReturnCode <> 00 ) begin

         /* Return the failure. */
         return @ReturnCode

      end

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spCreateNewContactAddress1' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spCreateNewContactAddress1

   go

create procedure spCreateNewContactAddress1( @Address1     varchar(255),
                                             @EntityId     integer,
                                             @EntityTypeId integer ) as

   declare @Transactions integer /* Number of active transactions at the start of this procedure  */
   declare @ReturnCode   integer /* Result code returned by the execution of the stored procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Generate the new contact information. */
   execute @ReturnCode = spCreateNewContact @Address1,
                                            @EntityId,
                                            @EntityTypeId, 02

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spCreateNewContactAddress2' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spCreateNewContactAddress2

   go

create procedure spCreateNewContactAddress2( @Address2     varchar(255),
                                             @EntityId     integer,
                                             @EntityTypeId integer ) as

   declare @Transactions integer /* Number of active transactions at the start of this procedure  */
   declare @ReturnCode   integer /* Result code returned by the execution of the stored procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Generate the new contact information. */
   execute @ReturnCode = spCreateNewContact @Address2,
                                            @EntityId,
                                            @EntityTypeId, 03

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spCreateNewContactAddress3' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spCreateNewContactAddress3

   go

create procedure spCreateNewContactAddress3( @Address3     varchar(255),
                                             @EntityId     integer,
                                             @EntityTypeId integer ) as

   declare @Transactions integer /* Number of active transactions at the start of this procedure  */
   declare @ReturnCode   integer /* Result code returned by the execution of the stored procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Generate the new contact information. */
   execute @ReturnCode = spCreateNewContact @Address3,
                                            @EntityId,
                                            @EntityTypeId, 04

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spCreateNewContactCity' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spCreateNewContactCity

   go

create procedure spCreateNewContactCity( @City         varchar(255),
                                         @EntityId     integer,
                                         @EntityTypeId integer ) as

   declare @Transactions integer /* Number of active transactions at the start of this procedure  */
   declare @ReturnCode   integer /* Result code returned by the execution of the stored procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Generate the new contact information. */
   execute @ReturnCode = spCreateNewContact @City,
                                            @EntityId,
                                            @EntityTypeId, 05

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spCreateNewContactCountry' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spCreateNewContactCountry

   go

create procedure spCreateNewContactCountry( @Country      varchar(255),
                                            @EntityId     integer,
                                            @EntityTypeId integer ) as

   declare @Transactions integer /* Number of active transactions at the start of this procedure  */
   declare @ReturnCode   integer /* Result code returned by the execution of the stored procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Generate the new contact information. */
   execute @ReturnCode = spCreateNewContact @Country,
                                            @EntityId,
                                            @EntityTypeId, 13

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spCreateNewContactEmail' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spCreateNewContactEmail

   go

create procedure spCreateNewContactEmail( @Email        varchar(255),
                                          @EntityId     integer,
                                          @EntityTypeId integer ) as

   declare @Transactions integer /* Number of active transactions at the start of this procedure  */
   declare @ReturnCode   integer /* Result code returned by the execution of the stored procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Generate the new contact information. */
   execute @ReturnCode = spCreateNewContact @Email,
                                            @EntityId,
                                            @EntityTypeId, 12

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spCreateNewContactFax' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spCreateNewContactFax

   go

create procedure spCreateNewContactFax( @Fax          varchar(255),
                                        @EntityId     integer,
                                        @EntityTypeId integer ) as

   declare @Transactions integer /* Number of active transactions at the start of this procedure  */
   declare @ReturnCode   integer /* Result code returned by the execution of the stored procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Generate the new contact information. */
   execute @ReturnCode = spCreateNewContact @Fax,
                                            @EntityId,
                                            @EntityTypeId, 09

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spCreateNewContactMobile' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spCreateNewContactMobile

   go

create procedure spCreateNewContactMobile( @Mobile       varchar(255),
                                           @EntityId     integer,
                                           @EntityTypeId integer ) as

   declare @Transactions integer /* Number of active transactions at the start of this procedure  */
   declare @ReturnCode   integer /* Result code returned by the execution of the stored procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Generate the new contact information. */
   execute @ReturnCode = spCreateNewContact @Mobile,
                                            @EntityId,
                                            @EntityTypeId, 10

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spCreateNewContactPager' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spCreateNewContactPager

   go

create procedure spCreateNewContactPager( @Pager        varchar(255),
                                          @EntityId     integer,
                                          @EntityTypeId integer ) as

   declare @Transactions integer /* Number of active transactions at the start of this procedure  */
   declare @ReturnCode   integer /* Result code returned by the execution of the stored procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Generate the new contact information. */
   execute @ReturnCode = spCreateNewContact @Pager,
                                            @EntityId,
                                            @EntityTypeId, 11

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spCreateNewContactPhone' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spCreateNewContactPhone

   go

create procedure spCreateNewContactPhone( @Phone        varchar(255),
                                          @EntityId     integer,
                                          @EntityTypeId integer ) as

   declare @Transactions integer /* Number of active transactions at the start of this procedure  */
   declare @ReturnCode   integer /* Result code returned by the execution of the stored procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Generate the new contact information. */
   execute @ReturnCode = spCreateNewContact @Phone,
                                            @EntityId,
                                            @EntityTypeId, 08

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spCreateNewContactState' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spCreateNewContactState

   go

create procedure spCreateNewContactState( @State        varchar(255),
                                          @EntityId     integer,
                                          @EntityTypeId integer ) as

   declare @Transactions integer /* Number of active transactions at the start of this procedure  */
   declare @ReturnCode   integer /* Result code returned by the execution of the stored procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Generate the new contact information. */
   execute @ReturnCode = spCreateNewContact @State,
                                            @EntityId,
                                            @EntityTypeId, 06

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spCreateNewContactTitle' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spCreateNewContactTitle

   go

create procedure spCreateNewContactTitle( @Title        varchar(255),
                                          @EntityId     integer,
                                          @EntityTypeId integer ) as

   declare @Transactions integer /* Number of active transactions at the start of this procedure  */
   declare @ReturnCode   integer /* Result code returned by the execution of the stored procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Generate the new contact information. */
   execute @ReturnCode = spCreateNewContact @Title,
                                            @EntityId,
                                            @EntityTypeId, 01

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spCreateNewContactWebMessage' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spCreateNewContactWebMessage

   go

create procedure spCreateNewContactWebMessage( @WebMessage   varchar(255),
                                               @EntityId     integer,
                                               @EntityTypeId integer ) as

   declare @Transactions integer /* Number of active transactions at the start of this procedure  */
   declare @ReturnCode   integer /* Result code returned by the execution of the stored procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Generate the new contact information. */
   execute @ReturnCode = spCreateNewContact @WebMessage,
                                            @EntityId,
                                            @EntityTypeId, 14

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spCreateNewContactZip' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spCreateNewContactZip

   go

create procedure spCreateNewContactZip( @Zip          varchar(255),

                                        @EntityId     integer,
                                        @EntityTypeId integer ) as

   declare @Transactions integer /* Number of active transactions at the start of this procedure  */
   declare @ReturnCode   integer /* Result code returned by the execution of the stored procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Generate the new contact information. */
   execute @ReturnCode = spCreateNewContact @Zip,
                                            @EntityId,
                                            @EntityTypeId, 07

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spCreateNewCustomer' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spCreateNewCustomer

   go

create procedure spCreateNewCustomer( @ProviderId         integer,
                                      @CustomerName       varchar(100),
									  @CustomerId         integer output,
									  @ProviderCustomerId integer output ) as

   declare @Transactions       integer /* Number of active transactions at the start of this procedure */
   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   execute @ReturnCode = spInsertMember 2,
                                        @CustomerName,
                                        @CustomerId output

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   execute @ReturnCode = spInsertProviderCustomer @ProviderId,
                                                  @CustomerId,
                                                  @ProviderCustomerId output

    /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spCreateNewCustomerContactInfo' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spCreateNewCustomerContactInfo

   go

create procedure spCreateNewCustomerContactInfo( @CustomerId    integer,
                                                 @ContactTypeId integer,
                                                 @ContactInfo   varchar(255),
                                                 @ContactId     integer output,
                                                 @ContactJoinId integer output ) as

   declare @Transactions       integer /* Number of active transactions at the start of this procedure */
   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   execute @ReturnCode = spInsertContact @ContactTypeId,
                                         @ContactInfo,
                                         @ContactId output
   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   execute @ReturnCode = spInsertContactJoin @ContactId,
                                             @CustomerId,
                                             4,
                                             @ContactJoinId output

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spCreateNewCustomerGroup' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spCreateNewCustomerGroup

   go

create procedure spCreateNewCustomerGroup( @CustomerGroupTypeId integer,
                                           @CustomerGroupName   varchar(50),
										   @CustomerGroupId     integer output ) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   execute @ReturnCode = spInsertMemberGroup @CustomerGroupTypeId, @CustomerGroupName, @CustomerGroupId output

    /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spCreateNewCustomerGroupType' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spCreateNewCustomerGroupType

   go

create procedure spCreateNewCustomerGroupType( @CustomerId            integer,
                                               @CustomerGroupTypeName varchar(50),
											   @CustomerGroupTypeId   integer output ) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

    -- new stored procedure
   execute @ReturnCode = spInsertMemberGroupType @CustomerGroupTypeName, @CustomerId, @CustomerGroupTypeId output

    /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spCreateNewCustomerSubUnit' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spCreateNewCustomerSubUnit

   go

create procedure spCreateNewCustomerSubUnit( @CustomerId         integer,
                                             @CustomerUnitName   varchar(100),
                                             @CustomerUnitNumber varchar(50),
                                             @UnitParentId       integer,
                                             @CustomerUnitTypeId integer,
                                             @CustomerUnitNameId integer,
                                             @CustomerUnitId     integer output ) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   execute @ReturnCode = spInsertCustomerSubUnit @CustomerId,
                                                 @CustomerUnitName,
                                                 @CustomerUnitNumber,
                                                 @UnitParentId,
                                                 @CustomerUnitTypeId,
                                                 @CustomerUnitNameId,
                                                 @CustomerUnitId output

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spCreateNewCustomerUnit' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spCreateNewCustomerUnit


   go

create procedure spCreateNewCustomerUnit( @CustomerId         integer,
                                          @CustomerUnitName   varchar(100),
                                          @CustomerUnitNumber varchar(50),
                                          @CustomerUnitTypeId integer,
                                          @CustomerUnitNameId integer,
                                          @UnitParentId       integer,
                                          @InstallDate        datetime,
                                          @CustomerUnitId     integer out ) as

   declare @Transactions       integer /* Number of active transactions at the start of this procedure */
   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   execute @ReturnCode = spInsertCustomerUnit @CustomerId,
                                              @CustomerUnitName,
                                              @CustomerUnitNumber,
                                              @UnitParentId,
                                              @InstallDate,
                                              @CustomerUnitId output

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   if @CustomerUnitTypeId <> null begin
      execute @ReturnCode = spInsertJoinCustomerUnitTypeCustomerUnit @CustomerUnitTypeId,
                                                                     @CustomerUnitId,
                                                                     @CustomerUnitNameId

      /* If there was an error... */
      if ( @ReturnCode <> 00 ) begin

         /* Return the failure. */
         return @ReturnCode

      end

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spCreateNewCustomerUnitContactInfo' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spCreateNewCustomerUnitContactInfo

   go

create procedure spCreateNewCustomerUnitContactInfo( @CustomerUnitId            integer,
                                                     @ContactTypeId             integer,
                                                     @ContactInfo               varchar(255),
                                                     @CustomerUnitContactId     integer out,
                                                     @CustomerUnitContactJoinId integer out ) as

   declare @Transactions              integer /* Number of active transactions at the start of this procedure */
   declare @ReturnCode                integer /* Result code returned by the execution of the stored procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   execute @ReturnCode = spInsertContact @ContactTypeId,
                                         @ContactInfo,
                                         @CustomerUnitContactId output

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   execute @ReturnCode = spInsertContactJoin @CustomerUnitContactId,
                                             @CustomerUnitId,
                                             5,
                                             @CustomerUnitContactJoinId output

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

    /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spCreateNewCustomerUnitLayoutImage' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spCreateNewCustomerUnitLayoutImage

   go

create procedure spCreateNewCustomerUnitLayoutImage( @CustomerUnitId            integer,
                                                     @CustomerUnitLayoutImage   text,
                                                     @CustomerUnitLayoutImageId integer output ) as

   declare @Transactions integer /* Number of active transactions at the start of this procedure  */
   declare @ReturnCode   integer /* Result code returned by the execution of the stored procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Generate the new customer unit layout image. */
   execute @ReturnCode = spInsertCustomerUnitLayoutImage @CustomerUnitId,
                                                         @CustomerUnitLayoutImage,
                                                         @CustomerUnitLayoutImageId output

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spCreateNewCustomerUnitName' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spCreateNewCustomerUnitName

   go

create procedure spCreateNewCustomerUnitName( @CustomerUnitTypeId                 integer,
                                              @TemplateProviderCustomerUnitNameId integer,
                                              @CustomerUnitName                   varchar(50),
                                              @CustomerUnitNumber                 varchar(10),
                                              @CustomerUnitNameId                 integer out ) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   -- new procedure
   execute @ReturnCode = spInsertCustomerUnitName @CustomerUnitTypeId,
                                                  @CustomerUnitName,
                                                  @CustomerUnitNumber,
                                                  @TemplateProviderCustomerUnitNameId,
                                                  @CustomerUnitNameId output

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spCreateNewCustomerUnitsByParentType' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spCreateNewCustomerUnitsByParentType

   go

create procedure spCreateNewCustomerUnitsByParentType( @ParentTypeId integer,
                                                       @ParentUnitId integer,
                                                       @CustomerId   integer ) as

   /* This stored procedure is called recursively when a parent customer unit
      (property) is added to an existing service program.  It receives the
      identifier for the parent unit, its unit type, and the identifier for the
      customer who owns the unit.  It creates all of the default units defined
      when the target service program was created.  It is important to note
      that the parent unit must exist and it must already be part of the target
      service program for this procedure to perform its processing correctly. */

   declare @ErrorCode    integer      /* Error code returned by the execution of the last statement    */
   declare @RowsAffected integer      /* Number of rows affected by the previously executed statement  */
   declare @Transactions integer      /* Number of active transactions at the start of this procedure  */
   declare @ReturnCode   integer      /* Result code returned by the execution of the stored procedure */
   declare @UnitTypeId   integer      /* Current identifier for the service program customer unit type */
   declare @UnitNameId   integer      /* Current identifier for the service program customer unit name */
   declare @UnitId       integer      /* Identifier for the new unit created for the service program   */
   declare @InstallDate  datetime /* Current system date and time used for the unit installation   */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Declare a cursor to iterate over all of the child unit types and unit
      names (default units) for the  passed parent unit type.  This will return
      all of the immediate children of the of the passed parent unit type. */
   declare UnitTypesCursor cursor local for
      select cut.CUSTOMER_UNIT_TYPE_ID,
             cun.CUSTOMER_UNIT_NAME_ID
      from CUSTOMER_UNIT_TYPE cut,
           CUSTOMER_UNIT_NAME cun
      where cut.CUSTOMER_UNIT_TYPE_ID        = cun.CUSTOMER_UNIT_TYPE_ID and
            cut.CUSTOMER_UNIT_TYPE_PARENT_ID = @ParentTypeId

      /* If there was an error... */
      if ( @@Error <> 00 ) begin

         /* Rollback the transaction. */
         rollback transaction

         /* Return the failure. */
         return 01

      end

   /* Open the cursor and return the result set. */
   open UnitTypesCursor

   /* Get the first row from the cursor and place the identifiers for the
      current customer unit type and customer unit name (default unit) in the
      local variables. */
   fetch next from UnitTypesCursor into @UnitTypeId, @UnitNameId

   /* While there are still customer unit types to process... */
   while ( @@Fetch_Status = 00 ) begin

      /* If there are no child units for the passed parent unit identifier,
         customer identifier, and the current unit type and unit name from the
         cursor... */
      if not exists ( select *
                      from JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT jcutcu,
                           CUSTOMER_UNIT cu
                      where jcutcu.CUSTOMER_UNIT_ID      = cu.CUSTOMER_UNIT_ID and
                            cu.UNIT_PARENT_ID            = @ParentUnitId       and
                            cu.CUSTOMER_ID               = @CustomerId         and
                            jcutcu.CUSTOMER_UNIT_TYPE_ID = @UnitTypeId         and
                            jcutcu.CUSTOMER_UNIT_NAME_ID = @UnitNameId ) begin

         /* If there was an error... */
         if ( @@Error <> 00 ) begin

            /* Rollback the transaction. */
            rollback transaction

            /* Return the failure. */
            return 01

         end

         /* Set the date of installation for the new unit as the current system
            date and time. */
         set @InstallDate = GetDate()

         /* Insert a new child unit making the passed parent unit its parent. */
         execute @ReturnCode = spInsertCustomerUnit @CustomerId,
                                                    null, null,
                                                    @ParentUnitId,
                                                    @InstallDate,
                                                    @UnitId output, 00

         /* If there was an error... */
         if ( @ReturnCode <> 00 ) begin

            /* Return the failure. */
            return @ReturnCode

         end

         /* Insert a row in the join table that will associate the new unit to
            the current customer unit type and customer unit name which will
            make it part of the service program. */
         execute @ReturnCode = spInsertJoinCustomerUnitTypeCustomerUnit @UnitTypeId,
                                                                        @UnitId,
                                                                        @UnitNameId

         /* If there was an error... */
         if ( @ReturnCode <> 00 ) begin

            /* Return the failure. */
            return @ReturnCode

         end

         /* Recursively execute this stored procedure in order to cascade
            through all of the child customer unit types for the current
            cuatomer unit type in the cursor.  This will append all of the
            child, grandchild, etc. default customer units defined in the
            service program as part of the customer unit type and customer
            unit name structure. */
         execute @ReturnCode = spCreateNewCustomerUnitsByParentType @UnitTypeId,
                                                                    @UnitId,
                                                                    @CustomerId

         /* If there was an error... */
         if ( @ReturnCode <> 00 ) begin

            /* Return the failure. */
            return @ReturnCode

         end

      end

      /* Get the next row from the cursor and place the identifiers for the
         current customer unit type and customer unit name (default unit) in
         the local variables. */
      fetch next from UnitTypesCursor into @UnitTypeId, @UnitNameId

   end

   /* Close the cursor and release the result set. */
   close UnitTypesCursor

   /* Release the resources allocated for the cursor. */
   deallocate UnitTypesCursor

   /* If there was an error... */
   if ( @@Error <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spCreateNewCustomerUnitType' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spCreateNewCustomerUnitType

   go

create procedure spCreateNewCustomerUnitType( @ProviderSystemId                   integer,
                                              @TemplateProviderCustomerUnitTypeId integer,
                                              @UnitTypeParentId                   integer,
                                              @CustomerUnitTypeName               varchar(50),
                                              @CustomerUnitTypeId                 integer output ) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   -- new procedure
   execute @ReturnCode = spInsertCustomerUnitType @ProviderSystemId,
                                                  @CustomerUnitTypeName,
                                                  @UnitTypeParentId,
                                                  @TemplateProviderCustomerUnitTypeId,
                                                  @CustomerUnitTypeId output

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spCreateNewCustomerUser' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spCreateNewCustomerUser

   go

create procedure spCreateNewCustomerUser(  @CustomerId       integer,
                                           @UserName         varchar(50),
                                           @Password         varchar(15),
                                           @FirstName        varchar(25),
                                           @LastName         varchar(25),
                                           @LastLogin        datetime,
                                           @Email            varchar(50),
                                           @SecurityGroupId  integer,
                                           @CustomerUserId   integer out ) as

   declare @Transactions       integer /* Number of active transactions at the start of this procedure */
   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   execute @ReturnCode = spInsertMemberUser @CustomerId,
                                            @UserName,
                                            @Password,
                                            @FirstName,
                                            @LastName,
                                            @LastLogin,
                                            @Email,
                                            @CustomerUserId output

    /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   if @SecurityGroupId > 00 begin
      execute spInsertJoinMemberUserSecurityGroup @CustomerUserId,
                                                  @SecurityGroupId

      /* If there was an error... */
      if ( @ReturnCode <> 00 ) begin

         /* Return the failure. */
         return @ReturnCode

      end

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spCreateNewCustomerUserContactInfo' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spCreateNewCustomerUserContactInfo

   go

create procedure spCreateNewCustomerUserContactInfo( @CustomerUserId            integer,
                                                     @ContactTypeId             integer,
                                                     @ContactInfo               varchar(255),
                                                     @CustomerUserContactId     integer out,
                                                     @CustomerUserContactJoinId integer out ) as

   declare @Transactions       integer /* Number of active transactions at the start of this procedure */
   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   execute @ReturnCode = spInsertContact @ContactTypeId,
                                         @ContactInfo,
                                         @CustomerUserContactId output

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   execute @ReturnCode = spInsertContactJoin @CustomerUserContactId,
                                             @CustomerUserId,
                                             2,
                                             @CustomerUserContactJoinId output

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spCreateNewMappingEntityByInterfaceIdEntityType' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spCreateNewMappingEntityByInterfaceIdEntityType

   go

create procedure spCreateNewMappingEntityByInterfaceIdEntityType( @InterfaceId     integer,
                                                                  @EntityType      varchar(50),
                                                                  @EntityId        integer,
                                                                  @ForeignId       varchar(50),
                                                                  @ForeignType     varchar(50),
                                                                  @MappingEntityId integer output ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement    */
   declare @RowsAffected integer /* Number of rows affected by the previously executed statement  */
   declare @Transactions integer /* Number of active transactions at the start of this procedure  */
   declare @ReturnCode   integer /* Result code returned by the execution of the stored procedure */
   declare @EntityTypeId integer /* The Entity Type identifier for the @EnityType parameter       */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Get the identifier for the passed entity type string. */
   select @EntityTypeId = ENTITY_TYPE_ID
   from ENTITY_TYPE
   where ENTITY_TYPE = @EntityType

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* Execute the stored procedure that will perform the actual insert of the
      row into the mapping table if it does not already exist.  This will
      associate the foreign data to the associated data in the native database. */
   execute @ReturnCode = spCreateNewMappingEntityByInterfaceIdEntityTypeId @InterfaceId,
                                                                           @EntityId,
                                                                           @EntityTypeId,
                                                                           @ForeignId,
                                                                           @ForeignType,
                                                                           @MappingEntityId output

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spCreateNewMappingEntityByInterfaceIdEntityTypeId' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spCreateNewMappingEntityByInterfaceIdEntityTypeId

   go

create procedure spCreateNewMappingEntityByInterfaceIdEntityTypeId( @InterfaceId     integer,
                                                                    @EntityId        integer,
                                                                    @EntityTypeId    integer,
                                                                    @ForeignId       varchar(50),
                                                                    @ForeignType     varchar(50),
                                                                    @MappingEntityId integer output ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement    */
   declare @RowsAffected integer /* Number of rows affected by the previously executed statement  */
   declare @Transactions integer /* Number of active transactions at the start of this procedure  */
   declare @ReturnCode   integer /* Result code returned by the execution of the stored procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* In the mapping entity row does not already exist... */
   if not exists ( select MAPPING_ENTITY_ID
                   from MAPPING_ENTITY
                   where ( INTERFACE_ID   = @InterfaceId  ) and
                         ( ENTITY_ID      = @EntityId     ) and
                         ( ENTITY_TYPE_ID = @EntityTypeId ) and
                         ( FOREIGN_ID     = @ForeignId    ) and
                        ( FOREIGN_TYPE    = @ForeignType  ) ) begin

      /* If there was an error... */
      if ( @@Error <> 00 ) begin

         /* Rollback the transaction. */
         rollback transaction

         /* Return the failure. */
         return 01

      end

      /* Execute the stored procedure that will perform the actual insert of
         the row into the mapping table.  This will associate the foreign data
         to the associated data in the native database. */
      execute @ReturnCode = spInsertMappingEntity @InterfaceId,
                                                  @EntityId,
                                                  @EntityTypeId,
                                                  @ForeignId,
                                                  @ForeignType,
                                                  @MappingEntityId output

      /* If there was an error... */
      if ( @ReturnCode <> 00 ) begin

         /* Return the failure. */
         return @ReturnCode

      end

   end

   else begin /* The mapping entity row already exists... */

      /* Return the current primary key for the row. */
      select @MappingEntityId = MAPPING_ENTITY_ID
      from MAPPING_ENTITY
      where ( INTERFACE_ID   = @InterfaceId  ) and
            ( ENTITY_ID      = @EntityId     ) and
            ( ENTITY_TYPE_ID = @EntityTypeId ) and
            ( FOREIGN_ID     = @ForeignId    ) and
            ( FOREIGN_TYPE   = @ForeignType  )

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spCreateNewMemberUserEmailSettings' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spCreateNewMemberUserEmailSettings

   go

create procedure spCreateNewMemberUserEmailSettings( @ProviderSystemId       integer,
                                                     @MemberUserId           integer,
                                                     @ProviderServiceValueId integer,
                                                     @EmailFrequencyDays     integer,
                                                     @EmailDisabled          bit,
                                                     @MemberUserEmailId      integer output ) as

   declare @Transactions       integer /* Number of active transactions at the start of this procedure */
   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */
   declare @UpdateDate         datetime
   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   set @UpdateDate = GetDate()

   execute @ReturnCode = spInsertMemberUserEmailSettings @ProviderSystemId,
                                                         @MemberUserId,
                                                         @ProviderServiceValueId,
                                                         @EmailFrequencyDays,
                                                         @UpdateDate,
                                                         @EmailDisabled,
                                                         @MemberUserEmailId output

     /* If there was an error... */
      if ( @ReturnCode <> 00 ) begin

         /* Return the failure. */
         return @ReturnCode

      end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spCreateNewProvider' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spCreateNewProvider

   go

create procedure spCreateNewProvider( @ProviderName varchar(100),
                                      @ProviderId   integer out ) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   execute @ReturnCode = spInsertMember 1,
                                        @ProviderName,
                                        @ProviderId output

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spCreateNewProviderContactInfo' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spCreateNewProviderContactInfo

   go

create procedure spCreateNewProviderContactInfo( @ProviderId            integer,
                                                 @ContactTypeId         integer,
                                                 @ContactInfo           varchar(255),
                                                 @ProviderContactId     integer out,
                                                 @ProviderContactJoinId integer out ) as

   declare @Transactions       integer /* Number of active transactions at the start of this procedure */
   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   execute @ReturnCode = spInsertContact @ContactTypeId,
                                         @ContactInfo,
                                         @ProviderContactId output

    /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   execute @ReturnCode = spInsertContactJoin @ProviderContactId,
                                             @ProviderId,
                                             3,
                                             @ProviderContactJoinId output

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spCreateNewProviderCustomerServiceSchedule' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spCreateNewProviderCustomerServiceSchedule

   go

create procedure spCreateNewProviderCustomerServiceSchedule( @ProviderServiceTypeId                 integer,
                                                             @CustomerUnitId                        integer,
															 @ProviderCustomerServiceScheduleDate   datetime,
															 @ComServiceId                          integer,
															 @WorkOrderNumber                       varchar(50),
															 @ProviderCustomerServiceScheduleId     integer out ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @RowsAffected integer /* Number of rows affected by the previously executed statement */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */
   declare @Count        integer /* Count tester if contact info exists for type        */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was executed... */
   if ( @Transactions = 00 ) begin

   /* Start the transaction. */
      begin transaction

   end

   /* If @ContactInfo value does not exist for @ContactTypeId, then insert it */
   select @Count = count(*)
   from provider_customer_service_schedule
   where ( provider_service_type_id = @ProviderServiceTypeId )
     and ( customer_unit_id         = @CustomerUnitId        )
     and ( work_order_number        = @WorkOrderNumber       )

   /* If there was an error... */
   if ( @@Error <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   if @Count > 0 begin

      select @ProviderCustomerServiceScheduleId = PROVIDER_CUSTOMER_SERVICE_SCHEDULE_ID
      from provider_customer_service_schedule
      where ( provider_service_type_id = @ProviderServiceTypeId )
        and ( customer_unit_id         = @CustomerUnitId        )
        and ( work_order_number        = @WorkOrderNumber       )

      /* Get the rows affected and the error code for the previous statement.
         Error checking MUST be done this way since any single statement executed
         will affect both of the global functions, @@RowCount and @@Error. */
      select @RowsAffected = @@RowCount, @ErrorCode = @@Error

      /* If there was an error... */
      if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

         /* Rollback the transaction. */
         rollback transaction

         /* Return the failure. */
         return 01

      end

      /* Update Contact_Info */
      exec spUpdateProviderCustomerServiceSchedule @ProviderCustomerServiceScheduleId,
                                                   NULL,
                                                   @ProviderServiceTypeId,
                                                   @CustomerUnitId,
                                                   @ProviderCustomerServiceScheduleDate,
                                                   @ComServiceId,
                                                   @WorkOrderNumber

      /* Get the rows affected and the error code for the previous statement.
         Error checking MUST be done this way since any single statement executed
         will affect both of the global functions, @@RowCount and @@Error. */
      select @RowsAffected = @@RowCount, @ErrorCode = @@Error

      /* If there was an error... */
      if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

         /* Rollback the transaction. */
         rollback transaction

         /* Return the failure. */
         return 01

      end

   end

   else begin

      /* Insert a new row in the XXXXXXXX table. */
      exec spInsertProviderCustomerServiceSchedule NULL,
                                                   @ProviderServiceTypeId,
                                                   @CustomerUnitId,
                                                   @ProviderCustomerServiceScheduleDate,
                                                   @ComServiceId,
                                                   @WorkOrderNumber,
                                                   @ProviderCustomerServiceScheduleId out

      /* Get the rows affected and the error code for the previous statement.
         Error checking MUST be done this way since any single statement executed
         will affect both of the global functions, @@RowCount and @@Error. */
      select @RowsAffected = @@RowCount, @ErrorCode = @@Error

      /* If there was an error... */
      if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

         /* Rollback the transaction. */
         rollback transaction

         /* Return the failure. */
         return 01

      end

   end

   /* If there were no active transactions when this stored procedure was executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spCreateNewProviderGroup' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spCreateNewProviderGroup

   go

create procedure spCreateNewProviderGroup( @ProviderGroupTypeId integer,
                                           @ProviderGroupName   varchar(50),
                                           @ProviderGroupId     integer out ) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   execute @ReturnCode = spInsertMemberGroup @ProviderGroupTypeId,
                                                       @ProviderGroupName,
                                                       @ProviderGroupId output

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spCreateNewProviderGroupType' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spCreateNewProviderGroupType

   go

create procedure spCreateNewProviderGroupType( @ProviderId            integer,
                                               @ProviderGroupTypeName varchar(50),
                                               @ProviderGroupTypeId   integer out ) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   -- new procedure
   execute @ReturnCode = spInsertMemberGroupType @ProviderGroupTypeName,
                                                 @ProviderId,
                                                 @ProviderGroupTypeId output

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spCreateNewProviderServiceCategory' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spCreateNewProviderServiceCategory

   go

create procedure spCreateNewProviderServiceCategory( @ProviderSystemId                  integer,
                                                     @TemplateProviderServiceCategoryId integer,
                                                     @ProviderServiceCategory           varchar(50),
                                                     @ProviderServiceCategoryId         integer out ) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   execute @ReturnCode = spInsertProviderServiceCategory @ProviderSystemId,
                                                         @ProviderServiceCategory,
                                                         @TemplateProviderServiceCategoryId,
                                                         @ProviderServiceCategoryId output
   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spCreateNewProviderServiceComment' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spCreateNewProviderServiceComment

   go

create procedure spCreateNewProviderServiceComment( @ProviderSystemId                 integer,
                                                    @TemplateProviderServiceCommentId integer,
                                                    @ProviderServiceComment           varchar(255),
                                                    @ProviderServiceCommentId         integer out ) as
													
   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   -- new procedure
   execute @ReturnCode = spInsertProviderServiceComment @ProviderSystemId,
                                                        @ProviderServiceComment,
                                                        @TemplateProviderServiceCommentId,
                                                        @ProviderServiceCommentId output

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spCreateNewProviderServiceData' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spCreateNewProviderServiceData

   go

create procedure spCreateNewProviderServiceData( @ProviderServiceDataTypeId     integer,
                                                 @TemplateProviderServiceDataId integer,
                                                 @ProviderServiceData           varchar(255),
                                                 @BarCodeId                     integer,
                                                 @ProviderServiceDataId         integer out ) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   execute @ReturnCode = spInsertProviderServiceData @ProviderServiceDataTypeId,
                                                     @ProviderServiceData,
                                                     @BarCodeId,
                                                     @TemplateProviderServiceDataId,
                                                     @ProviderServiceDataId output

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spCreateNewProviderServiceDataType' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spCreateNewProviderServiceDataType

   go

create procedure spCreateNewProviderServiceDataType( @ProviderServiceCategoryId         integer,
                                                     @TemplateProviderServiceDataTypeId integer,
                                                     @ProviderServiceDataType           varchar(50),
                                                     @WebQuery                          bit,
                                                     @SortOrder                         integer,
                                                     @FieldDataTypeId                   integer,
                                                     @FieldLength                       integer,
                                                     @FieldPrecision                    integer,
                                                     @DefaultValue                      varchar(50),
                                                     @Editable                          bit,
                                                     @ProviderServiceDataDefaultId      integer,
                                                     @PickList                          bit,
                                                     @MultipleSelect                    bit,
                                                     @ProviderServiceDataTypeId         integer output ) as

   declare @ReturnCode integer /* Result code returned by the execution of the stored procedure */

   execute @ReturnCode = spInsertProviderServiceDataType @ProviderServiceCategoryId,
                                                         @ProviderServiceDataType,
                                                         @WebQuery,
                                                         @SortOrder,
                                                         @TemplateProviderServiceDataTypeId,
                                                         @FieldDataTypeId,
                                                         @FieldLength,
                                                         @FieldPrecision,
                                                         @DefaultValue,
                                                         @Editable,
                                                         @ProviderServiceDataDefaultId,
                                                         @PickList,
                                                         @MultipleSelect,
                                                         @ProviderServiceDataTypeId output

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spCreateNewProviderServiceType' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spCreateNewProviderServiceType

   go

create procedure spCreateNewProviderServiceType( @ProviderSystemId              integer,
                                                 @TemplateProviderServiceTypeId integer,
                                                 @ProviderServiceType           varchar(50),
                                                 @ProviderServiceTypeId         integer out ) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   execute @ReturnCode = spInsertProviderServiceType @ProviderSystemId,
                                                     @ProviderServiceType,
                                                     @TemplateProviderServiceTypeId,
                                                     @ProviderServiceTypeId output

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spCreateNewProviderServiceValue' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spCreateNewProviderServiceValue

   go

create procedure spCreateNewProviderServiceValue( @ProviderSystemId               integer,
                                                  @TemplateProviderServiceValueId integer,
                                                  @ProviderServiceValueText       varchar(50),
                                                  @ProviderServiceValue           integer,
                                                  @ProviderServiceValueId         integer out ) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   -- new procedure
   execute @ReturnCode = spInsertProviderServiceValue  @ProviderSystemId,
                                                       @ProviderServiceValue,
                                                       @ProviderServiceValueText,
                                                       @TemplateProviderServiceValueId,
                                                       @ProviderServiceValueId output

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spCreateNewProviderSystem' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spCreateNewProviderSystem

   go

create procedure spCreateNewProviderSystem( @ProviderId                          integer,
                                            @TemplateProviderSystemId            integer,
                                            @ProviderSystemName                  varchar(100),
                                            @Review                              bit,
                                            @ProviderSystemServiceTypeDefaultId  integer,
                                            @ProviderSystemServiceValueDefaultId integer,
                                            @ProviderSystemId                    integer out ) as

   declare @ReturnCode integer /* Result code returned by the execution of the stored procedure */

   -- new procedure
   execute @ReturnCode = spInsertProviderSystem @ProviderId,
                                                @ProviderSystemName,
                                                @TemplateProviderSystemId,
                                                @Review,
                                                @ProviderSystemServiceTypeDefaultId,
                                                @ProviderSystemServiceValueDefaultId,
                                                @ProviderSystemId output

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spCreateNewProviderSystemContactInfo' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spCreateNewProviderSystemContactInfo

   go

create procedure spCreateNewProviderSystemContactInfo( @ProviderSystemId            integer,
                                                       @ContactTypeId               integer,
                                                       @ContactInfo                 varchar(255),
                                                       @ProviderSystemContactId     integer out,
                                                       @ProviderSystemContactJoinId integer out ) as

   declare @Transactions       integer /* Number of active transactions at the start of this procedure */
   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   execute @ReturnCode = spInsertContact @ContactTypeId,
                                         @ContactInfo,
                                         @ProviderSystemContactId output

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   execute @ReturnCode = spInsertContactJoin @ProviderSystemContactId,
                                             @ProviderSystemId,
                                             6,
                                             @ProviderSystemContactJoinId output

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

    /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spCreateNewProviderSystemFromTemplate' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spCreateNewProviderSystemFromTemplate

   go

create procedure spCreateNewProviderSystemFromTemplate( @ProviderId       integer,
                                                        @TemplateId       integer,
                                                        @SystemName       varchar(50),
                                                        @Review           bit,
                                                        @ProviderSystemId integer out ) as

   /****************************************************************************
      This block of code creates the new service program using the specified
      parameters.
    ***************************************************************************/

   /* If the name of the new service program was not provided... */
   if ( @SystemName = '' ) begin

      /* Retrieve the name of the new service program from the default name
         defined in the template. */
      select @SystemName = provider_system_name
      from template_provider_system
      where provider_system_id = @TemplateId

   end

   declare @SystemId integer /* Primary key identifier for the new service program */

   /* Insert a new service program into the provider system table and return
      its primary key identifier. */
   execute spInsertProviderSystem @ProviderId,
                                  @SystemName,
                                  @TemplateId,
                                  @Review,
                                  @ProviderSystemId output

   /* Get the primary key identifier for the new service program. */
   set @SystemId = @ProviderSystemId

   /****************************************************************************
      This block of code creates all of the sevice types for the new service
      program using the service types defined in the template table.
    ***************************************************************************/

   declare @TemplateTypeId integer /* Primary key identifier for the templated service type */

   /* Declare a cursor that will return the primary key identifiers for the
      templated service types. */
   declare service_type_cursor CURSOR for
      select provider_service_type_id
      from template_provider_service_type
      where provider_system_id = @TemplateId

   /* Open the cursor and return the result set. */
   open service_type_cursor

   /* Fetch the primary key identifier for the first service type template. */
   fetch next from service_type_cursor into @TemplateTypeId

   /* While there are service type templates in the cursor to fetch... */
   while ( @@Fetch_Status = 00 ) begin

      /* Insert a new service type into the service program with the primary
         key of the associated service type template. */
      execute spInsertProviderServiceType @SystemId,
                                          null,
                                          @TemplateTypeId

      /* Fetch the primary key identifier for the next service type
         template. */
      fetch next from service_type_cursor into @TemplateTypeId

   end

   /* Close the cursor and release the result set. */
   close service_type_cursor

   /* Release the resources allocated for the cursor. */
   deallocate service_type_cursor

   /****************************************************************************
      This block of code creates all of the sevice values for the new service
      program using the service values defined in the template table.
    ***************************************************************************/

   declare @TemplateValueId integer /* Primary key identifier for the templated service value */

   /* Declare a cursor that will return the primary key identifiers for the
      templated service values. */
   declare service_value_cursor cursor for
      select provider_service_value_id
      from template_provider_service_value
      where provider_system_id = @TemplateId

   /* Open the cursor and return the result set. */
   open service_value_cursor

   /* Fetch the primary key identifier for the first service value template. */
   fetch next from service_value_cursor into @TemplateValueId

   /* While there are service value templates in the cursor to fetch... */
   while ( @@Fetch_Status = 00 ) begin

      /* Insert a new service value into the service program with the primary
         key of the associated service value template. */
      execute spInsertProviderServiceValue @SystemId,
                                           null,
                                           null,
                                           @TemplateValueId

      /* Fetch the primary key identifier for the next service type
         template. */
      fetch next from service_value_cursor into @TemplateValueId

   end

   /* Close the cursor and release the result set. */
   close service_value_cursor

   /* Release the resources allocated for the cursor. */
   deallocate service_value_cursor

   /****************************************************************************
      This block of code creates all of the sevice categories, service data
      types (category fields) and service data items (field values) for the new
      service program using the sevice categories, service data types and
      service data items defined in the template tables.
    ***************************************************************************/

   declare @TemplateCategoryId integer /* Primary key identifier for the templated service category */

   /* Declare a cursor that will return the primary key identifiers for the
      templated service categories. */
   declare service_category_cursor cursor for
      select provider_service_category_id
      from template_provider_service_category
      where provider_system_id = @TemplateId

   /* Open the cursor and return the result set. */
   open service_category_cursor

   /* Fetch the primary key identifier for the first service category
      template. */
   fetch next from service_category_cursor into @TemplateCategoryId

   /* While there are service category templates in the cursor to fetch... */
   while ( @@Fetch_Status = 00 ) begin

      declare @CategoryId integer /* Primary key identifier for the new service category */

      /* Insert a new service category into the service program with the
         primary key of the associated service category template. */
      execute spInsertProviderServiceCategory @SystemId,
                                              null,
                                              @TemplateCategoryId,
                                              @CategoryId output

      declare @TemplateDataTypeId integer /* Primary key identifier for the templated service data type */

      /* Declare a cursor that will return the primary key identifiers for the
         templated service data types. */
      declare service_data_type_cursor cursor for
         select provider_service_data_type_id
         from template_provider_service_data_type
         where template_provider_service_category_id = @TemplateCategoryId

      /* Open the cursor and return the result set. */
      open service_data_type_cursor

      /* Fetch the primary key identifier for the first service data type
         template. */
      fetch next from service_data_type_cursor into @TemplateDataTypeId

      /* While there are service data type templates in the cursor to
         fetch... */
      while ( @@Fetch_Status = 00 ) begin

         declare @DataTypeId integer /* Primary key identifier for the new service data type */

         /* Insert a new service data type into the service program with the
            primary key of the associated service data type template. */
         execute spInsertProviderServiceDataType @CategoryId,
                                                 null,
                                                 null,
                                                 null,
                                                 @TemplateDataTypeId,
                                                 @DataTypeId output

         declare @TemplateDataId integer /* Primary key identifier for the templated service data item */

         /* Declare a cursor that will return the primary key identifiers
            for the templated service data items. */
         declare service_data_cursor cursor for
            select provider_service_data_id
            from template_provider_service_data
            where template_provider_service_data_type_id = @TemplateDataTypeId

         /* Open the cursor and return the result set. */
         open service_data_cursor

         /* Fetch the primary key identifier for the first service data item
            template. */
         fetch next from service_data_cursor into @TemplateDataId

         /* While there are service data item templates in the cursor to
            fetch... */
         while ( @@Fetch_Status = 00 ) begin

            /* Insert a new service data item into the service program with
               the primary key of the associated service data item
               template. */
            execute spInsertProviderServiceData @DataTypeId,
                                                null,
                                                null,
                                                @TemplateDataId

            /* Fetch the primary key identifier for the next service data
               item template. */
            fetch next from service_data_cursor into @TemplateDataId

         end

         /* Close the cursor and release the result set. */
         close service_data_cursor

         /* Release the resources allocated for the cursor. */
         deallocate service_data_cursor

         /* Fetch the primary key identifier for the next service data type
            template. */
         fetch next from service_data_type_cursor into @TemplateDataTypeId

      end

      /* Close the cursor and release the result set. */
      close service_data_type_cursor

      /* Release the resources allocated for the cursor. */
      deallocate service_data_type_cursor

      /* Fetch the primary key identifier for the next service category
         template. */
      fetch next from service_category_cursor into @TemplateCategoryId

   end

   /* Close the cursor and release the result set. */
   close service_category_cursor

   /* Release the resources allocated for the cursor. */
   deallocate service_category_cursor

   /****************************************************************************
      This block of code creates all of the customer unit types and customer
      unit names for the new service program using the customer unit types and
      customer unit names defined in the template tables.
    ***************************************************************************/

   /* Recursively call the stored procedure to generate any customer unit types
      for the new service program. */
   execute spCreateNewUnitTypesFromTemplate @TemplateId, -1, -1, @SystemId

   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spCreateNewProviderUser' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spCreateNewProviderUser

   go

create procedure spCreateNewProviderUser(  @ProviderId      integer,
                                           @UserName        varchar(50),
                                           @Password        varchar(15),
                                           @FirstName       varchar(25),
                                           @LastName        varchar(25),
                                           @Email           varchar(50),
                                           @LastLogin       datetime,
                                           @SecurityGroupId integer,
                                           @ProviderUserId  integer out ) as

   declare @Transactions       integer /* Number of active transactions at the start of this procedure */
   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   execute @ReturnCode = spInsertMemberUser @ProviderId,
                                            @UserName,
                                            @Password,
                                            @FirstName,
                                            @LastName,
                                            @LastLogin,
                                            @Email,
                                            @ProviderUserId output

    /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

  if @SecurityGroupId > 00 begin

      execute @ReturnCode = spInsertJoinMemberUserSecurityGroup @ProviderUserId,
                                                                @SecurityGroupId

      /* If there was an error... */
      if ( @ReturnCode <> 00 ) begin

         /* Return the failure. */
         return @ReturnCode

      end

   end

  /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spCreateNewProviderUserContactInfo' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spCreateNewProviderUserContactInfo

   go

create procedure spCreateNewProviderUserContactInfo( @ProviderUserId            integer,
                                                     @ContactTypeId             integer,
                                                     @ContactInfo               varchar(255),
                                                     @ProviderUserContactId     integer out,
                                                     @ProviderUserContactJoinId integer out ) as

   declare @Transactions       integer /* Number of active transactions at the start of this procedure */
   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   execute @ReturnCode = spInsertContact @ContactTypeId,
                                         @ContactInfo,
                                         @ProviderUserContactId output

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   execute @ReturnCode = spInsertContactJoin @ProviderUserContactId,
                                             @ProviderUserId,
                                             1,
                                             @ProviderUserContactJoinId output

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

    /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spCreateTrackerProviderAccount' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spCreateTrackerProviderAccount

   go

create procedure spCreateTrackerProviderAccount( @ProviderName varchar(50),
                                                 @FirstName    varchar(25),
                                                 @LastName     varchar(25),
                                                 @UserName     varchar(50),
                                                 @Password     varchar(15),
                                                 @UserEmail    varchar(50) ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement    */
   declare @RowsAffected integer /* Number of rows affected by the previously executed statement  */
   declare @ReturnCode   integer /* Result code returned by the execution of the stored procedure */
   declare @ProviderId   integer /* Identifier for the new provider                               */
   declare @UserId       integer /* Identifier for the new provider user                          */
   declare @Transactions integer /* Number of active transactions at the start of this procedure  */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Insert a new row in the member table for the provider. */
   insert into MEMBER
   ( MEMBER_TYPE_ID,
     MEMBER_NAME )
   values
   ( 05,
     @ProviderName )

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* Set the value of the new primary key for the provider. */
   select @ProviderId = @@Identity

   /* If there was an error... */
   if ( @@Error <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* Insert a new row in the member user table for the administrative provider
      user. */
   insert into MEMBER_USER
   ( MEMBER_ID,
     MEMBER_USER_NAME,
     MEMBER_USER_PWD,
     MEMBER_USER_FNAME,
     MEMBER_USER_LNAME,
     MEMBER_USER_EMAIL )
   values
   ( @ProviderId,
     @UserName,
     @Password,
     @FirstName,
     @LastName,
     @UserEmail )

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* Set the value of the new primary key for the provider user. */
   select @UserId = @@Identity

   /* If there was an error... */
   if ( @@Error <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* Insert a new row in the table that joins the provider user to the
      security group that makes them the administrator for their account. */
   insert into JOIN_MEMBER_USER_SECURITY_GROUP
   ( MEMBER_USER_ID,
     SECURITY_GROUP_ID )
   values
   ( @UserId,
     13 )

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error


   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* Insert a new row in the table that joins the provider to the templates
      that they can use to configure their service programs. */
   insert JOIN_PROVIDER_TEMPLATE_PROVIDER_SYSTEM
   ( TEMPLATE_PROVIDER_SYSTEM_ID,
     PROVIDER_ID )
   values
   ( 1,
     @ProviderId )

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spCreateTrainingProviderSystemCustomerUnit' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spCreateTrainingProviderSystemCustomerUnit

   go

create procedure spCreateTrainingProviderSystemCustomerUnit( @TemplateId         integer,
                                                             @ProviderId         integer,
                                                             @CustomerName       varchar(100),
                                                             @CustomerUnitName   varchar(100),
                                                             @CustomerUnitNumber varchar(50) ) as

   declare @ErrorCode          integer /* Error code returned by the execution of the last statement   */
   declare @RowsAffected       integer /* Number of rows affected by the previously executed statement */
   declare @Transactions       integer /* Number of active transactions at the start of this procedure */
   declare @MemberTypeId       integer /* Identifier for the customer member type                      */
   declare @CustomerId         integer /* Identifier for the new customer                              */
   declare @ProviderCustomerId integer /* Identifier for the new provider customer association         */
   declare @CustomerUnitId     integer /* Identifier for the new customer unit (property)              */
   declare @CustomerUnitTypeId integer /* Identifier for the type of the customer unit being created   */
   declare @ProviderSystemId   integer /* Identifier for the service program being created             */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Generate the new service program from the specified template. */
   execute @ProviderSystemId = spCreateNewProviderSystemFromTemplate @TemplateId,
                                                                           @ProviderId,
                                                                           '',
                                                                           00

   /* If there was an error... */
   if ( @@Error <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /*=========================================================================*/
   /*============================= Insert Customer ===========================*/
   /*=========================================================================*/

   /* Set the member type for a customer. */
   set @MemberTypeId = 02

   /* Insert a new row in the member table for the customer. */
   insert into MEMBER
   ( MEMBER_TYPE_ID,
     MEMBER_NAME )
   values
   ( @MemberTypeId,
     @CustomerName )

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* Set the value of the new primary key for the customer. */
   select @CustomerId = @@Identity

   /* If there was an error... */
   if ( @@Error <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /*=========================================================================*/
   /*================== Insert Provider Customer Association =================*/
   /*=========================================================================*/

   /* Insert a new row in the provider customer table to associate the
      customer with the passed provider. */
   insert into PROVIDER_CUSTOMER
   ( PROVIDER_ID,
     CUSTOMER_ID )
   values
   ( @ProviderId,
     @CustomerId )

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* Set the value of the new primary key for the provider customer
      association. */
   select @ProviderCustomerId = @@Identity

   /* If there was an error... */
   if ( @@Error <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /*=========================================================================*/
   /*========== Insert Provider Customer Service Program Association =========*/
   /*=========================================================================*/

   /* Insert a new row in the provider customer service table to associate the
      customer with the passed provider service program. */
   insert into PROVIDER_CUSTOMER_SERVICE
   ( PROVIDER_CUSTOMER_ID,
     PROVIDER_SYSTEM_ID )
   values
   ( @ProviderCustomerId,
     @ProviderSystemId )

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /*=========================================================================*/
   /*================= Insert Parent Customer Unit (Property) ================*/
   /*=========================================================================*/

   /* Insert a new row in the customer unit table for the parent customer unit
      (property). */
   insert into CUSTOMER_UNIT
   ( CUSTOMER_ID,
     CUSTOMER_UNIT_NAME,
     CUSTOMER_UNIT_NUMBER,
     UNIT_PARENT_ID,
     INSTALL_DATE )
   values
   ( @CustomerId,
     @CustomerUnitName,
     @CustomerUnitNumber,
     -1,
     GetDate() )

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* Set the value of the new primary key for the customer unit. */
   select @CustomerUnitId = @@Identity

   /* If there was an error... */
   if ( @@Error <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /*=========================================================================*/
   /*======== Get Service Program Parent Customer Unit Type (Property) =======*/
   /*=========================================================================*/

   /* Get the customer unit type identifier for the parent unit type in the
      passed service program.  Currently, a service program can have only one
      parent unit type.  If this changes, then this value will have to be
      specified by the user and passed to this stored procedure. */
   select @CustomerUnitTypeId = CUSTOMER_UNIT_TYPE_ID
   from CUSTOMER_UNIT_TYPE a
   where PROVIDER_SYSTEM_ID           = @ProviderSystemId and
         CUSTOMER_UNIT_TYPE_PARENT_ID = -1

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /*=========================================================================*/
   /*============ Insert Customer Unit Service Program Association ===========*/
   /*=========================================================================*/

   /* Insert a new row in the customer unit type customer unit table to
      associate the customer unit with the parent customer unit type which will
      also associate it with the passed provider service program. */
   insert into JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT
   ( CUSTOMER_UNIT_TYPE_ID,
     CUSTOMER_UNIT_ID,
     CUSTOMER_UNIT_NAME_ID )
   values
   ( @CustomerUnitTypeId,
     @CustomerUnitId,
     null )

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /*=========================================================================*/
   /*========== Insert Default Child Service Program Customer Units ==========*/
   /*=========================================================================*/

   /* Execute the stored procedure that will generate child units for all of the
      default units defined in the associated service program. */
   execute spCreateNewCustomerUnitsByParentType @CustomerUnitTypeId,
                                                @CustomerUnitId,
                                                @CustomerId

   /* If there was an error... */
   if ( @@Error <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spCreateNewUnitTypesFromTemplate' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spCreateNewUnitTypesFromTemplate

   go

create procedure spCreateNewUnitTypesFromTemplate( @TemplateSystemId         integer,
                                                   @TemplateUnitTypeParentId integer,
                                                   @UnitTypeParentId         integer,
                                                   @SystemId                 integer ) as

   /* This stored procedure is called recursively when a parent customer unit
      type is added to a service program during the creation of the service
      program from a template.  It receives the identifier for the for the
      service program template (@TemplateSystemId), the parent unit type
      template (@TemplateUnitTypeParentId), the parent unit type in the service
      program (@UnitTypeParentId), and the identifier for the new service
      program (@SystemId).  It creates all of the default unit types and unit
      names defined in the templates when the target service program was
      created. */

   declare @ErrorCode          integer /* Error code returned by the execution of the last statement    */
   declare @RowsAffected       integer /* Number of rows affected by the previously executed statement  */
   declare @Transactions       integer /* Number of active transactions at the start of this procedure  */
   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */
   declare @TemplateUnitTypeId integer /* Primary key identifier for a customer unit type template      */
   declare @TemplateUnitNameId integer /* Primary key identifier for a customer unit name template      */
   declare @NewUnitTypeId      integer /* Primary key of the new customer unit type                     */
   declare @UnitTypeCount      integer /* Number of customer unit type templates                        */
   declare @UnitNameCount      integer /* Number of customer unit name templates                        */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Get the number of templated customer unit types in the templated service
      program with the specified parent. */
   select @UnitTypeCount = count(*)
   from template_provider_customer_unit_type
   where template_provider_system_id  = @TemplateSystemId and
         customer_unit_type_parent_id = @TemplateUnitTypeParentId

   /* If there was an error... */
   if ( @@Error <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there are templated customer unit types that require processing for
      creating the new service program... */
   if ( @UnitTypeCount > 00 ) begin

      /* Declare a cursor that will return the primary key identifiers for
         the templated customer unit types in the templated service program
         with the specified parent. */
      declare unit_type_cursor cursor for
         select customer_unit_type_id
         from template_provider_customer_unit_type
         where template_provider_system_id  = @TemplateSystemId and
               customer_unit_type_parent_id = @TemplateUnitTypeParentId

      /* Open the cursor and return the result set. */
      open unit_type_cursor

      /* Fetch the primary key identifier for the first customer unit type
         template. */
      fetch next from unit_type_cursor into @TemplateUnitTypeId

      /* While there are customer unit type templates in the cursor to
         fetch... */
      while ( @@Fetch_Status = 00 ) begin

         /* Insert a new customer unit type into the service program with
            the primary key of the associated customer unit type template. */
         execute @ReturnCode = spInsertCustomerUnitType @SystemId,
                                                        null,
                                                        @UnitTypeParentId,
                                                        @TemplateUnitTypeId,
                                                        @NewUnitTypeId output

         /* If there was an error... */
         if ( @ReturnCode <> 00 ) begin

            /* Return the failure. */
            return @ReturnCode

         end

         /* Get the number of templated customer unit names in the templated
            service program with the specified cunstomer unit type template. */
         select @UnitNameCount = count(*)
         from template_provider_customer_unit_name
         where template_provider_customer_unit_type_id = @TemplateUnitTypeId

         /* If there was an error... */
         if ( @@Error <> 00 ) begin

            /* Rollback the transaction. */
            rollback transaction

            /* Return the failure. */
            return 01

         end

         /* If there are templated customer unit names that require processing
            for creating the new service program... */
         if ( @UnitNameCount > 00 ) begin

            /* Declare a cursor that will return the primary key identifiers
               for the templated customer unit names. */
            declare unit_name_cursor cursor for
               select customer_unit_name_id
               from template_provider_customer_unit_name
               where template_provider_customer_unit_type_id = @TemplateUnitTypeId

            /* Open the cursor and return the result set. */
            open unit_name_cursor

            /* Fetch the primary key identifier for the first customer unit
               name template. */
            fetch next from unit_name_cursor into @TemplateUnitNameId

            /* While there are customer unit name templates in the cursor to
               fetch... */
            while ( @@Fetch_Status = 00 ) begin

               /* Insert a new customer unit name into the service program with
                  the primary key of the associated customer unit name
                  template. */
               execute @ReturnCode = spInsertCustomerUnitName @NewUnitTypeId,
                                                              null,
                                                              null,
                                                              @TemplateUnitNameId

               /* If there was an error... */
               if ( @ReturnCode <> 00 ) begin

                  /* Return the failure. */
                  return @ReturnCode

               end

               /* Fetch the primary key identifier for the next customer unit
                  name template. */
               fetch next from unit_name_cursor into @TemplateUnitNameId

            end

            /* Close the cursor and release the result set. */
            close unit_name_cursor

            /* Release the resources allocated for the cursor. */
            deallocate unit_name_cursor

         end

         /* Recursively call this stored procedure to generate any child customer
            unit types of the new customer unit type just created. */
         execute spCreateNewUnitTypesFromTemplate @TemplateSystemId,
                                                  @TemplateUnitTypeId,
                                                  @NewUnitTypeId,
                                                  @SystemId

         /* Fetch the primary key identifier for the next customer unit type
            template. */
         fetch next from unit_type_cursor into @TemplateUnitTypeId

      end

      /* Close the cursor and release the result set. */
      close unit_type_cursor

      /* Release the resources allocated for the cursor. */
      deallocate unit_type_cursor

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spDCSBranch' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spDCSBranch

   go

create procedure spDCSBranch( @InterfaceId integer,       /* required - The Provider's interface identifier                         */
                              @ForeignId   varchar(50),   /* required - The identifier for the Branch object in the foreign system  */
                              @ForeignType varchar(50),   /* optional - The table the Branch object is stored in the foreign system */
                              @BranchName  varchar(50),   /* required - The name of the Branch object                               */
                              @BranchId    integer output ) as

   declare @ErrorCode         integer /* Error code returned by the execution of the last statement    */
   declare @RowsAffected      integer /* Number of rows affected by the previously executed statement  */
   declare @Transactions      integer /* Number of active transactions at the start of this procedure  */
   declare @ReturnCode        integer /* Result code returned by the execution of the stored procedure */
   declare @ProviderId        integer /* The Provider's identifier                                     */
   declare @MemberGroupTypeId integer /* The Branch Group Type identifier                              */
   declare @MappingEntityId   integer /* Identifier to store MAPPING_ENTITY_ID when Customer mapped    */
   declare @EntityCount       integer /* Flag to determine if the branch has been mapped               */

   set nocount on

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Set @ProviderId using the @InterfaceId parameter */
   select @ProviderId = PROVIDER_ID
   from MAPPING_INTERFACE
   where ( INTERFACE_ID = @InterfaceId  )

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Raise an error. */
      raiserror ( 'InterfaceId: %s not found', 15, 1, @InterfaceId )

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* Set the @MemberGroupTypeId using the @ProviderId value */
   select @MemberGroupTypeId = MEMBER_GROUP_TYPE_ID
   from MEMBER_GROUP_TYPE
   where MEMBER_ID = @ProviderId
     and MEMBER_GROUP_TYPE_NAME = 'Branches'

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Raise an error. */
      raiserror ( 'Branches group type for ProviderId: %s not found', 15, 1, @ProviderId )

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If the foreign type was passed as a null value... */
   if ( @ForeignType is null ) begin

     /* Get the count of the mapping entity records for the branch ignoring the
        empty foreign type. */
     select @EntityCount = count( MAPPING_ENTITY_ID )
     from MAPPING_ENTITY
     where ( INTERFACE_ID   = @InterfaceId )
       and ( FOREIGN_ID     = @ForeignId   )
       and ( FOREIGN_TYPE   is null        )
       and ( ENTITY_TYPE_ID = 15           )

   end

   else begin /* The foreign type is not null... */

     /* Get the count of the mapping entity records for the branch taking into
        account the foreign type. */
     select @EntityCount = count( MAPPING_ENTITY_ID )
     from MAPPING_ENTITY
     where ( INTERFACE_ID   = @InterfaceId )
       and ( FOREIGN_ID     = @ForeignId   )
       and ( FOREIGN_TYPE   = @ForeignType )
       and ( ENTITY_TYPE_ID = 15           )

   end

   /* If there was an error... */
   if ( @@Error <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If Branch already exists in Mapping... */
   if ( @EntityCount > 00 ) begin

      /* If the foreign type was passed as a null value... */
      if ( @ForeignType is null ) begin

        /* Get the branch identifier from the mapping table ignoring the empty
           foreign type. */
         select @BranchId = ENTITY_ID
         from MAPPING_ENTITY
         where ( INTERFACE_ID   = @InterfaceId )
           and ( FOREIGN_ID     = @ForeignId   )
           and ( FOREIGN_TYPE   is NULL        )
           and ( ENTITY_TYPE_ID = 15           )

      end

      else begin /* The foreign type is not null... */

        /* Get the branch identifier from the mapping table taking into account
           the foreign type. */
         select @BranchId = ENTITY_ID
         from MAPPING_ENTITY
         where ( INTERFACE_ID   = @InterfaceId )
           and ( FOREIGN_ID     = @ForeignId   )
           and ( FOREIGN_TYPE   = @ForeignType )
           and ( ENTITY_TYPE_ID = 15           )
      end

      /* Get the rows affected and the error code for the previous statement.
         Error checking MUST be done this way since any single statement executed
         will affect both of the global functions, @@RowCount and @@Error. */
      select @RowsAffected = @@RowCount, @ErrorCode = @@Error

      /* If there was an error... */
      if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

         /* Rollback the transaction. */
         rollback transaction

         /* Return the failure. */
         return 01

      end

      /* Update the MEMBER_GROUP table with @LogTransaction = 00 which will not
         log the change to the transaction log. */
      execute @ReturnCode = spUpdateMemberGroup @BranchId, @MemberGroupTypeId,
                                                @BranchName, 00

      /* If there was an error... */
      if ( @ReturnCode <> 00 ) begin

         /* Raise an error. */
         raiserror ( 'Error updating Branch: %s', 15, 1, @BranchName )

         /* Return the failure. */
         return @ReturnCode

      end

   end

   else begin

      /* Insert into the MEMBER_GROUP table with @LogTransaction = 00 which
         will not log the change to the transaction log. */
      execute @ReturnCode = spInsertMemberGroup @MemberGroupTypeId,
                                                @BranchName,
                                                @BranchId output, 00

      /* If there was an error... */
      if ( @ReturnCode <> 00 ) begin

         /* Raise an error. */
         raiserror ( 'Error inserting Branch: %s', 15, 1, @BranchName )

         /* Return the failure. */
         return @ReturnCode

      end

      /* Insert into the MAPPING_ENTITY table  */
      execute @ReturnCode = spInsertMappingEntity @InterfaceId, @BranchId, 15,
                                                  @ForeignId, @ForeignType,
                                                  @MappingEntityId

      /* If there was an error... */
      if ( @ReturnCode <> 00 ) begin

         /* Raise an error. */
         raiserror ( 'Error mapping Branch: %s', 15, 1, @ForeignId )

         /* Return the failure. */
         return @ReturnCode

      end

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spDCSCustomer' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spDCSCustomer

   go

create procedure spDCSCustomer( @InterfaceId  integer,      /* required - The Provider's Interface identifier                                                                  */
                                @ForeignId    varchar(50),  /* required - The Customer object's identifier in the foreign system                                               */
                                @ForeignType  varchar(50),  /* optional - Used to identify the type of customer (ex: for ServicePro should be 'MainAccountKey' or 'AccountKey' */
                                @CustomerName varchar(100), /* required - The Customer's name as it appears in the foreign system                                              */
                                @Address1     varchar(50),  /* optional - The customer's address1                                                                              */
                                @Address2     varchar(50),  /* optional - The customer's address2                                                                              */
                                @Address3     varchar(50),  /* optional - The customer's address3                                                                              */
                                @City         varchar(50),  /* optional - The customer's city                                                                                  */
                                @State        varchar(50),  /* optional - The customer's state                                                                                 */
                                @Zip          varchar(50),  /* optional - The customer's zip                                                                                   */
                                @Phone        varchar(50),  /* optional - The customer's phone                                                                                 */
                                @Fax          varchar(50),  /* optional - The customer's fax                                                                                   */
                                @Mobile       varchar(50),  /* optional - The customer's mobile                                                                                */
                                @Pager        varchar(50),  /* optional - The customer's pager                                                                                 */
                                @Email        varchar(50),  /* optional - The customer's email                                                                                 */
                                @CustomerId   integer output ) as

   declare @ErrorCode          integer /* Error code returned by the execution of the last statement    */
   declare @RowsAffected       integer /* Number of rows affected by the previously executed statement  */
   declare @Transactions       integer /* Number of active transactions at the start of this procedure  */
   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */
   declare @ProviderId         integer /* The PROVIDER_ID that this Customer is being added to          */
   declare @MappingEntityId    integer /* Identifier to store MAPPING_ENTITY_ID when Customer mapped    */
   declare @ProviderCustomerId integer /* Identifier to store PROVIDER_CUSTOMER_ID                      */
   declare @ContactId          integer /* Identifier to store CONTACT_ID when contact info is inserted  */
   declare @EntityCount        integer /* Flag to determine if the customer has been mapped             */

   set nocount on

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Get the Provider identifier for the current InterfaceId */
   select @ProviderId = PROVIDER_ID
   from MAPPING_INTERFACE
   where INTERFACE_ID = @InterfaceId

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Raise an error. */
      raiserror ( 'InterfaceId: %s not found', 15, 1, @InterfaceId )

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If the foreign type was passed as a null value... */
   if ( @ForeignType is null ) begin

     /* Get the count of the mapping entity records for the customer ignoring
        the empty foreign type. */
     select @EntityCount = count( MAPPING_ENTITY_ID )
     from MAPPING_ENTITY
     where ( INTERFACE_ID   = @InterfaceId )
       and ( FOREIGN_ID     = @ForeignId   )
       and ( FOREIGN_TYPE   is null        )
       and ( ENTITY_TYPE_ID = 04           )

   end

   else begin /* The foreign type is not null... */

     /* Get the count of the mapping entity records for the customer taking
        into account the foreign type. */
     select @EntityCount = count( MAPPING_ENTITY_ID )
     from MAPPING_ENTITY
     where ( INTERFACE_ID   = @InterfaceId )
       and ( FOREIGN_ID     = @ForeignId   )
       and ( FOREIGN_TYPE   = @ForeignType )
       and ( ENTITY_TYPE_ID = 04           )

   end

   /* If there was an error... */
   if ( @@Error <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If Customer already exists in Mapping... */
   if ( @EntityCount > 00 ) begin

      /* If the foreign type was passed as a null value... */
      if ( @ForeignType is null ) begin

        /* Get the customer identifier from the mapping table ignoring the
           empty foreign type. */
         select @CustomerId = ENTITY_ID
         from MAPPING_ENTITY
         where ( INTERFACE_ID   = @InterfaceId )
           and ( FOREIGN_ID     = @ForeignId   )
           and ( FOREIGN_TYPE   is null        )
           and ( ENTITY_TYPE_ID = 04           )

      end

      else begin /* The foreign type is not null... */

        /* Get the customer identifier from the mapping table taking into
           account the foreign type. */
         select @CustomerId = ENTITY_ID
         from MAPPING_ENTITY
         where ( INTERFACE_ID   = @InterfaceId )
           and ( FOREIGN_ID     = @ForeignId   )
           and ( FOREIGN_TYPE   = @ForeignType )
           and ( ENTITY_TYPE_ID = 04           )

      end

      /* Get the rows affected and the error code for the previous statement.
         Error checking MUST be done this way since any single statement executed
         will affect both of the global functions, @@RowCount and @@Error. */
      select @RowsAffected = @@RowCount, @ErrorCode = @@Error

      /* If there was an error... */
      if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

         /* Raise an error. */
         raiserror ( 'Error retrieving mapped Customer: %s', 15, 1, @ForeignId )

         /* Rollback the transaction. */
         rollback transaction

         /* Return the failure. */
         return 01

      end

      /* Update the MEMBER table with @LogTransaction = 00 which will not log
         the change to the transaction log. */
      execute @ReturnCode = spUpdateMember @CustomerId, 02, @CustomerName, 00

      /* If there was an error... */
      if ( @ReturnCode <> 00 ) begin

         /* Raise an error. */
         raiserror ( 'Error updating Member: %s', 15, 1, @CustomerName )

         /* Return the failure. */
         return @ReturnCode

      end

   end

   else begin

      /* Insert into the MEMBER table with @LogTransaction = 00 which will not
         log the change to the transaction log. */
      execute @ReturnCode = spInsertMember 02, @CustomerName,
                                           @CustomerId output, 00

      /* If there was an error... */
      if ( @ReturnCode <> 00 ) begin

         /* Raise an error. */
         raiserror ( 'Error inserting Member: %s', 15, 1, @CustomerName )

         /* Return the failure. */
         return @ReturnCode

      end

      /* Insert into the PROVIDER_CUSTOMER table */
      execute @ReturnCode = spInsertProviderCustomer @ProviderId, @CustomerId,
                                                     @ProviderCustomerId

      /* If there was an error... */
      if ( @ReturnCode <> 00 ) begin

         /* Raise an error. */
         raiserror ( 'Error inserting ProviderCustomer: %s', 15, 1, @CustomerName )

         /* Return the failure. */
         return @ReturnCode

      end

      /* Insert into the MAPPING_ENTITY table  */
      execute @ReturnCode = spInsertMappingEntity @InterfaceId, @CustomerId,
                                                  04, @ForeignId, @ForeignType,
                                                  @MappingEntityId

      /* If there was an error... */
      if ( @ReturnCode <> 00 ) begin

         /* Raise an error. */
         raiserror ( 'Error mapping Customer: %s', 15, 1, @ForeignId )

         /* Return the failure. */
         return @ReturnCode

      end

   end

   /* If Address1 value is not null... */
   if ( @Address1 is not null ) begin

      /* generate the new contact information for the service location.  If the
         contact information already exists, it will be updated. */
      execute @ReturnCode = spCreateNewContactAddress1 @Address1,
                                                       @CustomerId, 04

      /* If there was an error... */
      if ( @ReturnCode <> 00 ) begin

         /* Raise an error. */
         raiserror ( 'Error inserting address1 for Customer: %s', 15, 1, @CustomerName )

         /* Return the failure. */
         return @ReturnCode

      end

   end

   /* If Address2 value is not null... */
   if ( @Address2 is not null ) begin

      /* generate the new contact information for the service location.  If the
         contact information already exists, it will be updated. */
      execute @ReturnCode = spCreateNewContactAddress2 @Address2,
                                                       @CustomerId, 04

      /* If there was an error... */
      if ( @ReturnCode <> 00 ) begin

         /* Raise an error. */
         raiserror ( 'Error inserting address2 for Customer: %s', 15, 1, @CustomerName )

         /* Return the failure. */
         return @ReturnCode

      end

   end

   /* If Address3 value is not null... */
   if ( @Address3 is not null ) begin

      /* generate the new contact information for the service location.  If the
         contact information already exists, it will be updated. */
      execute @ReturnCode = spCreateNewContactAddress3 @Address3,
                                                       @CustomerId, 04

      /* If there was an error... */
      if ( @ReturnCode <> 00 ) begin

         /* Raise an error. */
         raiserror ( 'Error inserting address3 for Customer: %s', 15, 1, @CustomerName )

         /* Return the failure. */
         return @ReturnCode

      end

   end

   /* If City value is not null... */
   if ( @City is not null ) begin

      /* generate the new contact information for the service location.  If the
         contact information already exists, it will be updated. */
      execute @ReturnCode = spCreateNewContactCity @City,
                                                   @CustomerId, 04

      /* If there was an error... */
      if ( @ReturnCode <> 00 ) begin

         /* Raise an error. */
         raiserror ( 'Error inserting city for Customer: %s', 15, 1, @CustomerName )

         /* Return the failure. */
         return @ReturnCode

      end

   end

   /* If State value is not null... */
   if ( @State is not null ) begin

      /* generate the new contact information for the service location.  If the
         contact information already exists, it will be updated. */
      execute @ReturnCode = spCreateNewContactState @State,
                                                    @CustomerId, 04

      /* If there was an error... */
      if ( @ReturnCode <> 00 ) begin

         /* Raise an error. */
         raiserror ( 'Error inserting state for Customer: %s', 15, 1, @CustomerName )

         /* Return the failure. */
         return @ReturnCode

      end

   end

   /* If Zip value is not null... */
   if ( @Zip is not null ) begin

      /* generate the new contact information for the service location.  If the
         contact information already exists, it will be updated. */
      execute @ReturnCode = spCreateNewContactZip @Zip,
                                                  @CustomerId, 04

      /* If there was an error... */
      if ( @ReturnCode <> 00 ) begin

         /* Raise an error. */
         raiserror ( 'Error inserting zip for Customer: %s', 15, 1, @CustomerName )

         /* Return the failure. */
         return @ReturnCode

      end

   end

   /* If Phone value is not null... */
   if ( @Phone is not null ) begin

      /* generate the new contact information for the service location.  If the
         contact information already exists, it will be updated. */
      execute @ReturnCode = spCreateNewContactPhone @Phone,
                                                    @CustomerId, 04

      /* If there was an error... */
      if ( @ReturnCode <> 00 ) begin

         /* Raise an error. */
         raiserror ( 'Error inserting phone for Customer: %s', 15, 1, @CustomerName )

         /* Return the failure. */
         return @ReturnCode

      end

   end

   /* If Address2 value is not null... */
   if ( @Fax is not null ) begin

      /* generate the new contact information for the service location.  If the
         contact information already exists, it will be updated. */
      execute @ReturnCode = spCreateNewContactFax @Fax,
                                                  @CustomerId, 04

      /* If there was an error... */
      if ( @ReturnCode <> 00 ) begin

         /* Raise an error. */
         raiserror ( 'Error inserting fax for Customer: %s', 15, 1, @CustomerName )

         /* Return the failure. */
         return @ReturnCode

      end

   end

   /* If Mobile value is not null... */
   if ( @Mobile is not null ) begin

      /* generate the new contact information for the service location.  If the
         contact information already exists, it will be updated. */
      execute @ReturnCode = spCreateNewContactMobile @Mobile,
                                                     @CustomerId, 04

      /* If there was an error... */
      if ( @ReturnCode <> 00 ) begin

         /* Raise an error. */
         raiserror ( 'Error inserting mobile for Customer: %s', 15, 1, @CustomerName )

         /* Return the failure. */
         return @ReturnCode

      end

   end

   /* If Pager value is not null... */
   if ( @Pager is not null ) begin

      /* generate the new contact information for the service location.  If the
         contact information already exists, it will be updated. */
      execute @ReturnCode = spCreateNewContactPager @Pager,
                                                    @CustomerId, 04

      /* If there was an error... */
      if ( @ReturnCode <> 00 ) begin

         /* Raise an error. */
         raiserror ( 'Error inserting pager for Customer: %s', 15, 1, @CustomerName )

         /* Return the failure. */
         return @ReturnCode

      end

   end

   /* If Email value is not null... */
   if ( @Email is not null ) begin

      /* generate the new contact information for the service location.  If the
         contact information already exists, it will be updated. */
      execute @ReturnCode = spCreateNewContactEmail @Email,
                                                    @CustomerId, 04

      /* If there was an error... */
      if ( @ReturnCode <> 00 ) begin

         /* Raise an error. */
         raiserror ( 'Error inserting email for Customer: %s', 15, 1, @CustomerName )

         /* Return the failure. */
         return @ReturnCode

      end

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spDCSGroup' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spDCSGroup

   go

create procedure spDCSGroup( @InterfaceId integer,       /* required - The Provider's interface identifier                         */
                               @ForeignId   varchar(50),   /* required - The identifier for the Group object in the foreign system  */
                               @ForeignType varchar(50),   /* optional - The table the Group object is stored in the foreign system */
                               @GroupName   varchar(50),   /* required - The name of the Group object                               */
                               @GroupId     integer output ) as

   declare @ErrorCode         integer /* Error code returned by the execution of the last statement    */
   declare @RowsAffected      integer /* Number of rows affected by the previously executed statement  */
   declare @Transactions      integer /* Number of active transactions at the start of this procedure  */
   declare @ReturnCode        integer /* Result code returned by the execution of the stored procedure */
   declare @ProviderId        integer /* The Provider's identifier                                     */
   declare @MemberGroupTypeId integer /* The Group Group Type identifier                              */
   declare @MappingEntityId   integer /* Identifier to store MAPPING_ENTITY_ID when Customer mapped    */
   declare @EntityCount       integer /* Flag to determine if the Group has been mapped               */

   set nocount on

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Set @ProviderId using the @InterfaceId parameter */
   select @ProviderId = PROVIDER_ID
   from MAPPING_INTERFACE
   where ( INTERFACE_ID = @InterfaceId  )

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Raise an error. */
      raiserror ( 'InterfaceId: %s not found', 15, 1, @InterfaceId )

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   if ( @ForeignType is not null ) begin

      /* Set the @MemberGroupTypeId using the @ProviderId value */
      select @MemberGroupTypeId = MEMBER_GROUP_TYPE_ID
      from MEMBER_GROUP_TYPE
      where MEMBER_ID = @ProviderId
        and MEMBER_GROUP_TYPE_NAME = @ForeignType

      /* Get the rows affected and the error code for the previous statement.
         Error checking MUST be done this way since any single statement executed
         will affect both of the global functions, @@RowCount and @@Error. */
      select @RowsAffected = @@RowCount, @ErrorCode = @@Error

      /* If there was an error... */
      if ( @ErrorCode <> 00 ) begin

         /* Raise an error. */
         raiserror ( 'Error retrieving Group Type: %s', 15, 1, @ForeignType )

         /* Return the failure. */
         return @ReturnCode

      end

      /* If Meber Group Type does not exist... */
      else if ( @RowsAffected = 00 ) begin

         /* generate Group Type  */
         execute @ReturnCode = spInsertMemberGroupType @ForeignType,
                                                       @ProviderId,
                                                       @MemberGroupTypeId output

         /* If there was an error... */
         if ( @ReturnCode <> 00 ) begin

            /* Raise an error. */
            raiserror ( 'Error creating group type: %s', 15, 1, @ForeignType )

            /* Return the failure. */
            return @ReturnCode

         end

      end

      /* Get the Group identifier from the mapping table taking into account
              the foreign type. */
      select @GroupId = ENTITY_ID
      from MAPPING_ENTITY
      where ( INTERFACE_ID   = @InterfaceId )
        and ( FOREIGN_ID     = @ForeignId   )
        and ( FOREIGN_TYPE   = @ForeignType )
        and ( ENTITY_TYPE_ID in ( 15,16,17 ))

      /* Get the rows affected and the error code for the previous statement.
         Error checking MUST be done this way since any single statement executed
         will affect both of the global functions, @@RowCount and @@Error. */
      select @RowsAffected = @@RowCount, @ErrorCode = @@Error

      /* If there was an error... */
      if ( @ErrorCode <> 00 ) begin

         /* Raise an error. */
         raiserror ( 'Error retrieving Group: %s', 15, 1, @ForeignId )

         /* Return the failure. */
         return @ReturnCode

      end

      /* If Meber Group Type does not exist... */
      else if ( @RowsAffected = 00 ) begin

         /* Insert into the MEMBER_GROUP table with @LogTransaction = 00 which
            will not log the change to the transaction log. */
         execute @ReturnCode = spInsertMemberGroup @MemberGroupTypeId,
                                                   @GroupName,
                                                   @GroupId output, 00

         /* If there was an error... */
         if ( @ReturnCode <> 00 ) begin

            /* Raise an error. */
            raiserror ( 'Error inserting Group: %s', 15, 1, @GroupName )

            /* Return the failure. */
            return @ReturnCode

         end

         /* Insert into the MAPPING_ENTITY table  */
         execute @ReturnCode = spInsertMappingEntity @InterfaceId, @GroupId, 17,
                                                     @ForeignId, @ForeignType,
                                                     @MappingEntityId

         /* If there was an error... */
         if ( @ReturnCode <> 00 ) begin

            /* Raise an error. */
            raiserror ( 'Error mapping Group: %s', 15, 1, @ForeignId )

            /* Return the failure. */
            return @ReturnCode

         end

      end

      else begin

         /* Update the MEMBER_GROUP table with @LogTransaction = 00 which will not
            log the change to the transaction log. */
         execute @ReturnCode = spUpdateMemberGroup @GroupId, @MemberGroupTypeId,
                                                   @GroupName, 00

         /* If there was an error... */
         if ( @ReturnCode <> 00 ) begin

            /* Raise an error. */
            raiserror ( 'Error updating Group: %s', 15, 1, @GroupName )

            /* Return the failure. */
            return @ReturnCode

         end

      end

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spDCSProviderUser' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spDCSProviderUser

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spDCSProviderUser' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spDCSProviderUser

   go

create procedure spDCSProviderUser( @InterfaceId    integer,     /* required - The Provider's interface identifier       */
                                    @ForeignId      varchar(50), /* required - The User identifier in the foreign system */
                                    @ForeignType    varchar(50), /* optional - Not used by this object, should be NULL   */
                                    @FirstName      varchar(50), /* required - The user's first name                     */
                                    @LastName       varchar(50), /* required - The user's last name                      */
                                    @Address1       varchar(50), /* optional - The user's address1                       */
                                    @Address2       varchar(50), /* optional - The user's address2                       */
                                    @Address3       varchar(50), /* optional - The user's address3                       */
                                    @City           varchar(50), /* optional - The user's city                           */
                                    @State          varchar(50), /* optional - The user's state                          */
                                    @Zip            varchar(50), /* optional - The user's zip                            */
                                    @Phone          varchar(50), /* optional - The user's phone                          */
                                    @Fax            varchar(50), /* optional - The user's fax                            */
                                    @Mobile         varchar(50), /* optional - The user's mobile                         */
                                    @Pager          varchar(50), /* optional - The user's pager                          */
                                    @Email          varchar(50), /* required - The user's email                          */
                                    @ProviderUserId integer output ) as

   declare @ErrorCode       integer         /* Error code returned by the execution of the last statement    */
   declare @RowsAffected    integer         /* Number of rows affected by the previously executed statement  */
   declare @Transactions    integer         /* Number of active transactions at the start of this procedure  */
   declare @ReturnCode      integer         /* Result code returned by the execution of the stored procedure */
   declare @ProviderId      integer         /* Provider EYEON identifier                                     */
   declare @MappingEntityId integer         /* Identifier to store MAPPING_ENTITY_ID when Customer mapped    */
   declare @ContactId       integer         /* Identifier to store CONTACT_ID when contact info is inserted  */
   declare @UserName        varchar(50) /* User's username value                                         */
   declare @Password        varchar(50) /* User's Password value                                         */
   declare @LastLogin       varchar(50) /* User's LastLogin value                                        */
   declare @EntityCount     integer         /* Flag to determine if the service location has been mapped     */

   set nocount on

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Set the @ProviderId variable */
   select @ProviderId = PROVIDER_ID
   from MAPPING_INTERFACE
   where ( INTERFACE_ID = @InterfaceId  )

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Raise an error. */
      raiserror ( 'InterfaceId: %s not found', 15, 1, @InterfaceId )

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If the foreign type was passed as a null value... */
   if ( @ForeignType is null ) begin

     /* Get the count of the mapping entity records for the provider user
        ignoring the empty foreign type. */
     select @EntityCount = count( MAPPING_ENTITY_ID )
     from MAPPING_ENTITY
     where ( INTERFACE_ID   = @InterfaceId )
       and ( FOREIGN_ID     = @ForeignId   )
       and ( FOREIGN_TYPE   is null        )
       and ( ENTITY_TYPE_ID = 01           )

   end

   else begin /* The foreign type is not null... */

     /* Get the count of the mapping entity records for the provider user
        taking into account the foreign type. */
     select @EntityCount = count( MAPPING_ENTITY_ID )
     from MAPPING_ENTITY
     where ( INTERFACE_ID   = @InterfaceId )
       and ( FOREIGN_ID     = @ForeignId   )
       and ( FOREIGN_TYPE   = @ForeignType )
       and ( ENTITY_TYPE_ID = 01           )

   end

   /* If there was an error... */
   if ( @@Error <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If User already exists in Mapping... */
   if ( @EntityCount > 00 ) begin

      /* If the foreign type was passed as a null value... */
      if ( @ForeignType is null ) begin

        /* Get the provider user identifier from the mapping table ignoring
           the empty foreign type. */
         select @ProviderUserId = ENTITY_ID
         from MAPPING_ENTITY
         where ( INTERFACE_ID   = @InterfaceId )
           and ( FOREIGN_ID     = @ForeignId   )
           and ( FOREIGN_TYPE   is null        )
           and ( ENTITY_TYPE_ID = 01           )

      end

      else begin /* The foreign type is not null... */

        /* Get the provider user identifier from the mapping table taking
           into account the foreign type. */
         select @ProviderUserId = ENTITY_ID
         from MAPPING_ENTITY
         where ( INTERFACE_ID   = @InterfaceId )
           and ( FOREIGN_ID     = @ForeignId   )
           and ( FOREIGN_TYPE   = @ForeignType )
           and ( ENTITY_TYPE_ID = 01           )

      end

      /* Get the rows affected and the error code for the previous statement.
         Error checking MUST be done this way since any single statement executed
         will affect both of the global functions, @@RowCount and @@Error. */
      select @RowsAffected = @@RowCount, @ErrorCode = @@Error

      /* If there was an error... */
      if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

         /* Raise an error. */
         raiserror ( 'Error retrieveing ProviderUser: %s from mapping', 15, 1, @ForeignId )

         /* Rollback the transaction. */
         rollback transaction

         /* Return the failure. */
         return 01

      end

      /* Set the user's username, password, email, and lastlogin variables */
      select @UserName  = MEMBER_USER_NAME,
             @Password  = MEMBER_USER_PWD,
             @Email     = MEMBER_USER_EMAIL,
             @LastLogin = MEMBER_USER_LAST_LOGIN
      from MEMBER_USER
      where MEMBER_USER_ID = @ProviderUserId

      /* Get the rows affected and the error code for the previous statement.
         Error checking MUST be done this way since any single statement executed
         will affect both of the global functions, @@RowCount and @@Error. */
      select @RowsAffected = @@RowCount, @ErrorCode = @@Error

      /* If there was an error... */
      if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

         /* Raise an error. */
         raiserror ( 'Error retrieving ProviderUser: %s', 15, 1, @ProviderUserId )

         /* Rollback the transaction. */
         rollback transaction

         /* Return the failure. */
         return 01

      end

      /* Update the MEMBER_USER table with @LogTransaction = 00 which will not
         log the change to the transaction log. */
      execute @ReturnCode = spUpdateMemberUser @ProviderUserId, @ProviderId,
                                               @UserName, @Password,
                                               @FirstName, @LastName,
                                               @LastLogin, @Email, 00

      /* If there was an error... */
      if ( @ReturnCode <> 00 ) begin

         /* Raise an error. */
         raiserror ( 'Error updating ProviderUser: %s', 15, 1, @UserName )

         /* Return the failure. */
         return @ReturnCode

      end

   end

   else begin

      /* Set required user values */
      set @Username = @Email
      set @LastLogin = null

      /* Generate a random password for the new user. */
      execute spRandomPassword 05, 08, @Password output

      /* If there was an error... */
      if ( @@Error <> 00 ) begin

         /* Raise an error. */
         raiserror ( 'Error generating random password for ProviderUser: %s', 15, 1, @Username )

         /* Rollback the transaction. */
         rollback transaction

         /* Return the failure. */
         return 01

      end

      /* Insert into the MEMBER_USER table with @LogTransaction = 00 which will
         not log the change to the transaction log. */
      execute @ReturnCode = spInsertMemberUser @ProviderId, @UserName,
                                               @Password, @FirstName,
                                               @LastName, @LastLogin, @Email,
                                               @ProviderUserId output, 00

      /* If there was an error... */
      if ( @ReturnCode <> 00 ) begin

         /* Raise an error. */
         raiserror ( 'Error inserting ProviderUser: %s', 15, 1, @Username )

         /* Return the failure. */
         return @ReturnCode

      end

      /* Insert into the JOIN_MEMBER_USER_SECURITY_GROUP table with
         @SecurityGroupId = 14 (Disabled) */
      execute @ReturnCode = spInsertJoinMemberUserSecurityGroup @ProviderUserId,
                                                                14

      /* If there was an error... */
      if ( @ReturnCode <> 00 ) begin

         /* Raise an error. */
         raiserror ( 'Error setting security group for ProviderUser: %s', 15, 1, @Username )

         /* Return the failure. */
         return @ReturnCode

      end

      /* Insert into the MAPPING_ENTITY table.  This will associate the foreign
         service location data to the native data in the EyeOn database. */
      execute @ReturnCode = spInsertMappingEntity @InterfaceId,
                                                  @ProviderUserId, 01,
                                                  @ForeignId,
                                                  @ForeignType,
                                                  @MappingEntityId

      /* If there was an error... */
      if ( @ReturnCode <> 00 ) begin

         /* Raise an error. */
         raiserror ( 'Error mapping ProviderUser: %s', 15, 1, @ForeignId )

         /* Return the failure. */
         return @ReturnCode

      end

   end

   /* If Address1 value is not null... */
   if ( @Address1 is not null ) begin

      /* generate the new contact information for the service location.  If the
         contact information already exists, it will be updated. */
      execute @ReturnCode = spCreateNewContactAddress1 @Address1,
                                                       @ProviderUserId, 01

      /* If there was an error... */
      if ( @ReturnCode <> 00 ) begin

         /* Raise an error. */
         raiserror ( 'Error inserting address1 for ProviderUser: %s', 15, 1, @Username )

         /* Return the failure. */
         return @ReturnCode

      end

   end

   /* If Address2 value is not null... */
   if ( @Address2 is not null ) begin

      /* generate the new contact information for the service location.  If the
         contact information already exists, it will be updated. */
      execute @ReturnCode = spCreateNewContactAddress2 @Address2,
                                                       @ProviderUserId, 01

      /* If there was an error... */
      if ( @ReturnCode <> 00 ) begin

         /* Raise an error. */
         raiserror ( 'Error inserting address2 for ProviderUser: %s', 15, 1, @Username )

         /* Return the failure. */
         return @ReturnCode

      end

   end

   /* If Address3 value is not null... */
   if ( @Address3 is not null ) begin

      /* generate the new contact information for the service location.  If the
         contact information already exists, it will be updated. */
      execute @ReturnCode = spCreateNewContactAddress3 @Address3,
                                                       @ProviderUserId, 01

      /* If there was an error... */
      if ( @ReturnCode <> 00 ) begin

         /* Raise an error. */
         raiserror ( 'Error inserting address3 for ProviderUser: %s', 15, 1, @Username )

         /* Return the failure. */
         return @ReturnCode

      end

   end

   /* If City value is not null... */
   if ( @City is not null ) begin

      /* generate the new contact information for the service location.  If the
         contact information already exists, it will be updated. */
      execute @ReturnCode = spCreateNewContactCity @City,
                                                   @ProviderUserId, 01

      /* If there was an error... */
      if ( @ReturnCode <> 00 ) begin

         /* Raise an error. */
         raiserror ( 'Error inserting city for ProviderUser: %s', 15, 1, @Username )

         /* Return the failure. */
         return @ReturnCode

      end

   end

   /* If State value is not null... */
   if ( @State is not null ) begin

      /* generate the new contact information for the service location.  If the

         contact information already exists, it will be updated. */
      execute @ReturnCode = spCreateNewContactState @State,
                                                    @ProviderUserId, 01

      /* If there was an error... */
      if ( @ReturnCode <> 00 ) begin

         /* Raise an error. */
         raiserror ( 'Error inserting state for ProviderUser: %s', 15, 1, @Username )

         /* Return the failure. */
         return @ReturnCode

      end

   end

   /* If Zip value is not null... */
   if ( @Zip is not null ) begin

      /* generate the new contact information for the service location.  If the
         contact information already exists, it will be updated. */
      execute @ReturnCode = spCreateNewContactZip @Zip,
                                                  @ProviderUserId, 01

      /* If there was an error... */
      if ( @ReturnCode <> 00 ) begin

         /* Raise an error. */
         raiserror ( 'Error inserting zip for ProviderUser: %s', 15, 1, @Username )

         /* Return the failure. */
         return @ReturnCode

      end

   end

   /* If Phone value is not null... */
   if ( @Phone is not null ) begin

      /* generate the new contact information for the service location.  If the
         contact information already exists, it will be updated. */
      execute @ReturnCode = spCreateNewContactPhone @Phone,
                                                    @ProviderUserId, 01

      /* If there was an error... */
      if ( @ReturnCode <> 00 ) begin

         /* Raise an error. */
         raiserror ( 'Error inserting phone for ProviderUser: %s', 15, 1, @Username )

         /* Return the failure. */
         return @ReturnCode

      end

   end

   /* If Address2 value is not null... */
   if ( @Fax is not null ) begin

      /* Generate the new contact information for the service location.  If the
         contact information already exists, it will be updated. */
      execute @ReturnCode = spCreateNewContactFax @Fax,
                                                  @ProviderUserId, 01

      /* If there was an error... */
      if ( @ReturnCode <> 00 ) begin

         /* Raise an error. */
         raiserror ( 'Error inserting fax for ProviderUser: %s', 15, 1, @Username )

         /* Return the failure. */
         return @ReturnCode

      end

   end

   /* If Mobile value is not null... */
   if ( @Mobile is not null ) begin

      /* Generate the new contact information for the service location.  If the
         contact information already exists, it will be updated. */
      execute @ReturnCode = spCreateNewContactMobile @Mobile,
                                                     @ProviderUserId, 01

      /* If there was an error... */
      if ( @ReturnCode <> 00 ) begin

         /* Raise an error. */
         raiserror ( 'Error inserting mobile for ProviderUser: %s', 15, 1, @Username )

         /* Return the failure. */
         return @ReturnCode

      end

   end

   /* If Pager value is not null... */
   if ( @Pager is not null ) begin

      /* Generate the new contact information for the service location.  If the
         contact information already exists, it will be updated. */
      execute @ReturnCode = spCreateNewContactPager @Pager,
                                                    @ProviderUserId, 01

      /* If there was an error... */
      if ( @ReturnCode <> 00 ) begin

         /* Raise an error. */
         raiserror ( 'Error inserting pager for ProviderUser: %s', 15, 1, @Username )

         /* Return the failure. */
         return @ReturnCode

      end

   end

   /* If Email value is not null... */
   if ( @Email is not null ) begin

      /* Generate the new contact information for the service location.  If the
         contact information already exists, it will be updated. */
      execute @ReturnCode = spCreateNewContactEmail @Email,
                                                    @ProviderUserId, 01

      /* If there was an error... */
      if ( @ReturnCode <> 00 ) begin

         /* Raise an error. */
         raiserror ( 'Error inserting email for ProviderUser: %s', 15, 1, @Username )

         /* Return the failure. */
         return @ReturnCode

      end

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spDCSRoute' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spDCSRoute

   go

create procedure spDCSRoute( @InterfaceId integer,       /* required - The Provider's interface identifier                        */
                             @ForeignId   varchar(50),   /* required - The identifier for the Route object in the foreign system  */
                             @ForeignType varchar(50),   /* optional - The table the Route object is stored in the foreign system */
                             @RouteName   varchar(50),   /* required - The name of the Route object                               */
                             @RouteId     integer output ) as

   declare @ErrorCode         integer /* Error code returned by the execution of the last statement    */
   declare @RowsAffected      integer /* Number of rows affected by the previously executed statement  */
   declare @Transactions      integer /* Number of active transactions at the start of this procedure  */
   declare @ReturnCode        integer /* Result code returned by the execution of the stored procedure */
   declare @ProviderId        integer /* The Provider's identifier                                     */
   declare @MemberGroupTypeId integer /* The Route Group Type identifier                               */
   declare @MappingEntityId   integer /* Identifier to store MAPPING_ENTITY_ID when Customer mapped    */
   declare @EntityCount       integer /* Flag to determine if the route has been mapped                */

   set nocount on

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Set @ProviderId using the @InterfaceId parameter */
   select @ProviderId = PROVIDER_ID
   from MAPPING_INTERFACE
   where ( INTERFACE_ID = @InterfaceId  )

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Raise an error. */
      raiserror ( 'InterfaceId: %s not found', 15, 1, @InterfaceId )

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* Set the @MemberGroupTypeId using the @ProviderId value */
   select @MemberGroupTypeId = MEMBER_GROUP_TYPE_ID
   from MEMBER_GROUP_TYPE
   where MEMBER_ID = @ProviderId and
         MEMBER_GROUP_TYPE_NAME = 'Routes'

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */

   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Raise an error. */
      raiserror ( 'Routes group type for ProviderId: %s not found', 15, 1, @ProviderId )

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If the foreign type was passed as a null value... */
   if ( @ForeignType is null ) begin

     /* Get the count of the mapping entity records for the route ignoring the
        empty foreign type. */
     select @EntityCount = count( MAPPING_ENTITY_ID )
     from MAPPING_ENTITY
     where ( INTERFACE_ID   = @InterfaceId )
       and ( FOREIGN_ID     = @ForeignId   )
       and ( FOREIGN_TYPE   is null        )
       and ( ENTITY_TYPE_ID = 16           )

   end

   else begin /* The foreign type is not null... */

     /* Get the count of the mapping entity records for the route taking into
        account the foreign type. */
     select @EntityCount = count( MAPPING_ENTITY_ID )
     from MAPPING_ENTITY
     where ( INTERFACE_ID   = @InterfaceId )
       and ( FOREIGN_ID     = @ForeignId   )
       and ( FOREIGN_TYPE   = @ForeignType )
       and ( ENTITY_TYPE_ID = 16           )

   end

   /* If there was an error... */
   if ( @@Error <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If Route already exists in Mapping... */
   if ( @EntityCount > 00 ) begin

      /* If the foreign type was passed as a null value... */
      if ( @ForeignType is null ) begin

        /* Get the route identifier from the mapping table ignoring the empty
           foreign type. */
         select @RouteId = ENTITY_ID
         from MAPPING_ENTITY
         where ( INTERFACE_ID   = @InterfaceId )
           and ( FOREIGN_ID     = @ForeignId   )
           and ( FOREIGN_TYPE   is null        )
           and ( ENTITY_TYPE_ID = 16           )

      end

      else begin /* The foreign type is not null... */

        /* Get the route identifier from the mapping table taking into account
           the foreign type. */
         select @RouteId = ENTITY_ID
         from MAPPING_ENTITY
         where ( INTERFACE_ID   = @InterfaceId )
           and ( FOREIGN_ID     = @ForeignId   )
           and ( FOREIGN_TYPE   = @ForeignType )
           and ( ENTITY_TYPE_ID = 16           )

      end

      /* Get the rows affected and the error code for the previous statement.
         Error checking MUST be done this way since any single statement executed
         will affect both of the global functions, @@RowCount and @@Error. */
      select @RowsAffected = @@RowCount, @ErrorCode = @@Error

      /* If there was an error... */
      if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

         /* Rollback the transaction. */
         rollback transaction

         /* Return the failure. */
         return 01

      end

      /* Update the MEMBER_GROUP table with @LogTransaction = 00 which will not
         log the change to the transaction log. */
      execute @ReturnCode = spUpdateMemberGroup @RouteId,
                                                @MemberGroupTypeId,
                                                @RouteName, 00

      /* If there was an error... */
      if ( @ReturnCode <> 00 ) begin

         /* Raise an error. */
         raiserror ( 'Error updating Route: %s', 15, 1, @RouteName )

         /* Return the failure. */
         return @ReturnCode

      end

   end

   else begin

      /* Insert into the MEMBER_GROUP table with @LogTransaction = 00 which
         will not log the change to the transaction log. */
      execute @ReturnCode = spInsertMemberGroup @MemberGroupTypeId,
                                                @RouteName,
                                                @RouteId output, 00

      /* If there was an error... */
      if ( @ReturnCode <> 00 ) begin

         /* Raise an error. */
         raiserror ( 'Error inserting Route: %s', 15, 1, @RouteName )

         /* Return the failure. */
         return @ReturnCode

      end

      /* Insert into the MAPPING_ENTITY table.  This will associate the foreign
         route data to the native data in the EyeOn database. */
      execute @ReturnCode = spInsertMappingEntity @InterfaceId,
                                                  @RouteId, 16,
                                                  @ForeignId,
                                                  @ForeignType,
                                                  @MappingEntityId

      /* If there was an error... */
      if ( @ReturnCode <> 00 ) begin

         /* Raise an error. */
         raiserror ( 'Error mapping Route: %s', 15, 1, @ForeignId )

         /* Return the failure. */
         return @ReturnCode

      end

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spDCSService' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spDCSService

   go

create procedure spDCSService( @InterfaceId         integer,      /* required - Provider's interface identifier                                                                                      */
                               @ForeignId           varchar(50),  /* required - Service identifier from foreign system, ex: ServicePro's ServiceId                                                   */
                               @ForeignType         varchar(50),  /* optional - If foreign system has different types of services stored in different tables ex: ServicePro's 'Service' or 'Request' */
                               @WorkOrderNumber     varchar(50),  /* required - Foreign system's user readable reference for service                                                                 */
                               @ServiceType         varchar(50),  /* required - Foreign system's mapped Service Type, ex: ServicePro's Service from tblSetupServices                                 */
                               @ServiceLocation     varchar(50),  /* required - Foreign system's Service Location identifier                                                                         */
                               @ScheduleDate        varchar(50),  /* required - Scheduled service date                                                                                               */
                               @ServiceDate         varchar(50),  /* optional - If is completed service, then the actual Service Date                                                                */
                               @TimeIn              varchar(50),  /* optional - If is completed service, then the Time started                                                                       */
                               @TimeOut             varchar(50),  /* optional - If is completed service, then the time completed                                                                     */
                               @Technician          varchar(50),  /* optional - If is completed service, then the technician that completed the service                                              */
                               @Route               varchar(50),  /* required - The foreign system's mapped RouteId the service is assigned to                                                       */
                               @Contact             varchar(50),  /* optional - If is completed service, then Contact person at the customer site, not used by ServicePro                            */
                               @Comments            varchar(255), /* optional - If is completed service, then the Service general comments                                                           */
                               @ProviderInputUserId integer,      /* optional - If is completed service, then the EYEON ProviderUserId for the user doing the insert/update                          */
                               @ServiceId           integer output ) as

   declare @ErrorCode                 integer /* Error code returned by the execution of the last statement                         */
   declare @RowsAffected              integer /* Number of rows affected by the previously executed statement                       */
   declare @Transactions              integer /* Number of active transactions at the start of this procedure                       */
   declare @ReturnCode                integer /* Result code returned by the execution of the stored procedure                      */
   declare @ProviderServiceTypeId     integer /* Mapped PROVIDER_SERVICE_TYPE_ID for @ServiceType parameter                         */
   declare @CustomerUnitId            integer /* Mapped CUSTOMER_UNIT_ID for @ServiceLocation parameter                             */
   declare @TechnicianId              integer /* Mapped MEMBER_USER_ID for @Technician parameter                                    */
   declare @RouteId                   integer /* Mapped MEMBER_GROUP_ID for @Route parameter                                        */
   declare @ProviderId                integer /* Provider's identifier                                                              */
   declare @CustomerId                integer /* MEMBER_ID for Service Location's customer identifier                               */
   declare @ProviderCustomerId        integer /* PROVIDER_CUSTOMER_ID for @CustomerId and @ProviderId                               */
   declare @ProviderSystemId          integer /* PROVIDER_SYSTEM_ID from @ProviderServiceTypeId                                     */
   declare @ProviderCustomerServiceId integer /* PROVIDER_CUSTOMER_SERVICE_ID for @ProviderCustomerId and @ProviderSystemId         */
   declare @CustomerUnitTypeId        integer /* CUSTOMER_UNIT_TYPE_ID for @ProviderSystemId and CUSTOMNER_UNIT_TYPE_PARENT_ID = -1 */
   declare @ComServiceId              integer /* EYEON completed service identifier                                                 */
   declare @MappingEntityId           integer /* Identifier to store MAPPING_ENTITY_ID when Customer mapped                         */
   declare @EntityCount               integer /* Flag to determine if the service has been mapped                                   */
   declare @ProviderCustomerServiceCount integer /* Flag to determine if PROVIDER_CUSTOMER_SERVICE record exists                    */
   declare @JoinCustomerUnitTypeCustomerUnitCount integer /* Flag to determine if JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT record exists */
   declare @JoinMemberGroupCustomerUnitCount integer /* Flag to determine if JOIN_MEMBER_GROUP_CUSTOMER_UNIT record exists          */
   declare @InputUserId                      integer
   declare @InputDate                        datetime
   declare @ReviewUserId                     integer
   declare @ReviewDate                       datetime

   set nocount on

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Set @ProviderId */
   select @ProviderId = PROVIDER_ID
   from MAPPING_INTERFACE
   where ( INTERFACE_ID   = @InterfaceId  )

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Raise an error. */
      raiserror ( 'InterfaceId: %s not found', 15, 1, @InterfaceId )

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* Get the PROVIDER_SERVICE_TYPE_ID from the MAPPING_ENTITY table with the
      @ServiceType parameter */
   select @ProviderServiceTypeId = ENTITY_ID
   from MAPPING_ENTITY
   where ( INTERFACE_ID   = @InterfaceId  )
     and ( FOREIGN_ID     = @ServiceType  )
     and ( ENTITY_TYPE_ID = 7             )

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Raise an error. */
      raiserror ( 'ServiceType: %s not found', 15, 1, @ServiceType )

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 02

   end

   /* Get the CUSTOMER_UNIT_ID from the MAPING_ENTITY table with the
      @ServiceLocation parameter */
   select @CustomerUnitId = ENTITY_ID
   from MAPPING_ENTITY
   where ( INTERFACE_ID   = @InterfaceId     )
     and ( FOREIGN_ID     = @ServiceLocation )
     and ( ENTITY_TYPE_ID = 5                )

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Raise an error. */
      raiserror ( 'ServiceLocation: %s not found', 15, 1, @ServiceLocation )

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 03

   end

   /* Get the MEMBER_GROUP_ID for the route from the MAPING_ENTITY table with
      the @Route parameter */
   select @RouteId = ENTITY_ID
   from MAPPING_ENTITY
   where ( INTERFACE_ID   = @InterfaceId  )
     and ( FOREIGN_ID     = @Route        )
     and ( ENTITY_TYPE_ID in ( 16, 17 )   )

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Raise an error. */
      raiserror ( 'Route: %s not found', 15, 1, @Route )

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 04

   end

   /* Set the @ProviderSystemId value used in inserts below */
   select @ProviderSystemId = PROVIDER_SYSTEM_ID
   from PROVIDER_SERVICE_TYPE
   where PROVIDER_SERVICE_TYPE_ID = @ProviderServiceTypeId

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Raise an error. */
      raiserror ( 'Error retrieving ProviderSystem for ServiceType: %s ', 15, 1, @ServiceType )

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 05

   end

   /* Set @CustomerId */
   select @CustomerId = CUSTOMER_ID
   from CUSTOMER_UNIT
   where CUSTOMER_UNIT_ID = @CustomerUnitId

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement
      executed will affect both of the global functions, @@RowCount and
      @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Raise an error. */
      raiserror ( 'Error retrieiving Customer for ServiceLocation: %s', 15, 1, @ServiceLocation )

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 13

   end

   /* Set @ProviderCustomerId */
   select @ProviderCustomerId = PROVIDER_CUSTOMER_ID
   from PROVIDER_CUSTOMER
   where ( CUSTOMER_ID = @CustomerId ) and
         ( PROVIDER_ID = @ProviderId )

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement
      executed will affect both of the global functions, @@RowCount and
      @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Raise an error. */
      raiserror ( 'Error retrieiving ProviderCustomer for ServiceLocation: %s', 15, 1, @ServiceLocation )

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 07

   end

   select @ProviderCustomerServiceCount = count(*)
   from PROVIDER_CUSTOMER_SERVICE
   where ( PROVIDER_SYSTEM_ID   = @ProviderSystemId   ) and
         ( PROVIDER_CUSTOMER_ID = @ProviderCustomerId )

   /* If there was an error... */
   if ( @@Error <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 06

   end

   if ( @ProviderCustomerServiceCount < 01 ) begin

      /* Add Customer to ProviderSystem */
      execute @ReturnCode = spInsertProviderCustomerService @ProviderCustomerId,
                                                            @ProviderSystemId,
                                                            @ProviderCustomerServiceId output

      /* If there was an error... */
      if ( @ReturnCode <> 00 ) begin

         /* Raise an error. */
         raiserror ( 'Error inserting ProviderCustomerService record', 15, 1 )

         /* Return the failure. */
         return @ReturnCode

      end

   end

   else begin

      /* Set @ProviderCustomerServiceId */
      select @ProviderCustomerServiceId = PROVIDER_CUSTOMER_SERVICE_ID
      from PROVIDER_CUSTOMER_SERVICE pcs
      where ( pcs.PROVIDER_SYSTEM_ID   = @ProviderSystemId   ) and
            ( pcs.PROVIDER_CUSTOMER_ID = @ProviderCustomerId )

      /* Get the rows affected and the error code for the previous statement.
         Error checking MUST be done this way since any single statement
         executed will affect both of the global functions, @@RowCount and
         @@Error. */
      select @RowsAffected = @@RowCount, @ErrorCode = @@Error

      /* If there was an error... */
      if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

         /* Raise an error. */
         raiserror ( 'Error retrieiving ProviderCustomerService for ServiceLocation: %s and ServiceType: %s', 15, 1, @ServiceLocation, @ServiceType )

         /* Rollback the transaction. */
         rollback transaction

         /* Return the failure. */
         return 09

      end

   end

   /* Set @CustomerUnitTypeId */
   select @CustomerUnitTypeId = CUSTOMER_UNIT_TYPE_ID
   from CUSTOMER_UNIT_TYPE
   where ( PROVIDER_SYSTEM_ID           = @ProviderSystemId )
     and ( CUSTOMER_UNIT_TYPE_PARENT_ID = -1                )

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement
      executed will affect both of the global functions, @@RowCount and
      @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Raise an error. */
      raiserror ( 'Error retrieiving CustomerUnitType', 15, 1 )

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 11

   end

   select @JoinCustomerUnitTypeCustomerUnitCount = count(*)
   from JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT
   where ( CUSTOMER_UNIT_ID      = @CustomerUnitId     )
     and ( CUSTOMER_UNIT_TYPE_ID = @CustomerUnitTypeId )


   /* If there was an error... */
   if ( @@Error <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 10

   end

   if ( @JoinCustomerUnitTypeCustomerUnitCount < 01 ) begin

      /* Add Service Location to ProviderSystem by assigning
         @CustomerUnitTypeId */
      execute @ReturnCode = spInsertJoinCustomerUnitTypeCustomerUnit @CustomerUnitTypeId,
                                                                     @CustomerUnitId,
                                                                     null

      /* If there was an error... */
      if ( @ReturnCode <> 00 ) begin

         /* Raise an error. */
         raiserror ( 'Error inserting CustomerUnitType for ServiceLocation: %s', 15, 1, @ServiceLocation )

         /* Return the failure. */
         return @ReturnCode

      end

      /* Generate default child units for Service Location based on
         ProviderSystem settings */
      execute @ReturnCode = spCreateNewCustomerUnitsByParentType @CustomerUnitTypeId,
                                                                 @CustomerUnitId,
                                                                 @CustomerId

      /* If there was an error... */
      if ( @ReturnCode <> 00 ) begin

         /* Raise an error. */
         raiserror ( 'Error creating default units for ServiceLocation: %s', 15, 1, @ServiceLocation )

         /* Return the failure. */
         return @ReturnCode

      end

   end

   select @JoinMemberGroupCustomerUnitCount = count(*)
   from JOIN_MEMBER_GROUP_CUSTOMER_UNIT
   where ( CUSTOMER_UNIT_ID = @CustomerUnitId ) and
         ( MEMBER_GROUP_ID  = @RouteId        )

   /* If there was an error... */
   if ( @@Error <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 15

   end

   if ( @JoinMemberGroupCustomerUnitCount < 01 ) begin

      /* Assign ServiceLocation to Route */
      execute @ReturnCode = spInsertJoinMemberGroupCustomerUnit @RouteId,
                                                                @CustomerUnitId

      /* If there was an error... */
      if ( @ReturnCode <> 00 ) begin

         /* Raise an error. */
         raiserror ( 'Error assigning route for ServiceLocation: %s', 15, 1, @ServiceLocation )

         /* Return the failure. */
         return @ReturnCode

      end

   end

   /* If the foreign type was passed as a null value... */
   if ( @ForeignType is null ) begin

     /* Get the count of the mapping entity records for the service ignoring
        the empty foreign type. */
     select @EntityCount = count( MAPPING_ENTITY_ID )
     from MAPPING_ENTITY
     where ( INTERFACE_ID   = @InterfaceId )
       and ( FOREIGN_ID     = @ForeignId   )
       and ( FOREIGN_TYPE   is null        )
       and ( ENTITY_TYPE_ID = 12           )

   end

   else begin /* The foreign type is not null... */

     /* Get the count of the mapping entity records for the service taking into
        account the foreign type. */
     select @EntityCount = count( MAPPING_ENTITY_ID )
     from MAPPING_ENTITY
     where ( INTERFACE_ID   = @InterfaceId )
       and ( FOREIGN_ID     = @ForeignId   )
       and ( FOREIGN_TYPE   = @ForeignType )
       and ( ENTITY_TYPE_ID = 12           )

   end

   /* If there was an error... */
   if ( @@Error <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 17

   end

   /* If Service already exists in Mapping... */
   if ( @EntityCount > 00 ) begin

      /* If the foreign type was passed as a null value... */
      if ( @ForeignType is null ) begin

        /* Get the service identifier from the mapping table ignoring the empty
           foreign type. */
         select @ServiceId = ENTITY_ID
         from MAPPING_ENTITY
         where ( INTERFACE_ID   = @InterfaceId )
           and ( FOREIGN_ID     = @ForeignId   )
           and ( FOREIGN_TYPE   is null        )
           and ( ENTITY_TYPE_ID = 12           )

      end

      else begin /* The foreign type is not null... */

        /* Get the service identifier from the mapping table taking into
           account the foreign type. */
         select @ServiceId = ENTITY_ID
         from MAPPING_ENTITY
         where ( INTERFACE_ID   = @InterfaceId )
           and ( FOREIGN_ID     = @ForeignId   )
           and ( FOREIGN_TYPE   = @ForeignType )
           and ( ENTITY_TYPE_ID = 12           )

      end

      /* Get the rows affected and the error code for the previous statement.
         Error checking MUST be done this way since any single statement
         executed will affect both of the global functions, @@RowCount and
         @@Error. */
      select @RowsAffected = @@RowCount, @ErrorCode = @@Error

      /* If there was an error... */
      if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

         /* Raise an error. */
         raiserror ( 'Error retrieiving mapped service: %s', 15, 1, @ForeignId )

         /* Rollback the transaction. */
         rollback transaction

         /* Return the failure. */
         return 18

      end

      /* Set @ComServiceId if service is completed */
      select @ComServiceId = COM_SERVICE_ID
      from PROVIDER_CUSTOMER_SERVICE_SCHEDULE
      where PROVIDER_CUSTOMER_SERVICE_SCHEDULE_ID = @ServiceId

      /* If there was an error... */
      if ( @@Error <> 00 ) begin

         /* Raise an error. */
         raiserror ( 'Error retrieiving completed service', 15, 1 )

         /* Rollback the transaction. */
         rollback transaction

         /* Return the failure. */
         return 19

      end

      /* if @ComServiceId is null, then see if a record already exists
         that meets the unique index requirements */
      if ( @ComServiceId is null ) begin

         select @ComServiceId = com_service_id
         from com_service
		 where com_service_date               = @ServiceDate
		   and customer_unit_id               = @CustomerUnitId
		   and provider_service_type_id       = @ProviderServiceTypeId
           and technician_id                  = @TechnicianId
           and ( ( DATEDIFF(hh, convert(varchar(08), TIME_IN, 08), @TimeIn) = 00 ) and ( DATEDIFF(mi, convert(varchar(08), TIME_IN, 08), @TimeIn) = 00 ) )

	     /* If there was an error... */
		 if ( @@Error <> 00 ) begin

		    /* Raise an error. */
	        raiserror ( 'Error retrieiving completed service', 15, 1 )

		    /* Rollback the transaction. */
			rollback transaction

            /* Return the failure. */
		    return 19

		 end

      end

      /* Get the MEMBER_USER_ID for the technician from the MAPING_ENTITY table
         with the @Technician parameter */
      select @TechnicianId = ENTITY_ID
      from MAPPING_ENTITY
      where ( INTERFACE_ID   = @InterfaceId  )
        and ( FOREIGN_ID     = @Technician   )
        and ( ENTITY_TYPE_ID = 1             )

      /* If there was an error... */
      if ( @@Error <> 00 ) begin

         /* Raise an error. */
         raiserror ( 'Error retrieiving mapped technician: %s', 15, 1, @Technician )

         /* Rollback the transaction. */
         rollback transaction

         /* Return the failure. */
         return 20

      end

      /* If @ComserviceId is NULL and @ServiceDate is not NULL, then insert a
         COM_SERVICE record */
      if ( @ServiceDate is not null ) begin

         if ( @ComServiceId is null ) begin

            select @InputDate = getdate()

            /* Add completed service record */
            execute @ReturnCode = spInsertComService @ServiceDate,
                                                     @CustomerUnitId,
                                                     @ProviderServiceTypeId,
                                                     @TimeIn,
                                                     @TimeOut,
                                                     @TechnicianId,
                                                     @Contact,
                                                     @Comments,
                                                     @ProviderInputUserId,
                                                     @InputDate,
                                                     null,
                                                     null,
                                                     @ComServiceId output

            /* If there was an error... */
            if ( @ReturnCode <> 00 ) begin

               /* Raise an error. */
               raiserror ( 'Error inserting service', 15, 1 )

               /* Return the failure. */
               return @ReturnCode

            end

         end

         else begin

            declare @OldTimeIn datetime
            declare @OldTimeOut datetime
            select @OldTimeIn    = TIME_IN,
                   @OldTimeOut   = TIME_OUT,
                   @InputUserId  = PROVIDER_INPUT_USER_ID,
                   @InputDate    = PROVIDER_INPUT_DATE,
                   @ReviewUserId = REVIEW_USER_ID,
                   @ReviewDate   = REVIEW_DATE
            from COM_SERVICE
            where COM_SERVICE_ID = @ComServiceId

            declare @hours integer
            declare @minutes integer
            set @hours = DATEDIFF(hh, convert(varchar(50), @OldTimeIn, 08), @TimeIn)
            set @minutes = DATEDIFF(mi, convert(varchar(50), @OldTimeIn, 08), @TimeIn)
            /* If the @TimeIn and @TimeOut are 00:00:00 then retain the existing values from the original record */
            /* If the @TimeIn hh:mi are equal then retain the existing values from the original record */
            if ( ( @TimeIn = '00:00:00' ) and ( @TimeOut = '00:00:00' ) ) or
               ( ( @hours = 00 ) and ( @minutes = 00 ) ) begin
               set @TimeIn = @OldTimeIn
               set @TimeOut = @OldTimeOut
            end

            /* Update existing completed service record */
            execute @ReturnCode = spUpdateComService @ComServiceId,
                                                     @ServiceDate,
                                                     @CustomerUnitId,
                                                     @ProviderServiceTypeId,
                                                     @TimeIn,
                                                     @TimeOut,
                                                     @TechnicianId,
                                                     @Contact,
                                                     @Comments,
                                                     @InputUserId,
                                                     @InputDate,
                                                     @ReviewUserId,
                                                     @ReviewDate

            /* If there was an error... */
            if ( @ReturnCode <> 00 ) begin

               /* Raise an error. */
               raiserror ( 'Error updating service', 15, 1 )

               /* Return the failure. */
               return @ReturnCode

            end

         end

      end

      if not exists (
         select *
         from provider_customer_service_schedule
         where provider_service_type_id = @ProviderServiceTypeId
           and customer_unit_id = @CustomerUnitId
           and provider_customer_service_schedule_date = @ScheduleDate ) begin

         /* Update the PROVIDER_CUSTOMER_SERVICE_SCHEDULE table with
            @LogTransaction = 00 which will not log the change to the transaction
            log. */
         execute @ReturnCode = spUpdateProviderCustomerServiceSchedule @ServiceId,
                                                                       @ProviderCustomerServiceId,
                                                                       @ProviderServiceTypeId,
                                                                       @CustomerUnitId,
                                                                       @ScheduleDate,
                                                                       @ComServiceId,
                                                                       @WorkOrderNumber, 00

         /* If there was an error... */
         if ( @ReturnCode <> 00 ) begin

            /* Raise an error. */
            raiserror ( 'Error updating scheduled service', 15, 1 )

            /* Return the failure. */
            return @ReturnCode

         end

      end

   end

   else begin

      /* If @ComserviceId is NULL and @ServiceDate is not NULL, then insert a
         COM_SERVICE record */
      if ( @ServiceDate is not null ) begin

         /* Get the MEMBER_USER_ID for the technician from the MAPING_ENTITY
            table with the @Technician parameter */
         select @TechnicianId = ENTITY_ID
         from MAPPING_ENTITY
         where ( INTERFACE_ID   = @InterfaceId  )
           and ( FOREIGN_ID     = @Technician   )
           and ( ENTITY_TYPE_ID = 1             )

         /* Get the rows affected and the error code for the previous statement.
            Error checking MUST be done this way since any single statement executed
            will affect both of the global functions, @@RowCount and @@Error. */
         select @RowsAffected = @@RowCount, @ErrorCode = @@Error

         /* If there was an error... */
         if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

            /* Raise an error. */
            raiserror ( 'Error retreiving mapped technician: %s', 15, 1, @Technician )

            /* Rollback the transaction. */
            rollback transaction

            /* Return the failure. */
            return 24

         end

         select @ComServiceId = com_service_id
         from com_service
		 where com_service_date               = @ServiceDate
		   and customer_unit_id               = @CustomerUnitId
		   and provider_service_type_id       = @ProviderServiceTypeId
           and technician_id                  = @TechnicianId
           and ( ( DATEDIFF(hh, convert(varchar(08), TIME_IN, 08), @TimeIn) = 00 ) and ( DATEDIFF(mi, convert(varchar(08), TIME_IN, 08), @TimeIn) = 00 ) )

	     /* If there was an error... */
		 if ( @@Error <> 00 ) begin

		    /* Raise an error. */
	        raiserror ( 'Error retrieiving completed service', 15, 1 )

		    /* Rollback the transaction. */
			rollback transaction

            /* Return the failure. */
		    return 19

		 end

         if ( @ComServiceId is null ) begin

            /* Add completed service record */
            execute @ReturnCode = spInsertComService @ServiceDate,
                                                     @CustomerUnitId,
                                                     @ProviderServiceTypeId,
                                                     @TimeIn,
                                                     @TimeOut,
                                                     @TechnicianId,
                                                     @Contact,
                                                     @Comments,
                                                     @ProviderInputUserId,
                                                     null,
                                                     null,
                                                     null,
                                                     @ComServiceId output

            /* If there was an error... */
            if ( @ReturnCode <> 00 ) begin

               /* Raise an error. */
               raiserror ( 'Error inserting service', 15, 1 )

               /* Return the failure. */
               return @ReturnCode

            end

         end

      end

      select @ServiceId = provider_customer_service_schedule_id
      from provider_customer_service_schedule
      where provider_service_type_id = @ProviderServiceTypeId
        and customer_unit_id = @CustomerUnitId
        and provider_customer_service_schedule_date = @ScheduleDate

      if ( @ServiceId is null ) begin

         /* Insert into the PROVIDER_CUSTOMER_SERVICE_SCHEDULE table with
            @LogTransaction = 00 which will not log the change to the transaction
            log. */
         execute @ReturnCode = spInsertProviderCustomerServiceSchedule @ProviderCustomerServiceId,
                                                                       @ProviderServiceTypeId,
                                                                       @CustomerUnitId,
                                                                       @ScheduleDate,
                                                                       @ComServiceId,
                                                                       @WorkOrderNumber,
                                                                       @ServiceId output, 00

         /* If there was an error... */
         if ( @ReturnCode <> 00 ) begin

            /* Raise an error. */
            raiserror ( 'Error inserting scheduled service', 15, 1 )

            /* Return the failure. */
            return @ReturnCode

         end

      end

      else begin

         /* Update the PROVIDER_CUSTOMER_SERVICE_SCHEDULE table with
            @LogTransaction = 00 which will not log the change to the transaction
            log. */
         execute @ReturnCode = spUpdateProviderCustomerServiceSchedule @ServiceId,
                                                                       @ProviderCustomerServiceId,
                                                                       @ProviderServiceTypeId,
                                                                       @CustomerUnitId,
                                                                       @ScheduleDate,
                                                                       @ComServiceId,
                                                                       @WorkOrderNumber, 00

         /* If there was an error... */
         if ( @ReturnCode <> 00 ) begin

            /* Raise an error. */
            raiserror ( 'Error updating scheduled service', 15, 1 )

            /* Return the failure. */
            return @ReturnCode

         end

      end

      /* Insert into the MAPPING_ENTITY table.  This will associate the foreign
         servicee data to the native data in the EyeOn database. */
      execute @ReturnCode = spInsertMappingEntity @InterfaceId,
                                                  @ServiceId, 12,
                                                  @ForeignId,
                                                  @ForeignType,
                                                  @MappingEntityId

      /* If there was an error... */
      if ( @ReturnCode <> 00 ) begin

         /* Raise an error. */
         raiserror ( 'Error inserting scheduled service mapping: %s', 15, 1, @ForeignId )

         /* Return the failure. */
         return @ReturnCode

      end

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spDCSServiceAmount' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spDCSServiceAmount

   go

create procedure spDCSServiceAmount( @InterfaceId         integer,      /* required - Provider's interface identifier                                                                                       */
                                     @ForeignId           varchar(50),  /* required - Service amount identifier from foreign system, ex: ServicePro's ServiceLocationId                                     */
                                     @ForeignType         varchar(50),  /* optional - If foreign system has different types of services this is service type ex: ServicePro's Service from tblSetupServices */
                                     @ServiceLocation     varchar(50),  /* required - Foreign system's Service Location identifier                                                                          */
                                     @ServiceType         varchar(50),  /* required - Foreign system's mapped Service Type, ex: ServicePro's Service from tblSetupServices                                  */
                                     @ServiceAmount       varchar(50),  /* required - Foreign system's service amount, ex: ServicePro's SaleAmount from tblMainServices                                     */
                                     @ServiceAmountId     integer output ) as

   declare @ErrorCode                 integer /* Error code returned by the execution of the last statement                         */
   declare @RowsAffected              integer /* Number of rows affected by the previously executed statement                       */
   declare @Transactions              integer /* Number of active transactions at the start of this procedure                       */
   declare @ReturnCode                integer /* Result code returned by the execution of the stored procedure                      */
   declare @ProviderServiceTypeId     integer /* Mapped PROVIDER_SERVICE_TYPE_ID for @ServiceType parameter                         */
   declare @CustomerUnitId            integer /* Mapped CUSTOMER_UNIT_ID for @ServiceLocation parameter                             */
   declare @ProviderId                integer /* Provider's identifier                                                              */
   declare @CustomerId                integer /* MEMBER_ID for Service Location's customer identifier                               */
   declare @ProviderCustomerId        integer /* PROVIDER_CUSTOMER_ID for @CustomerId and @ProviderId                               */
   declare @ProviderSystemId          integer /* PROVIDER_SYSTEM_ID from @ProviderServiceTypeId                                     */
   declare @ProviderCustomerServiceId integer /* PROVIDER_CUSTOMER_SERVICE_ID for @ProviderCustomerId and @ProviderSystemId         */
   declare @MappingEntityId           integer /* Identifier to store MAPPING_ENTITY_ID when Customer mapped                         */
   declare @EntityCount               integer /* Flag to determine if the service has been mapped                                   */
   declare @ProviderCustomerServiceCount integer /* Flag to determine if PROVIDER_CUSTOMER_SERVICE record exists                    */

   set nocount on

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Set @ProviderId */
   select @ProviderId = PROVIDER_ID
   from MAPPING_INTERFACE
   where ( INTERFACE_ID   = @InterfaceId  )

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Raise an error. */
      raiserror ( 'InterfaceId: %s not found', 15, 1, @InterfaceId )

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* Get the PROVIDER_SERVICE_TYPE_ID from the MAPPING_ENTITY table with the
      @ServiceType parameter */
   select @ProviderServiceTypeId = ENTITY_ID
   from MAPPING_ENTITY
   where ( INTERFACE_ID   = @InterfaceId  )
     and ( FOREIGN_ID     = @ServiceType  )
     and ( ENTITY_TYPE_ID = 7             )

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Raise an error. */
      raiserror ( 'ServiceType: %s not found', 15, 1, @ServiceType )

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 02

   end

   /* Get the CUSTOMER_UNIT_ID from the MAPING_ENTITY table with the
      @ServiceLocation parameter */
   select @CustomerUnitId = ENTITY_ID
   from MAPPING_ENTITY
   where ( INTERFACE_ID   = @InterfaceId     )
     and ( FOREIGN_ID     = @ServiceLocation )
     and ( ENTITY_TYPE_ID = 5                )

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Raise an error. */
      raiserror ( 'ServiceLocation: %s not found', 15, 1, @ServiceLocation )

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 03

   end

   /* Set the @ProviderSystemId value used in inserts below */
   select @ProviderSystemId = PROVIDER_SYSTEM_ID
   from PROVIDER_SERVICE_TYPE
   where ( PROVIDER_SERVICE_TYPE_ID = @ProviderServiceTypeId )

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Raise an error. */
      raiserror ( 'Error retrieving ProviderSystem for ServiceType: %s ', 15, 1, @ServiceType )

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 05

   end

   /* Set @CustomerId */
   select @CustomerId = CUSTOMER_ID
   from CUSTOMER_UNIT
   where ( CUSTOMER_UNIT_ID = @CustomerUnitId )

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement
      executed will affect both of the global functions, @@RowCount and
      @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Raise an error. */
      raiserror ( 'Error retrieiving Customer for ServiceLocation: %s', 15, 1, @ServiceLocation )

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 13

   end

   /* Set @ProviderCustomerId */
   select @ProviderCustomerId = PROVIDER_CUSTOMER_ID
   from PROVIDER_CUSTOMER pc
   where ( pc.CUSTOMER_ID = @CustomerId ) and
         ( pc.PROVIDER_ID = @ProviderId )

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement
      executed will affect both of the global functions, @@RowCount and
      @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Raise an error. */
      raiserror ( 'Error retrieiving ProviderCustomer for ServiceLocation: %s', 15, 1, @ServiceLocation )

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 07

   end

   select @ProviderCustomerServiceCount = count(*)
   from PROVIDER_CUSTOMER_SERVICE pcs
   where ( pcs.PROVIDER_SYSTEM_ID   = @ProviderSystemId   ) and
         ( pcs.PROVIDER_CUSTOMER_ID = @ProviderCustomerId )

   /* If there was an error... */
   if ( @@Error <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 06

   end

   if ( @ProviderCustomerServiceCount < 01 ) begin

      /* Add Customer to ProviderSystem */
      execute @ReturnCode = spInsertProviderCustomerService @ProviderCustomerId,
                                                            @ProviderSystemId,
                                                            @ProviderCustomerServiceId output

      /* If there was an error... */
      if ( @ReturnCode <> 00 ) begin

         /* Raise an error. */
         raiserror ( 'Error inserting ProviderCustomerService record', 15, 1 )

         /* Return the failure. */
         return @ReturnCode

      end

   end

   else begin

      /* Set @ProviderCustomerServiceId */
      select @ProviderCustomerServiceId = PROVIDER_CUSTOMER_SERVICE_ID
      from PROVIDER_CUSTOMER_SERVICE pcs
      where ( pcs.PROVIDER_SYSTEM_ID   = @ProviderSystemId   ) and
            ( pcs.PROVIDER_CUSTOMER_ID = @ProviderCustomerId )

      /* Get the rows affected and the error code for the previous statement.
         Error checking MUST be done this way since any single statement
         executed will affect both of the global functions, @@RowCount and
         @@Error. */
      select @RowsAffected = @@RowCount, @ErrorCode = @@Error

      /* If there was an error... */
      if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

         /* Raise an error. */
         raiserror ( 'Error retrieiving ProviderCustomerService for ServiceLocation: %s and ServiceType: %s', 15, 1, @ServiceLocation, @ServiceType )

         /* Rollback the transaction. */
         rollback transaction

         /* Return the failure. */
         return 09

      end

   end

   /* If the foreign type was passed as a null value... */
   if ( @ForeignType is null ) begin

     /* Get the count of the mapping entity records for the service ignoring
        the empty foreign type. */
     select @EntityCount = count( MAPPING_ENTITY_ID )
     from MAPPING_ENTITY
     where ( INTERFACE_ID   = @InterfaceId )
       and ( FOREIGN_ID     = @ForeignId   )
       and ( FOREIGN_TYPE   is null        )
       and ( ENTITY_TYPE_ID = 14           )

   end

   else begin /* The foreign type is not null... */

     /* Get the count of the mapping entity records for the service taking into
        account the foreign type. */
     select @EntityCount = count( MAPPING_ENTITY_ID )
     from MAPPING_ENTITY
     where ( INTERFACE_ID   = @InterfaceId )
       and ( FOREIGN_ID     = @ForeignId   )
       and ( FOREIGN_TYPE   = @ForeignType )
       and ( ENTITY_TYPE_ID = 14           )

   end

   /* If there was an error... */
   if ( @@Error <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 17

   end

   /* If Service already exists in Mapping... */
   if ( @EntityCount > 00 ) begin

      /* If the foreign type was passed as a null value... */
      if ( @ForeignType is null ) begin

        /* Get the service identifier from the mapping table ignoring the empty
           foreign type. */
         select @ServiceAmountId = ENTITY_ID
         from MAPPING_ENTITY
         where ( INTERFACE_ID   = @InterfaceId )
           and ( FOREIGN_ID     = @ForeignId   )
           and ( FOREIGN_TYPE   is null        )
           and ( ENTITY_TYPE_ID = 14           )

      end

      else begin /* The foreign type is not null... */

        /* Get the service identifier from the mapping table taking into
           account the foreign type. */
         select @ServiceAmountId = ENTITY_ID
         from MAPPING_ENTITY
         where ( INTERFACE_ID   = @InterfaceId )
           and ( FOREIGN_ID     = @ForeignId   )
           and ( FOREIGN_TYPE   = @ForeignType )
           and ( ENTITY_TYPE_ID = 14           )

      end

      /* Get the rows affected and the error code for the previous statement.
         Error checking MUST be done this way since any single statement
         executed will affect both of the global functions, @@RowCount and
         @@Error. */
      select @RowsAffected = @@RowCount, @ErrorCode = @@Error

      /* If there was an error... */
      if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

         /* Raise an error. */
         raiserror ( 'Error retrieiving mapped service amount: %s', 15, 1, @ForeignId )

         /* Rollback the transaction. */
         rollback transaction

         /* Return the failure. */
         return 18

      end

      /* Update the PROVIDER_CUSTOMER_SERVICE_FINANCIAL table with
         @LogTransaction = 00 which will not log the change to the transaction
         log. */
      execute @ReturnCode = spUpdateProviderCustomerServiceFinancial @ServiceAmountId,
                                                                     @ProviderCustomerServiceId,
                                                                     @ProviderServiceTypeId,
                                                                     @CustomerUnitId,
                                                                     @ServiceAmount, 00

      /* If there was an error... */
      if ( @ReturnCode <> 00 ) begin

         /* Raise an error. */
         raiserror ( 'Error updating service amount', 15, 1 )

         /* Return the failure. */
         return @ReturnCode

      end

   end

   else begin

      /* Insert into the PROVIDER_CUSTOMER_SERVICE_FINANCIAL table with
         @LogTransaction = 00 which will not log the change to the transaction
         log. */
      execute @ReturnCode = spInsertProviderCustomerServiceFinancial @ProviderCustomerServiceId,
                                                                     @ProviderServiceTypeId,
                                                                     @CustomerUnitId,
                                                                     @ServiceAmount,
                                                                     @ServiceAmountId output, 00

      /* If there was an error... */
      if ( @ReturnCode <> 00 ) begin

         /* Raise an error. */
         raiserror ( 'Error inserting service amount', 15, 1 )

         /* Return the failure. */
         return @ReturnCode

      end

      /* Insert into the MAPPING_ENTITY table.  This will associate the foreign
         servicee data to the native data in the EyeOn database. */
      execute @ReturnCode = spInsertMappingEntity @InterfaceId,
                                                  @ServiceAmountId, 14,
                                                  @ForeignId,
                                                  @ForeignType,
                                                  @MappingEntityId

      /* If there was an error... */
      if ( @ReturnCode <> 00 ) begin

         /* Raise an error. */
         raiserror ( 'Error inserting service amount mapping: %s', 15, 1, @ForeignId )

         /* Return the failure. */
         return @ReturnCode

      end

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spDCSServiceDetail' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spDCSServiceDetail

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spDCSServiceDetail' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spDCSServiceDetail

   go

create procedure spDCSServiceDetail( @InterfaceId     integer,       /* required - Provider's Interface identifier                                           */
                                     @ForeignId       varchar(50),   /* required - Foreign identifier for the ServiceDetailId                                */
                                     @ForeignType     varchar(50),   /* optional - For ServicePro, should contain the character 'S' or 'R' and the ServiceId */
                                     @ServiceId       varchar(50),   /* required - Foreign identifier for the ServiceId                                      */
                                     @DetailData      varchar(8000), /* required - Service Detail Data formatted as comma delimitted, name=value pairs       */
                                     @ServiceDetailId integer output ) as

   declare @ErrorCode                         integer /* Error code returned by the execution of the last statement    */
   declare @RowsAffected                      integer /* Number of rows affected by the previously executed statement  */
   declare @Transactions                      integer /* Number of active transactions at the start of this procedure  */
   declare @ReturnCode                        integer /* Result code returned by the execution of the stored procedure */
   declare @ProviderCustomerServiceScheduleId integer
   declare @ComServiceId                      integer
   declare @CustomerUnitId                    integer
   declare @MappingEntityId                   integer /* Identifier to store MAPPING_ENTITY_ID when Customer mapped    */
   declare @ProviderServiceDataTypeId         integer
   declare @ProviderServiceDataId             integer
   declare @DataId                            varchar(50)
   declare @RowId                             integer
   declare @ComServiceDataId                  integer
   declare @DataType                          varchar(50)
   declare @DetailDataItem                    varchar(50)
   declare @ComServiceUnitValueId             integer
   declare @EntityCount                       integer /* Flag to determine if the service location has been mapped     */
   declare @DataTypeList                      varchar(8000)
   declare @ParsedList                        table( DataType   varchar(50), DetailData varchar(255) )
   declare @DataTypeVar                       varchar(50)
   declare @DetailDataVar                     varchar(255)
   declare @Pos                               integer
   declare @Equal                             integer

   set nocount on

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Parse the @DetailData parameter into a table variable @ParsedList */
   set @DataTypeList = ltrim( rtrim( @DetailData ) ) + ';'
   set @Pos = charindex( ';', @DataTypeList, 1 )
   if replace( @DataTypeList, ';', '' ) <> '' begin
      while @Pos > 0 begin
         set @DataTypeVar = ltrim( rtrim( left( @DataTypeList, @Pos - 1 ) ) )
         set @Equal = charindex( '=', @DataTypeVar, 1 )
         set @DetailDataVar = ltrim( rtrim( right( @DataTypeVar, len( @DataTypeVar ) - @Equal ) ) )
         set @DataTypeVar = ltrim( rtrim( left( @DataTypeVar, @Equal - 1 ) ) )
         if @DataTypeVar <> '' begin
            insert into @ParsedList ( DataType, DetailData )
            values ( @DataTypeVar, @DetailDataVar )
         end
         set @DataTypeList = right( @DataTypeList, len( @DataTypeList ) - @Pos )
         set @Pos = charindex( ';', @DataTypeList, 1 )
      end
   end

   /* Get the PROVIDER_CUSTOMER_SERVICE_SCHEDULE_ID from the MAPING_ENTITY
      table with the @ServiceId parameter */
   select @ProviderCustomerServiceScheduleId = ENTITY_ID
   from MAPPING_ENTITY
   where ( INTERFACE_ID   = @InterfaceId  )
     and ( FOREIGN_ID     = @ServiceId    )
     and ( ENTITY_TYPE_ID = 12            )


   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Raise an exception to be returned to the client */
      raiserror ( 'ServiceId: %s does not exist in the mapping table.', 15, 1, @ServiceId )

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* Get the COM_SERVICE_ID from the PROVIDER_CUSTOMER_SERVICE_SCHEDULE table with the @ProviderCustomerServiceScheduleId variable */
   select @ComServiceId = COM_SERVICE_ID
   from PROVIDER_CUSTOMER_SERVICE_SCHEDULE
   where ( PROVIDER_CUSTOMER_SERVICE_SCHEDULE_ID = @ProviderCustomerServiceScheduleId     )

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Raise an exception to be returned to the client */
      raiserror ( 'No completed service found for ServiceId: %s does not exist in the mapping table.', 15, 1, @ServiceId )

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If the foreign type was passed as a null value... */
   if ( @ForeignType is null ) begin

     /* Get the count of the mapping entity records for the service detail
        ignoring the empty foreign type. */
     select @EntityCount = count( MAPPING_ENTITY_ID )
     from MAPPING_ENTITY
     where ( INTERFACE_ID   = @InterfaceId )
       and ( FOREIGN_ID     = @ForeignId   )
       and ( FOREIGN_TYPE   is null        )
       and ( ENTITY_TYPE_ID = 13           )

   end

   else begin /* The foreign type is not null... */

     /* Get the count of the mapping entity records for the service detail
        taking into account the foreign type. */
     select @EntityCount = count( MAPPING_ENTITY_ID )
     from MAPPING_ENTITY
     where ( INTERFACE_ID   = @InterfaceId )
       and ( FOREIGN_ID     = @ForeignId   )
       and ( FOREIGN_TYPE   = @ForeignType )
       and ( ENTITY_TYPE_ID = 13           )

   end

   /* If there was an error... */
   if ( @@Error <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If Service Detail already exists in Mapping... */
   if ( @EntityCount > 00 ) begin

      /* If the foreign type was passed as a null value... */
      if ( @ForeignType is null ) begin

        /* Get the service detail identifier from the mapping table ignoring
           the empty foreign type. */
         select @ServiceDetailId = ENTITY_ID
         from MAPPING_ENTITY
         where ( INTERFACE_ID   = @InterfaceId )
           and ( FOREIGN_ID     = @ForeignId   )
           and ( FOREIGN_TYPE   is null        )
           and ( ENTITY_TYPE_ID = 13           )

      end

      else begin /* The foreign type is not null... */

        /* Get the service detail identifier from the mapping table taking
           into account the foreign type. */
         select @ServiceDetailId = ENTITY_ID
         from MAPPING_ENTITY
         where ( INTERFACE_ID   = @InterfaceId )
           and ( FOREIGN_ID     = @ForeignId   )
           and ( FOREIGN_TYPE   = @ForeignType )
           and ( ENTITY_TYPE_ID = 13           )

      end

      /* Get the rows affected and the error code for the previous statement.
         Error checking MUST be done this way since any single statement executed
         will affect both of the global functions, @@RowCount and @@Error. */
      select @RowsAffected = @@RowCount, @ErrorCode = @@Error

      /* If there was an error... */
      if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

         /* Raise an exception to be returned to the client */
         raiserror ( 'Error retrieving ServiceDetailId: %s from the mapping table.', 15, 1, @ForeignId )

         /* Rollback the transaction. */
         rollback transaction

         /* Return the failure. */
         return 01

      end

      select distinct @ComServiceUnitValueId = csuv.com_service_unit_value_id, @RowId = ROW_ID
      from com_service_unit_value csuv, com_service_data csd
      where com_service_id = @ComServiceId
        and csuv.com_service_unit_value_id = csd.com_service_unit_value_id
        and csuv.com_service_unit_value_id = left(@ServiceDetailId, len(csuv.com_service_unit_value_id))
        and csd.row_id = right(@ServiceDetailId, len(@ServiceDetailId) - len(csuv.com_service_unit_value_id))

      /* Get the rows affected and the error code for the previous statement.
         Error checking MUST be done this way since any single statement executed
         will affect both of the global functions, @@RowCount and @@Error. */
      select @RowsAffected = @@RowCount, @ErrorCode = @@Error

      /* If there was an error... */
      if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

         /* Raise an exception to be returned to the client */
         raiserror ( 'Error retrieving ServiceDetailId: %s from the ServiceDetail table.', 15, 1, @ServiceDetailId )

         /* Rollback the transaction. */
         rollback transaction

         /* Return the failure. */
         return 01

      end

      select @CustomerUnitId = CUSTOMER_UNIT_ID
      from COM_SERVICE_UNIT_VALUE
      where COM_SERVICE_UNIT_VALUE_ID = @ComServiceUnitValueId

      /* Get the rows affected and the error code for the previous statement.
         Error checking MUST be done this way since any single statement executed
         will affect both of the global functions, @@RowCount and @@Error. */
      select @RowsAffected = @@RowCount, @ErrorCode = @@Error

      /* If there was an error... */
      if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

         /* Raise an exception to be returned to the client */
         raiserror ( 'Error retrieving CustomerUnitId from the ServiceDetail table for ServiceDetailId: %s.', 15, 1, @ServiceDetailId )

         /* Rollback the transaction. */
         rollback transaction

         /* Return the failure. */
         return 01

      end

      execute @ReturnCode = spUpdateComServiceUnitValue @ComServiceUnitValueId,
                                                        @ComServiceId,
                                                        null,
                                                        @CustomerUnitId,
                                                        null, 00

      /* If there was an error... */
      if ( @ReturnCode <> 00 ) begin

         /* Raise an exception to be returned to the client */
         raiserror ( 'Error updating ServiceDetail: %s.', 15, 1, @ServiceDetailId )

         /* Return the failure. */
         return @ReturnCode

      end

      /* Iterate over the @ParsedList table variable */
      declare data_cursor cursor for
      select DataType, DetailData
      from @ParsedList
      open data_cursor
      fetch next from data_cursor into
      @DataType, @DetailDataItem
      while ( @@fetch_status = 0 ) begin

         /* If the current @DataType variable is mapped to a PROVIDER_SERVICE_DATA_TYPE_ID */
         if exists (
            select *
            from MAPPING_ENTITY
            where ( INTERFACE_ID = @InterfaceId )
              and ( ENTITY_TYPE_ID = 9 )
              and ( FOREIGN_ID = @DataType ) ) begin

            /* If there was an error... */
            if ( @@Error <> 00 ) begin

               /* Raise an exception to be returned to the client */
               raiserror ( 'Error retrieving mapped DataType: %s', 15, 1, @DataType )

               /* Rollback the transaction. */
               rollback transaction

               /* close and deallocate the cursor */
               close data_cursor
               deallocate data_cursor

               /* Return the failure. */
               return 01

            end

            /* Assign the mapped entity_id to the @ProviderServiceDataTypeId variable */
            /* Assign the mapped foreign_type to the @DataId variable */
            select @ProviderServiceDataTypeId = ENTITY_ID, @DataId = FOREIGN_TYPE
            from MAPPING_ENTITY
            where ( INTERFACE_ID = @InterfaceId )
              and ( ENTITY_TYPE_ID = 9 )
              and ( FOREIGN_ID = @DataType )

            /* Get the rows affected and the error code for the previous statement.
               Error checking MUST be done this way since any single statement executed
               will affect both of the global functions, @@RowCount and @@Error. */
            select @RowsAffected = @@RowCount, @ErrorCode = @@Error

            /* If there was an error... */
            if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

               /* Raise an exception to be returned to the client */
               raiserror ( 'Error retrieving native DataType: %s', 15, 1, @DataType )

               /* Rollback the transaction. */
               rollback transaction

               /* close and deallocate the cursor */
               close data_cursor
               deallocate data_cursor

               /* Return the failure. */
               return 01

            end

            if ( @DataId is not null ) begin

               select @ProviderServiceDataId = ENTITY_ID
               from MAPPING_ENTITY me
               inner join @ParsedList dd on me.FOREIGN_ID = dd.DetailData
               where ( INTERFACE_ID = @InterfaceId )
                 and ( ENTITY_TYPE_ID = 10 )
                 and ( FOREIGN_TYPE = @DataId )

               /* If there was an error... */
               if ( @@Error <> 00 ) begin

                  /* Raise an exception to be returned to the client */
                  raiserror ( 'Error retrieving mapped Data: %s', 15, 1, @DataId )

                  /* Rollback the transaction. */
                  rollback transaction

                  /* close and deallocate the cursor */
                  close data_cursor
                  deallocate data_cursor

                  /* Return the failure. */
                  return 01

               end

            end

            else set @ProviderServiceDataId = null

            if exists (
               select *
               from COM_SERVICE_DATA
               where PROVIDER_SERVICE_DATA_TYPE_ID = @ProviderServiceDataTypeId
                 and COM_SERVICE_UNIT_VALUE_ID = @ComServiceUnitValueId
                 and ROW_ID = @RowId ) begin

               /* If there was an error... */
               if ( @@Error <> 00 ) begin

                  /* Rollback the transaction. */
                  rollback transaction

                  /* close and deallocate the cursor */
                  close data_cursor
                  deallocate data_cursor

                  /* Return the failure. */
                  return 01

               end

               select @ComServiceDataId = COM_SERVICE_DATA_ID
               from COM_SERVICE_DATA
               where PROVIDER_SERVICE_DATA_TYPE_ID = @ProviderServiceDataTypeId
                 and COM_SERVICE_UNIT_VALUE_ID = @ComServiceUnitValueId
                 and ROW_ID = @RowId

               /* Get the rows affected and the error code for the previous statement.
                  Error checking MUST be done this way since any single statement executed
                  will affect both of the global functions, @@RowCount and @@Error. */
               select @RowsAffected = @@RowCount, @ErrorCode = @@Error

               /* If there was an error... */
               if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

                  /* Raise an exception to be returned to the client */
                  raiserror ( 'ServiceDetail Data record not found for ServiceDetailId: %s.', 15, 1, @ServiceDetailId )

                  /* Rollback the transaction. */
                  rollback transaction

                  /* close and deallocate the cursor */
                  close data_cursor
                  deallocate data_cursor

                  /* Return the failure. */
                  return 01

               end

               execute @ReturnCode = spUpdateComServiceData @ComServiceDataId,
                                                            @ComServiceUnitValueId,
                                                            @ProviderServiceDataTypeId,
                                                            @ProviderServiceDataId,
                                                            @DetailDataItem,
                                                            @RowId, 00

               /* If there was an error... */
               if ( @ReturnCode <> 00 ) begin

                  /* Raise an exception to be returned to the client */
                  raiserror ( 'Error updating Service Detail Data record', 15, 1 )

                  /* close and deallocate the cursor */
                  close data_cursor
                  deallocate data_cursor

                  /* Return the failure. */
                  return @ReturnCode

               end

            end

            else begin

               execute @ReturnCode = spInsertComServiceData @ComServiceUnitValueId,
                                                            @ProviderServiceDataTypeId,
                                                            @ProviderServiceDataId,
                                                            @DetailDataItem,
                                                            @RowId,
                                                            @ComServiceDataId output, 00

               /* If there was an error... */
               if ( @ReturnCode <> 00 ) begin

                  /* Raise an exception to be returned to the client */
                  raiserror ( 'Error inserting Service Detail Data record', 15, 1 )

                  /* close and deallocate the cursor */
                  close data_cursor
                  deallocate data_cursor

                  /* Return the failure. */
                  return @ReturnCode

               end

            end

         end

      fetch next from data_cursor into
      @DataType, @DetailDataItem

      end

      close data_cursor
      deallocate data_cursor

   end

   else begin

      select @CustomerUnitId = CUSTOMER_UNIT_ID
      from COM_SERVICE
      where COM_SERVICE_ID = @ComServiceId

      /* Get the rows affected and the error code for the previous statement.
         Error checking MUST be done this way since any single statement executed
         will affect both of the global functions, @@RowCount and @@Error. */
      select @RowsAffected = @@RowCount, @ErrorCode = @@Error

      /* If there was an error... */
      if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

         /* Raise an exception to be returned to the client */
         raiserror ( 'Error retrieiving ServiceLocation', 15, 1 )

         /* Rollback the transaction. */
         rollback transaction

         /* Return the failure. */
         return 01

      end

      if not exists (
         select *
         from MAPPING_ENTITY
         where INTERFACE_ID = @InterfaceId
           and ENTITY_TYPE_ID = 13
           and FOREIGN_ID = @ForeignId
           and FOREIGN_TYPE = @ForeignType ) begin

         /* If there was an error... */
         if ( @@Error <> 00 ) begin

            /* Rollback the transaction. */
            rollback transaction

            /* Return the failure. */
            return 01

         end

         /* Insert into the COM_SERVICE_UNIT_VALUE table with LogTransaction = 0 */
         execute @ReturnCode = spInsertComServiceUnitValue @ComServiceId,
                                                           null,
                                                           @CustomerUnitId,
                                                           null,
                                                           @ComServiceUnitValueId output, 00

         /* If there was an error... */
         if ( @ReturnCode <> 00 ) begin

            /* Raise an exception to be returned to the client */
            raiserror ( 'Error inserting Service Detail', 15, 1 )

            /* Return the failure. */
            return @ReturnCode

         end

         set @RowId = 01

      end

      else begin

         select distinct @ComServiceUnitValueId = csuv.COM_SERVICE_UNIT_VALUE_ID, @RowId = ( max(ROW_ID) + 1 )
         from COM_SERVICE_UNIT_VALUE csuv, COM_SERVICE_DATA csd
         where COM_SERVICE_ID = @ComServiceId
           and CUSTOMER_UNIT_ID = @CustomerUnitId
           and csuv.COM_SERVICE_UNIT_VALUE_ID = csd.COM_SERVICE_UNIT_VALUE_ID
           and csuv.COM_SERVICE_UNIT_VALUE_ID in (
              select left(ENTITY_ID, len(csuv.COM_SERVICE_UNIT_VALUE_ID))
              from MAPPING_ENTITY
              where INTERFACE_ID = @InterfaceId
                and ENTITY_TYPE_ID = 13
                and FOREIGN_TYPE = @ForeignType )
           and csd.ROW_ID in (
              select right(ENTITY_ID, len(ENTITY_ID) - len(csuv.COM_SERVICE_UNIT_VALUE_ID))
              from MAPPING_ENTITY
              where INTERFACE_ID = @InterfaceId
                and ENTITY_TYPE_ID = 13
                and FOREIGN_TYPE = @ForeignType )
         group by csuv.COM_SERVICE_UNIT_VALUE_ID

         /* Get the rows affected and the error code for the previous statement.
            Error checking MUST be done this way since any single statement executed
            will affect both of the global functions, @@RowCount and @@Error. */
         select @RowsAffected = @@RowCount, @ErrorCode = @@Error

         /* If there was an error... */
         if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

            /* Raise an exception to be returned to the client */
            raiserror ( 'Error retrieiving ServiceDetail', 15, 1 )

            /* Rollback the transaction. */
            rollback transaction

            /* Return the failure. */
            return 01

         end

      end

      /* Parse and process @DetailData */
      declare data_cursor cursor for
      select DataType, DetailData
      from @ParsedList
      open data_cursor
      fetch next from data_cursor into
      @DataType, @DetailDataItem
      while ( @@fetch_status = 0 ) begin

         if exists (
            select *
            from MAPPING_ENTITY
            where ( INTERFACE_ID = @InterfaceId )
              and ( ENTITY_TYPE_ID = 9 )
              and ( FOREIGN_ID = @DataType ) ) begin

            /* If there was an error... */
            if ( @@Error <> 00 ) begin

               /* Rollback the transaction. */
               rollback transaction

               /* close and deallocate the cursor */
               close data_cursor
               deallocate data_cursor

               /* Return the failure. */
               return 01

            end

            select @ProviderServiceDataTypeId = ENTITY_ID, @DataId = FOREIGN_TYPE
            from MAPPING_ENTITY
            where ( INTERFACE_ID = @InterfaceId )
              and ( ENTITY_TYPE_ID = 9 )
              and ( FOREIGN_ID = @DataType )

            /* Get the rows affected and the error code for the previous statement.
               Error checking MUST be done this way since any single statement executed
               will affect both of the global functions, @@RowCount and @@Error. */
            select @RowsAffected = @@RowCount, @ErrorCode = @@Error

            /* If there was an error... */
            if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

               /* Raise an exception to be returned to the client */
               raiserror ( 'Error retrieiving mapped DataType: %s', 15, 1, @DataType )

               /* Rollback the transaction. */
               rollback transaction

               /* close and deallocate the cursor */
               close data_cursor
               deallocate data_cursor

               /* Return the failure. */
               return 01

            end


            if @DataId is not NULL begin

               select @ProviderServiceDataId = ENTITY_ID
               from MAPPING_ENTITY me
               join @ParsedList dd on me.FOREIGN_ID = dd.DetailData
               where ( INTERFACE_ID = @InterfaceId )
                 and ( ENTITY_TYPE_ID = 10 )
                 and ( FOREIGN_TYPE = @DataId )

               /* If there was an error... */
               if ( @@Error <> 00 ) begin

                  /* Raise an exception to be returned to the client */
                  raiserror ( 'Error retrieving mapped Data: %s', 15, 1, @DataId )

                  /* Rollback the transaction. */
                  rollback transaction

                  /* close and deallocate the cursor */
                  close data_cursor
                  deallocate data_cursor

                  /* Return the failure. */
                  return 01

               end

            end

            else set @ProviderServiceDataId = null

            execute @ReturnCode = spInsertComServiceData @ComServiceUnitValueId,
                                                         @ProviderServiceDataTypeId,
                                                         @ProviderServiceDataId,
                                                         @DetailDataItem,
                                                         @RowId,
                                                         @ComServiceDataId output, 00

            /* If there was an error... */
            if ( @ReturnCode <> 00 ) begin

               /* Raise an exception to be returned to the client */
               raiserror ( 'Error inserting ServiceDetailData: %s', 15, 1, @DetailDataItem )

              /* close and deallocate the cursor */
               close data_cursor
               deallocate data_cursor

               /* Return the failure. */
               return @ReturnCode

            end

         end

         fetch next from data_cursor into @DataType, @DetailDataItem

      end

      close data_cursor
      deallocate data_cursor

      set @ServiceDetailId = cast(cast(@ComServiceUnitValueId as varchar(15)) + cast(@RowId as varchar(15)) as integer)

      /* Insert into the MAPPING_ENTITY table  */
      execute @ReturnCode = spInsertMappingEntity @InterfaceId,
                                                  @ServiceDetailId, 13,
                                                  @ForeignId,
                                                  @ForeignType,
                                                  @MappingEntityId

      /* If there was an error... */
      if ( @ReturnCode <> 00 ) begin

         /* Raise an exception to be returned to the client */
         raiserror ( 'Error mapping ServiceDetail: %s', 15, 1, @ForeignId )

         /* Return the failure. */
         return @ReturnCode

      end

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spDCSServiceLocation' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spDCSServiceLocation

   go

create procedure spDCSServiceLocation( @InterfaceId         integer,      /* required - The Provider's Interface identifier                     */
                                       @ForeignId           varchar(50),  /* required - The Service Location's identifier in the foreign system */
                                       @ForeignType         varchar(50),  /* optional - Not used for this object, should be NULL                */
                                       @CustomerId          varchar(50),  /* required - The Customer's identifier in the foreign system         */
                                       @ServiceLocationName varchar(100), /* required - The Service Location's name in the foreign system       */
                                       @Address1            varchar(50),  /* optional - The service location's address1                         */
                                       @Address2            varchar(50),  /* optional - The service location's address2                         */
                                       @Address3            varchar(50),  /* optional - The service location's address3                         */
                                       @City                varchar(50),  /* optional - The service location's city                             */
                                       @State               varchar(50),  /* optional - The service location's state                            */
                                       @Zip                 varchar(50),  /* optional - The service location's zip                              */
                                       @Phone               varchar(50),  /* optional - The service location's phone                            */
                                       @Fax                 varchar(50),  /* optional - The service location's fax                              */
                                       @Mobile              varchar(50),  /* optional - The service location's mobile                           */
                                       @Pager               varchar(50),  /* optional - The service location's pager                            */
                                       @Email               varchar(50),  /* optional - The service location's email                            */
                                       @Branch              varchar(50),  /* optional - The service location's branch                           */
                                       @ServiceLocationId   integer output ) as

   declare @ErrorCode          integer         /* Error code returned by the execution of the last statement    */
   declare @RowsAffected       integer         /* Number of rows affected by the previously executed statement  */
   declare @Transactions       integer         /* Number of active transactions at the start of this procedure  */
   declare @ReturnCode         integer         /* Result code returned by the execution of the stored procedure */
   declare @EyeOnCustomerId    integer         /* The mapped Customer Identifier for the @CustomerId            */
   declare @OldCustomerId      integer         /* The mapped Customer Identifier for the @CustomerId            */
   declare @ProviderSystemId   integer         /* The SystemIds that the current location is linked to          */
   declare @ProviderCustomerId integer         /* The PROVIDER_CUSTOMER_ID                                      */
   declare @ProviderId         integer         /* The ProviderId for the current InterfaceId                    */
   declare @ProviderCustomerServiceId integer  /* PROVIDER_CUSTOMER_SERVICE_ID                                  */
   declare @CustomerUnitId     integer
   declare @CustomerUnitName   varchar(100)
   declare @CustomerUnitNumber varchar(50)
   declare @UnitParentId       integer
   declare @MappingEntityId    integer         /* Identifier to store MAPPING_ENTITY_ID when Customer mapped    */
   declare @BranchId           integer         /* Identifier for mapped MEMBER_GROUP_ID for Branch              */
   declare @ContactId          integer         /* Identifier to store CONTACT_ID when contact info is inserted  */
   declare @EntityCount        integer         /* Flag to determine if the service location has been mapped     */

   set nocount on

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Get the Provider identifier for the current InterfaceId */
   select @ProviderId = PROVIDER_ID
   from MAPPING_INTERFACE
   where INTERFACE_ID = @InterfaceId

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Raise an error. */
      raiserror ( 'InterfaceId: %s not found', 15, 1, @InterfaceId )

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* Get the identifier for the customer in the EyeOn database from the
      mapping table. */
   select @EyeOnCustomerId = ENTITY_ID
   from MAPPING_ENTITY
   where ( INTERFACE_ID   = @InterfaceId  )
     and ( FOREIGN_ID     = @CustomerId   )
     and ( ENTITY_TYPE_ID = 4             )

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Raise an exception to be returned to the client */
      raiserror ( 'Error retrieiving mapped Customer: %s for Interface: %s', 15, 1, @CustomerId, @InterfaceId )

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If the foreign type was passed as a null value... */
   if ( @ForeignType is null ) begin

     /* Get the count of the mapping entity records for the service location
        ignoring the empty foreign type. */
     select @EntityCount = count( MAPPING_ENTITY_ID )
     from MAPPING_ENTITY
     where ( INTERFACE_ID   = @InterfaceId )
       and ( FOREIGN_ID     = @ForeignId   )
       and ( FOREIGN_TYPE   is null        )
       and ( ENTITY_TYPE_ID = 05           )

   end

   else begin /* The foreign type is not null... */

     /* Get the count of the mapping entity records for the service location
        taking into account the foreign type. */
     select @EntityCount = count( MAPPING_ENTITY_ID )
     from MAPPING_ENTITY
     where ( INTERFACE_ID   = @InterfaceId )
       and ( FOREIGN_ID     = @ForeignId   )
       and ( FOREIGN_TYPE   = @ForeignType )
       and ( ENTITY_TYPE_ID = 05           )

   end

   /* If there was an error... */
   if ( @@Error <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If Service Location already exists in Mapping... */
   if ( @EntityCount > 00 ) begin

      /* If the foreign type was passed as a null value... */
      if ( @ForeignType is null ) begin

        /* Get the service location identifier from the mapping table ignoring
           the empty foreign type. */
         select @ServiceLocationId = ENTITY_ID
         from MAPPING_ENTITY
         where ( INTERFACE_ID   = @InterfaceId )
           and ( FOREIGN_ID     = @ForeignId   )
           and ( FOREIGN_TYPE   is null        )
           and ( ENTITY_TYPE_ID = 05           )

      end

      else begin /* The foreign type is not null... */

        /* Get the service location identifier from the mapping table taking
           into account the foreign type. */
         select @ServiceLocationId = ENTITY_ID
         from MAPPING_ENTITY
         where ( INTERFACE_ID   = @InterfaceId )
           and ( FOREIGN_ID     = @ForeignId   )
           and ( FOREIGN_TYPE   = @ForeignType )
           and ( ENTITY_TYPE_ID = 05           )

      end

      /* Get the rows affected and the error code for the previous statement.
         Error checking MUST be done this way since any single statement executed
         will affect both of the global functions, @@RowCount and @@Error. */
      select @RowsAffected = @@RowCount, @ErrorCode = @@Error

      /* If there was an error... */
      if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

         /* Raise an exception to be returned to the client */
         raiserror ( 'Error retrieiving mapped ServiceLocation: %s for Interface: %s', 15, 1, @ForeignId, @InterfaceId )

         /* Rollback the transaction. */
         rollback transaction

         /* Return the failure. */
         return 01

      end

      /* Declare cursor of systems that the current service location is linked to, so after the update, they can be relinked */
      declare system_unit cursor for
      select cu.customer_id, cut.provider_system_id
      from customer_unit cu
      inner join join_customer_unit_type_customer_unit jcutcu on cu.customer_unit_id = jcutcu.customer_unit_id
      inner join customer_unit_type cut on jcutcu.customer_unit_type_id = cut.customer_unit_type_id
      where cu.customer_unit_id = @ServiceLocationId

      /* If there was an error... */
      if ( @@Error <> 00 ) begin

         /* Raise an exception to be returned to the client */
         raiserror ( 'Error retrieiving systems for ServiceLocation: %s', 15, 1, @ForeignId )

         /* Rollback the transaction. */
         rollback transaction

         /* Return the failure. */
         return 01

      end

      open system_unit
      fetch next from system_unit into
      @OldCustomerId,
      @ProviderSystemId
      while ( @@fetch_status = 00 ) begin

         /* If the current customer_id is different than the stored customer_id then */
         if ( @OldCustomerId <> @EyeOnCustomerId ) begin

            /* retrieve the new provider_customer_id and the provider_customer_service_id */
            select @ProviderCustomerId = pc.provider_customer_id, @ProviderCustomerServiceId = provider_customer_service_id
            from provider_customer pc
            left outer join provider_customer_service pcs on ( pc.provider_customer_id = pcs.provider_customer_id ) and
                                                             ( pcs.provider_system_id = @ProviderSystemId )
            where pc.provider_id = @ProviderId
              and pc.customer_id = @EyeOnCustomerId

            /* if the provider_customer_service_id is null then insert a new one */
            if ( @ProviderCustomerServiceId is null ) begin
               execute @ReturnCode = spInsertProviderCustomerService @ProviderCustomerId, @ProviderSystemId, @ProviderCustomerServiceId output

               /* If there was an error... */
               if ( @ReturnCode <> 00 ) begin

                  /* Raise an exception to be returned to the client */
                  raiserror ( 'Error updating ServiceLocation', 15, 1 )

                  /* Rollback the transaction. */
                  rollback transaction

                  /* Return the failure. */
                  return @ReturnCode

               end

            end

         end

         /* In SQL 2000, execute cannot be used in an insert statement for table variables */
         /* so, the table variable code is commented out and a temp table is created instead */
         /* When we go to SQL 2005, we can change this to a table variable */

         /* declare a table variable to store the current service location's subunits in */
         create table #UnitTable (
--         declare @UnitTable table (
            CustomerUnitId integer,
            UnitParentId integer,
            UnitTopParentId integer,
            CustomerUnitTypeName varchar(50),
            CustomerUnitName varchar(50),
            CustomerUnitNumber varchar(50),
            ProviderServiceValueId integer )

         /* Get the current service location's subunits and insert them into the table variable */
         insert into #UnitTable
--         insert into @UnitTable
         exec spGetCustomerUnitsBySystemParent @ProviderSystemId, @ServiceLocationId

         /* declare a cursor to iterate over the table variable */
         declare unit_cursor cursor for
         select CustomerUnitId,
                CustomerUnitName,
                CustomerUnitNumber,
                UnitParentId
         from #UnitTable
--         from @UnitTable

         /* If there was an error... */
         if ( @@Error <> 00 ) begin

            /* Raise an exception to be returned to the client */
            raiserror ( 'Error retrieiving subunits for ServiceLocation: %s', 15, 1, @ForeignId )

            /* Rollback the transaction. */
            rollback transaction

            /* Return the failure. */
            return 01

         end

         open unit_cursor
         fetch next from unit_cursor into
         @CustomerUnitId,
         @CustomerUnitName,
         @CustomerUnitNumber,
         @UnitParentId

         /* Update the customer unit table with LogTransaction = 00 which will not
            log the change to the transaction log. */
         execute @ReturnCode = spUpdateCustomerUnit @ServiceLocationId,
                                                    @EyeOnCustomerId,
                                                    @ServiceLocationName,
                                                    @CustomerUnitNumber,
                                                    -1, null, 00

         /* If there was an error... */
         if ( @ReturnCode <> 00 ) begin

            /* Raise an exception to be returned to the client */
            raiserror ( 'Error updating ServiceLocation', 15, 1 )

            /* Rollback the transaction. */
            rollback transaction

            /* Return the failure. */
            return @ReturnCode

         end

         fetch next from unit_cursor into
         @CustomerUnitId,
         @CustomerUnitName,
         @CustomerUnitNumber,
         @UnitParentId

         while ( @@fetch_status = 00 ) begin

            /* Update the customer unit table with LogTransaction = 00 which will not
               log the change to the transaction log. */
            execute @ReturnCode = spUpdateCustomerUnit @CustomerUnitId,
                                                       @EyeOnCustomerId,
                                                       @CustomerUnitName,
                                                       @CustomerUnitNumber,
                                                       @UnitParentId,
                                                       null, 00

            /* If there was an error... */
            if ( @ReturnCode <> 00 ) begin

               /* Raise an exception to be returned to the client */
               raiserror ( 'Error updating ServiceLocation Sub-Unit', 15, 1 )

               /* Rollback the transaction. */
               rollback transaction

               /* Return the failure. */
               return @ReturnCode

            end

            fetch next from unit_cursor into
            @CustomerUnitId,
            @CustomerUnitName,
            @CustomerUnitNumber,
            @UnitParentId

         end

         close unit_cursor
         deallocate unit_cursor

         fetch next from system_unit into
         @OldCustomerId,
         @ProviderSystemId

      end

      close system_unit
      deallocate system_unit

   end

   else begin /* Does not exist in mapping so doing an insert... */

      /* Insert into the CUSTOMER_UNIT table with LogTransaction = 00 which
         will not log the change to the transaction log. */
      execute @ReturnCode = spInsertCustomerUnit @EyeOnCustomerId,

                                                 @ServiceLocationName,
                                                 null, -1, null,
                                                 @ServiceLocationId output, 00

      /* If there was an error... */
      if ( @ReturnCode <> 00 ) begin

         /* Raise an exception to be returned to the client */
         raiserror ( 'Error inserting ServiceLocation', 15, 1 )

         /* Return the failure. */
         return @ReturnCode

      end

      /* Insert into the MAPPING_ENTITY table.  This will associate the foreign
         service location data to the native data in the EyeOn database. */
      execute @ReturnCode = spInsertMappingEntity @InterfaceId,
                                                  @ServiceLocationId, 05,
                                                  @ForeignId,
                                                  @ForeignType,
                                                  @MappingEntityId

      /* If there was an error... */
      if ( @ReturnCode <> 00 ) begin

         /* Raise an exception to be returned to the client */
         raiserror ( 'Error inserting ServiceLocation mapping', 15, 1 )

         /* Return the failure. */
         return @ReturnCode

      end

   end

   /* If the branch passed is not null... */
   if ( @Branch is not null ) begin

      /* If the branch has previously been mapped... */
      if exists ( select *
                  from MAPPING_ENTITY
                  where INTERFACE_ID   = @InterfaceId and
                        FOREIGN_ID     = @Branch      and
                        ENTITY_TYPE_ID = 15 ) begin

         /* If there was an error... */
         if ( @@Error <> 00 ) begin

            /* Rollback the transaction. */
            rollback transaction

            /* Return the failure. */
            return 01

         end

         /* Get the identifier for the branch in the EyeOn database from the
            mapping table. */
         select @BranchId = ENTITY_ID
         from MAPPING_ENTITY
         where INTERFACE_ID   = @InterfaceId
           and FOREIGN_ID     = @Branch
           and ENTITY_TYPE_ID = 15

         /* Get the rows affected and the error code for the previous statement.
            Error checking MUST be done this way since any single statement executed
            will affect both of the global functions, @@RowCount and @@Error. */
         select @RowsAffected = @@RowCount, @ErrorCode = @@Error

         /* If there was an error... */
         if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

            /* Raise an exception to be returned to the client */
            raiserror ( 'Error retrieiving mapped Branch: %s for Interface: %s', 15, 1, @Branch, @InterfaceId )

            /* Rollback the transaction. */
            rollback transaction

            /* Return the failure. */
            return 01

         end

         /* If the service location has not previously been associated with the
            branch...*/
         if ( not exists ( select *
                           from JOIN_MEMBER_GROUP_CUSTOMER_UNIT
                           where ( ( MEMBER_GROUP_ID  = @BranchId          ) and
                                   ( CUSTOMER_UNIT_ID = @ServiceLocationId ) ) ) ) begin

            /* Associate the branch to the service location. */
            execute @ReturnCode = spInsertJoinMemberGroupCustomerUnit @BranchId,
                                                                      @ServiceLocationId

            /* If there was an error... */
            if ( @ReturnCode <> 00 ) begin

               /* Raise an exception to be returned to the client */
               raiserror ( 'Error assigning Branch to ServiceLocation', 15, 1 )

               /* Return the failure. */
               return @ReturnCode

            end

         end

      end

   end

   /* If Address1 value is not null... */
   if ( @Address1 is not null ) begin

      /* Generate the new contact information for the service location.  If the
         contact information already exists, it will be updated. */
      execute @ReturnCode = spCreateNewContactAddress1 @Address1,
                                                       @ServiceLocationId, 05

      /* If there was an error... */
      if ( @ReturnCode <> 00 ) begin

         /* Raise an error. */
         raiserror ( 'Error inserting address1 for ServiceLocation: %s', 15, 1, @ForeignId )

         /* Return the failure. */
         return @ReturnCode

      end

   end

   /* If Address2 value is not null... */
   if ( @Address2 is not null ) begin

      /* Generate the new contact information for the service location.  If the
         contact information already exists, it will be updated. */
      execute @ReturnCode = spCreateNewContactAddress2 @Address2,
                                                       @ServiceLocationId, 05

      /* If there was an error... */
      if ( @ReturnCode <> 00 ) begin

         /* Raise an error. */
         raiserror ( 'Error inserting address2 for ServiceLocation: %s', 15, 1, @ForeignId )

         /* Return the failure. */
         return @ReturnCode

      end

   end

   /* If Address3 value is not null... */
   if ( @Address3 is not null ) begin

      /* Generate the new contact information for the service location.  If the
         contact information already exists, it will be updated. */
      execute @ReturnCode = spCreateNewContactAddress3 @Address3,
                                                       @ServiceLocationId, 05

      /* If there was an error... */
      if ( @ReturnCode <> 00 ) begin

         /* Raise an error. */
         raiserror ( 'Error inserting address3 for ServiceLocation: %s', 15, 1, @ForeignId )

         /* Return the failure. */
         return @ReturnCode

      end

   end

   /* If City value is not null... */
   if ( @City is not null ) begin

      /* Generate the new contact information for the service location.  If the
         contact information already exists, it will be updated. */
      execute @ReturnCode = spCreateNewContactCity @City,
                                                   @ServiceLocationId, 05

      /* If there was an error... */
      if ( @ReturnCode <> 00 ) begin

         /* Raise an error. */
         raiserror ( 'Error inserting city for ServiceLocation: %s', 15, 1, @ForeignId )

         /* Return the failure. */
         return @ReturnCode

      end

   end

   /* If State value is not null... */
   if ( @State is not null ) begin

      /* Generate the new contact information for the service location.  If the
         contact information already exists, it will be updated. */
      execute @ReturnCode = spCreateNewContactState @State,
                                                    @ServiceLocationId, 05

      /* If there was an error... */
      if ( @ReturnCode <> 00 ) begin

         /* Raise an error. */
         raiserror ( 'Error inserting state for ServiceLocation: %s', 15, 1, @ForeignId )

         /* Return the failure. */
         return @ReturnCode

      end

   end

   /* If Zip value is not null... */
   if ( @Zip is not null ) begin

      /* Generate the new contact information for the service location.  If the
         contact information already exists, it will be updated. */
      execute @ReturnCode = spCreateNewContactZip @Zip,
                                                  @ServiceLocationId, 05

      /* If there was an error... */
      if ( @ReturnCode <> 00 ) begin

         /* Raise an error. */
         raiserror ( 'Error inserting zip for ServiceLocation: %s', 15, 1, @ForeignId )

         /* Return the failure. */
         return @ReturnCode

      end

   end

   /* If Phone value is not null... */
   if ( @Phone is not null ) begin

      /* Generate the new contact information for the service location.  If the
         contact information already exists, it will be updated. */
      execute @ReturnCode = spCreateNewContactPhone @Phone,
                                                    @ServiceLocationId, 05

      /* If there was an error... */
      if ( @ReturnCode <> 00 ) begin

         /* Raise an error. */
         raiserror ( 'Error inserting phone for ServiceLocation: %s', 15, 1, @ForeignId )

         /* Return the failure. */
         return @ReturnCode

      end

   end

   /* If Address2 value is not null... */
   if ( @Fax is not null ) begin

      /* Generate the new contact information for the service location.  If the
         contact information already exists, it will be updated. */
      execute @ReturnCode = spCreateNewContactFax @Fax,
                                                  @ServiceLocationId, 05

      /* If there was an error... */
      if ( @ReturnCode <> 00 ) begin

         /* Raise an error. */
         raiserror ( 'Error inserting fax for ServiceLocation: %s', 15, 1, @ForeignId )

         /* Return the failure. */
         return @ReturnCode

      end

   end

   /* If Mobile value is not null... */
   if ( @Mobile is not null ) begin

      /* Generate the new contact information for the service location.  If the
         contact information already exists, it will be updated. */
      execute @ReturnCode = spCreateNewContactMobile @Mobile,
                                                     @ServiceLocationId, 05

      /* If there was an error... */
      if ( @ReturnCode <> 00 ) begin

         /* Raise an error. */
         raiserror ( 'Error inserting mobile for ServiceLocation: %s', 15, 1, @ForeignId )

         /* Return the failure. */
         return @ReturnCode

      end

   end

   /* If Pager value is not null... */
   if ( @Pager is not null ) begin

      /* Generate the new contact information for the service location.  If the
         contact information already exists, it will be updated. */
      execute @ReturnCode = spCreateNewContactPager @Pager,
                                                    @ServiceLocationId, 05

      /* If there was an error... */
      if ( @ReturnCode <> 00 ) begin

         /* Raise an error. */
         raiserror ( 'Error inserting pager for ServiceLocation: %s', 15, 1, @ForeignId )

         /* Return the failure. */
         return @ReturnCode

      end

   end

   /* If Email value is not null... */
   if ( @Email is not null ) begin

      /* Generate the new contact information for the service location.  If the
         contact information already exists, it will be updated. */
      execute @ReturnCode = spCreateNewContactEmail @Email,
                                                    @ServiceLocationId, 05

      /* If there was an error... */
      if ( @ReturnCode <> 00 ) begin

         /* Raise an error. */
         raiserror ( 'Error inserting email for ServiceLocation: %s', 15, 1, @ForeignId )

         /* Return the failure. */
         return @ReturnCode

      end

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spDeclineLicenseAgreement' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spDeclineLicenseAgreement

   go

create procedure spDeclineLicenseAgreement( @MemberUserId integer ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @RowsAffected integer /* Number of rows affected by the previously executed statement */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Update the row in the member user table to reset the last login date and
      time to null so that the user will see the license agreement on their
      next login forcing them to accept or decline it again. */
   update MEMBER_USER
   set MEMBER_USER_LAST_LOGIN = null
   where MEMBER_USER_ID = @MemberUserId

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spDeleteApplicationHelpByHelpId' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spDeleteApplicationHelpByHelpId

   go

create procedure spDeleteApplicationHelpByHelpId( @HelpId integer ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @RowsAffected integer /* Number of rows affected by the previously executed statement */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Delete the target row. */
   delete
   from APPLICATION_HELP
   where HELP_ID = @HelpId

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spDeleteApplicationHelpByPage' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spDeleteApplicationHelpByPage

   go

create procedure spDeleteApplicationHelpByPage( @PhysicalPage integer,
                                                @LogicalPage  integer,
                                                @HelpAction   integer ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @RowsAffected integer /* Number of rows affected by the previously executed statement */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Delete the target row. */
   delete
   from APPLICATION_HELP
   where PHYSICAL_PAGE = @PhysicalPage and
         LOGICAL_PAGE  = @LogicalPage  and
         HELP_ACTION   = @HelpAction

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spDeleteCustomer' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spDeleteCustomer

   go

create procedure spDeleteCustomer( @CustomerId integer ) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   execute @ReturnCode = spDeleteMember @CustomerId

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spDeleteCustomerContactInfo' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spDeleteCustomerContactInfo

   go

create procedure spDeleteCustomerContactInfo( @ContactId integer ) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   execute @ReturnCode = spDeleteContact @ContactId

    /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spDeleteCustomerGroup' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spDeleteCustomerGroup

   go

create procedure spDeleteCustomerGroup( @CustomerGroupId integer ) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   execute @ReturnCode = spDeleteMemberGroup @CustomerGroupId

    /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spDeleteCustomerGroupType' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spDeleteCustomerGroupType

   go

create procedure spDeleteCustomerGroupType( @CustomerGroupTypeId integer ) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   execute @ReturnCode = spDeleteMemberGroupType @CustomerGroupTypeId

    /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spDeleteCustomerSubUnit' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spDeleteCustomerSubUnit

   go

create procedure spDeleteCustomerSubUnit( @CustomerUnitTypeId integer,
                                          @CustomerUnitId     integer ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @RowsAffected integer /* Number of rows affected by the previously executed statement */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Delete the customer sub-unit/customer unit type row that will remove the
      sub-unit from the service program. */
   delete JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT
   where CUSTOMER_UNIT_TYPE_ID = @CustomerUnitTypeId and
         CUSTOMER_UNIT_ID      = @CustomerUnitId

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* Delete the customer sub-unit from the database. */
   delete CUSTOMER_UNIT
   where CUSTOMER_UNIT_ID = @CustomerUnitId

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spDeleteCustomerUnit' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spDeleteCustomerUnit

   go

create procedure spDeleteCustomerUnit( @CustomerUnitId integer ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @RowsAffected integer /* Number of rows affected by the previously executed statement */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* First delete com_service_unit_value records referenced by the unit */
   delete from COM_SERVICE_UNIT_VALUE
   where customer_unit_id = @CustomerUnitId

   /* If there was an error... */
   if ( @@Error > 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* First delete com_service_unit_value records referenced by the unit */
   delete from PROVIDER_CUSTOMER_SERVICE_SCHEDULE
   where customer_unit_id = @CustomerUnitId

   /* If there was an error... */
   if ( @@Error > 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* Delete the row from the customer unit table. */
   delete from CUSTOMER_UNIT
   where
   [CUSTOMER_UNIT_ID] = @CustomerUnitId

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spDeleteCustomerUnitContactInfo' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spDeleteCustomerUnitContactInfo

   go

create procedure spDeleteCustomerUnitContactInfo( @ContactId integer) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   execute @ReturnCode = spDeleteContact @ContactId

    /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spDeleteCustomerUser' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spDeleteCustomerUser

   go

create procedure spDeleteCustomerUser( @CustomerUserId integer ) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   execute @ReturnCode = spDeleteMemberUser @CustomerUserId

    /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spDeleteCustomerUserContactInfo' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spDeleteCustomerUserContactInfo

   go

create procedure spDeleteCustomerUserContactInfo( @ContactId integer ) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   execute @ReturnCode = spDeleteContact @ContactId

    /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spDeleteJoinMemberUserSecurityGroup' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spDeleteJoinMemberUserSecurityGroup

   go

create procedure spDeleteJoinMemberUserSecurityGroup( @MemberUserId integer ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @RowsAffected integer /* Number of rows affected by the previously executed statement */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Delete the row from the XXXXXXXX table. */
   delete from JOIN_MEMBER_USER_SECURITY_GROUP
   where MEMBER_USER_ID = @MemberUserId

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spDeleteMappingEntity' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spDeleteMappingEntity

   go

create procedure spDeleteMappingEntity( @MappingEntityId integer ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @RowsAffected integer /* Number of rows affected by the previously executed statement */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Delete the row from the mapping entity table. */
   delete from MAPPING_ENTITY
   where
   [MAPPING_ENTITY_ID] = @MappingEntityId

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spDeleteProviderContactInfo' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spDeleteProviderContactInfo

   go

create procedure spDeleteProviderContactInfo( @ContactId integer ) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   execute @ReturnCode = spDeleteContact @ContactId

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spDeleteProviderCustomerServiceFinancial' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spDeleteProviderCustomerServiceFinancial

   go

create procedure spDeleteProviderCustomerServiceFinancial( @ProviderCustomerServiceFinancialId integer ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @RowsAffected integer /* Number of rows affected by the previously executed statement */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Delete the customer service schedule. */
   delete from PROVIDER_CUSTOMER_SERVICE_FINANCIAL
   where PROVIDER_CUSTOMER_SERVICE_FINANCIAL_ID = @ProviderCustomerServiceFinancialId

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spDeleteProviderCustomerServiceSchedule' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spDeleteProviderCustomerServiceSchedule

   go

create procedure spDeleteProviderCustomerServiceSchedule( @ProviderCustomerServiceScheduleId integer ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @RowsAffected integer /* Number of rows affected by the previously executed statement */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Delete the customer service schedule. */
   delete from PROVIDER_CUSTOMER_SERVICE_SCHEDULE
   where PROVIDER_CUSTOMER_SERVICE_SCHEDULE_ID = @ProviderCustomerServiceScheduleId

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spDeleteProviderGroup' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spDeleteProviderGroup

   go

create procedure spDeleteProviderGroup( @ProviderGroupId integer ) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   execute @ReturnCode = spDeleteMemberGroup @ProviderGroupId

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spDeleteProviderGroupType' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spDeleteProviderGroupType

   go

create procedure spDeleteProviderGroupType( @ProviderGroupTypeId integer ) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   -- new procedure
   execute @ReturnCode = spDeleteMemberGroupType @ProviderGroupTypeId

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spDeleteProviderSystemContactInfo' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spDeleteProviderSystemContactInfo

   go

create procedure spDeleteProviderSystemContactInfo( @ContactId integer ) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   execute @ReturnCode = spDeleteContact @ContactId

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spDeleteProviderUser' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spDeleteProviderUser

   go

create procedure spDeleteProviderUser( @ProviderUserId integer) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   execute @ReturnCode = spDeleteMemberUser @ProviderUserId

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spDeleteProviderUserContactInfo' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spDeleteProviderUserContactInfo

   go

create procedure spDeleteProviderUserContactInfo( @ContactId integer ) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   execute @ReturnCode = spDeleteContact @ContactId

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spFixCustomerUnitNameBarCodeIds' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spFixCustomerUnitNameBarCodeIds

   go

create procedure spFixCustomerUnitNameBarCodeIds as

   declare @ErrorCode          integer         /* Error code returned by the execution of the last statement   */
   declare @RowsAffected       integer         /* Number of rows affected by the previously executed statement */
   declare @CustomerUnitNameId integer         /* Customer unit name row identifier                            */
   declare @ProviderSystemId   integer         /* Provider system row identifier                               */
   declare @MaxBarCodeId       varchar(10) /* Maximum barcode identifier for the current provider system   */
   declare @NewBarCodeId       varchar(10) /* New barcode identifier for the current provider system       */
   declare @NextBarCodeId      integer         /* Next barcode identifier for the current provider system      */
   declare @CurrentSystemId    integer         /* Current provider system row identifier begin processed       */

   /* Set the isolation level for the transactions so that the data
      remains consistent throughout the entire stored procedure. */
   set transaction isolation level serializable

   /* Start the transaction. */
   begin transaction

   /* Declare a cursor that will contain all of the customer unit names that
      are not inherited from the template and do not contain a valid barcode
      identifier.  This result set should contain all of the customer unit
      names in this state. */
   declare BarCodeIdCursor cursor for
   select ut.PROVIDER_SYSTEM_ID, un.CUSTOMER_UNIT_NAME_ID
   from CUSTOMER_UNIT_NAME un
        inner join CUSTOMER_UNIT_TYPE ut on un.CUSTOMER_UNIT_TYPE_ID = ut.CUSTOMER_UNIT_TYPE_ID
   where un.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME_ID is null and
         un.CUSTOMER_UNIT_NUMBER is null
   order by ut.PROVIDER_SYSTEM_ID, un.CUSTOMER_UNIT_NAME_ID

   /* If there was an error... */
   if ( @@Error <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* open the cursor and return the result set. */
   open BarCodeIdCursor

   /* If there was an error... */
   if ( @@Error <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* Fetch the first row from the cursor into the local variables.  We only
      need the system key and the customer unit name key in order to find the
      next barcode identifier for the system and save it into the table. */
   fetch next from BarCodeIdCursor into @ProviderSystemId, @CustomerUnitNameId

   /* While there are still rows to process in the cursor... */
   while ( @@Fetch_Status = 00 ) begin

      /* Store the current system identifier for processing the system. */
      set @CurrentSystemId = @ProviderSystemId

      /* If there was an error... */
      if ( @@Error <> 00 ) begin

         /* Rollback the transaction. */
         rollback transaction

         /* Return the failure. */
         return 01

      end

      /* Use the stored procedure that returns the maximum barcode identifier
         currently assigned to a customer unit name for the system. */
      execute spGetMaxCustomerUnitNameBarCodeIdBySystem @ProviderSystemId,
                                                        @MaxBarCodeId output

      /* If there was an error... */
      if ( @@Error <> 00 ) begin

         /* Rollback the transaction. */
         rollback transaction

         /* Return the failure. */
         return 01

      end

      /* If there is a maximum barcode identifier in the table for the system
         (i.e. the system inherits some barcode identifiers from a template) */
      if ( @MaxBarCodeId is not null ) begin

         /* Assign the initial value for the new barcode identifiers. */
         set @NextBarCodeId = Cast( @MaxBarCodeId as integer )

         /* If there was an error... */
         if ( @@Error <> 00 ) begin

            /* Rollback the transaction. */
            rollback transaction

            /* Return the failure. */
            return 01

         end

      end

      else begin /* No inherited template barcode identifiers... */

         /* Assign the default starting barcode identifier. */
         set @NextBarCodeId = 10000

         /* If there was an error... */
         if ( @@Error <> 00 ) begin

            /* Rollback the transaction. */
            rollback transaction

            /* Return the failure. */
            return 01

         end

      end

      /* While still processing the current system and while there are still
         rows to process in the cursor... */
      while ( ( @ProviderSystemId = @CurrentSystemId ) and
              ( @@Fetch_Status = 00 ) ) begin

         /* Increment the barcode identifier to get the next one to assign. */
         set @NextBarCodeId = @NextBarCodeId + 01

         /* If there was an error... */
         if ( @@Error <> 00 ) begin

            /* Rollback the transaction. */
            rollback transaction

            /* Return the failure. */
            return 01

         end

         /* Convert the next barcode identifier to assign to the table. */
         set @NewBarCodeId = Cast( @NextBarCodeId as varchar(10) )

         /* If there was an error... */
         if ( @@Error <> 00 ) begin

            /* Rollback the transaction. */
            rollback transaction

            /* Return the failure. */
            return 01

         end

         /* Update the customer unit name with the new barcode identifier. */
         update CUSTOMER_UNIT_NAME
         set CUSTOMER_UNIT_NUMBER = @NewBarCodeId
         where CUSTOMER_UNIT_NAME_ID = @CustomerUnitNameId

         /* Get the rows affected and the error code for the previous
            statement.  Error checking MUST be done this way since any single
            statement executed will affect both of the global functions,
            @@RowCount and @@Error. */
         select @RowsAffected = @@RowCount, @ErrorCode = @@Error

         /* If there was an error... */
         if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

            /* Rollback the transaction. */
            rollback transaction

            /* Return the failure. */
            return 01

         end

         /* Move to the next row in the result set. */
         fetch next from BarCodeIdCursor into @ProviderSystemId,
                                              @CustomerUnitNameId

      end

   end

   /* Close the cursor and release the result set. */
   close BarCodeIdCursor

   /* Release the resources allocated for the cursor. */
   deallocate BarCodeIdCursor

   /* Commit the transaction. */
   commit transaction

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spFixProviderServiceDataBarCodeIds' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spFixProviderServiceDataBarCodeIds

   go

create procedure spFixProviderServiceDataBarCodeIds as

   declare @ErrorCode        integer         /* Error code returned by the execution of the last statement   */
   declare @RowsAffected     integer         /* Number of rows affected by the previously executed statement */
   declare @ServiceDataId    integer         /* Service data item row identifier                             */
   declare @ProviderSystemId integer         /* Provider system row identifier                               */
   declare @MaxBarCodeId     varchar(10) /* Maximum barcode identifier for the current provider system   */
   declare @NewBarCodeId     varchar(10) /* New barcode identifier for the current provider system       */
   declare @NextBarCodeId    integer         /* Next barcode identifier for the current provider system      */
   declare @CurrentSystemId  integer         /* Current provider system row identifier begin processed       */

   /* Set the isolation level for the transactions so that the data
      remains consistent throughout the entire stored procedure. */
   set transaction isolation level serializable

   /* Start the transaction. */
   begin transaction

   /* Update the barcode identifiers that contain invalid data. */
   update PROVIDER_SERVICE_DATA
   set BARCODE_ID = null
   where TEMPLATE_PROVIDER_SERVICE_DATA_ID is null and
         BARCODE_ID = '<'

   /* If there was an error... */
   if ( @@Error <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* Update the barcode identifiers that contain undefined data. */
   update PROVIDER_SERVICE_DATA
   set BARCODE_ID = null
   where TEMPLATE_PROVIDER_SERVICE_DATA_ID is null and
         BARCODE_ID = 'undefined'

   /* If there was an error... */
   if ( @@Error <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* Update the barcode identifiers that contain empty data. */
   update PROVIDER_SERVICE_DATA
   set BARCODE_ID = null
   where TEMPLATE_PROVIDER_SERVICE_DATA_ID is null and
         BARCODE_ID = ''

   /* If there was an error... */
   if ( @@Error <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* Declare a cursor that will contain all of the service data items that are
      not inherited from the template and do not contain a valid barcode
      identifier.  This result set should contain all of the service data items
      in this state since we ran the previous updates. */
   declare BarCodeIdCursor cursor for
   select sc.PROVIDER_SYSTEM_ID, fv.PROVIDER_SERVICE_DATA_ID
   from PROVIDER_SERVICE_DATA fv
        inner join PROVIDER_SERVICE_DATA_TYPE cf on fv.PROVIDER_SERVICE_DATA_TYPE_ID = cf.PROVIDER_SERVICE_DATA_TYPE_ID
        inner join PROVIDER_SERVICE_CATEGORY  sc on cf.PROVIDER_SERVICE_CATEGORY_ID  = sc.PROVIDER_SERVICE_CATEGORY_ID
   where fv.TEMPLATE_PROVIDER_SERVICE_DATA_ID is null and
         fv.BARCODE_ID is null
   order by sc.PROVIDER_SYSTEM_ID, fv.PROVIDER_SERVICE_DATA_ID

   /* If there was an error... */
   if ( @@Error <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* open the cursor and return the result set. */
   open BarCodeIdCursor

   /* If there was an error... */
   if ( @@Error <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* Fetch the first row from the cursor into the local variables.  We only
      need the system key and the service data item key in order to find the
      next barcode identifier for the system and save it into the table. */
   fetch next from BarCodeIdCursor into @ProviderSystemId, @ServiceDataId

   /* While there are still rows to process in the cursor... */
   while ( @@Fetch_Status = 00 ) begin

      /* Store the current system identifier for processing the system. */
      set @CurrentSystemId = @ProviderSystemId

      /* If there was an error... */
      if ( @@Error <> 00 ) begin

         /* Rollback the transaction. */
         rollback transaction

         /* Return the failure. */
         return 01

      end

      /* Use the stored procedure that returns the maximum barcode identifier
         currently assigned to a service data item for the system. */
      execute spGetMaxProviderServiceDataBarCodeIdBySystem @ProviderSystemId,
                                                           @MaxBarCodeId output

      /* If there was an error... */
      if ( @@Error <> 00 ) begin

         /* Rollback the transaction. */
         rollback transaction

         /* Return the failure. */
         return 01

      end

      /* If there is a maximum barcode identifier in the table for the system
         (i.e. the system inherits some barcode identifiers from a template) */
      if ( @MaxBarCodeId is not null ) begin

         /* Assign the initial value for the new barcode identifiers. */
         set @NextBarCodeId = Cast( @MaxBarCodeId as integer )

         /* If there was an error... */
         if ( @@Error <> 00 ) begin

            /* Rollback the transaction. */
            rollback transaction

            /* Return the failure. */
            return 01

         end

      end

      else begin /* No inherited template barcode identifiers... */

         /* Assign the default starting barcode identifier. */
         set @NextBarCodeId = 1000000000

         /* If there was an error... */
         if ( @@Error <> 00 ) begin

            /* Rollback the transaction. */
            rollback transaction

            /* Return the failure. */
            return 01

         end

      end

      /* While still processing the current system and while there are still
         rows to process in the cursor... */
      while ( ( @ProviderSystemId = @CurrentSystemId ) and
              ( @@Fetch_Status = 00 ) ) begin

         /* Increment the barcode identifier to get the next one to assign. */
         set @NextBarCodeId = @NextBarCodeId + 01

         /* If there was an error... */
         if ( @@Error <> 00 ) begin

            /* Rollback the transaction. */
            rollback transaction

            /* Return the failure. */
            return 01

         end

         /* Convert the next barcode identifier to assign to the table. */
         set @NewBarCodeId = Cast( @NextBarCodeId as varchar(10) )

         /* If there was an error... */
         if ( @@Error <> 00 ) begin

            /* Rollback the transaction. */
            rollback transaction

            /* Return the failure. */
            return 01

         end

         /* Update the service data item with the new barcode identifier. */
         update PROVIDER_SERVICE_DATA
         set BARCODE_ID = @NewBarCodeId
         where PROVIDER_SERVICE_DATA_ID = @ServiceDataId

         /* Get the rows affected and the error code for the previous
            statement.  Error checking MUST be done this way since any single
            statement executed will affect both of the global functions,
            @@RowCount and @@Error. */
         select @RowsAffected = @@RowCount, @ErrorCode = @@Error

         /* If there was an error... */
         if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

            /* Rollback the transaction. */
            rollback transaction

            /* Return the failure. */
            return 01

         end

         /* Move to the next row in the result set. */
         fetch next from BarCodeIdCursor into @ProviderSystemId,
                                              @ServiceDataId

      end

   end

   /* Close the cursor and release the result set. */
   close BarCodeIdCursor

   /* Release the resources allocated for the cursor. */
   deallocate BarCodeIdCursor

   /* Commit the transaction. */
   commit transaction

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spFindAndUpdateParentIdDisplay' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spFindAndUpdateParentIdDisplay

   go

create procedure spFindAndUpdateParentIdDisplay( @CustomerUnitId integer ) as

   declare @ParentUnitId integer

   declare @ErrorCode     integer /* Error code returned by the execution of the last statement   */
   declare @Transactions  integer /* Number of active transactions at the start of this procedure */
   declare @ReturnCode    integer /* Result code returned by the execution of the stored procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   select @ParentUnitId = tu.PARENT_UNIT_ID from #TEMP_UNIT tu
   where tu.CUSTOMER_UNIT_ID = @CustomerUnitId

    /* If there was an error... */
   if ( @ErrorCode <> 00 )  begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   update #TEMP_UNIT set [DISPLAY_SERVICE] = 'Y'
   where CUSTOMER_UNIT_ID = @CustomerUnitId

    /* If there was an error... */
   if ( @ErrorCode <> 00 )  begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   if @CustomerUnitId <> -1 begin
      execute @ReturnCode = spFindAndUpdateParentIdDisplay @ParentUnitId

        /* If there was an error... */
      if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

      end

   end

     /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetAgreementById' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetAgreementById

   go

create procedure spGetAgreementById ( @agreementid integer ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @RowsAffected integer /* Number of rows affected by the previously executed statement */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   select AGREEMENT_ID, AGREEMENT_TEXT, AGREEMENT_HTML
   from AGREEMENT
   where AGREEMENT_ID = @agreementid

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetApplicationHelpHelpIdByPage' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetApplicationHelpHelpIdByPage

   go

create procedure spGetApplicationHelpHelpIdByPage( @PhysicalPage integer,
                                                   @LogicalPage  integer,
                                                   @HelpAction   integer,
                                                   @HelpId       integer output ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @RowsAffected integer /* Number of rows affected by the previously executed statement */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Get the target row. */
   select @HelpId   = HELP_ID
   from APPLICATION_HELP
   where PHYSICAL_PAGE = @PhysicalPage and
         LOGICAL_PAGE  = @LogicalPage  and
         HELP_ACTION   = @HelpAction

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetApplicationHelpPageByHelpId' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetApplicationHelpPageByHelpId

   go

create procedure spGetApplicationHelpPageByHelpId( @HelpId       integer,
                                                   @PhysicalPage integer  output,
                                                   @LogicalPage  integer  output,
                                                   @HelpAction   integer  output ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @RowsAffected integer /* Number of rows affected by the previously executed statement */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Get the target row. */
   select @PhysicalPage = PHYSICAL_PAGE,
          @LogicalPage  = LOGICAL_PAGE,
          @HelpAction   = HELP_ACTION
   from APPLICATION_HELP
   where HELP_ID = @HelpId

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetApplicationHelpTextByHelpId' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetApplicationHelpTextByHelpId

   go

create procedure spGetApplicationHelpTextByHelpId( @HelpId integer ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @RowsAffected integer /* Number of rows affected by the previously executed statement */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Delete the target row. */
   select HELP_TEXT
   from APPLICATION_HELP
   where HELP_ID = @HelpId

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetApplicationHelpTextByPage' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetApplicationHelpTextByPage

   go

create procedure spGetApplicationHelpTextByPage( @PhysicalPage integer,
                                                 @LogicalPage  integer,
                                                 @HelpAction   integer ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @RowsAffected integer /* Number of rows affected by the previously executed statement */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Get the target row. */
   select HELP_TEXT
   from APPLICATION_HELP
   where PHYSICAL_PAGE = @PhysicalPage and
         LOGICAL_PAGE  = @LogicalPage  and
         HELP_ACTION   = @HelpAction

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetApplicationReportByReportId' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetApplicationReportByReportId

   go

create procedure spGetApplicationReportByReportId( @ReportId       integer,
                                                   @ReportNumber   integer          output,
                                                   @ReportName     varchar(50)  output,
                                                   @ReportFileName varchar(50)  output,
                                                   @ReportCaption  varchar(100) output ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @RowsAffected integer /* Number of rows affected by the previously executed statement */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Get the target row. */
   select @ReportNumber   = REPORT_NUMBER,
          @ReportName     = REPORT_NAME,
          @ReportFileName = REPORT_FILENAME,
          @ReportCaption  = REPORT_CAPTION
   from APPLICATION_REPORT
   where REPORT_ID = @ReportId

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetApplicationReportByReportNumber' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetApplicationReportByReportNumber

   go

create procedure spGetApplicationReportByReportNumber( @ReportNumber   integer,
                                                       @ReportId       integer          output,
                                                       @ReportName     varchar(50)  output,
                                                       @ReportFileName varchar(50)  output,
                                                       @ReportCaption  varchar(100) output ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @RowsAffected integer /* Number of rows affected by the previously executed statement */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Get the target row. */
   select @ReportId       = REPORT_ID,
          @ReportName     = REPORT_NAME,
          @ReportFileName = REPORT_FILENAME,
          @ReportCaption  = REPORT_CAPTION
   from APPLICATION_REPORT
   where REPORT_NUMBER = @ReportNumber

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetApplicationReports' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetApplicationReports

   go

create procedure spGetApplicationReports( @ApplicationId integer ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @RowsAffected integer /* Number of rows affected by the previously executed statement */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Get the target row. */
   select REPORT_CAPTION,
          REPORT_NUMBER,
          REPORT_ID
   from APPLICATION_REPORT ar
   inner join JOIN_APPLICATION_APPLICATION_REPORT jaar on ar.REPORT_ID = jaar.REPORT_ID
   where jaar.APPLICATION_ID = @ApplicationId
   order by REPORT_CAPTION

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetBranchTransactionsByInterfaceId' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetBranchTransactionsByInterfaceId

   go

create procedure spGetBranchTransactionsByInterfaceId ( @InterfaceId integer ) as

   select
   mg.MEMBER_GROUP_ID   as BranchId,
   mg.MEMBER_GROUP_NAME as BranchName,
   me.FOREIGN_ID        as ForeignId,
   me.FOREIGN_TYPE      as ForeignType
   from MEMBER_GROUP mg
   inner join MEMBER_GROUP_TYPE mgt  on mg.MEMBER_GROUP_TYPE_ID = mgt.MEMBER_GROUP_TYPE_ID
   inner join MAPPING_INTERFACE mi   on mi.INTERFACE_ID         = @InterfaceId
   inner join TRANSACTION_LOG tl     on mi.INTERFACE_ID         = tl.INTERFACE_ID and
                                        mg.MEMBER_GROUP_ID      = tl.ENTITY_ID and
                                        tl.ENTITY_TYPE_ID       = 15
   left outer join MAPPING_ENTITY me on tl.INTERFACE_ID         = me.INTERFACE_ID and
                                        tl.ENTITY_ID            = me.ENTITY_ID and
                                        tl.ENTITY_TYPE_ID       = me.ENTITY_TYPE_ID
   where mgt.MEMBER_GROUP_TYPE_NAME = 'Branches'
     and tl.TRANSMITTED             = 0
   order by mg.MEMBER_GROUP_ID, me.FOREIGN_ID

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetCategoryDataByPropertyDate' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetCategoryDataByPropertyDate

   go

create procedure spGetCategoryDataByPropertyDate( @ServiceCategoryId integer,
                                                  @StartDate         varchar(10),
                                                  @EndDate           varchar(10) ) as

   declare @sqlselect nvarchar( 4000 )
   declare @sqlfrom   nvarchar( 4000 )
   declare @tabtable  nvarchar( 4000 )
   declare @tabinsert nvarchar( 4000 )
   declare @tabselect nvarchar( 4000 )
   declare @tabfrom   nvarchar( 4000 )
   declare @tabwhere  nvarchar( 4000 )
   declare @tabgroup  nvarchar( 4000 )
   declare @tmpsql    nvarchar( 4000 )

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   set nocount on

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   set @tabtable = char(13) + 'declare @tab table ( SERVICE_DETAIL_ID integer, SERVICE_ID integer, PARENT_UNIT_ID integer, SERVICE_DATE datetime, SERVICE_UNIT_ID integer, CATEGORY_ID integer, ROW_ID integer '

   set @tabinsert = char(13) + 'insert into @tab  ( SERVICE_DETAIL_ID, SERVICE_ID, PARENT_UNIT_ID, SERVICE_DATE, SERVICE_UNIT_ID, CATEGORY_ID, ROW_ID '

   set @tabselect = char(13) + 'select csuv.COM_SERVICE_UNIT_VALUE_ID, cs.COM_SERVICE_ID, cs.CUSTOMER_UNIT_ID, cs.COM_SERVICE_DATE, csuv.CUSTOMER_UNIT_ID, psdt.PROVIDER_SERVICE_CATEGORY_ID, csd.ROW_ID '

   set @tabfrom =  char(13)+ 'from com_service_unit_value csuv '
   set @tabfrom = @tabfrom + char(13) + 'inner join com_service cs                        on csuv.com_service_id                = cs.com_service_id '
   set @tabfrom = @tabfrom + char(13) + 'inner join com_service_data csd                  on csuv.com_service_unit_value_id     = csd.com_service_unit_value_id '
   set @tabfrom = @tabfrom + char(13) + 'inner join provider_service_data_type psdt       on csd.provider_service_data_type_id  = psdt.provider_service_data_type_id '

   set @tabwhere = char(13) + 'where psdt.provider_service_category_id  = ' + cast(@ServiceCategoryId   as varchar(10)) + ''
   set @tabwhere = @tabwhere + char(13) + '  and cs.com_service_date >= ''' + convert(varchar(10), @StartDate, 01) + ''''
   set @tabwhere = @tabwhere + char(13) + '  and cs.com_service_date <= ''' + convert(varchar(10), @EndDate, 01) + ''''

   set @tabgroup = char(13) + 'group by csuv.COM_SERVICE_UNIT_VALUE_ID, cs.COM_SERVICE_ID, cs.CUSTOMER_UNIT_ID, cs.COM_SERVICE_DATE, csuv.CUSTOMER_UNIT_ID, psdt.PROVIDER_SERVICE_CATEGORY_ID, csd.ROW_ID '
   set @tabgroup = @tabgroup + char(13) + 'order by csuv.COM_SERVICE_UNIT_VALUE_ID, cs.COM_SERVICE_ID, cs.CUSTOMER_UNIT_ID, cs.COM_SERVICE_DATE, csuv.CUSTOMER_UNIT_ID, psdt.PROVIDER_SERVICE_CATEGORY_ID, csd.ROW_ID '

   set @sqlselect = char(13) + 'select cu.customer_unit_name as Property, a.service_date as Date '

   set @sqlfrom = char(13) + 'from @tab a'
   set @sqlfrom = @sqlfrom + char(13) + 'inner join customer_unit cu on a.parent_unit_id  = cu.customer_unit_id and cu.unit_parent_id = -1'

   declare @datatypeid   integer
   declare @datatype     varchar(50)

   declare data_type_cursor cursor for
   select psdt.provider_service_data_type_id, isnull(psdt.provider_service_data_type_text, tpsdt.provider_service_data_type_text) as provider_service_data_type_text
   from provider_service_data_type psdt
   left outer join template_provider_service_data_type tpsdt on psdt.template_provider_service_data_type_id = tpsdt.provider_service_data_type_id
   where provider_service_category_id = @ServiceCategoryId
   order by psdt.sort_order, tpsdt.sort_order

    /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   open data_type_cursor
   fetch next from data_type_cursor into
   @datatypeid,
   @datatype

   while ( @@fetch_status = 0 ) begin

      select @DataType = replace(@DataType, ',', '' )
      select @DataType = replace(@DataType, ' ', '_')

      if exists ( select name from tempdb..sysobjects where name like '#tmp2%' ) begin
         set @tmpsql = 'ALTER TABLE #tmp2 ADD ' + @datatype + ' varchar(255) NULL'
         exec(@tmpsql)
          /* Get the error code for the previous statement.
          Error checking MUST be done this way since any single statement executed
          will affect both of the global functions,  @@Error. */
          select @ErrorCode = @@Error

          /* If there was an error... */
          if ( @ErrorCode <> 00 ) begin

          /* Rollback the transaction. */
             rollback transaction

             /* Return the failure. */
             return 01

          end

      end

      set @tabtable = @tabtable + ',' + char(13) + '[' + @datatype + '] varchar(255) NULL' + char(13)
      set @tabinsert = @tabinsert + ',' + char(13) + '[' + @datatype + ']'
      set @tabselect = @tabselect + ',' + char(13) + 'sum(case psdt.provider_service_data_type_id when ' + cast(@datatypeid as varchar(10)) + ' then csd.com_service_data_id else NULL end) as ' + '[' + @datatype + ']'

      set @sqlselect = @sqlselect + ',' + char(13) + 'dt' + cast(@datatypeid as varchar(10)) + '.com_service_data_alt_text as ' + '[' + @datatype + ']'
      set @sqlfrom = @sqlfrom + char(13) + 'left outer join com_service_data dt' + cast(@datatypeid as varchar(10)) + ' on a.[' + @datatype + ']= dt' + cast(@datatypeid as varchar(10)) + '.com_service_data_id'

   fetch next from data_type_cursor into
   @datatypeid,
   @datatype

   end

   close data_type_cursor
   deallocate data_type_cursor

   set @tabtable = @tabtable   + ') ' + char(13)
   set @tabinsert = @tabinsert + ') ' + char(13)

   if exists ( select name from tempdb..sysobjects where name like '#tmp2%' ) begin
     insert into #tmp2 exec( @tabTable + @tabInsert + @tabSelect + @tabFrom + @tabwhere + @tabgroup + @sqlSelect + @sqlFrom )
   end
   else begin
     exec( @tabTable + @tabInsert + @tabSelect + @tabFrom + @tabwhere + @tabgroup + @sqlSelect + @sqlFrom )
   end

    /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetCategoryDataByPropertyDateCustomer' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetCategoryDataByPropertyDateCustomer

   go

create procedure spGetCategoryDataByPropertyDateCustomer( @CustomerId        integer,
                                                          @ServiceCategoryId integer,
                                                          @StartDate         varchar(10),
                                                          @EndDate           varchar(10) ) as

   declare @sqlselect nvarchar( 4000 )
   declare @sqlfrom   nvarchar( 4000 )
   declare @tabtable  nvarchar( 4000 )
   declare @tabinsert nvarchar( 4000 )
   declare @tabselect nvarchar( 4000 )
   declare @tabfrom   nvarchar( 4000 )
   declare @tabwhere  nvarchar( 4000 )
   declare @tabgroup  nvarchar( 4000 )
   declare @tmpsql    nvarchar( 4000 )

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   set nocount on

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   set @tabtable = char(13) + 'declare @tab table ( SERVICE_DETAIL_ID integer, SERVICE_ID integer, PARENT_UNIT_ID integer, SERVICE_DATE datetime, SERVICE_UNIT_ID integer, CATEGORY_ID integer '

   set @tabinsert = char(13) + 'insert into @tab  ( SERVICE_DETAIL_ID, SERVICE_ID, PARENT_UNIT_ID, SERVICE_DATE, SERVICE_UNIT_ID, CATEGORY_ID '

   set @tabselect = char(13) + 'select csuv.COM_SERVICE_UNIT_VALUE_ID, cs.COM_SERVICE_ID, cs.CUSTOMER_UNIT_ID, cs.COM_SERVICE_DATE, csuv.CUSTOMER_UNIT_ID, psdt.PROVIDER_SERVICE_CATEGORY_ID '

   set @tabfrom =  char(13)+ 'from com_service_unit_value csuv '
   set @tabfrom = @tabfrom + char(13) + 'inner join com_service cs                        on csuv.com_service_id                = cs.com_service_id '
   set @tabfrom = @tabfrom + char(13) + 'left outer join com_service_data csd             on csuv.com_service_unit_value_id     = csd.com_service_unit_value_id '
   set @tabfrom = @tabfrom + char(13) + 'inner join provider_service_data_type psdt       on csd.provider_service_data_type_id  = psdt.provider_service_data_type_id '

   set @tabwhere = char(13) + 'where psdt.provider_service_category_id  = ' + cast(@ServiceCategoryId   as varchar(10)) + ''
   set @tabwhere = @tabwhere + char(13) + '  and cs.com_service_date >= ''' + convert(varchar(10), @StartDate, 01) + ''''
   set @tabwhere = @tabwhere + char(13) + '  and cs.com_service_date <= ''' + convert(varchar(10), @EndDate, 01) + ''''

   if ( @CustomerId > 0 ) begin

      set @tabfrom = @tabfrom + char(13) + 'inner join customer_unit cu on cs.customer_unit_id  = cu.customer_unit_id '

      set @tabwhere = @tabwhere + char(13) + '  and cu.customer_id = ' + cast( @CustomerId as varchar( 25 ) ) + ''

   end

   set @tabgroup = char(13) + 'group by csuv.COM_SERVICE_UNIT_VALUE_ID, cs.COM_SERVICE_ID, cs.CUSTOMER_UNIT_ID, cs.COM_SERVICE_DATE, csuv.CUSTOMER_UNIT_ID, psdt.PROVIDER_SERVICE_CATEGORY_ID '
   set @tabgroup = @tabgroup + char(13) + 'order by csuv.COM_SERVICE_UNIT_VALUE_ID, cs.COM_SERVICE_ID, cs.CUSTOMER_UNIT_ID, cs.COM_SERVICE_DATE, csuv.CUSTOMER_UNIT_ID, psdt.PROVIDER_SERVICE_CATEGORY_ID '

   set @sqlselect = char(13) + 'select cu.customer_unit_name as Property, a.service_date as Date, m.member_id, m.member_name '

   set @sqlfrom = char(13) + 'from @tab a'
   set @sqlfrom = @sqlfrom + char(13) + 'inner join customer_unit cu on a.parent_unit_id  = cu.customer_unit_id and cu.unit_parent_id = -1'
   set @sqlfrom = @sqlfrom + char(13) + 'inner join member m on cu.customer_id  = m.member_id '

   declare @datatypeid   integer
   declare @datatype     varchar(50)

   declare data_type_cursor cursor for
   select psdt.provider_service_data_type_id, isnull(psdt.provider_service_data_type_text, tpsdt.provider_service_data_type_text) as provider_service_data_type_text
   from provider_service_data_type psdt
   left outer join template_provider_service_data_type tpsdt on psdt.template_provider_service_data_type_id = tpsdt.provider_service_data_type_id
   where provider_service_category_id = @ServiceCategoryId
   order by psdt.sort_order, tpsdt.sort_order

    /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   open data_type_cursor

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   fetch next from data_type_cursor into
   @datatypeid,
   @datatype


   while ( @@fetch_status = 0 ) begin

      select @DataType = replace(@DataType, ',', '' )
      select @DataType = replace(@DataType, ' ', '_')

      if exists ( select name from tempdb..sysobjects where name like '#tmp2%' ) begin
         set @tmpsql = 'ALTER TABLE #tmp2 ADD ' + @datatype + ' varchar(255) NULL'
         exec(@tmpsql)
      end

      set @tabtable = @tabtable + ',' + char(13) + '[' + @datatype + '] varchar(255) NULL' + char(13)
      set @tabinsert = @tabinsert + ',' + char(13) + '[' + @datatype + ']'
      set @tabselect = @tabselect + ',' + char(13) + 'sum(case psdt.provider_service_data_type_id when ' + cast(@datatypeid as varchar(10)) + ' then csd.com_service_data_id else NULL end) as ' + '[' + @datatype + '] '

      set @sqlselect = @sqlselect + ',' + char(13) + 'dt' + cast(@datatypeid as varchar(10)) + '.com_service_data_alt_text as ' + '[' + @datatype + '] '
      set @sqlfrom = @sqlfrom + char(13) + 'left outer join com_service_data dt' + cast(@datatypeid as varchar(10)) + ' on a.[' + @datatype + ']= dt' + cast(@datatypeid as varchar(10)) + '.com_service_data_id '

   fetch next from data_type_cursor into
   @datatypeid,
   @datatype

   end

   close data_type_cursor
   deallocate data_type_cursor

   set @tabtable = @tabtable   + ') ' + char(13)
   set @tabinsert = @tabinsert + ') ' + char(13)
   set @sqlFrom = @sqlFrom + char(13) + 'order by m.member_name, cu.customer_unit_name, a.service_date desc '

   if exists ( select name from tempdb..sysobjects where name like '#tmp2%' ) begin
     insert into #tmp2 exec( @tabTable + @tabInsert + @tabSelect + @tabFrom + @tabwhere + @tabgroup + @sqlSelect + @sqlFrom )
   end
   else begin
     exec( @tabTable + @tabInsert + @tabSelect + @tabFrom + @tabwhere + @tabgroup + @sqlSelect + @sqlFrom )
   end

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

      /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetCategoryDataByPropertyDateGroup' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetCategoryDataByPropertyDateGroup

   go

create procedure spGetCategoryDataByPropertyDateGroup( @ServiceCategoryId integer,
                                                       @StartDate         varchar(10),
                                                       @EndDate           varchar(10) ) as

   declare @sqlselect nvarchar( 4000 )
   declare @sqlfrom   nvarchar( 4000 )
   declare @tabtable  nvarchar( 4000 )
   declare @tabinsert nvarchar( 4000 )
   declare @tabselect nvarchar( 4000 )
   declare @tabfrom   nvarchar( 4000 )
   declare @tabwhere  nvarchar( 4000 )
   declare @tabgroup  nvarchar( 4000 )
   declare @tmpsql    nvarchar( 4000 )

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   set nocount on

    /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   set @tabtable = char(13) + 'declare @tab table ( SERVICE_DETAIL_ID integer, SERVICE_ID integer, PARENT_UNIT_ID integer, SERVICE_DATE datetime, SERVICE_UNIT_ID integer, CATEGORY_ID integer '

   set @tabinsert = char(13) + 'insert into @tab  ( SERVICE_DETAIL_ID, SERVICE_ID, PARENT_UNIT_ID, SERVICE_DATE, SERVICE_UNIT_ID, CATEGORY_ID '

   set @tabselect = char(13) + 'select csuv.COM_SERVICE_UNIT_VALUE_ID, cs.COM_SERVICE_ID, cs.CUSTOMER_UNIT_ID, cs.COM_SERVICE_DATE, csuv.CUSTOMER_UNIT_ID, psdt.PROVIDER_SERVICE_CATEGORY_ID '

   set @tabfrom =  char(13)+ 'from com_service_unit_value csuv '
   set @tabfrom = @tabfrom + char(13) + 'inner join com_service cs                        on csuv.com_service_id                = cs.com_service_id '
   set @tabfrom = @tabfrom + char(13) + 'left outer join com_service_data csd             on csuv.com_service_unit_value_id     = csd.com_service_unit_value_id '
   set @tabfrom = @tabfrom + char(13) + 'inner join provider_service_data_type psdt       on csd.provider_service_data_type_id  = psdt.provider_service_data_type_id '

   set @tabwhere = char(13) + 'where psdt.provider_service_category_id  = ' + cast(@ServiceCategoryId   as varchar(10)) + ''
   set @tabwhere = @tabwhere + char(13) + '  and cs.com_service_date >= ''' + convert(varchar(10), @StartDate, 01) + ''''
   set @tabwhere = @tabwhere + char(13) + '  and cs.com_service_date <= ''' + convert(varchar(10), @EndDate, 01) + ''''

   set @tabgroup = char(13) + 'group by csuv.COM_SERVICE_UNIT_VALUE_ID, cs.COM_SERVICE_ID, cs.CUSTOMER_UNIT_ID, cs.COM_SERVICE_DATE, csuv.CUSTOMER_UNIT_ID, psdt.PROVIDER_SERVICE_CATEGORY_ID '
   set @tabgroup = @tabgroup + char(13) + 'order by csuv.COM_SERVICE_UNIT_VALUE_ID, cs.COM_SERVICE_ID, cs.CUSTOMER_UNIT_ID, cs.COM_SERVICE_DATE, csuv.CUSTOMER_UNIT_ID, psdt.PROVIDER_SERVICE_CATEGORY_ID '

   set @sqlselect = char(13) + 'select cu.customer_unit_name as Property, a.service_date as Date, mg.member_group_id, mg.member_group_name, mgt.member_group_type_name '

   set @sqlfrom = char(13) + 'from @tab a'
   set @sqlfrom = @sqlfrom + char(13) + 'inner join customer_unit cu on a.parent_unit_id  = cu.customer_unit_id and cu.unit_parent_id = -1'
   set @sqlfrom = @sqlfrom + char(13) + 'inner join join_member_group_customer_unit jmgcu on cu.customer_unit_id  = jmgcu.customer_unit_id '
   set @sqlfrom = @sqlfrom + char(13) + 'inner join member_group mg on jmgcu.member_group_id  = mg.member_group_id '
   set @sqlfrom = @sqlfrom + char(13) + 'inner join member_group_type mgt on mg.member_group_type_id  = mgt.member_group_type_id '

   declare @datatypeid   integer
   declare @datatype     varchar(50)

   declare data_type_cursor cursor for
   select psdt.provider_service_data_type_id, isnull(psdt.provider_service_data_type_text, tpsdt.provider_service_data_type_text) as provider_service_data_type_text
   from provider_service_data_type psdt
   left outer join template_provider_service_data_type tpsdt on psdt.template_provider_service_data_type_id = tpsdt.provider_service_data_type_id
   where provider_service_category_id = @ServiceCategoryId
   order by psdt.sort_order, tpsdt.sort_order

    /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   open data_type_cursor
    /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   fetch next from data_type_cursor into
   @datatypeid,
   @datatype

   while ( @@fetch_status = 0 ) begin

      select @DataType = replace(@DataType, ',', '' )
      select @DataType = replace(@DataType, ' ', '_')

      if exists ( select name from tempdb..sysobjects where name like '#tmp2%' ) begin
         set @tmpsql = 'ALTER TABLE #tmp2 ADD ' + @datatype + ' varchar(255) NULL'
         exec(@tmpsql)

          /* Get the error code for the previous statement.
          Error checking MUST be done this way since any single statement executed
          will affect both of the global functions,  @@Error. */
          select @ErrorCode = @@Error

           /* If there was an error... */
           if ( @ErrorCode <> 00 ) begin

              /* Rollback the transaction. */
              rollback transaction

              /* Return the failure. */
              return 01

           end

      end

      set @tabtable = @tabtable + ',' + char(13) + '[' + @datatype + '] varchar(255) NULL' + char(13)
      set @tabinsert = @tabinsert + ',' + char(13) + '[' + @datatype + ']'
      set @tabselect = @tabselect + ',' + char(13) + 'sum(case psdt.provider_service_data_type_id when ' + cast(@datatypeid as varchar(10)) + ' then csd.com_service_data_id else NULL end) as ' + '[' + @datatype + ']'

      set @sqlselect = @sqlselect + ',' + char(13) + 'dt' + cast(@datatypeid as varchar(10)) + '.com_service_data_alt_text as ' + '[' + @datatype + ']'
      set @sqlfrom = @sqlfrom + char(13) + 'left outer join com_service_data dt' + cast(@datatypeid as varchar(10)) + ' on a.[' + @datatype + ']= dt' + cast(@datatypeid as varchar(10)) + '.com_service_data_id'

   fetch next from data_type_cursor into
   @datatypeid,
   @datatype

   end

   close data_type_cursor
   deallocate data_type_cursor

   set @tabtable = @tabtable   + ') ' + char(13)
   set @tabinsert = @tabinsert + ') ' + char(13)

   if exists ( select name from tempdb..sysobjects where name like '#tmp2%' ) begin
     insert into #tmp2 exec( @tabTable + @tabInsert + @tabSelect + @tabFrom + @tabwhere + @tabgroup + @sqlSelect + @sqlFrom )
   end
   else begin
     exec( @tabTable + @tabInsert + @tabSelect + @tabFrom + @tabwhere + @tabgroup + @sqlSelect + @sqlFrom )
   end

    /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

    /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetCategoryDataByPropertyDateTechnician' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetCategoryDataByPropertyDateTechnician

   go

create procedure spGetCategoryDataByPropertyDateTechnician( @ServiceCategoryId integer,
                                                            @StartDate         varchar(10),
                                                            @EndDate           varchar(10) ) as

   declare @sqlselect nvarchar( 4000 )
   declare @sqlfrom   nvarchar( 4000 )
   declare @tabtable  nvarchar( 4000 )
   declare @tabinsert nvarchar( 4000 )
   declare @tabselect nvarchar( 4000 )
   declare @tabfrom   nvarchar( 4000 )
   declare @tabwhere  nvarchar( 4000 )
   declare @tabgroup  nvarchar( 4000 )
   declare @tmpsql    nvarchar( 4000 )

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   set nocount on

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   set @tabtable = char(13) + 'declare @tab table ( SERVICE_DETAIL_ID integer, SERVICE_ID integer, PARENT_UNIT_ID integer, SERVICE_DATE datetime, SERVICE_UNIT_ID integer, CATEGORY_ID integer '

   set @tabinsert = char(13) + 'insert into @tab  ( SERVICE_DETAIL_ID, SERVICE_ID, PARENT_UNIT_ID, SERVICE_DATE, SERVICE_UNIT_ID, CATEGORY_ID '

   set @tabselect = char(13) + 'select csuv.COM_SERVICE_UNIT_VALUE_ID, cs.COM_SERVICE_ID, cs.CUSTOMER_UNIT_ID, cs.COM_SERVICE_DATE, csuv.CUSTOMER_UNIT_ID, psdt.PROVIDER_SERVICE_CATEGORY_ID '

   set @tabfrom =  char(13)+ 'from com_service_unit_value csuv '
   set @tabfrom = @tabfrom + char(13) + 'inner join com_service cs                        on csuv.com_service_id                = cs.com_service_id '
   set @tabfrom = @tabfrom + char(13) + 'left outer join com_service_data csd             on csuv.com_service_unit_value_id     = csd.com_service_unit_value_id '
   set @tabfrom = @tabfrom + char(13) + 'inner join provider_service_data_type psdt       on csd.provider_service_data_type_id  = psdt.provider_service_data_type_id '

   set @tabwhere = char(13) + 'where psdt.provider_service_category_id  = ' + cast(@ServiceCategoryId   as varchar(10)) + ''
   set @tabwhere = @tabwhere + char(13) + '  and cs.com_service_date >= ''' + convert(varchar(10), @StartDate, 01) + ''''
   set @tabwhere = @tabwhere + char(13) + '  and cs.com_service_date <= ''' + convert(varchar(10), @EndDate, 01) + ''''

   set @tabgroup = char(13) + 'group by csuv.COM_SERVICE_UNIT_VALUE_ID, cs.COM_SERVICE_ID, cs.CUSTOMER_UNIT_ID, cs.COM_SERVICE_DATE, csuv.CUSTOMER_UNIT_ID, psdt.PROVIDER_SERVICE_CATEGORY_ID '
   set @tabgroup = @tabgroup + char(13) + 'order by csuv.COM_SERVICE_UNIT_VALUE_ID, cs.COM_SERVICE_ID, cs.CUSTOMER_UNIT_ID, cs.COM_SERVICE_DATE, csuv.CUSTOMER_UNIT_ID, psdt.PROVIDER_SERVICE_CATEGORY_ID '

   set @sqlselect = char(13) + 'select cu.customer_unit_name as Property, a.service_date as Date, mu.member_user_id, mu.member_user_fname + '' '' + mu.member_user_lname as technician_name'

   set @sqlfrom = char(13) + 'from @tab a'
   set @sqlfrom = @sqlfrom + char(13) + 'inner join customer_unit cu on a.parent_unit_id  = cu.customer_unit_id and cu.unit_parent_id = -1'
   set @sqlfrom = @sqlfrom + char(13) + 'inner join com_service cs on a.service_id  = cs.com_service_id '
   set @sqlfrom = @sqlfrom + char(13) + 'inner join member_user mu on cs.technician_id  = mu.member_user_id '

   declare @datatypeid   integer
   declare @datatype     varchar(50)

   declare data_type_cursor cursor for
   select psdt.provider_service_data_type_id, isnull(psdt.provider_service_data_type_text, tpsdt.provider_service_data_type_text) as provider_service_data_type_text
   from provider_service_data_type psdt
   left outer join template_provider_service_data_type tpsdt on psdt.template_provider_service_data_type_id = tpsdt.provider_service_data_type_id
   where provider_service_category_id = @ServiceCategoryId
   order by psdt.sort_order, tpsdt.sort_order

   open data_type_cursor

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   fetch next from data_type_cursor into
   @datatypeid,
   @datatype

   while ( @@fetch_status = 0 ) begin

      select @DataType = replace(@DataType, ',', '' )
      select @DataType = replace(@DataType, ' ', '_')

      if exists ( select name from tempdb..sysobjects where name like '#tmp2%' ) begin
         set @tmpsql = 'ALTER TABLE #tmp2 ADD ' + @datatype + ' varchar(255) NULL'
         exec(@tmpsql)

         /* Get the error code for the previous statement.
         Error checking MUST be done this way since any single statement executed
         will affect both of the global functions,  @@Error. */
        select @ErrorCode = @@Error

        /* If there was an error... */
       if ( @ErrorCode <> 00 ) begin

            /* Rollback the transaction. */
            rollback transaction

            /* Return the failure. */
            return 01

         end

      end

      set @tabtable = @tabtable + ',' + char(13) + '[' + @datatype + '] varchar(255) NULL' + char(13)
      set @tabinsert = @tabinsert + ',' + char(13) + '[' + @datatype + ']'
      set @tabselect = @tabselect + ',' + char(13) + 'sum(case psdt.provider_service_data_type_id when ' + cast(@datatypeid as varchar(10)) + ' then csd.com_service_data_id else NULL end) as ' + '[' + @datatype + ']'

      set @sqlselect = @sqlselect + ',' + char(13) + 'dt' + cast(@datatypeid as varchar(10)) + '.com_service_data_alt_text as ' + '[' + @datatype + ']'
      set @sqlfrom = @sqlfrom + char(13) + 'left outer join com_service_data dt' + cast(@datatypeid as varchar(10)) + ' on a.[' + @datatype + ']= dt' + cast(@datatypeid as varchar(10)) + '.com_service_data_id'

   fetch next from data_type_cursor into
   @datatypeid,
   @datatype

   end

   close data_type_cursor
   deallocate data_type_cursor

   set @tabtable = @tabtable   + ') ' + char(13)
   set @tabinsert = @tabinsert + ') ' + char(13)

   if exists ( select name from tempdb..sysobjects where name like '#tmp2%' ) begin
     insert into #tmp2 exec( @tabTable + @tabInsert + @tabSelect + @tabFrom + @tabwhere + @tabgroup + @sqlSelect + @sqlFrom )
   end
   else begin
     exec( @tabTable + @tabInsert + @tabSelect + @tabFrom + @tabwhere + @tabgroup + @sqlSelect + @sqlFrom )
   end

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetCategoryDataByUnitTypeDateCustomer' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetCategoryDataByUnitTypeDateCustomer

   go

create procedure spGetCategoryDataByUnitTypeDateCustomer( @CustomerId         integer,
                                                          @CustomerUnitTypeId integer,
                                                          
@ServiceCategoryId  integer,
                                                          @ServiceValueId     integer,
                                                          @StartDate          datetime,
                                                          @EndDate            datetime  ) as

   set nocount on

   declare @sqlselect           nvarchar( 4000 ),
           @sqlfrom             nvarchar( 4000 ),
           @sqlorder            nvarchar( 4000 ),
           @tabtable            nvarchar( 4000 ),
           @tabinsert           nvarchar( 4000 ),
           @tabselect           nvarchar( 4000 ),
           @tabfrom             nvarchar( 4000 ),
           @tabwhere            nvarchar( 4000 ),
           @tabgroup            nvarchar( 4000 ),
           @tmpsql              nvarchar( 4000 ),
           @ProviderSystemName  varchar(100),
           @MemberName          varchar(100),
           @ServiceCategoryName varchar(50),
           @ServiceValue        integer,
           @ServiceValueName    varchar(60),
           @ParentUnitTypeId    integer,
           @TopParentUnitTypeId integer,
           @ParUnitTypeId       integer,
           @ChildUnitTypeId     integer

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   select @ParentUnitTypeId = customer_unit_type_parent_id
   from dbo.customer_unit_type
   where customer_unit_type_id = @CustomerUnitTypeId

    /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
      select @ErrorCode = @@Error

      /* If there was an error... */
      if ( @ErrorCode <> 00 ) begin

         /* Rollback the transaction. */
         rollback transaction

         /* Return the failure. */
         return 01

      end

   set @ChildUnitTypeId = @CustomerUnitTypeId
   while (@ChildUnitTypeId > 0 ) begin
      set @TopParentUnitTypeId = @ChildUnitTypeId
      select @ParUnitTypeId = customer_unit_type_parent_id
      from dbo.customer_unit_type
      where customer_unit_type_id = @ChildUnitTypeId

       /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
      select @ErrorCode = @@Error

      /* If there was an error... */
      if ( @ErrorCode <> 00 ) begin

         /* Rollback the transaction. */
         rollback transaction

         /* Return the failure. */
         return 01

      end

      set @ChildUnitTypeId = @ParUnitTypeId

   end

   select @ProviderSystemName = ISNULL(ps.PROVIDER_SYSTEM_NAME, tps.PROVIDER_SYSTEM_NAME )
   from dbo.customer_unit_type cut
   inner join dbo.PROVIDER_SYSTEM ps on cut.provider_system_id = ps.PROVIDER_SYSTEM_ID
   left outer join dbo.TEMPLATE_PROVIDER_SYSTEM tps on ps.TEMPLATE_PROVIDER_SYSTEM_ID = tps.PROVIDER_SYSTEM_ID
   where cut.customer_unit_type_id = @CustomerUnitTypeId

    /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   select @MemberName = member_name from dbo.member where member_id = @CustomerId

    /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   select     @ServiceValue = ISNULL( psv.provider_service_value,      tpsv.provider_service_value      ),
          @ServiceValueName = ISNULL( psv.provider_service_value_text, tpsv.provider_service_value_text )
   from dbo.provider_service_value psv
   left outer join dbo.template_provider_service_value tpsv on psv.template_provider_service_value_id = tpsv.provider_service_value_id
   where psv.provider_service_value_id = @ServiceValueId

    /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   set @ServiceValueName = cast( @ServiceValue as varchar(10) ) + ': ' + @ServiceValueName

   select @ServiceCategoryName = ISNULL( a.provider_service_category, b.provider_service_category )
   from dbo.provider_service_category  a
   left outer join template_provider_service_category b on a.template_provider_service_category_id = b.provider_service_category_id
   where a.provider_service_category_id = @ServiceCategoryId

    /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   select @ProviderSystemName = Replace(@ProviderSystemName,  '''', '''''')

   select @MemberName = Replace(@MemberName, '''', '''''')

   select @ServiceValueName = Replace(@ServiceValueName,  '''', '''''')

   select @ServiceCategoryName = Replace(@ServiceCategoryName,  '''', '''''')

   set @tabtable = char(13) + 'declare @tab table ( SERVICE_DETAIL_ID integer,
                                                    SERVICE_ID integer,
                                                    TOP_PARENT_UNIT_ID integer,
                                                    SERVICE_DATE datetime,
                                                    SERVICE_UNIT_ID integer,
                                                    UNIT_PARENT_ID integer,
                                                    CATEGORY_ID integer,
                                                    ROW_ID integer '

   set @tabinsert = char(13) + 'insert into @tab  ( SERVICE_DETAIL_ID,
                                                    SERVICE_ID,
                                                    TOP_PARENT_UNIT_ID,
                                                    SERVICE_DATE,
                                                    SERVICE_UNIT_ID,
                                                    UNIT_PARENT_ID,
                                                    CATEGORY_ID,
                                                    ROW_ID '

   set @tabselect = char(13) + 'select csuv.COM_SERVICE_UNIT_VALUE_ID,
                                       cs.COM_SERVICE_ID,
                                       cs.CUSTOMER_UNIT_ID,
                                       cs.COM_SERVICE_DATE,
                                       csuv.CUSTOMER_UNIT_ID,
                                       cu.UNIT_PARENT_ID,
                                       psdt.PROVIDER_SERVICE_CATEGORY_ID,
                                       csd.ROW_ID '

   set @tabfrom =  char(13)+ 'from com_service_unit_value csuv '
   set @tabfrom = @tabfrom + char(13) + 'inner join com_service cs                        on csuv.com_service_id                = cs.com_service_id '
   set @tabfrom = @tabfrom + char(13) + 'inner join com_service_data csd                  on csuv.com_service_unit_value_id     = csd.com_service_unit_value_id '
   set @tabfrom = @tabfrom + char(13) + 'inner join provider_service_data_type psdt       on csd.provider_service_data_type_id  = psdt.provider_service_data_type_id '
   set @tabfrom = @tabfrom + char(13) + 'inner join customer_unit cu                      on ( csuv.customer_unit_id = cu.customer_unit_id ) ' +
                                                                                          'and ( cu.customer_id = ' + cast( @CustomerId as varchar( 25 ) ) + ') '
   set @tabfrom = @tabfrom + char(13) + 'inner join dbo.JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT jcutcu on ( csuv.CUSTOMER_UNIT_ID = jcutcu.CUSTOMER_UNIT_ID ) ' +
                                                                                                        'and ( jcutcu.customer_unit_type_id = ' + cast( @CustomerUnitTypeId as varchar(10)) + ' ) '
   set @tabwhere = char(13) + 'where psdt.provider_service_category_id  = ' + cast(@ServiceCategoryId   as varchar(10)) + ''
   set @tabwhere = @tabwhere + char(13) + '  and cs.com_service_date >= ''' + convert(varchar(10), @StartDate, 01) + ''''
   set @tabwhere = @tabwhere + char(13) + '  and cs.com_service_date <= ''' + convert(varchar(10), @EndDate, 01) + ''''
   set @tabwhere = @tabwhere + char(13) + '  and csuv.provider_service_value_id = ' + cast( @ServiceValueId as varchar(10) )
   set @tabgroup = char(13) + 'group by csuv.COM_SERVICE_UNIT_VALUE_ID, cs.COM_SERVICE_ID, cs.CUSTOMER_UNIT_ID, cs.COM_SERVICE_DATE, csuv.CUSTOMER_UNIT_ID, cu.UNIT_PARENT_ID, psdt.PROVIDER_SERVICE_CATEGORY_ID, csd.ROW_ID '
   set @tabgroup = @tabgroup + char(13) + 'order by csuv.COM_SERVICE_UNIT_VALUE_ID, cs.COM_SERVICE_ID, cs.CUSTOMER_UNIT_ID, cs.COM_SERVICE_DATE, csuv.CUSTOMER_UNIT_ID, cu.UNIT_PARENT_ID, psdt.PROVIDER_SERVICE_CATEGORY_ID, csd.ROW_ID '

   set @sqlselect = char(13) + 'select a.SERVICE_DETAIL_ID, a.SERVICE_ID as COM_SERVICE_ID, a.service_date as SERVICE_DATE,  su.CUSTOMER_UNIT_ID, a.TOP_PARENT_UNIT_ID, '

   set @sqlselect = @sqlselect + char(13) + 'ISNULL( tu.CUSTOMER_UNIT_NAME,   ISNULL( tun.CUSTOMER_UNIT_NAME,   tptun.CUSTOMER_UNIT_NAME   ) ) as TOP_PARENT_UNIT_NAME, '

   set @sqlselect = @sqlselect + char(13) + 'ISNULL( tut.CUSTOMER_UNIT_TYPE_NAME, tptut.CUSTOMER_UNIT_TYPE_NAME ) as TOP_PARENT_UNIT_TYPE_NAME, '

   set @sqlselect = @sqlselect + char(13) + 'ISNULL( su.CUSTOMER_UNIT_NAME,   ISNULL( sun.CUSTOMER_UNIT_NAME,   tpsun.CUSTOMER_UNIT_NAME   ) ) as CUSTOMER_UNIT_NAME, '
   set @sqlselect = @sqlselect + char(13) + 'ISNULL( sut.CUSTOMER_UNIT_TYPE_NAME, tpsut.CUSTOMER_UNIT_TYPE_NAME ) as CUSTOMER_UNIT_TYPE_NAME, '

   set @sqlselect = @sqlselect + char(13) + 'ISNULL( pu.CUSTOMER_UNIT_NAME,   ISNULL( pun.CUSTOMER_UNIT_NAME,   tppun.CUSTOMER_UNIT_NAME   ) ) as PARENT_UNIT_NAME, '
   set @sqlselect = @sqlselect + char(13) + 'ISNULL( put.CUSTOMER_UNIT_TYPE_NAME, tpput.CUSTOMER_UNIT_TYPE_NAME ) as PARENT_UNIT_TYPE_NAME, '

   set @sqlselect = @sqlselect + char(13) + '''' + @ProviderSystemName  + '''' + ' as PROVIDER_SYSTEM_NAME, '
   set @sqlselect = @sqlselect + char(13) + '''' + @MemberName + '''' + ' as MEMBER_NAME, '
   set @sqlselect = @sqlselect + char(13) + '''' + @ServiceValueName + '''' + ' as SERVICE_VALUE, '
   set @sqlselect = @sqlselect + char(13) + '''' + @ServiceCategoryName + '''' + ' as SERVICE_CATEGORY, '
   set @sqlselect = @sqlselect + char(13) + 'a.ROW_ID'

   set @sqlfrom = char(13) + 'from @tab a'

   set @sqlfrom = @sqlfrom + char(13) + 'inner join customer_unit tu on a.TOP_PARENT_UNIT_ID  = tu.customer_unit_id and tu.unit_parent_id = -1'

   set @sqlfrom = @sqlfrom + char(13) + 'inner join dbo.JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT jcuttu on ( tu.CUSTOMER_UNIT_ID = jcuttu.CUSTOMER_UNIT_ID ) and ( jcuttu.CUSTOMER_UNIT_TYPE_ID =' + cast( @TopParentUnitTypeId as varchar(10) ) + ' )'

   set @sqlfrom = @sqlfrom + char(13) + 'inner join dbo.CUSTOMER_UNIT_TYPE tut on tut.customer_unit_type_id = jcuttu.customer_unit_type_id'
   set @sqlfrom = @sqlfrom + char(13) + 'left outer join dbo.TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE tptut on tut.template_provider_customer_unit_type_id = tptut.CUSTOMER_UNIT_TYPE_ID'

   set @sqlfrom = @sqlfrom + char(13) + 'left outer join dbo.CUSTOMER_UNIT_NAME tun on jcuttu.CUSTOMER_UNIT_NAME_ID = tun.CUSTOMER_UNIT_NAME_ID'
   set @sqlfrom = @sqlfrom + char(13) + 'left outer join dbo.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME tptun on tun.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME_ID = tptun.CUSTOMER_UNIT_NAME_ID'

   set @sqlfrom = @sqlfrom + char(13) + 'inner join customer_unit su on a.SERVICE_UNIT_ID  = su.customer_unit_id'
   set @sqlfrom = @sqlfrom + char(13) + 'inner join dbo.JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT jcutsu on ( su.CUSTOMER_UNIT_ID = jcutsu.CUSTOMER_UNIT_ID ) and ( jcutsu.CUSTOMER_UNIT_TYPE_ID = ' + Cast( @CustomerUnitTypeId as varchar(10) ) + ' )'
   set @sqlfrom = @sqlfrom + char(13) + 'inner join dbo.CUSTOMER_UNIT_TYPE sut on sut.customer_unit_type_id = jcutsu.customer_unit_type_id'
   set @sqlfrom = @sqlfrom + char(13) + 'left outer join dbo.TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE tpsut on sut.template_provider_customer_unit_type_id = tpsut.CUSTOMER_UNIT_TYPE_ID'
   set @sqlfrom = @sqlfrom + char(13) + 'left outer join dbo.CUSTOMER_UNIT_NAME sun on jcutsu.CUSTOMER_UNIT_NAME_ID = sun.CUSTOMER_UNIT_NAME_ID'
   set @sqlfrom = @sqlfrom + char(13) + 'left outer join dbo.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME tpsun on sun.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME_ID = tpsun.CUSTOMER_UNIT_NAME_ID'

   set @sqlfrom = @sqlfrom + char(13) + 'inner join customer_unit pu on a.unit_parent_id = pu.customer_unit_id'
   set @sqlfrom = @sqlfrom + char(13) + 'inner join dbo.JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT jcutpu on pu.CUSTOMER_UNIT_ID = jcutpu.CUSTOMER_UNIT_ID  and ( jcutpu.CUSTOMER_UNIT_TYPE_ID = ' + Cast( @ParentUnitTypeId as varchar(10) ) + ' )'
   set @sqlfrom = @sqlfrom + char(13) + 'inner join dbo.CUSTOMER_UNIT_TYPE put on put.customer_unit_type_id = jcutpu.customer_unit_type_id'
   set @sqlfrom = @sqlfrom + char(13) + 'left outer join dbo.TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE tpput on put.template_provider_customer_unit_type_id = tpput.CUSTOMER_UNIT_TYPE_ID'
   set @sqlfrom = @sqlfrom + char(13) + 'left outer join dbo.CUSTOMER_UNIT_NAME pun on jcutpu.CUSTOMER_UNIT_NAME_ID = pun.CUSTOMER_UNIT_NAME_ID'
   set @sqlfrom = @sqlfrom + char(13) + 'left outer join dbo.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME tppun on pun.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME_ID = tppun.CUSTOMER_UNIT_NAME_ID'

   set @sqlorder = char(13) + 'order by TOP_PARENT_UNIT_NAME, SERVICE_DATE desc, su.CUSTOMER_UNIT_ID, CUSTOMER_UNIT_NAME '

   declare @datatypeid   integer
   declare @datatype     varchar(50)

   declare data_type_cursor cursor for
   select psdt.provider_service_data_type_id, isnull(psdt.provider_service_data_type_text, tpsdt.provider_service_data_type_text) as provider_service_data_type_text
   from provider_service_data_type psdt
   left outer join template_provider_service_data_type tpsdt on psdt.template_provider_service_data_type_id = tpsdt.provider_service_data_type_id
   where provider_service_category_id = @ServiceCategoryId
   order by psdt.sort_order, tpsdt.sort_order

   open data_type_cursor

    /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   fetch next from data_type_cursor into
   @datatypeid,
   @datatype

   while ( @@fetch_status = 0 ) begin

      select @DataType = replace(@DataType, ',', '' )
      select @DataType = replace(@DataType, ' ', '_')

      set @tabtable = @tabtable + ',' + char(13) + '[' + @datatype + '] varchar(255) NULL' + char(13)
      set @tabinsert = @tabinsert + ',' + char(13) + '[' + @datatype + ']'
      set @tabselect = @tabselect + ',' + char(13) + 'sum(case psdt.provider_service_data_type_id when ' + cast(@datatypeid as varchar(10)) + ' then csd.com_service_data_id else NULL end) as ' + '[' + @datatype + ']'

      set @sqlselect = @sqlselect + ',' + char(13) + 'dt' + cast(@datatypeid as varchar(10)) + '.com_service_data_alt_text as ' + '[' + @datatype + ']'
      set @sqlfrom = @sqlfrom + char(13) + 'left outer join com_service_data dt' + cast(@datatypeid as varchar(10)) + ' on a.[' + @datatype + ']= dt' + cast(@datatypeid as varchar(10)) + '.com_service_data_id'

   fetch next from data_type_cursor into
   @datatypeid,
   @datatype

   end

   close data_type_cursor
   deallocate data_type_cursor

   set @tabtable = @tabtable   + ') ' + char(13)
   set @tabinsert = @tabinsert + ') ' + char(13)

   exec( @tabTable + @tabInsert + @tabSelect + @tabFrom + @tabwhere + @tabgroup + @sqlSelect + @sqlFrom + @sqlorder )

    /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

      /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetCategoryDataByUnitTypeDateGroup' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetCategoryDataByUnitTypeDateGroup

   go

create procedure spGetCategoryDataByUnitTypeDateGroup(   @GroupId            integer,
                                                         @CustomerUnitTypeId integer,
                                                         @ServiceCategoryId  integer,
                                                         @ServiceValueId     integer,
                                                         @StartDate          datetime,
                                                         @EndDate            datetime  ) as

   set nocount on

   declare @sqlselect          nvarchar( 4000 ),
           @sqlfrom            nvarchar( 4000 ),
           @sqlorder           nvarchar( 4000 ),
           @tabtable           nvarchar( 4000 ),
           @tabinsert          nvarchar( 4000 ),
           @tabselect          nvarchar( 4000 ),
           @tabfrom            nvarchar( 4000 ),
           @tabwhere           nvarchar( 4000 ),
           @tabgroup           nvarchar( 4000 ),
           @tmpsql             nvarchar( 4000 ),
           @ProviderSystemName varchar(100),
           @GroupType varchar(50),
           @GroupName varchar(50),
           @ServiceCategoryName varchar(50),
           @ServiceValue        integer,
           @ServiceValueName    varchar(60),
           @ParentUnitTypeId    integer,
           @TopParentUnitTypeId integer,
           @ParUnitTypeId       integer,
           @ChildUnitTypeId     integer

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

    /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */

      rollback transaction

      /* Return the failure. */
      return 01

   end

   select @ParentUnitTypeId = customer_unit_type_parent_id
   from dbo.customer_unit_type
   where customer_unit_type_id = @CustomerUnitTypeId

    /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   set @ChildUnitTypeId = @CustomerUnitTypeId
   while (@ChildUnitTypeId > 0 ) begin
      set @TopParentUnitTypeId = @ChildUnitTypeId
      select @ParUnitTypeId = customer_unit_type_parent_id
      from dbo.customer_unit_type
      where customer_unit_type_id = @ChildUnitTypeId

       /* Get the error code for the previous statement.
       Error checking MUST be done this way since any single statement executed
       will affect both of the global functions,  @@Error. */
       select @ErrorCode = @@Error

       /* If there was an error... */
      if ( @ErrorCode <> 00 ) begin

         /* Rollback the transaction. */
         rollback transaction

         /* Return the failure. */
         return 01

      end

      set @ChildUnitTypeId = @ParUnitTypeId

   end

   select @ProviderSystemName = ISNULL(ps.PROVIDER_SYSTEM_NAME, tps.PROVIDER_SYSTEM_NAME )
   from dbo.customer_unit_type cut
   inner join dbo.PROVIDER_SYSTEM ps on cut.provider_system_id = ps.PROVIDER_SYSTEM_ID
   left outer join dbo.TEMPLATE_PROVIDER_SYSTEM tps on ps.TEMPLATE_PROVIDER_SYSTEM_ID = tps.PROVIDER_SYSTEM_ID
   where cut.customer_unit_type_id = @CustomerUnitTypeId

    /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   select     @ServiceValue = ISNULL( psv.provider_service_value,      tpsv.provider_service_value      ),
          @ServiceValueName = ISNULL( psv.provider_service_value_text, tpsv.provider_service_value_text )
   from dbo.provider_service_value psv
   left outer join dbo.template_provider_service_value tpsv on psv.template_provider_service_value_id = tpsv.provider_service_value_id
   where psv.provider_service_value_id = @ServiceValueId

    /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   set @ServiceValueName = cast( @ServiceValue as varchar(10) ) + ': ' + @ServiceValueName

   select @ServiceCategoryName = ISNULL( a.provider_service_category, b.provider_service_category )
   from dbo.provider_service_category  a
   left outer join template_provider_service_category b on a.template_provider_service_category_id = b.provider_service_category_id
   where a.provider_service_category_id = @ServiceCategoryId

    /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   select @GroupType = mgt.member_group_type_name,
          @GroupName = mg.member_group_name from
          dbo.member_group mg
   inner join dbo.member_group_type mgt
   on mg.member_group_type_id = mgt.member_group_type_id
   where mg.member_group_id = @GroupId

    /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   select @ProviderSystemName = Replace(@ProviderSystemName,  '''', '''''')

   select @ServiceValueName = Replace(@ServiceValueName,  '''', '''''')

   select @ServiceCategoryName = Replace(@ServiceCategoryName,  '''', '''''')

   select @GroupType = Replace(@GroupType,  '''', '''''')

   select @GroupName = Replace(@GroupName,  '''', '''''')

   set @tabtable = char(13) + 'declare @tab table ( SERVICE_DETAIL_ID integer,
                                                    SERVICE_ID integer,
                                                    TOP_PARENT_UNIT_ID integer,
                                                    SERVICE_DATE datetime,
                                                    SERVICE_UNIT_ID integer,
                                                    UNIT_PARENT_ID integer,
                                                    CATEGORY_ID integer,
                                                    ROW_ID integer '

   set @tabinsert = char(13) + 'insert into @tab  ( SERVICE_DETAIL_ID,
                                                    SERVICE_ID,
                                                    TOP_PARENT_UNIT_ID,
                                                    SERVICE_DATE,
                                                    SERVICE_UNIT_ID,
                                                    UNIT_PARENT_ID,
                                                    CATEGORY_ID,
                                                    ROW_ID '

   set @tabselect = char(13) + 'select csuv.COM_SERVICE_UNIT_VALUE_ID,
                                       cs.COM_SERVICE_ID,
                                       cs.CUSTOMER_UNIT_ID,
                                       cs.COM_SERVICE_DATE,
                                       csuv.CUSTOMER_UNIT_ID,
                                       cu.UNIT_PARENT_ID,
                                       psdt.PROVIDER_SERVICE_CATEGORY_ID,
                                       csd.ROW_ID '

   set @tabfrom =  char(13)+ 'from com_service_unit_value csuv '
   set @tabfrom = @tabfrom + char(13) + 'inner join com_service cs                        on csuv.com_service_id                = cs.com_service_id '
   set @tabfrom = @tabfrom + char(13) + 'inner join com_service_data csd                  on csuv.com_service_unit_value_id     = csd.com_service_unit_value_id '
   set @tabfrom = @tabfrom + char(13) + 'inner join provider_service_data_type psdt       on csd.provider_service_data_type_id  = psdt.provider_service_data_type_id '
   set @tabfrom = @tabfrom + char(13) + 'inner join customer_unit cu                      on ( csuv.customer_unit_id = cu.customer_unit_id ) '
   set @tabfrom = @tabfrom + char(13) + 'inner join join_customer_unit_type_customer_unit jcutcu on ( csuv.CUSTOMER_UNIT_ID = jcutcu.CUSTOMER_UNIT_ID ) ' +
                                                                                                        'and ( jcutcu.customer_unit_type_id = ' + cast( @CustomerUnitTypeId as varchar(10)) + ' ) '

   set @tabwhere = char(13) + 'where psdt.provider_service_category_id  = ' + cast(@ServiceCategoryId   as varchar(10)) + ''
   set @tabwhere = @tabwhere + char(13) + '  and cs.com_service_date >= ''' + convert(varchar(10), @StartDate, 01) + ''''
   set @tabwhere = @tabwhere + char(13) + '  and cs.com_service_date <= ''' + convert(varchar(10), @EndDate, 01) + ''''
   set @tabwhere = @tabwhere + char(13) + '  and csuv.provider_service_value_id = ' + cast( @ServiceValueId as varchar(10) )
   set @tabgroup = char(13) + 'group by csuv.COM_SERVICE_UNIT_VALUE_ID, cs.COM_SERVICE_ID, cs.CUSTOMER_UNIT_ID, cs.COM_SERVICE_DATE, csuv.CUSTOMER_UNIT_ID, cu.UNIT_PARENT_ID, psdt.PROVIDER_SERVICE_CATEGORY_ID, csd.ROW_ID '
   set @tabgroup = @tabgroup + char(13) + 'order by csuv.COM_SERVICE_UNIT_VALUE_ID, cs.COM_SERVICE_ID, cs.CUSTOMER_UNIT_ID, cs.COM_SERVICE_DATE, csuv.CUSTOMER_UNIT_ID, cu.UNIT_PARENT_ID, psdt.PROVIDER_SERVICE_CATEGORY_ID, csd.ROW_ID '

   set @sqlselect = char(13) + 'select a.SERVICE_DETAIL_ID, a.SERVICE_ID as COM_SERVICE_ID, a.service_date as SERVICE_DATE, su.CUSTOMER_UNIT_ID, a.TOP_PARENT_UNIT_ID, '
   set @sqlselect = @sqlselect + char(13) + 'ISNULL( tu.CUSTOMER_UNIT_NAME,   ISNULL( tun.CUSTOMER_UNIT_NAME,   tptun.CUSTOMER_UNIT_NAME   ) ) as TOP_PARENT_UNIT_NAME, '
   set @sqlselect = @sqlselect + char(13) + 'ISNULL( tut.CUSTOMER_UNIT_TYPE_NAME, tptut.CUSTOMER_UNIT_TYPE_NAME ) as TOP_PARENT_UNIT_TYPE_NAME, '
   set @sqlselect = @sqlselect + char(13) + 'ISNULL( su.CUSTOMER_UNIT_NAME,   ISNULL( sun.CUSTOMER_UNIT_NAME,   tpsun.CUSTOMER_UNIT_NAME   ) ) as CUSTOMER_UNIT_NAME, '
   set @sqlselect = @sqlselect + char(13) + 'ISNULL( sut.CUSTOMER_UNIT_TYPE_NAME, tpsut.CUSTOMER_UNIT_TYPE_NAME ) as CUSTOMER_UNIT_TYPE_NAME, '
   set @sqlselect = @sqlselect + char(13) + 'ISNULL( pu.CUSTOMER_UNIT_NAME,   ISNULL( pun.CUSTOMER_UNIT_NAME,   tppun.CUSTOMER_UNIT_NAME   ) ) as PARENT_UNIT_NAME, '
   set @sqlselect = @sqlselect + char(13) + 'ISNULL( put.CUSTOMER_UNIT_TYPE_NAME, tpput.CUSTOMER_UNIT_TYPE_NAME ) as PARENT_UNIT_TYPE_NAME, '
   set @sqlselect = @sqlselect + char(13) + '''' + @ProviderSystemName  + '''' + ' as PROVIDER_SYSTEM_NAME, '
   set @sqlselect = @sqlselect + char(13) + '''' + @ServiceValueName + '''' + ' as SERVICE_VALUE, '
   set @sqlselect = @sqlselect + char(13) + '''' + @ServiceCategoryName + '''' + ' as SERVICE_CATEGORY, '
   set @sqlselect = @sqlselect + char(13) + 'm.MEMBER_NAME, '
   set @sqlselect = @sqlselect + char(13) + '''' + @GroupType  + '''' + ' as MEMBER_GROUP_TYPE_NAME, '
   set @sqlselect = @sqlselect + char(13) + '''' + @GroupName  + '''' + ' as MEMBER_GROUP_NAME, '
   set @sqlselect = @sqlselect + char(13) + 'a.ROW_ID'

   set @sqlfrom = char(13) + 'from @tab a'

   set @sqlfrom = @sqlfrom + char(13) + 'inner join customer_unit tu on a.TOP_PARENT_UNIT_ID  = tu.customer_unit_id and tu.unit_parent_id = -1'
   set @sqlfrom = @sqlfrom + char(13) + 'inner join dbo.JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT jcuttu on ( tu.CUSTOMER_UNIT_ID = jcuttu.CUSTOMER_UNIT_ID ) and ( jcuttu.CUSTOMER_UNIT_TYPE_ID =' + cast( @TopParentUnitTypeId as varchar(10) ) + ' )'
   set @sqlfrom = @sqlfrom + char(13) + 'inner join dbo.CUSTOMER_UNIT_TYPE tut on tut.customer_unit_type_id = jcuttu.customer_unit_type_id'
   set @sqlfrom = @sqlfrom + char(13) + 'left outer join dbo.TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE tptut on tut.template_provider_customer_unit_type_id = tptut.CUSTOMER_UNIT_TYPE_ID'
   set @sqlfrom = @sqlfrom + char(13) + 'left outer join dbo.CUSTOMER_UNIT_NAME tun on jcuttu.CUSTOMER_UNIT_NAME_ID = tun.CUSTOMER_UNIT_NAME_ID'
   set @sqlfrom = @sqlfrom + char(13) + 'left outer join dbo.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME tptun on tun.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME_ID = tptun.CUSTOMER_UNIT_NAME_ID'

   set @sqlfrom = @sqlfrom + char(13) + 'inner join dbo.MEMBER m on m.MEMBER_ID = tu.CUSTOMER_ID'

   set @sqlfrom = @sqlfrom + char(13) + 'inner join dbo.JOIN_MEMBER_GROUP_CUSTOMER_UNIT jmgcu on ( tu.CUSTOMER_UNIT_ID = jmgcu.CUSTOMER_UNIT_ID ) and ( jmgcu.MEMBER_GROUP_ID = ' + cast( @GroupId as varchar(10) ) + ' )'

   set @sqlfrom = @sqlfrom + char(13) + 'inner join customer_unit su on a.SERVICE_UNIT_ID  = su.customer_unit_id'
   set @sqlfrom = @sqlfrom + char(13) + 'inner join dbo.JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT jcutsu on ( su.CUSTOMER_UNIT_ID = jcutsu.CUSTOMER_UNIT_ID ) and ( jcutsu.CUSTOMER_UNIT_TYPE_ID = ' + Cast( @CustomerUnitTypeId as varchar(10) ) + ' )'
   set @sqlfrom = @sqlfrom + char(13) + 'inner join dbo.CUSTOMER_UNIT_TYPE sut on sut.customer_unit_type_id = jcutsu.customer_unit_type_id'
   set @sqlfrom = @sqlfrom + char(13) + 'left outer join dbo.TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE tpsut on sut.template_provider_customer_unit_type_id = tpsut.CUSTOMER_UNIT_TYPE_ID'
   set @sqlfrom = @sqlfrom + char(13) + 'left outer join dbo.CUSTOMER_UNIT_NAME sun on jcutsu.CUSTOMER_UNIT_NAME_ID = sun.CUSTOMER_UNIT_NAME_ID'
   set @sqlfrom = @sqlfrom + char(13) + 'left outer join dbo.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME tpsun on sun.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME_ID = tpsun.CUSTOMER_UNIT_NAME_ID'

   set @sqlfrom = @sqlfrom + char(13) + 'inner join customer_unit pu on a.unit_parent_id = pu.customer_unit_id'
   set @sqlfrom = @sqlfrom + char(13) + 'inner join dbo.JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT jcutpu on ( pu.CUSTOMER_UNIT_ID = jcutpu.CUSTOMER_UNIT_ID ) and ( jcutpu.CUSTOMER_UNIT_TYPE_ID = ' + Cast( @ParentUnitTypeId as varchar(10) ) + ' )'
   set @sqlfrom = @sqlfrom + char(13) + 'inner join dbo.CUSTOMER_UNIT_TYPE put on put.customer_unit_type_id = jcutpu.customer_unit_type_id'

   set @sqlfrom = @sqlfrom + char(13) + 'left outer join dbo.TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE tpput on put.template_provider_customer_unit_type_id = tpput.CUSTOMER_UNIT_TYPE_ID'
   set @sqlfrom = @sqlfrom + char(13) + 'left outer join dbo.CUSTOMER_UNIT_NAME pun on jcutpu.CUSTOMER_UNIT_NAME_ID = pun.CUSTOMER_UNIT_NAME_ID'
   set @sqlfrom = @sqlfrom + char(13) + 'left outer join dbo.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME tppun on pun.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME_ID = tppun.CUSTOMER_UNIT_NAME_ID'

   set @sqlorder = char(13) + 'order by TOP_PARENT_UNIT_NAME, SERVICE_DATE desc, CUSTOMER_UNIT_NAME '

   declare @datatypeid   integer
   declare @datatype     varchar(50)

   declare data_type_cursor cursor for
   select psdt.provider_service_data_type_id, isnull(psdt.provider_service_data_type_text, tpsdt.provider_service_data_type_text) as provider_service_data_type_text
   from dbo.provider_service_data_type psdt
   left outer join template_provider_service_data_type tpsdt on psdt.template_provider_service_data_type_id = tpsdt.provider_service_data_type_id
   where provider_service_category_id = @ServiceCategoryId
   order by psdt.sort_order, tpsdt.sort_order

   open data_type_cursor

    /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   fetch next from data_type_cursor into
   @datatypeid,
   @datatype

   while ( @@fetch_status = 0 ) begin

      select @DataType = replace(@DataType, ',', '' )
      select @DataType = replace(@DataType, ' ', '_')

      set @tabtable = @tabtable + ',' + char(13) + '[' + @datatype + '] varchar(255) NULL' + char(13)
      set @tabinsert = @tabinsert + ',' + char(13) + '[' + @datatype + ']'
      set @tabselect = @tabselect + ',' + char(13) + 'sum(case psdt.provider_service_data_type_id when ' + cast(@datatypeid as varchar(10)) + ' then csd.com_service_data_id else NULL end) as ' + '[' + @datatype + ']'

      set @sqlselect = @sqlselect + ',' + char(13) + 'dt' + cast(@datatypeid as varchar(10)) + '.com_service_data_alt_text as ' + '[' + @datatype + ']'
      set @sqlfrom = @sqlfrom + char(13) + 'left outer join com_service_data dt' + cast(@datatypeid as varchar(10)) + ' on a.[' + @datatype + ']= dt' + cast(@datatypeid as varchar(10)) + '.com_service_data_id'

   fetch next from data_type_cursor into
   @datatypeid,
   @datatype

   end

   close data_type_cursor
   deallocate data_type_cursor

   set @tabtable = @tabtable   + ') ' + char(13)
   set @tabinsert = @tabinsert + ') ' + char(13)

   exec( @tabTable + @tabInsert + @tabSelect + @tabFrom + @tabwhere + @tabgroup + @sqlSelect + @sqlFrom + @sqlorder )

    /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

     /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetCategoryDataByUnitTypeDateParent' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetCategoryDataByUnitTypeDateParent

   go

create procedure spGetCategoryDataByUnitTypeDateParent(  @CustomerUnitId     integer,
                                                         @CustomerUnitTypeId integer,
                                                         @ServiceCategoryId  integer,
                                                         @ServiceValueId     integer,
                                                         @StartDate          datetime,
                                                         @EndDate            datetime  ) as

   set nocount on

   declare @sqlselect          nvarchar( 4000 ),
           @sqlfrom            nvarchar( 4000 ),
           @sqlorder           nvarchar( 4000 ),
           @tabtable           nvarchar( 4000 ),
           @tabinsert          nvarchar( 4000 ),
           @tabselect          nvarchar( 4000 ),
           @tabfrom            nvarchar( 4000 ),
           @tabwhere           nvarchar( 4000 ),
           @tabgroup           nvarchar( 4000 ),
           @tmpsql             nvarchar( 4000 ),
           @CustomerId         integer,
           @ProviderSystemName varchar(100),
           @MemberName         varchar(100),
           @ServiceCategoryName varchar(50),
           @ServiceValue        integer,
           @ServiceValueName    varchar(60),
           @ParentUnitTypeId    integer,
           @TopParentUnitTypeId integer,
           @ParUnitTypeId       integer,
           @ChildUnitTypeId     integer

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   select @ParentUnitTypeId = customer_unit_type_parent_id
   from customer_unit_type
   where customer_unit_type_id = @CustomerUnitTypeId

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   set @ChildUnitTypeId = @CustomerUnitTypeId
   while (@ChildUnitTypeId > 0 ) begin
      set @TopParentUnitTypeId = @ChildUnitTypeId
      select @ParUnitTypeId = customer_unit_type_parent_id
      from customer_unit_type
      where customer_unit_type_id = @ChildUnitTypeId

      /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
      select @ErrorCode = @@Error

      /* If there was an error... */
      if ( @ErrorCode <> 00 ) begin

         /* Rollback the transaction. */
         rollback transaction

         /* Return the failure. */
         return 01

      end

      set @ChildUnitTypeId = @ParUnitTypeId

   end

    /* get the customer name from the parent unit passed in */
   select @MemberName = m.member_name,
          @CustomerId = m.member_id from member m
   inner join customer_unit cu on cu.customer_id = m.member_id
   where cu.customer_unit_id = @CustomerUnitId

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   select @ProviderSystemName = ISNULL(ps.PROVIDER_SYSTEM_NAME, tps.PROVIDER_SYSTEM_NAME )
   from dbo.customer_unit_type cut
   inner join dbo.PROVIDER_SYSTEM ps on cut.provider_system_id = ps.PROVIDER_SYSTEM_ID
   left outer join dbo.TEMPLATE_PROVIDER_SYSTEM tps on ps.TEMPLATE_PROVIDER_SYSTEM_ID = tps.PROVIDER_SYSTEM_ID
   where cut.customer_unit_type_id = @CustomerUnitTypeId

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   select     @ServiceValue = ISNULL( psv.provider_service_value,      tpsv.provider_service_value      ),
          @ServiceValueName = ISNULL( psv.provider_service_value_text, tpsv.provider_service_value_text )
   from dbo.provider_service_value psv
   left outer join dbo.template_provider_service_value tpsv on psv.template_provider_service_value_id = tpsv.provider_service_value_id
   where psv.provider_service_value_id = @ServiceValueId

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   set @ServiceValueName = cast( @ServiceValue as varchar(10) ) + ': ' + @ServiceValueName

   select @ServiceCategoryName = ISNULL( a.provider_service_category, b.provider_service_category )
   from provider_service_category  a
   left outer join template_provider_service_category b on a.template_provider_service_category_id = b.provider_service_category_id
   where a.provider_service_category_id = @ServiceCategoryId

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   select @ProviderSystemName = Replace(@ProviderSystemName,  '''', '''''')

   select @MemberName = Replace(@MemberName, '''', '''''')

   select @ServiceValueName = Replace(@ServiceValueName,  '''', '''''')

   select @ServiceCategoryName = Replace(@ServiceCategoryName,  '''', '''''')

   set @tabtable = char(13) + 'declare @tab table ( SERVICE_DETAIL_ID integer,
                                                    SERVICE_ID integer,
                                                    TOP_PARENT_UNIT_ID integer,
                                                    SERVICE_DATE datetime,
                                                    SERVICE_UNIT_ID integer,
                                                    UNIT_PARENT_ID integer,
                                                    CATEGORY_ID integer,
                                                    ROW_ID integer '

   set @tabinsert = char(13) + 'insert into @tab  ( SERVICE_DETAIL_ID,
                                                    SERVICE_ID,
                                                    TOP_PARENT_UNIT_ID,
                                                    SERVICE_DATE,
                                                    SERVICE_UNIT_ID,
                                                    UNIT_PARENT_ID,
                                                    CATEGORY_ID,
                                                    ROW_ID '

   set @tabselect = char(13) + 'select csuv.COM_SERVICE_UNIT_VALUE_ID,
                                       cs.COM_SERVICE_ID,
                                       cs.CUSTOMER_UNIT_ID,
                                       cs.COM_SERVICE_DATE,
                                       csuv.CUSTOMER_UNIT_ID,
                                       cu.UNIT_PARENT_ID,
                                       psdt.PROVIDER_SERVICE_CATEGORY_ID,
                                       csd.ROW_ID '

   set @tabfrom =  char(13)+ 'from com_service_unit_value csuv '
   set @tabfrom = @tabfrom + char(13) + 'inner join com_service cs                        on ( csuv.com_service_id              = cs.com_service_id ) and (cs.customer_unit_id = ' + cast( @CustomerUnitId as varchar(10) ) + ' )'
   set @tabfrom = @tabfrom + char(13) + 'inner join com_service_data csd                  on csuv.com_service_unit_value_id     = csd.com_service_unit_value_id '
   set @tabfrom = @tabfrom + char(13) + 'inner join provider_service_data_type psdt       on csd.provider_service_data_type_id  = psdt.provider_service_data_type_id '
   set @tabfrom = @tabfrom + char(13) + 'inner join customer_unit cu                      on ( csuv.customer_unit_id = cu.customer_unit_id ) ' +
                                                                                          'and ( cu.customer_id = ' + cast( @CustomerId as varchar( 25 ) ) + ') '
   set @tabfrom = @tabfrom + char(13) + 'inner join dbo.JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT jcutcu on ( csuv.CUSTOMER_UNIT_ID = jcutcu.CUSTOMER_UNIT_ID ) ' +
                                                                                                        'and ( jcutcu.customer_unit_type_id = ' + cast( @CustomerUnitTypeId as varchar(10)) + ' ) '
   set @tabwhere = char(13) + 'where psdt.provider_service_category_id  = ' + cast(@ServiceCategoryId   as varchar(10)) + ''
   set @tabwhere = @tabwhere + char(13) + '  and cs.com_service_date >= ''' + convert(varchar(10), @StartDate, 01) + ''''
   set @tabwhere = @tabwhere + char(13) + '  and cs.com_service_date <= ''' + convert(varchar(10), @EndDate, 01) + ''''
   set @tabwhere = @tabwhere + char(13) + '  and csuv.provider_service_value_id = ' + cast( @ServiceValueId as varchar(10) )
   set @tabgroup = char(13) + 'group by csuv.COM_SERVICE_UNIT_VALUE_ID, cs.COM_SERVICE_ID, cs.CUSTOMER_UNIT_ID, cs.COM_SERVICE_DATE, csuv.CUSTOMER_UNIT_ID, cu.UNIT_PARENT_ID, psdt.PROVIDER_SERVICE_CATEGORY_ID, csd.ROW_ID '
   set @tabgroup = @tabgroup + char(13) + 'order by csuv.COM_SERVICE_UNIT_VALUE_ID, cs.COM_SERVICE_ID, cs.CUSTOMER_UNIT_ID, cs.COM_SERVICE_DATE, csuv.CUSTOMER_UNIT_ID, cu.UNIT_PARENT_ID, psdt.PROVIDER_SERVICE_CATEGORY_ID, csd.ROW_ID '

   set @sqlselect = char(13) + 'select a.SERVICE_DETAIL_ID, a.SERVICE_ID as COM_SERVICE_ID, a.service_date as SERVICE_DATE, su.CUSTOMER_UNIT_ID, '
   set @sqlselect = @sqlselect + char(13) + 'ISNULL( tu.CUSTOMER_UNIT_NAME,   ISNULL( tun.CUSTOMER_UNIT_NAME,   tptun.CUSTOMER_UNIT_NAME   ) ) as TOP_PARENT_UNIT_NAME, '
   set @sqlselect = @sqlselect + char(13) + 'ISNULL( tut.CUSTOMER_UNIT_TYPE_NAME, tptut.CUSTOMER_UNIT_TYPE_NAME ) as TOP_PARENT_UNIT_TYPE_NAME, '
   set @sqlselect = @sqlselect + char(13) + 'ISNULL( su.CUSTOMER_UNIT_NAME,   ISNULL( sun.CUSTOMER_UNIT_NAME,   tpsun.CUSTOMER_UNIT_NAME   ) ) as CUSTOMER_UNIT_NAME, '
   set @sqlselect = @sqlselect + char(13) + 'ISNULL( sut.CUSTOMER_UNIT_TYPE_NAME, tpsut.CUSTOMER_UNIT_TYPE_NAME ) as CUSTOMER_UNIT_TYPE_NAME, '
   set @sqlselect = @sqlselect + char(13) + 'ISNULL( pu.CUSTOMER_UNIT_NAME,   ISNULL( pun.CUSTOMER_UNIT_NAME,   tppun.CUSTOMER_UNIT_NAME   ) ) as PARENT_UNIT_NAME, '
   set @sqlselect = @sqlselect + char(13) + 'ISNULL( put.CUSTOMER_UNIT_TYPE_NAME, tpput.CUSTOMER_UNIT_TYPE_NAME ) as PARENT_UNIT_TYPE_NAME, '
   set @sqlselect = @sqlselect + char(13) + '''' + @ProviderSystemName  + '''' + ' as PROVIDER_SYSTEM_NAME, '
   set @sqlselect = @sqlselect + char(13) + '''' + @MemberName + '''' + ' as MEMBER_NAME, '
   set @sqlselect = @sqlselect + char(13) + '''' + @ServiceValueName + '''' + ' as SERVICE_VALUE, '
   set @sqlselect = @sqlselect + char(13) + '''' + @ServiceCategoryName + '''' + ' as SERVICE_CATEGORY, '
   set @sqlselect = @sqlselect + char(13) + 'a.ROW_ID'

   set @sqlfrom = char(13) + 'from @tab a'

   set @sqlfrom = @sqlfrom + char(13) + 'inner join customer_unit tu on a.TOP_PARENT_UNIT_ID  = tu.customer_unit_id and tu.unit_parent_id = -1'
   set @sqlfrom = @sqlfrom + char(13) + 'inner join dbo.JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT jcuttu on ( tu.CUSTOMER_UNIT_ID = jcuttu.CUSTOMER_UNIT_ID ) and ( jcuttu.CUSTOMER_UNIT_TYPE_ID =' + cast( @TopParentUnitTypeId as varchar(10) ) + ' )'
   set @sqlfrom = @sqlfrom + char(13) + 'inner join dbo.CUSTOMER_UNIT_TYPE tut on tut.customer_unit_type_id = jcuttu.customer_unit_type_id'
   set @sqlfrom = @sqlfrom + char(13) + 'left outer join dbo.TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE tptut on tut.template_provider_customer_unit_type_id = tptut.CUSTOMER_UNIT_TYPE_ID'
   set @sqlfrom = @sqlfrom + char(13) + 'left outer join dbo.CUSTOMER_UNIT_NAME tun on jcuttu.CUSTOMER_UNIT_NAME_ID = tun.CUSTOMER_UNIT_NAME_ID'
   set @sqlfrom = @sqlfrom + char(13) + 'left outer join dbo.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME tptun on tun.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME_ID = tptun.CUSTOMER_UNIT_NAME_ID'

   set @sqlfrom = @sqlfrom + char(13) + 'inner join customer_unit su on a.SERVICE_UNIT_ID  = su.customer_unit_id'
   set @sqlfrom = @sqlfrom + char(13) + 'inner join dbo.JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT jcutsu on ( su.CUSTOMER_UNIT_ID = jcutsu.CUSTOMER_UNIT_ID ) and ( jcutsu.CUSTOMER_UNIT_TYPE_ID = ' + Cast( @CustomerUnitTypeId as varchar(10) ) + ' )'
   set @sqlfrom = @sqlfrom + char(13) + 'inner join dbo.CUSTOMER_UNIT_TYPE sut on sut.customer_unit_type_id = jcutsu.customer_unit_type_id'
   set @sqlfrom = @sqlfrom + char(13) + 'left outer join dbo.TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE tpsut on sut.template_provider_customer_unit_type_id = tpsut.CUSTOMER_UNIT_TYPE_ID'
   set @sqlfrom = @sqlfrom + char(13) + 'left outer join dbo.CUSTOMER_UNIT_NAME sun on jcutsu.CUSTOMER_UNIT_NAME_ID = sun.CUSTOMER_UNIT_NAME_ID'
   set @sqlfrom = @sqlfrom + char(13) + 'left outer join dbo.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME tpsun on sun.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME_ID = tpsun.CUSTOMER_UNIT_NAME_ID'

   set @sqlfrom = @sqlfrom + char(13) + 'inner join customer_unit pu on a.unit_parent_id = pu.customer_unit_id'
   set @sqlfrom = @sqlfrom + char(13) + 'inner join dbo.JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT jcutpu on ( pu.CUSTOMER_UNIT_ID = jcutpu.CUSTOMER_UNIT_ID ) and ( jcutpu.CUSTOMER_UNIT_TYPE_ID = ' + Cast( @ParentUnitTypeId as varchar(10) ) + ' )'
   set @sqlfrom = @sqlfrom + char(13) + 'inner join dbo.CUSTOMER_UNIT_TYPE put on put.customer_unit_type_id = jcutpu.customer_unit_type_id'
   set @sqlfrom = @sqlfrom + char(13) + 'left outer join dbo.TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE tpput on put.template_provider_customer_unit_type_id = tpput.CUSTOMER_UNIT_TYPE_ID'
   set @sqlfrom = @sqlfrom + char(13) + 'left outer join dbo.CUSTOMER_UNIT_NAME pun on jcutpu.CUSTOMER_UNIT_NAME_ID = pun.CUSTOMER_UNIT_NAME_ID'
   set @sqlfrom = @sqlfrom + char(13) + 'left outer join dbo.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME tppun on pun.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME_ID = tppun.CUSTOMER_UNIT_NAME_ID'

   set @sqlorder = char(13) + 'order by TOP_PARENT_UNIT_NAME, SERVICE_DATE desc, su.CUSTOMER_UNIT_ID, CUSTOMER_UNIT_NAME '

   declare @datatypeid   integer
   declare @datatype     varchar(50)

   declare data_type_cursor cursor for
   select psdt.provider_service_data_type_id, isnull(psdt.provider_service_data_type_text, tpsdt.provider_service_data_type_text) as provider_service_data_type_text
   from provider_service_data_type psdt
   left outer join template_provider_service_data_type tpsdt on psdt.template_provider_service_data_type_id = tpsdt.provider_service_data_type_id
   where provider_service_category_id = @ServiceCategoryId
   order by psdt.sort_order, tpsdt.sort_order

   open data_type_cursor
   fetch next from data_type_cursor into
   @datatypeid,
   @datatype

   while ( @@fetch_status = 0 ) begin

      select @DataType = replace(@DataType, ',', '' )
      select @DataType = replace(@DataType, ' ', '_')

      set @tabtable = @tabtable + ',' + char(13) + '[' + @datatype + '] varchar(255) NULL' + char(13)
      set @tabinsert = @tabinsert + ',' + char(13) + '[' + @datatype + ']'
      set @tabselect = @tabselect + ',' + char(13) + 'sum(case psdt.provider_service_data_type_id when ' + cast(@datatypeid as 
varchar(10)) + ' then csd.com_service_data_id else NULL end) as ' + '[' + @datatype + ']'

      set @sqlselect = @sqlselect + ',' + char(13) + 'dt' + cast(@datatypeid as varchar(10)) + '.com_service_data_alt_text as ' + '[' + @datatype + ']'
      set @sqlfrom = @sqlfrom + char(13) + 'left outer join com_service_data dt' + cast(@datatypeid as varchar(10)) + ' on a.[' + @datatype + ']= dt' + cast(@datatypeid as varchar(10)) + '.com_service_data_id'

   fetch next from data_type_cursor into
   @datatypeid,
   @datatype

   end

   close data_type_cursor
   deallocate data_type_cursor

   set @tabtable = @tabtable   + ') ' + char(13)
   set @tabinsert = @tabinsert + ') ' + char(13)

   exec( @tabTable + @tabInsert + @tabSelect + @tabFrom + @tabwhere + @tabgroup + @sqlSelect + @sqlFrom + @sqlorder )

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetComServiceDataByComServiceUnitValue' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetComServiceDataByComServiceUnitValue

   go

create procedure spGetComServiceDataByComServiceUnitValue( @comserviceunitvalueid integer ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   SELECT a.COM_SERVICE_DATA_ID,
	g.provider_service_category_id,
	isnull( g.provider_service_category, h.provider_service_category ) as PROVIDER_SERVICE_CATEGORY,
        d.provider_service_data_type_id,
	isnull( d.provider_service_data_type_text, f.provider_service_data_type_text ) as PROVIDER_SERVICE_DATA_TYPE,
	c.provider_service_data_id,
	isnull( COM_SERVICE_DATA_ALT_TEXT, isnull( c.PROVIDER_SERVICE_DATA, e.PROVIDER_SERVICE_DATA ) ) as COM_SERVICE_DATA_TEXT,
	ROW_ID
   FROM COM_SERVICE_DATA a
   left outer join provider_service_data c on a.provider_service_data_id = c.provider_service_data_id
   left outer join template_provider_service_data e on c.template_provider_service_data_id = e.provider_service_data_id
   left outer join provider_service_data_type d on c.provider_service_data_type_id = d.provider_service_data_type_id
   left outer join template_provider_service_data_type f on d.template_provider_service_data_type_id = f.provider_service_data_type_id
   left outer join provider_service_category g on d.provider_service_category_id = g.provider_service_category_id
   left outer join template_provider_service_category h on g.template_provider_service_category_id = h.provider_service_category_id
   WHERE COM_SERVICE_UNIT_VALUE_ID = @comserviceunitvalueid
   ORDER BY d.sort_order, f.sort_order, ROW_ID

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 )  begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetComServiceDataByComServiceUnitValueCategory' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetComServiceDataByComServiceUnitValueCategory

   go

create procedure spGetComServiceDataByComServiceUnitValueCategory ( @comserviceunitvalueid     integer,
                                                                    @providerservicecategoryid integer ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   SELECT a.COM_SERVICE_DATA_ID,
        d.provider_service_data_type_id,
	c.provider_service_data_id,
	isnull( COM_SERVICE_DATA_ALT_TEXT, isnull( c.PROVIDER_SERVICE_DATA, e.PROVIDER_SERVICE_DATA ) ) as COM_SERVICE_DATA_TEXT,
	ROW_ID,
        isnull( d.sort_order, f.sort_order ) as SORT_ORDER,
   FROM COM_SERVICE i
   right outer join provider_service_type g on i.provider_service_type_id = g.provider_service_type_id
   left outer join COM_SERVICE_UNIT_VALUE b on i.com_service_id = b.com_service_id
   left outer join COM_SERVICE_DATA a on b.COM_SERVICE_UNIT_VALUE_ID = a.COM_SERVICE_UNIT_VALUE_ID
   left outer join provider_service_data c on a.provider_service_data_id = c.provider_service_data_id

   inner join provider_service_data_type d on d.provider_service_data_type_id = a.provider_service_data_type_id
   left outer join template_provider_service_data_type f on d.template_provider_service_data_type_id = f.provider_service_data_type_id
   left outer join template_provider_service_data e on c.template_provider_service_data_id = e.provider_service_data_id
   WHERE b.COM_SERVICE_UNIT_VALUE_ID = @comserviceunitvalueid
   AND d.PROVIDER_SERVICE_CATEGORY_ID = @providerservicecategoryid
   ORDER BY ROW_ID, SORT_ORDER

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 )  begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetComServiceDataBySystemUserDateRange' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetComServiceDataBySystemUserDateRange

   go

create procedure spGetComServiceDataBySystemUserDateRange ( @ProviderSystemId integer,
                                                            @MemberUserId     integer,
                                                            @StartDate        datetime,
                                                            @EndDate          datetime ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   declare @SecurityGroupId integer
   select @SecurityGroupId = security_group_id from join_member_user_security_group where member_user_id = @MemberUserId

   if ( @SecurityGroupId = 6 ) begin

   declare @CustomerId integer
   select @CustomerId = member_id from member_user where member_user_id = @MemberUserId

      SELECT
          csd.com_service_data_id,
          csuv.com_service_unit_value_id,
          psc.provider_service_category_id,
          isnull( psc.provider_service_category, tpsc.provider_service_category ) as provider_service_category,
          psdt.provider_service_data_type_id,
          isnull( psdt.provider_service_data_type_text, tpsdt.provider_service_data_type_text ) as provider_service_data_type,
          csd.provider_service_data_id,
          isnull( csd.com_service_data_alt_text, isnull( psd.provider_service_data, tpsd.provider_service_data ) ) as com_service_data_text,
          csd.row_id

   from com_service cs
      inner join customer_unit cu on ( cs.customer_unit_id = cu.customer_unit_id ) and ( cu.unit_parent_id = -1 ) and
                                     ( cu.customer_id = @CustomerId )
      inner join join_customer_unit_type_customer_unit jcutcu on ( cu.customer_unit_id = jcutcu.customer_unit_id )
      inner join customer_unit_type cut on ( jcutcu.customer_unit_type_id = cut.customer_unit_type_id ) and
                                           ( cut.provider_system_id = @ProviderSystemId )
      inner join com_service_unit_value csuv on ( cs.com_service_id = csuv.com_service_id )
      inner join com_service_data csd on ( csuv.com_service_unit_value_id = csd.com_service_unit_value_id )
      inner join provider_service_data_type psdt on ( csd.provider_service_data_type_id = psdt.provider_service_data_type_id )
      left outer join template_provider_service_data_type tpsdt on ( psdt.template_provider_service_data_type_id = tpsdt.provider_service_data_type_id )
      inner join provider_service_category psc on ( psdt.provider_service_category_id = psc.provider_service_category_id ) and
                                                  ( psc.provider_system_id = cut.provider_system_id )
      left outer join template_provider_service_category tpsc on ( psc.template_provider_service_category_id = tpsc.provider_service_category_id )
      left outer join provider_service_data psd on ( csd.provider_service_data_id = psd.provider_service_data_id ) and
                                                   ( psdt.provider_service_data_type_id = psd.provider_service_data_type_id )
      left outer join template_provider_service_data tpsd on ( psd.template_provider_service_data_id = tpsd.provider_service_data_id )

      where ( cs.com_service_date >= @StartDate )
        and ( cs.com_service_date <= @EndDate )
        and ( cs.review_date is not null )

      order by psdt.sort_order, tpsdt.sort_order, csd.row_id

   end

   else begin

      SELECT
          csd.com_service_data_id,
          csuv.com_service_unit_value_id,
          psc.provider_service_category_id,
          isnull( psc.provider_service_category, tpsc.provider_service_category ) as provider_service_category,
          psdt.provider_service_data_type_id,
          isnull( psdt.provider_service_data_type_text, tpsdt.provider_service_data_type_text ) as provider_service_data_type,
          csd.provider_service_data_id,
          isnull( csd.com_service_data_alt_text, isnull( psd.provider_service_data, tpsd.provider_service_data ) ) as com_service_data_text,
          csd.row_id

      from com_service cs
      inner join customer_unit cu on ( cs.customer_unit_id = cu.customer_unit_id ) and ( cu.unit_parent_id = -1 )
      inner join join_customer_unit_type_customer_unit jcutcu on ( cu.customer_unit_id = jcutcu.customer_unit_id )
      inner join customer_unit_type cut on ( jcutcu.customer_unit_type_id = cut.customer_unit_type_id ) and
                                           ( cut.provider_system_id = @ProviderSystemId )
      inner join join_member_group_customer_unit jmgcu on ( cu.customer_unit_id = jmgcu.customer_unit_id )
      inner join join_member_group_user jmgu on ( jmgcu.member_group_id = jmgu.member_group_id ) and
                                                ( jmgu.member_user_id = @MemberUserId )
      inner join com_service_unit_value csuv on ( cs.com_service_id = csuv.com_service_id )
      inner join com_service_data csd on ( csuv.com_service_unit_value_id = csd.com_service_unit_value_id )
      inner join provider_service_data_type psdt on ( csd.provider_service_data_type_id = psdt.provider_service_data_type_id )
      left outer join template_provider_service_data_type tpsdt on ( psdt.template_provider_service_data_type_id = tpsdt.provider_service_data_type_id )
      inner join provider_service_category psc on ( psdt.provider_service_category_id = psc.provider_service_category_id ) and
                                                  ( psc.provider_system_id = cut.provider_system_id )
      left outer join template_provider_service_category tpsc on ( psc.template_provider_service_category_id = tpsc.provider_service_category_id )
      left outer join provider_service_data psd on ( csd.provider_service_data_id = psd.provider_service_data_id ) and
                                                   ( psdt.provider_service_data_type_id = psd.provider_service_data_type_id )
      left outer join template_provider_service_data tpsd on ( psd.template_provider_service_data_id = tpsd.provider_service_data_id )

      where ( cs.com_service_date >= @StartDate )
        and ( cs.com_service_date <= @EndDate )
        and ( cs.review_date is not null )

      order by psdt.sort_order, tpsdt.sort_order, csd.row_id

   end

   /* If there was an error... */
   if ( @@Error <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetComServicesByCustomerUnitId' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetComServicesByCustomerUnitId

   go

create procedure spGetComServicesByCustomerUnitId ( @ProviderSystemId integer,
                                                    @CustomerUnitId   integer ) as

   declare @UnitId integer
   declare @CustomerUnitName varchar(100)
   declare @CustomerUnitTypeName varchar(50)
   declare @ParentUnitId integer
   declare @DisplayOrder integer

   declare @ServiceUnitId integer
   declare @MemberName varchar(100)
   declare @ProviderSystemName varchar(100)

   declare @TopParentUnitId integer
   declare @FindParentUnitId   integer
   declare @ParentUnitName     varchar(100)
   declare @ParentUnitType     varchar(50)

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   set nocount on

    /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   create table #TEMP_UNIT(    CUSTOMER_UNIT_ID      integer not null,
                               PARENT_UNIT_ID        integer,
                               UNIT_NAME             varchar(100),
                               UNIT_TYPE_NAME        varchar(50),
                               DISPLAY_SERVICE       char(1),
                               DISPLAY_ORDER         integer,
                               PRIMARY KEY( CUSTOMER_UNIT_ID) )

   set @DisplayOrder = 0

   select @MemberName = m.MEMBER_NAME from MEMBER m
   inner join CUSTOMER_UNIT cu on ( cu.CUSTOMER_ID = m.MEMBER_ID )
   where cu.CUSTOMER_UNIT_ID = @CustomerUnitId

      /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 )  begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   select @ProviderSystemName = ISNULL(ps.PROVIDER_SYSTEM_NAME, tps.PROVIDER_SYSTEM_NAME )
   from PROVIDER_SYSTEM ps
   left outer join dbo.TEMPLATE_PROVIDER_SYSTEM tps on ps.TEMPLATE_PROVIDER_SYSTEM_ID = tps.PROVIDER_SYSTEM_ID
   where ps.PROVIDER_SYSTEM_ID = @ProviderSystemId

      /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 )  begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   set @TopParentUnitId = @CustomerUnitId
   set @FindParentUnitId = 1

   while @FindParentUnitId <> -1 begin
      select @FindParentUnitId = cu.UNIT_PARENT_ID from CUSTOMER_UNIT cu where
             cu.CUSTOMER_UNIT_ID = @TopParentUnitId
      if @FindParentUnitId <> -1
         set @TopParentUnitId = @FindParentUnitId

   end

   declare parent_cursor cursor local fast_forward for
   select isnull( pcut.CUSTOMER_UNIT_TYPE_NAME, ptcut.CUSTOMER_UNIT_TYPE_NAME ) as PARENT_UNIT_TYPE_NAME,
          isnull( pu.CUSTOMER_UNIT_NAME, isnull( pcun.CUSTOMER_UNIT_NAME, ptcun.CUSTOMER_UNIT_NAME ) ) as PARENT_UNIT_NAME
   from CUSTOMER_UNIT pu
   /* Joins to retrieve the parent units (properties) for the service. */

   inner join      JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT pjcut on ( pu.CUSTOMER_UNIT_ID                          = pjcut.CUSTOMER_UNIT_ID      )
   left outer join CUSTOMER_UNIT_NAME pcun                     on ( pjcut.CUSTOMER_UNIT_NAME_ID                  = pcun.CUSTOMER_UNIT_NAME_ID  )
   left outer join TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME ptcun  on ( pcun.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME_ID = ptcun.CUSTOMER_UNIT_NAME_ID )
   inner join      CUSTOMER_UNIT_TYPE pcut                     on ( pjcut.CUSTOMER_UNIT_TYPE_ID                  = pcut.CUSTOMER_UNIT_TYPE_ID  ) and
                                                                  ( pcut.PROVIDER_SYSTEM_ID                      = @ProviderSystemId    )
   left outer join TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE ptcut  on ( pcut.TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE_ID = ptcut.CUSTOMER_UNIT_TYPE_ID )

   where pu.CUSTOMER_UNIT_ID = @TopParentUnitId

      /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 )  begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   open parent_cursor fetch next from parent_cursor into @ParentUnitType, @ParentUnitName

   close parent_cursor
   deallocate parent_cursor

   declare main_cursor cursor local fast_forward for

   select
   cu.customer_unit_id,
   ISNULL( cu.CUSTOMER_UNIT_NAME,   ISNULL( cun.CUSTOMER_UNIT_NAME,   tpcun.CUSTOMER_UNIT_NAME   ) ) as CUSTOMER_UNIT_NAME,
   ISNULL( cut.CUSTOMER_UNIT_TYPE_NAME, tpcut.CUSTOMER_UNIT_TYPE_NAME ) as CUSTOMER_UNIT_TYPE_NAME,
   cu.UNIT_PARENT_ID
   from
   customer_unit cu
   inner join dbo.JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT jcutcu on cu.CUSTOMER_UNIT_ID = jcutcu.CUSTOMER_UNIT_ID
   inner join dbo.CUSTOMER_UNIT_TYPE cut on ( cut.customer_unit_type_id = jcutcu.customer_unit_type_id ) and
                                            ( cut.provider_system_id = @ProviderSystemId )
   left outer join dbo.CUSTOMER_UNIT_NAME cun on jcutcu.CUSTOMER_UNIT_NAME_ID = cun.CUSTOMER_UNIT_NAME_ID
   left outer join dbo.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME tpcun on cun.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME_ID = tpcun.CUSTOMER_UNIT_NAME_ID
   left outer join dbo.TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE tpcut on cut.template_provider_customer_unit_type_id = tpcut.CUSTOMER_UNIT_TYPE_ID
   where cu.customer_unit_id = @CustomerUnitId

      /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 )  begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   open main_cursor fetch next from main_cursor into @UnitId,
                                                     @CustomerUnitName,
                                                     @CustomerUnitTypeName,
                                                     @ParentUnitId

  while ( @@Fetch_Status = 0 ) begin

         set @DisplayOrder = @DisplayOrder + 1
         insert into #TEMP_UNIT
         values(@UnitId,
                @ParentUnitId,
                @CustomerUnitName,
                @CustomerUnitTypeName,
                null,
                @DisplayOrder )

      execute spGetCustomerUnitChildrenInfrastructure @ProviderSystemId, @UnitId, @DisplayOrder output

      fetch next from main_cursor into @UnitId,
                                       @CustomerUnitName,
                                       @CustomerUnitTypeName,
                                       @ParentUnitId

   end

   close main_cursor
   deallocate main_cursor

   /* Get the completed services between the start and end dates for the passed
      provider user and customer. */
   select cs.COM_SERVICE_ID,
          cs.COM_SERVICE_DATE,
          cs.CUSTOMER_CONTACT,

          /* Name of the technician who provided the service. */
          mu.MEMBER_USER_FNAME,
          mu.MEMBER_USER_LNAME,

          /* Time stamp for the barcoding of the unit. */
          csuv.TIMESTAMP,

          csuv.COM_SERVICE_UNIT_VALUE_ID,

          TIMESTAMP_IS_NULL = case
                                 when csuv.TIMESTAMP is null then 01
                                 else 00
                              end,

          isnull( psv.PROVIDER_SERVICE_VALUE, tpsv.PROVIDER_SERVICE_VALUE ) as PROVIDER_SERVICE_VALUE,
          isnull( psv.PROVIDER_SERVICE_VALUE_TEXT, tpsv.PROVIDER_SERVICE_VALUE_TEXT ) as PROVIDER_SERVICE_VALUE_TEXT,

          /* Identifying information for the child units serviced. */
          su.CUSTOMER_UNIT_ID as SERVICE_UNIT_ID,

          psc1.PROVIDER_SERVICE_CATEGORY_ID,
          isnull( psc1.PROVIDER_SERVICE_CATEGORY, tpsc.PROVIDER_SERVICE_CATEGORY ) as PROVIDER_SERVICE_CATEGORY,
          isnull( psdt.SORT_ORDER, tpsdt.SORT_ORDER ) as SORT_ORDER,
          isnull( psdt.PROVIDER_SERVICE_DATA_TYPE_TEXT, tpsdt.PROVIDER_SERVICE_DATA_TYPE_TEXT ) as PROVIDER_SERVICE_DATA_TYPE_TEXT,
          COM_SERVICE_DATA = csd.COM_SERVICE_DATA_ALT_TEXT,

          ROW_ID
   into #CS_TEMP from COM_SERVICE cs

   /* Joins to retrieve the ranking data for the child units. */
   left outer join COM_SERVICE_UNIT_VALUE csuv          on ( cs.COM_SERVICE_ID                      = csuv.COM_SERVICE_ID            )
   left outer join PROVIDER_SERVICE_VALUE psv           on ( csuv.PROVIDER_SERVICE_VALUE_ID         = psv.PROVIDER_SERVICE_VALUE_ID  )
   left outer join TEMPLATE_PROVIDER_SERVICE_VALUE tpsv on ( psv.TEMPLATE_PROVIDER_SERVICE_VALUE_ID = tpsv.PROVIDER_SERVICE_VALUE_ID )

    /* Joins to retrieve the child units for the service. */
   left outer join CUSTOMER_UNIT su                            on ( csuv.CUSTOMER_UNIT_ID                        = su.CUSTOMER_UNIT_ID         )

   inner join #TEMP_UNIT tu on su.CUSTOMER_UNIT_ID = tu.CUSTOMER_UNIT_ID

   /* Joins to retrieve the data for the categories, fields, and field values. */
   left outer join COM_SERVICE_DATA csd                      on ( csuv.COM_SERVICE_UNIT_VALUE_ID              = csd.COM_SERVICE_UNIT_VALUE_ID       )
   left outer join PROVIDER_SERVICE_DATA_TYPE psdt           on ( csd.PROVIDER_SERVICE_DATA_TYPE_ID           = psdt.PROVIDER_SERVICE_DATA_TYPE_ID  )
   left outer join TEMPLATE_PROVIDER_SERVICE_DATA_TYPE tpsdt on ( psdt.TEMPLATE_PROVIDER_SERVICE_DATA_TYPE_ID = tpsdt.PROVIDER_SERVICE_DATA_TYPE_ID )
   left outer join PROVIDER_SERVICE_CATEGORY psc             on ( psdt.PROVIDER_SERVICE_CATEGORY_ID           = psc.PROVIDER_SERVICE_CATEGORY_ID    )

    /* get category name even when provider_service_data_id is null */
   left outer join PROVIDER_SERVICE_DATA_TYPE psdt1 on ( csd.PROVIDER_SERVICE_DATA_TYPE_ID = psdt1.PROVIDER_SERVICE_DATA_TYPE_ID )
   left outer join PROVIDER_SERVICE_CATEGORY psc1 on ( psdt1.PROVIDER_SERVICE_CATEGORY_ID = psc1.PROVIDER_SERVICE_CATEGORY_ID )
   left outer join TEMPLATE_PROVIDER_SERVICE_CATEGORY tpsc   on ( psc1.TEMPLATE_PROVIDER_SERVICE_CATEGORY_ID   = tpsc.PROVIDER_SERVICE_CATEGORY_ID   )

   /* Join to retrieve the name of the technician who performed the service. */
   left outer join MEMBER_USER mu on ( cs.TECHNICIAN_ID = mu.MEMBER_USER_ID )

   /* Sort the data by the service date. */
   order by PARENT_UNIT_ID,
            SERVICE_UNIT_ID,
            cs.COM_SERVICE_DATE desc,
            cs.COM_SERVICE_ID,
            csuv.COM_SERVICE_UNIT_VALUE_ID,
            psdt.PROVIDER_SERVICE_CATEGORY_ID,
            ROW_ID,
            SORT_ORDER

      /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 )  begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* update rows that have service data */
   update #TEMP_UNIT set [DISPLAY_SERVICE] = 'Y'
   where CUSTOMER_UNIT_ID in ( select distinct( ctu.SERVICE_UNIT_ID ) from #CS_TEMP ctu)

   declare display_service_cursor cursor local fast_forward for

      select distinct( ctu.SERVICE_UNIT_ID ) from #CS_TEMP ctu

   open display_service_cursor fetch next from display_service_cursor into
      @ServiceUnitId

   while ( @@Fetch_Status = 0 ) begin

      execute spFindAndUpdateParentIdDisplay @ServiceUnitId
      fetch next from display_service_cursor into @ServiceUnitId

   end

   close display_service_cursor
   deallocate display_service_cursor

   select tu.CUSTOMER_UNIT_ID as INF_CUSTOMER_UNIT_ID,
          tu.PARENT_UNIT_ID   as INF_PARENT_UNIT_ID,
          tu.UNIT_NAME        as INF_UNIT_NAME,
          tu.UNIT_TYPE_NAME   as INF_UNIT_TYPE_NAME,
          tu.DISPLAY_ORDER    as INF_DISPLAY_ORDER,
          @MemberName         as CUSTOMER_NAME,
          @TopParentUnitId    as PARENT_UNIT_ID,
          @ParentUnitType     as PARENT_UNIT_TYPE_NAME,
          @ParentUnitName     as PARENT_UNIT_NAME,

          ctu.*
          from #TEMP_UNIT tu
   left outer join #CS_TEMP ctu on tu.CUSTOMER_UNIT_ID = ctu.SERVICE_UNIT_ID
   where tu.DISPLAY_SERVICE is not null
   order by tu.DISPLAY_ORDER

      /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 )  begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

     /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetComServicesByCustomerUnitIdAndType' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetComServicesByCustomerUnitIdAndType

   go

create procedure spGetComServicesByCustomerUnitIdAndType( @ProviderSystemId    integer,
                                                          @CustomerUnitId      integer,
                                                          @CustomerUnitTypeId  integer ) as

  declare @UnitId integer
   declare @CustomerUnitName varchar(100)
   declare @CustomerUnitTypeName varchar(50)
   declare @ParentUnitId integer
   declare @UnitTypeIds varchar(100)
   declare @Pos integer
   declare @FindUnitTypeId integer
   declare @CustomerUnitTypeTable table ( UnitTypeId integer )

   declare @DisplayOrder integer

   declare @ServiceUnitId integer
   declare @MemberName varchar(100)
   declare @ProviderSystemName varchar(100)

   declare @TopParentUnitId integer
   declare @FindParentUnitId   integer
   declare @ParentUnitName     varchar(100)
   declare @ParentUnitType     varchar(50)

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   set nocount on

    /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   create table #TEMP_UNIT(    CUSTOMER_UNIT_ID      integer,
                               PARENT_UNIT_ID        integer,
                               UNIT_NAME             varchar(100),
                               UNIT_TYPE_NAME        varchar(50),
                               DISPLAY_SERVICE       char(1),
                               DISPLAY_ORDER         integer,
                               PRIMARY KEY( CUSTOMER_UNIT_ID) )

     set @DisplayOrder = 0

   select @MemberName = m.MEMBER_NAME from MEMBER m
   inner join CUSTOMER_UNIT cu on ( cu.CUSTOMER_ID = m.MEMBER_ID )
   where cu.CUSTOMER_UNIT_ID = @CustomerUnitId

   select @ProviderSystemName = ISNULL(ps.PROVIDER_SYSTEM_NAME, tps.PROVIDER_SYSTEM_NAME )
   from PROVIDER_SYSTEM ps
   left outer join dbo.TEMPLATE_PROVIDER_SYSTEM tps on ps.TEMPLATE_PROVIDER_SYSTEM_ID = tps.PROVIDER_SYSTEM_ID
   where ps.PROVIDER_SYSTEM_ID = @ProviderSystemId

   set @TopParentUnitId = @CustomerUnitId
   set @FindParentUnitId = 1

   while @FindParentUnitId <> -1 begin
      select @FindParentUnitId = cu.UNIT_PARENT_ID from CUSTOMER_UNIT cu where
             cu.CUSTOMER_UNIT_ID = @TopParentUnitId
      if @FindParentUnitId <> -1
         set @TopParentUnitId = @FindParentUnitId

   end

   declare parent_cursor cursor local fast_forward for
   select isnull( pcut.CUSTOMER_UNIT_TYPE_NAME, ptcut.CUSTOMER_UNIT_TYPE_NAME ) as PARENT_UNIT_TYPE_NAME,
          isnull( pu.CUSTOMER_UNIT_NAME, isnull( pcun.CUSTOMER_UNIT_NAME, ptcun.CUSTOMER_UNIT_NAME ) as PARENT_UNIT_NAME
   from CUSTOMER_UNIT pu
   /* Joins to retrieve the parent units (properties) for the service. */

   inner join      JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT pjcut on ( pu.CUSTOMER_UNIT_ID                          = pjcut.CUSTOMER_UNIT_ID      )
   left outer join CUSTOMER_UNIT_NAME pcun                     on ( pjcut.CUSTOMER_UNIT_NAME_ID                  = pcun.CUSTOMER_UNIT_NAME_ID  )
   left outer join TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME ptcun  on ( pcun.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME_ID = ptcun.CUSTOMER_UNIT_NAME_ID )
   inner join      CUSTOMER_UNIT_TYPE pcut                     on ( pjcut.CUSTOMER_UNIT_TYPE_ID                  = pcut.CUSTOMER_UNIT_TYPE_ID  ) and
                                                                  ( pcut.PROVIDER_SYSTEM_ID                      = @ProviderSystemId    )
   left outer join TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE ptcut  on ( pcut.TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE_ID = ptcut.CUSTOMER_UNIT_TYPE_ID )

   where pu.CUSTOMER_UNIT_ID = @TopParentUnitId

   open parent_cursor fetch next from parent_cursor into @ParentUnitType, @ParentUnitName

   close parent_cursor
   deallocate parent_cursor

   set @UnitTypeIds = cast( @CustomerUnitTypeId as varchar(10 ))
   execute spGetUnitTypeChildrenUnitType @CustomerUnitTypeId, @UnitTypeIds out

   set @UnitTypeIds = @UnitTypeIds + ','
   while @UnitTypeIds <> '' begin
      set @Pos = CHARINDEX(',', @UnitTypeIds )
      set @FindUnitTypeId = CAST( SUBSTRING( @UnitTypeIds, 1, @Pos-1 ) as integer )
      insert into @CustomerUnitTypeTable values( @FindUnitTypeId )
      set @UnitTypeIds = SUBSTRING(@UnitTypeIds, @Pos+1, LEN(@UnitTypeIds) - @Pos )

   end

   declare top_cursor cursor local fast_forward for

   select
   cu.customer_unit_id,
   ISNULL( cu.CUSTOMER_UNIT_NAME,   ISNULL( cun.CUSTOMER_UNIT_NAME,   
tpcun.CUSTOMER_UNIT_NAME   ) ) as CUSTOMER_UNIT_NAME,
   ISNULL( cut.CUSTOMER_UNIT_TYPE_NAME, tpcut.CUSTOMER_UNIT_TYPE_NAME ) as CUSTOMER_UNIT_TYPE_NAME,
   cu.unit_parent_id
   from
   customer_unit cu
   inner join dbo.JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT jcutcu on cu.CUSTOMER_UNIT_ID = jcutcu.CUSTOMER_UNIT_ID
   inner join dbo.CUSTOMER_UNIT_TYPE cut on ( cut.customer_unit_type_id = jcutcu.customer_unit_type_id ) and
                                            ( cut.provider_system_id = @ProviderSystemId )
   left outer join dbo.CUSTOMER_UNIT_NAME cun on jcutcu.CUSTOMER_UNIT_NAME_ID = cun.CUSTOMER_UNIT_NAME_ID
   left outer join dbo.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME tpcun on cun.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME_ID = tpcun.CUSTOMER_UNIT_NAME_ID
   left outer join dbo.TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE tpcut on cut.template_provider_customer_unit_type_id = tpcut.CUSTOMER_UNIT_TYPE_ID
   where cu.customer_unit_id = @CustomerUnitId

     /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 )  begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   open top_cursor fetch next from top_cursor into   @UnitId,
                                                     @CustomerUnitName,
                                                     @CustomerUnitTypeName,
                                                     @ParentUnitId

   set @DisplayOrder = @DisplayOrder + 1
   insert into #TEMP_UNIT
         values(@UnitId,
                @ParentUnitId,
                @CustomerUnitName,
                @CustomerUnitTypeName,
                null,
                @DisplayOrder
                 )

   close top_cursor
   deallocate top_cursor

   declare main_cursor cursor local fast_forward for

   select
   cu.customer_unit_id,
   ISNULL( cu.CUSTOMER_UNIT_NAME,   ISNULL( cun.CUSTOMER_UNIT_NAME,   tpcun.CUSTOMER_UNIT_NAME   ) ) as CUSTOMER_UNIT_NAME,
   ISNULL( cut.CUSTOMER_UNIT_TYPE_NAME, tpcut.CUSTOMER_UNIT_TYPE_NAME ) as CUSTOMER_UNIT_TYPE_NAME,
   cu.UNIT_PARENT_ID
   from
   customer_unit cu
   inner join dbo.JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT jcutcu on cu.CUSTOMER_UNIT_ID = jcutcu.CUSTOMER_UNIT_ID
   inner join dbo.CUSTOMER_UNIT_TYPE cut on ( cut.customer_unit_type_id = jcutcu.customer_unit_type_id ) and
                                            ( cut.provider_system_id = @ProviderSystemId )
   left outer join dbo.CUSTOMER_UNIT_NAME cun on jcutcu.CUSTOMER_UNIT_NAME_ID = cun.CUSTOMER_UNIT_NAME_ID
   left outer join dbo.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME tpcun on cun.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME_ID = tpcun.CUSTOMER_UNIT_NAME_ID
   left outer join dbo.TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE tpcut on cut.template_provider_customer_unit_type_id = tpcut.CUSTOMER_UNIT_TYPE_ID
   where cu.unit_parent_id = @CustomerUnitId

     /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 )  begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   open main_cursor fetch next from main_cursor into @UnitId,
                                                     @CustomerUnitName,
                                                     @CustomerUnitTypeName,
                                                     @ParentUnitId

   while ( @@Fetch_Status = 0 ) begin
      set @DisplayOrder = @DisplayOrder + 1
       insert into #TEMP_UNIT
         values(@UnitId,
                @ParentUnitId,
                @CustomerUnitName,
                @CustomerUnitTypeName,
                null,
                @DisplayOrder )

      execute spGetCustomerUnitChildrenInfrastructure @ProviderSystemId, @UnitId, @DisplayOrder output

      fetch next from main_cursor into @UnitId,
                                       @CustomerUnitName,
                                       @CustomerUnitTypeName,
                                       @ParentUnitId

   end

   close main_cursor
   deallocate main_cursor

    /* Get the completed services between the start and end dates for the passed
      provider user and customer. */
   select cs.COM_SERVICE_ID,
          cs.COM_SERVICE_DATE,
          cs.CUSTOMER_CONTACT,

          /* Name of the technician who provided the service. */
          mu.MEMBER_USER_FNAME,
          mu.MEMBER_USER_LNAME,

          /* Time stamp for the barcoding of the unit. */
          csuv.TIMESTAMP,

          TIMESTAMP_IS_NULL = case
                                 when csuv.TIMESTAMP is null then 01
                                 else 00
                              end,
          csuv.COM_SERVICE_UNIT_VALUE_ID,

          isnull( psv.PROVIDER_SERVICE_VALUE, tpsv.PROVIDER_SERVICE_VALUE ) as PROVIDER_SERVICE_VALUE,
          isnull( psv.PROVIDER_SERVICE_VALUE_TEXT, tpsv.PROVIDER_SERVICE_VALUE_TEXT ) as PROVIDER_SERVICE_VALUE_TEXT,

          /* Identifying information for the child units serviced. */
          su.CUSTOMER_UNIT_ID as SERVICE_UNIT_ID,

          psc1.PROVIDER_SERVICE_CATEGORY_ID,
          isnull( psc1.PROVIDER_SERVICE_CATEGORY, tpsc.PROVIDER_SERVICE_CATEGORY ) as PROVIDER_SERVICE_CATEGORY,
          isnull( psdt.SORT_ORDER, tpsdt.SORT_ORDER ) as SORT_ORDER,
          isnull( psdt.PROVIDER_SERVICE_DATA_TYPE_TEXT, tpsdt.PROVIDER_SERVICE_DATA_TYPE_TEXT ) as PROVIDER_SERVICE_DATA_TYPE_TEXT,

          COM_SERVICE_DATA = csd.COM_SERVICE_DATA_ALT_TEXT,

          ROW_ID
   into #CS_TEMP from COM_SERVICE cs

   /* Joins to retrieve the service type and the service program name. */
   inner join      PROVIDER_SERVICE_TYPE pst           on ( cs.PROVIDER_SERVICE_TYPE_ID           = pst.PROVIDER_SERVICE_TYPE_ID  )
   left outer join TEMPLATE_PROVIDER_SERVICE_TYPE tpst on ( pst.TEMPLATE_PROVIDER_SERVICE_TYPE_ID = tpst.PROVIDER_SERVICE_TYPE_ID )
   inner join      PROVIDER_SYSTEM ps                  on ( pst.PROVIDER_SYSTEM_ID                = ps.PROVIDER_SYSTEM_ID         )
   left outer join TEMPLATE_PROVIDER_SYSTEM tps        on ( ps.TEMPLATE_PROVIDER_SYSTEM_ID        = tps.PROVIDER_SYSTEM_ID        )

   /* Joins to retrieve the ranking data for the child units. */
   left outer join COM_SERVICE_UNIT_VALUE csuv          on ( cs.COM_SERVICE_ID                      = csuv.COM_SERVICE_ID            )
   left outer join PROVIDER_SERVICE_VALUE psv           on ( csuv.PROVIDER_SERVICE_VALUE_ID         = psv.PROVIDER_SERVICE_VALUE_ID  )
   left outer join TEMPLATE_PROVIDER_SERVICE_VALUE tpsv on ( psv.TEMPLATE_PROVIDER_SERVICE_VALUE_ID = tpsv.PROVIDER_SERVICE_VALUE_ID )

   /* Joins to retrieve the data for the categories, fields, and field values. */
   left outer join COM_SERVICE_DATA csd                      on ( csuv.COM_SERVICE_UNIT_VALUE_ID              = csd.COM_SERVICE_UNIT_VALUE_ID       )

   left outer join PROVIDER_SERVICE_DATA_TYPE psdt           on ( csd.PROVIDER_SERVICE_DATA_TYPE_ID          = psdt.PROVIDER_SERVICE_DATA_TYPE_ID  )
   left outer join TEMPLATE_PROVIDER_SERVICE_DATA_TYPE tpsdt on ( psdt.TEMPLATE_PROVIDER_SERVICE_DATA_TYPE_ID = tpsdt.PROVIDER_SERVICE_DATA_TYPE_ID )
   left outer join PROVIDER_SERVICE_CATEGORY psc             on ( psdt.PROVIDER_SERVICE_CATEGORY_ID           = psc.PROVIDER_SERVICE_CATEGORY_ID    )

    /* Joins to retrieve the child units for the service. */
   left outer join CUSTOMER_UNIT su                            on ( csuv.CUSTOMER_UNIT_ID                        = su.CUSTOMER_UNIT_ID         )
   left outer join JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT sjcut on ( su.CUSTOMER_UNIT_ID                          = sjcut.CUSTOMER_UNIT_ID      )

    /* get category name even when provider_service_data_id is null */
   left outer join PROVIDER_SERVICE_DATA_TYPE psdt1 on ( csd.PROVIDER_SERVICE_DATA_TYPE_ID = psdt1.PROVIDER_SERVICE_DATA_TYPE_ID )
   left outer join PROVIDER_SERVICE_CATEGORY psc1 on ( psdt1.PROVIDER_SERVICE_CATEGORY_ID = psc1.PROVIDER_SERVICE_CATEGORY_ID )
   left outer join TEMPLATE_PROVIDER_SERVICE_CATEGORY tpsc   on ( psc1.TEMPLATE_PROVIDER_SERVICE_CATEGORY_ID   = tpsc.PROVIDER_SERVICE_CATEGORY_ID   )

   /* Join to retrieve the name of the technician who performed the service. */
   left outer join MEMBER_USER mu on ( cs.TECHNICIAN_ID = mu.MEMBER_USER_ID )

   inner join #TEMP_UNIT tu on su.CUSTOMER_UNIT_ID = tu.CUSTOMER_UNIT_ID

   inner join CUSTOMER_UNIT_TYPE scut                     on ( sjcut.CUSTOMER_UNIT_TYPE_ID                  = scut.CUSTOMER_UNIT_TYPE_ID  ) and
                                                                  ( ps.PROVIDER_SYSTEM_ID                   = scut.PROVIDER_SYSTEM_ID     )

   left outer join TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE stcut  on ( scut.TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE_ID = stcut.CUSTOMER_UNIT_TYPE_ID )

   inner join @CustomerUnitTypeTable cutt on scut.CUSTOMER_UNIT_TYPE_ID = cutt.UnitTypeId

   where ( ps.PROVIDER_SYSTEM_ID = @ProviderSystemId )
   /* Sort the data by the service date. */
   order by PARENT_UNIT_ID,
            SERVICE_UNIT_ID,
            cs.COM_SERVICE_DATE desc,
            cs.COM_SERVICE_ID,
            csuv.COM_SERVICE_UNIT_VALUE_ID,
            psdt.PROVIDER_SERVICE_CATEGORY_ID,
            ROW_ID,
            SORT_ORDER

     /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 )  begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

    /* update rows that have service data */
   update #TEMP_UNIT set [DISPLAY_SERVICE] = 'Y'
   where CUSTOMER_UNIT_ID in ( select distinct( ctu.SERVICE_UNIT_ID ) from #CS_TEMP ctu)

   declare display_service_cursor cursor local fast_forward for
      /*select distinct( ctu.PARENT_UNIT_ID ) from #CS_TEMP ctu */
      select distinct( ctu.SERVICE_UNIT_ID ) from #CS_TEMP ctu

   open display_service_cursor fetch next from display_service_cursor into
      @ServiceUnitId

   while ( @@Fetch_Status = 0 ) begin

      execute spFindAndUpdateParentIdDisplay @ServiceUnitId
      fetch next from display_service_cursor into @ServiceUnitId

   end

   close display_service_cursor
   deallocate display_service_cursor

   select tu.CUSTOMER_UNIT_ID as INF_CUSTOMER_UNIT_ID,
          tu.PARENT_UNIT_ID   as INF_PARENT_UNIT_ID,
          tu.UNIT_NAME        as INF_UNIT_NAME,
          tu.UNIT_TYPE_NAME   as INF_UNIT_TYPE_NAME,
          tu.DISPLAY_ORDER    as INF_DISPLAY_ORDER,
          @MemberName         as CUSTOMER_NAME,
          @TopParentUnitId    as PARENT_UNIT_ID,
          @ParentUnitType     as PARENT_UNIT_TYPE_NAME,
          @ParentUnitName     as PARENT_UNIT_NAME,

          ctu.*
          from #TEMP_UNIT tu
   left outer join #CS_TEMP ctu on tu.CUSTOMER_UNIT_ID = ctu.SERVICE_UNIT_ID
   where tu.DISPLAY_SERVICE is not null
   order by tu.DISPLAY_ORDER

     /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 )  begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

    /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetComServicesByProviderAdminCustomerDateRange' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetComServicesByProviderAdminCustomerDateRange

   go

create procedure spGetComServicesByProviderAdminCustomerDateRange( @ProviderId integer,
                                                                   @CustomerId integer,
                                                                   @StartDate  datetime,
                                                                   @EndDate    datetime ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Get the completed services between the start and end dates for the passed
      provider user and customer. */
   select START_DATE = @StartDate,
          END_DATE   = @EndDate,
          cs.COM_SERVICE_ID,
          cs.COM_SERVICE_DATE,
          cs.CUSTOMER_CONTACT,
          cs.COM_SERVICE_COMMENT,
          cs.TIME_IN,

          /* Used to handle null TIME_IN Field, so screwy looking results are
             not displayed in the report if the TIME_IN field is NULL. */
          TIME_IN_IS_NULL = case
                               when cs.TIME_IN is null then 01
                               else 00
                            end,
          cs.TIME_OUT,

          /* Used to handle null TIME_OUT Field, so screwy looking results are
             not displayed in the report if the TIME_OUT field is NULL. */
          TIME_OUT_IS_NULL = case
                                when cs.TIME_OUT is null then 01
                                else 00
                             end,

          /* Name of the technician who provided the service. */
          mu.MEMBER_USER_FNAME,
          mu.MEMBER_USER_LNAME,

          /* Name of the customer who was serviced. */
          m.MEMBER_NAME as CUSTOMER_NAME,

          /* Time stamp for the barcoding of the unit. */
          csuv.TIMESTAMP,

          TIMESTAMP_IS_NULL = case
                                 when csuv.TIMESTAMP is null then 01
                                 else 00
                              end,

          isnull( psv.PROVIDER_SERVICE_VALUE, tpsv.PROVIDER_SERVICE_VALUE ) as PROVIDER_SERVICE_VALUE,
          isnull( psv.PROVIDER_SERVICE_VALUE_TEXT, tpsv.PROVIDER_SERVICE_VALUE_TEXT ) as PROVIDER_SERVICE_VALUE_TEXT,
          isnull( pst.PROVIDER_SERVICE_TYPE_TEXT, tpst.PROVIDER_SERVICE_TYPE_TEXT ) as PROVIDER_SERVICE_TYPE_TEXT,

          /* Identifying information for the property serviced. */
          pu.CUSTOMER_UNIT_ID as PARENT_UNIT_ID,
          isnull( pcut.CUSTOMER_UNIT_TYPE_NAME, ptcut.CUSTOMER_UNIT_TYPE_NAME ) as PARENT_UNIT_TYPE_NAME,
          isnull( pu.CUSTOMER_UNIT_NAME, isnull( pcun.CUSTOMER_UNIT_NAME, ptcun.CUSTOMER_UNIT_NAME ) ) as PARENT_UNIT_NAME,

          /* Identifying information for the child units serviced. */
          su.CUSTOMER_UNIT_ID as SERVICE_UNIT_ID,
          isnull( scut.CUSTOMER_UNIT_TYPE_NAME, stcut.CUSTOMER_UNIT_TYPE_NAME ) as SERVICE_UNIT_TYPE_NAME,
          isnull( su.CUSTOMER_UNIT_NAME, isnull( scun.CUSTOMER_UNIT_NAME, stcun.CUSTOMER_UNIT_NAME ) ) as SERVICE_UNIT_NAME,

          isnull( ps.PROVIDER_SYSTEM_NAME, tps.PROVIDER_SYSTEM_NAME ) as PROVIDER_SYSTEM_NAME,
          psdt.PROVIDER_SERVICE_CATEGORY_ID,
          isnull( psc.PROVIDER_SERVICE_CATEGORY, tpsc.PROVIDER_SERVICE_CATEGORY ) as PROVIDER_SERVICE_CATEGORY,
          isnull( psdt.SORT_ORDER, tpsdt.SORT_ORDER ) as SORT_ORDER,
          isnull( psdt.PROVIDER_SERVICE_DATA_TYPE_TEXT, tpsdt.PROVIDER_SERVICE_DATA_TYPE_TEXT ) as PROVIDER_SERVICE_DATA_TYPE_TEXT,

          COM_SERVICE_DATA = csd.COM_SERVICE_DATA_ALT_TEXT,

          ROW_ID
   from COM_SERVICE cs

   /* Joins to retrieve the service type and the service program name. */
   inner join      PROVIDER_SERVICE_TYPE pst           on ( cs.PROVIDER_SERVICE_TYPE_ID           = pst.PROVIDER_SERVICE_TYPE_ID  )
   left outer join TEMPLATE_PROVIDER_SERVICE_TYPE tpst on ( pst.TEMPLATE_PROVIDER_SERVICE_TYPE_ID = tpst.PROVIDER_SERVICE_TYPE_ID )
   inner join      PROVIDER_SYSTEM ps                  on ( pst.PROVIDER_SYSTEM_ID                = ps.PROVIDER_SYSTEM_ID         )
   left outer join TEMPLATE_PROVIDER_SYSTEM tps        on ( ps.TEMPLATE_PROVIDER_SYSTEM_ID        = tps.PROVIDER_SYSTEM_ID        )

   /* Joins to retrieve the ranking data for the child units. */
   left outer join COM_SERVICE_UNIT_VALUE csuv          on ( cs.COM_SERVICE_ID                      = csuv.COM_SERVICE_ID            )
   left outer join PROVIDER_SERVICE_VALUE psv           on ( csuv.PROVIDER_SERVICE_VALUE_ID         = psv.PROVIDER_SERVICE_VALUE_ID  )
   left outer join TEMPLATE_PROVIDER_SERVICE_VALUE tpsv on ( psv.TEMPLATE_PROVIDER_SERVICE_VALUE_ID = tpsv.PROVIDER_SERVICE_VALUE_ID )

   /* Joins to retrieve the data for the categories, fields, and field values. */
   left outer join COM_SERVICE_DATA csd                      on ( csuv.COM_SERVICE_UNIT_VALUE_ID              = csd.COM_SERVICE_UNIT_VALUE_ID       )

   left outer join PROVIDER_SERVICE_DATA_TYPE psdt           on ( csd.PROVIDER_SERVICE_DATA_TYPE_ID           = psdt.PROVIDER_SERVICE_DATA_TYPE_ID  )

   left outer join TEMPLATE_PROVIDER_SERVICE_DATA_TYPE tpsdt on ( psdt.TEMPLATE_PROVIDER_SERVICE_DATA_TYPE_ID = tpsdt.PROVIDER_SERVICE_DATA_TYPE_ID )
   left outer join PROVIDER_SERVICE_CATEGORY psc             on ( psdt.PROVIDER_SERVICE_CATEGORY_ID           = psc.PROVIDER_SERVICE_CATEGORY_ID    )
   left outer join TEMPLATE_PROVIDER_SERVICE_CATEGORY tpsc   on ( psc.TEMPLATE_PROVIDER_SERVICE_CATEGORY_ID   = tpsc.PROVIDER_SERVICE_CATEGORY_ID   )

   /* Join to retrieve the name of the technician who performed the service. */
   left outer join MEMBER_USER mu on ( cs.TECHNICIAN_ID = mu.MEMBER_USER_ID )

   /* Joins to retrieve the parent units (properties) for the service. */
   inner join      CUSTOMER_UNIT pu                            on ( cs.CUSTOMER_UNIT_ID                          = pu.CUSTOMER_UNIT_ID         ) and
                                                                  ( pu.unit_parent_id                            = -1                          )
   inner join      JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT pjcut on ( pu.CUSTOMER_UNIT_ID                          = pjcut.CUSTOMER_UNIT_ID      )
   left outer join CUSTOMER_UNIT_NAME pcun                     on ( pjcut.CUSTOMER_UNIT_NAME_ID                  = pcun.CUSTOMER_UNIT_NAME_ID  )
   left outer join TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME ptcun  on ( pcun.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME_ID = ptcun.CUSTOMER_UNIT_NAME_ID )
   inner join      CUSTOMER_UNIT_TYPE pcut                     on ( pjcut.CUSTOMER_UNIT_TYPE_ID                  = pcut.CUSTOMER_UNIT_TYPE_ID  ) and
                                                                  ( ps.PROVIDER_SYSTEM_ID                        = pcut.PROVIDER_SYSTEM_ID     )
   left outer join TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE ptcut  on ( pcut.TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE_ID = ptcut.CUSTOMER_UNIT_TYPE_ID )

   /* Join to retrieve the name of the customer who owns the property. */
   inner join MEMBER m on ( pu.CUSTOMER_ID = m.MEMBER_ID )

   /* Joins to retrieve the child units for the service. */
   left outer join CUSTOMER_UNIT su                            on ( csuv.CUSTOMER_UNIT_ID                        = su.CUSTOMER_UNIT_ID         )
   left outer join JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT sjcut on ( su.CUSTOMER_UNIT_ID                          = sjcut.CUSTOMER_UNIT_ID      )
   left outer join CUSTOMER_UNIT_NAME scun                     on ( sjcut.CUSTOMER_UNIT_NAME_ID                  = scun.CUSTOMER_UNIT_NAME_ID  )
   left outer join TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME stcun  on ( scun.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME_ID = stcun.CUSTOMER_UNIT_NAME_ID )
   left outer join CUSTOMER_UNIT_TYPE scut                     on ( sjcut.CUSTOMER_UNIT_TYPE_ID                  = scut.CUSTOMER_UNIT_TYPE_ID  ) and
                                                                  ( ps.PROVIDER_SYSTEM_ID                        = scut.PROVIDER_SYSTEM_ID     )
   left outer join TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE stcut  on ( scut.TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE_ID = stcut.CUSTOMER_UNIT_TYPE_ID )

   /* Only include data for the passed customer between the specified dates. */
   where ( ps.provider_id       = @ProviderId   ) and
         ( m.MEMBER_ID          = @CustomerId   ) and
         ( cs.COM_SERVICE_DATE >= @StartDate    ) and
         ( cs.COM_SERVICE_DATE <= @EndDate      )

   /* Sort the data by the service date. */
   order by cs.COM_SERVICE_DATE desc,
            cs.COM_SERVICE_ID,
            csuv.COM_SERVICE_UNIT_VALUE_ID,
            psdt.PROVIDER_SERVICE_CATEGORY_ID,
            ROW_ID,
            SORT_ORDER

    /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetComServicesByProviderAdminGroupDateRange' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetComServicesByProviderAdminGroupDateRange

   go

create procedure spGetComServicesByProviderAdminGroupDateRange( @MemberGroupId integer,
                                                                @StartDate     datetime,
                                                                @EndDate       datetime ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

    /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Get the completed services between the start and end dates for the passed
      provider user and customer. */
   select START_DATE = @StartDate,
          END_DATE   = @EndDate,
          cs.COM_SERVICE_ID,
          cs.COM_SERVICE_DATE,
          cs.CUSTOMER_CONTACT,
          cs.COM_SERVICE_COMMENT,
          cs.TIME_IN,

          /* Used to handle null TIME_IN Field, so screwy looking results are
             not displayed in the report if the TIME_IN field is NULL. */
          TIME_IN_IS_NULL = case
                               when cs.TIME_IN is null then 01
                               else 00
                            end,
          cs.TIME_OUT,

          /* Used to handle null TIME_OUT Field, so screwy looking results are
             not displayed in the report if the TIME_OUT field is NULL. */
          TIME_OUT_IS_NULL = case
                                when cs.TIME_OUT is null then 01
                                else 00
                             end,

          /* Name of the technician who provided the service. */
          mu.MEMBER_USER_FNAME,
          mu.MEMBER_USER_LNAME,

          /* Name of the customer who was serviced. */
          m.MEMBER_NAME as CUSTOMER_NAME,

          /* Time stamp for the barcoding of the unit. */
          csuv.TIMESTAMP,

          TIMESTAMP_IS_NULL = case
                                 when csuv.TIMESTAMP is null then 01
                                 else 00
                              end,

          isnull( psv.PROVIDER_SERVICE_VALUE, tpsv.PROVIDER_SERVICE_VALUE ) as PROVIDER_SERVICE_VALUE,
          isnull( psv.PROVIDER_SERVICE_VALUE_TEXT, tpsv.PROVIDER_SERVICE_VALUE_TEXT ) as PROVIDER_SERVICE_VALUE_TEXT,
          isnull( pst.PROVIDER_SERVICE_TYPE_TEXT, tpst.PROVIDER_SERVICE_TYPE_TEXT ) as PROVIDER_SERVICE_TYPE_TEXT,

          /* Identifying information for the property serviced. */
          pu.CUSTOMER_UNIT_ID as PARENT_UNIT_ID,
          isnull( pcut.CUSTOMER_UNIT_TYPE_NAME, ptcut.CUSTOMER_UNIT_TYPE_NAME ) as PARENT_UNIT_TYPE_NAME,
          isnull( pu.CUSTOMER_UNIT_NAME, isnull( pcun.CUSTOMER_UNIT_NAME, ptcun.CUSTOMER_UNIT_NAME ) ) as PARENT_UNIT_NAME,

          /* Identifying information for the child units serviced. */
          su.CUSTOMER_UNIT_ID as SERVICE_UNIT_ID,
          isnull( scut.CUSTOMER_UNIT_TYPE_NAME, stcut.CUSTOMER_UNIT_TYPE_NAME ) as SERVICE_UNIT_TYPE_NAME,
          isnull( su.CUSTOMER_UNIT_NAME, isnull( scun.CUSTOMER_UNIT_NAME, stcun.CUSTOMER_UNIT_NAME ) ) as SERVICE_UNIT_NAME,

          isnull( ps.PROVIDER_SYSTEM_NAME, tps.PROVIDER_SYSTEM_NAME ) as PROVIDER_SYSTEM_NAME,
          psdt.PROVIDER_SERVICE_CATEGORY_ID,
          isnull( psc.PROVIDER_SERVICE_CATEGORY, tpsc.PROVIDER_SERVICE_CATEGORY ) as PROVIDER_SERVICE_CATEGORY,
          isnull( psdt.SORT_ORDER, tpsdt.SORT_ORDER ) as SORT_ORDER,
          isnull( psdt.PROVIDER_SERVICE_DATA_TYPE_TEXT, tpsdt.PROVIDER_SERVICE_DATA_TYPE_TEXT ) as PROVIDER_SERVICE_DATA_TYPE_TEXT,

          COM_SERVICE_DATA = csd.COM_SERVICE_DATA_ALT_TEXT,

          ROW_ID,

          sjmgcu.Member_Group_ID,
          mg.Member_Group_Name

   from COM_SERVICE cs

   /* Joins to retrieve the service type and the service program name. */
   inner join      PROVIDER_SERVICE_TYPE pst           on ( cs.PROVIDER_SERVICE_TYPE_ID           = pst.PROVIDER_SERVICE_TYPE_ID  )
   left outer join TEMPLATE_PROVIDER_SERVICE_TYPE tpst on ( pst.TEMPLATE_PROVIDER_SERVICE_TYPE_ID = tpst.PROVIDER_SERVICE_TYPE_ID )
   inner join      PROVIDER_SYSTEM ps                  on ( pst.PROVIDER_SYSTEM_ID                = ps.PROVIDER_SYSTEM_ID         )
   left outer join TEMPLATE_PROVIDER_SYSTEM tps        on ( ps.TEMPLATE_PROVIDER_SYSTEM_ID        = tps.PROVIDER_SYSTEM_ID        )

   /* Joins to retrieve the ranking data for the child units. */
   left outer join COM_SERVICE_UNIT_VALUE csuv          on ( cs.COM_SERVICE_ID                      = csuv.COM_SERVICE_ID            )
   left outer join PROVIDER_SERVICE_VALUE psv           on ( csuv.PROVIDER_SERVICE_VALUE_ID         = psv.PROVIDER_SERVICE_VALUE_ID  )
   left outer join TEMPLATE_PROVIDER_SERVICE_VALUE tpsv on ( psv.TEMPLATE_PROVIDER_SERVICE_VALUE_ID = tpsv.PROVIDER_SERVICE_VALUE_ID )

   /* Joins to retrieve the data for the categories, fields, and field values. */
   left outer join COM_SERVICE_DATA csd                      on ( csuv.COM_SERVICE_UNIT_VALUE_ID              = csd.COM_SERVICE_UNIT_VALUE_ID       )

   left outer join PROVIDER_SERVICE_DATA_TYPE psdt           on ( csd.PROVIDER_SERVICE_DATA_TYPE_ID           = psdt.PROVIDER_SERVICE_DATA_TYPE_ID  )
   left outer join TEMPLATE_PROVIDER_SERVICE_DATA_TYPE tpsdt on ( psdt.TEMPLATE_PROVIDER_SERVICE_DATA_TYPE_ID = tpsdt.PROVIDER_SERVICE_DATA_TYPE_ID )
   left outer join PROVIDER_SERVICE_CATEGORY psc             on ( psdt.PROVIDER_SERVICE_CATEGORY_ID           = psc.PROVIDER_SERVICE_CATEGORY_ID    )
   left outer join TEMPLATE_PROVIDER_SERVICE_CATEGORY tpsc   on ( psc.TEMPLATE_PROVIDER_SERVICE_CATEGORY_ID   = tpsc.PROVIDER_SERVICE_CATEGORY_ID   )

   /* Join to retrieve the name of the technician who performed the service. */
   left outer join MEMBER_USER mu on ( cs.TECHNICIAN_ID = mu.MEMBER_USER_ID )

   /* Joins to retrieve the parent units (properties) for the service. */
   inner join      CUSTOMER_UNIT pu                            on ( cs.CUSTOMER_UNIT_ID                          = pu.CUSTOMER_UNIT_ID         ) and
                                                                  ( pu.unit_parent_id                            =  -1                         )
   inner join      JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT pjcut on ( pu.CUSTOMER_UNIT_ID                          = pjcut.CUSTOMER_UNIT_ID      )
   left outer join CUSTOMER_UNIT_NAME pcun                     on ( pjcut.CUSTOMER_UNIT_NAME_ID                  = pcun.CUSTOMER_UNIT_NAME_ID  )
   left outer join TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME ptcun  on ( pcun.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME_ID = ptcun.CUSTOMER_UNIT_NAME_ID )
   inner join      CUSTOMER_UNIT_TYPE pcut                     on ( pjcut.CUSTOMER_UNIT_TYPE_ID                  = pcut.CUSTOMER_UNIT_TYPE_ID  ) and
                                                                  ( ps.PROVIDER_SYSTEM_ID                        = pcut.PROVIDER_SYSTEM_ID     )
   left outer join TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE ptcut  on ( pcut.TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE_ID = ptcut.CUSTOMER_UNIT_TYPE_ID )

   /* Join to retrieve the name of the customer who owns the property. */
   inner join MEMBER m on ( pu.CUSTOMER_ID = m.MEMBER_ID )

   /* Joins to retrieve the child units for the service. */
   left outer join CUSTOMER_UNIT su                            on ( csuv.CUSTOMER_UNIT_ID                        = su.CUSTOMER_UNIT_ID         )
   left outer join JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT sjcut on ( su.CUSTOMER_UNIT_ID                          = sjcut.CUSTOMER_UNIT_ID      )
   left outer join CUSTOMER_UNIT_NAME scun                     on ( sjcut.CUSTOMER_UNIT_NAME_ID                  = scun.CUSTOMER_UNIT_NAME_ID  )
   left outer join TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME stcun  on ( scun.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME_ID = stcun.CUSTOMER_UNIT_NAME_ID )
   left outer join CUSTOMER_UNIT_TYPE scut                     on ( sjcut.CUSTOMER_UNIT_TYPE_ID                  = scut.CUSTOMER_UNIT_TYPE_ID  ) and
                                                                  ( ps.PROVIDER_SYSTEM_ID                        = scut.PROVIDER_SYSTEM_ID     )
   left outer join TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE stcut  on ( scut.TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE_ID = stcut.CUSTOMER_UNIT_TYPE_ID )

   inner join Join_Member_Group_Customer_Unit sjmgcu      on ( pu.Customer_Unit_ID = sjmgcu.Customer_Unit_ID )
   inner join Member_Group mg                             on ( sjmgcu.Member_Group_ID = mg.Member_Group_ID )
   inner join Member_Group_Type mgt                       on ( mg.Member_Group_Type_ID = mgt.Member_Group_Type_ID ) and
                                                             ( ps.provider_id = mgt.member_id )

   /* Only include data for the passed gorup between the specified dates. */
   where ( sjmgcu.MEMBER_Group_ID =  @MemberGroupId ) and
         ( cs.COM_SERVICE_DATE    >= @StartDate     ) and
         ( cs.COM_SERVICE_DATE    <= @EndDate       )

   /* Sort the data by the service date. */
   order by cs.COM_SERVICE_DATE desc,
            cs.COM_SERVICE_ID,
            csuv.COM_SERVICE_UNIT_VALUE_ID,
            psdt.PROVIDER_SERVICE_CATEGORY_ID,
            ROW_ID,
            SORT_ORDER

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetComServicesByProviderAdminTechnicianIdDateRange' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetComServicesByProviderAdminTechnicianIdDateRange

   go

create procedure spGetComServicesByProviderAdminTechnicianIdDateRange( @TechnicianId integer,
                                                                       @StartDate    datetime,
                                                                       @EndDate      datetime ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Get the completed services between the start and end dates for the passed
      provider user and customer. */
   select START_DATE = @StartDate,
          END_DATE   = @EndDate,
          cs.COM_SERVICE_ID,
          cs.COM_SERVICE_DATE,
          cs.CUSTOMER_CONTACT,
          cs.COM_SERVICE_COMMENT,
          cs.TIME_IN,

          /* Used to handle null TIME_IN Field, so screwy looking results are
             not displayed in the report if the TIME_IN field is NULL. */
          TIME_IN_IS_NULL = case
                               when cs.TIME_IN is null then 01
                               else 00
                            end,
          cs.TIME_OUT,

          /* Used to handle null TIME_OUT Field, so screwy looking results are
             not displayed in the report if the TIME_OUT field is NULL. */
          TIME_OUT_IS_NULL = case
                                when cs.TIME_OUT is null then 01
                                else 00
                             end,

          /* Name of the technician who provided the service. */
          mu.MEMBER_USER_FNAME,
          mu.MEMBER_USER_LNAME,

          /* Name of the customer who was serviced. */
          m.MEMBER_NAME as CUSTOMER_NAME,

          /* Time stamp for the barcoding of the unit. */
          csuv.TIMESTAMP,

          TIMESTAMP_IS_NULL = case
                                 when csuv.TIMESTAMP is null then 01
                                 else 00
                              end,

          isnull( psv.PROVIDER_SERVICE_VALUE, tpsv.PROVIDER_SERVICE_VALUE ) as PROVIDER_SERVICE_VALUE,
          isnull( psv.PROVIDER_SERVICE_VALUE_TEXT, tpsv.PROVIDER_SERVICE_VALUE_TEXT ) as PROVIDER_SERVICE_VALUE_TEXT,
          isnull( pst.PROVIDER_SERVICE_TYPE_TEXT, tpst.PROVIDER_SERVICE_TYPE_TEXT ) as PROVIDER_SERVICE_TYPE_TEXT,

          /* Identifying information for the property serviced. */
          pu.CUSTOMER_UNIT_ID as PARENT_UNIT_ID,
          isnull( pcut.CUSTOMER_UNIT_TYPE_NAME, ptcut.CUSTOMER_UNIT_TYPE_NAME ) as PARENT_UNIT_TYPE_NAME,
          isnull( pu.CUSTOMER_UNIT_NAME, isnull( pcun.CUSTOMER_UNIT_NAME, ptcun.CUSTOMER_UNIT_NAME ) ) as PARENT_UNIT_NAME,

          /* Identifying information for the child units serviced. */
          su.CUSTOMER_UNIT_ID as SERVICE_UNIT_ID,
          isnull( scut.CUSTOMER_UNIT_TYPE_NAME, stcut.CUSTOMER_UNIT_TYPE_NAME ) as SERVICE_UNIT_TYPE_NAME,
          isnull( su.CUSTOMER_UNIT_NAME, isnull( scun.CUSTOMER_UNIT_NAME, stcun.CUSTOMER_UNIT_NAME ) ) as SERVICE_UNIT_NAME,

          isnull( ps.PROVIDER_SYSTEM_NAME, tps.PROVIDER_SYSTEM_NAME ) as PROVIDER_SYSTEM_NAME,
          psdt.PROVIDER_SERVICE_CATEGORY_ID,
          isnull( psc.PROVIDER_SERVICE_CATEGORY, tpsc.PROVIDER_SERVICE_CATEGORY ) as PROVIDER_SERVICE_CATEGORY,
          isnull( psdt.SORT_ORDER, tpsdt.SORT_ORDER ) as SORT_ORDER,
          isnull( psdt.PROVIDER_SERVICE_DATA_TYPE_TEXT, tpsdt.PROVIDER_SERVICE_DATA_TYPE_TEXT ) as PROVIDER_SERVICE_DATA_TYPE_TEXT,
          COM_SERVICE_DATA = csd.COM_SERVICE_DATA_ALT_TEXT,

          ROW_ID
   from COM_SERVICE cs

   /* Joins to retrieve the service type and the service program name. */
   inner join      PROVIDER_SERVICE_TYPE pst           on ( cs.PROVIDER_SERVICE_TYPE_ID           = pst.PROVIDER_SERVICE_TYPE_ID  )
   left outer join TEMPLATE_PROVIDER_SERVICE_TYPE tpst on ( pst.TEMPLATE_PROVIDER_SERVICE_TYPE_ID = tpst.PROVIDER_SERVICE_TYPE_ID )
   inner join      PROVIDER_SYSTEM ps                  on ( pst.PROVIDER_SYSTEM_ID                = ps.PROVIDER_SYSTEM_ID         )
   left outer join TEMPLATE_PROVIDER_SYSTEM tps        on ( ps.TEMPLATE_PROVIDER_SYSTEM_ID        = tps.PROVIDER_SYSTEM_ID        )

   /* Joins to retrieve the ranking data for the child units. */
   left outer join COM_SERVICE_UNIT_VALUE csuv          on ( cs.COM_SERVICE_ID                      = csuv.COM_SERVICE_ID            )
   left outer join PROVIDER_SERVICE_VALUE psv           on ( csuv.PROVIDER_SERVICE_VALUE_ID         = psv.PROVIDER_SERVICE_VALUE_ID  )
   left outer join TEMPLATE_PROVIDER_SERVICE_VALUE tpsv on ( psv.TEMPLATE_PROVIDER_SERVICE_VALUE_ID = tpsv.PROVIDER_SERVICE_VALUE_ID )

   /* Joins to retrieve the data for the categories, fields, and field values. */
   left outer join COM_SERVICE_DATA csd                      on ( csuv.COM_SERVICE_UNIT_VALUE_ID              = csd.COM_SERVICE_UNIT_VALUE_ID       )
   left outer join PROVIDER_SERVICE_DATA_TYPE psdt           on ( csd.PROVIDER_SERVICE_DATA_TYPE_ID           = psdt.PROVIDER_SERVICE_DATA_TYPE_ID  )
   left outer join TEMPLATE_PROVIDER_SERVICE_DATA_TYPE tpsdt on ( psdt.TEMPLATE_PROVIDER_SERVICE_DATA_TYPE_ID = tpsdt.PROVIDER_SERVICE_DATA_TYPE_ID )
   left outer join PROVIDER_SERVICE_CATEGORY psc             on ( psdt.PROVIDER_SERVICE_CATEGORY_ID           = psc.PROVIDER_SERVICE_CATEGORY_ID    )
   left outer join TEMPLATE_PROVIDER_SERVICE_CATEGORY tpsc   on ( psc.TEMPLATE_PROVIDER_SERVICE_CATEGORY_ID   = tpsc.PROVIDER_SERVICE_CATEGORY_ID   )

   /* Join to retrieve the name of the technician who performed the service. */
   inner join MEMBER_USER mu on ( cs.TECHNICIAN_ID = mu.MEMBER_USER_ID ) and
                                ( ps.provider_id   = mu.member_id      )

   /* Joins to retrieve the parent units (properties) for the service. */
   inner join      CUSTOMER_UNIT pu                            on ( cs.CUSTOMER_UNIT_ID                          = pu.CUSTOMER_UNIT_ID         ) and
                                                                  ( pu.unit_parent_id                            = -1                          )
   inner join      JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT pjcut on ( pu.CUSTOMER_UNIT_ID                          = pjcut.CUSTOMER_UNIT_ID      )
   left outer join CUSTOMER_UNIT_NAME pcun                     on ( pjcut.CUSTOMER_UNIT_NAME_ID                  = pcun.CUSTOMER_UNIT_NAME_ID  )
   left outer join TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME ptcun  on ( pcun.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME_ID = ptcun.CUSTOMER_UNIT_NAME_ID )
   inner join      CUSTOMER_UNIT_TYPE pcut                     on ( pjcut.CUSTOMER_UNIT_TYPE_ID                  = pcut.CUSTOMER_UNIT_TYPE_ID  ) and
                                                                  ( ps.PROVIDER_SYSTEM_ID                        = pcut.PROVIDER_SYSTEM_ID     )
   left outer join TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE ptcut  on ( pcut.TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE_ID = ptcut.CUSTOMER_UNIT_TYPE_ID )

   /* Join to retrieve the name of the customer who owns the property. */
   inner join MEMBER m on ( pu.CUSTOMER_ID = m.MEMBER_ID )

   /* Joins to retrieve the child units for the service. */
   left outer join CUSTOMER_UNIT su                            on ( csuv.CUSTOMER_UNIT_ID                        = su.CUSTOMER_UNIT_ID         )
   left outer join JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT sjcut on ( su.CUSTOMER_UNIT_ID                          = sjcut.CUSTOMER_UNIT_ID      )
   left outer join CUSTOMER_UNIT_NAME scun                     on ( sjcut.CUSTOMER_UNIT_NAME_ID                  = scun.CUSTOMER_UNIT_NAME_ID  )
   left outer join TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME stcun  on ( scun.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME_ID = stcun.CUSTOMER_UNIT_NAME_ID )
   left outer join CUSTOMER_UNIT_TYPE scut                     on ( sjcut.CUSTOMER_UNIT_TYPE_ID                  = scut.CUSTOMER_UNIT_TYPE_ID  ) and
                                                                  ( ps.PROVIDER_SYSTEM_ID                        = scut.PROVIDER_SYSTEM_ID     )
   left outer join TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE stcut  on ( scut.TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE_ID = stcut.CUSTOMER_UNIT_TYPE_ID )

   /* Only include data for the passed customer between the specified dates. */
   where ( cs.TECHNICIAN_ID     = @TechnicianId ) and
         ( cs.COM_SERVICE_DATE >= @StartDate    ) and
         ( cs.COM_SERVICE_DATE <= @EndDate      )

   /* Sort the data by the service date. */
   order by cs.COM_SERVICE_DATE desc,
            cs.COM_SERVICE_ID,
            csuv.COM_SERVICE_UNIT_VALUE_ID,
            psdt.PROVIDER_SERVICE_CATEGORY_ID,
            ROW_ID,
            SORT_ORDER

    /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetComServicesByProviderUserCustomerDateRange' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetComServicesByProviderUserCustomerDateRange

   go

create procedure spGetComServicesByProviderUserCustomerDateRange( @MemberUserId integer,
                                                                  @CustomerId   integer,
                                                                  @StartDate    datetime,
                                                                  @EndDate      datetime ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Get the completed services between the start and end dates for the passed
      provider user and customer. */
   select START_DATE = @StartDate,
          END_DATE   = @EndDate,
          cs.COM_SERVICE_ID,
          cs.COM_SERVICE_DATE,
          cs.CUSTOMER_CONTACT,
          cs.COM_SERVICE_COMMENT,
          cs.TIME_IN,

          /* Used to handle null TIME_IN Field, so screwy looking results are
             not displayed in the report if the TIME_IN field is NULL. */
          TIME_IN_IS_NULL = case
                               when cs.TIME_IN is null then 01
                               else 00
                            end,
          cs.TIME_OUT,

          /* Used to handle null TIME_OUT Field, so screwy looking results are
             not displayed in the report if the TIME_OUT field is NULL. */
          TIME_OUT_IS_NULL = case
                                when cs.TIME_OUT is null then 01
                                else 00
                             end,

          /* Name of the technician who provided the service. */
          mu.MEMBER_USER_FNAME,
          mu.MEMBER_USER_LNAME,

          /* Name of the customer who was serviced. */
          m.MEMBER_NAME as CUSTOMER_NAME,

          /* Time stamp for the barcoding of the unit. */
          csuv.TIMESTAMP,

          TIMESTAMP_IS_NULL = case
                                 when csuv.TIMESTAMP is null then 01
                                 else 00
                              end,

          isnull( psv.PROVIDER_SERVICE_VALUE, tpsv.PROVIDER_SERVICE_VALUE ) as PROVIDER_SERVICE_VALUE,
          isnull( psv.PROVIDER_SERVICE_VALUE_TEXT, tpsv.PROVIDER_SERVICE_VALUE_TEXT ) as PROVIDER_SERVICE_VALUE_TEXT,
          isnull( pst.PROVIDER_SERVICE_TYPE_TEXT, tpst.PROVIDER_SERVICE_TYPE_TEXT ) as PROVIDER_SERVICE_TYPE_TEXT,

          /* Identifying information for the property serviced. */
          pu.CUSTOMER_UNIT_ID as PARENT_UNIT_ID,
          isnull( pcut.CUSTOMER_UNIT_TYPE_NAME, ptcut.CUSTOMER_UNIT_TYPE_NAME ) as PARENT_UNIT_TYPE_NAME,
          isnull( pu.CUSTOMER_UNIT_NAME, isnull( pcun.CUSTOMER_UNIT_NAME, ptcun.CUSTOMER_UNIT_NAME ) ) as PARENT_UNIT_NAME,

          /* Identifying information for the child units serviced. */
          su.CUSTOMER_UNIT_ID as SERVICE_UNIT_ID,
          isnull( scut.CUSTOMER_UNIT_TYPE_NAME, stcut.CUSTOMER_UNIT_TYPE_NAME ) as SERVICE_UNIT_TYPE_NAME,
          isnull( su.CUSTOMER_UNIT_NAME, isnull( scun.CUSTOMER_UNIT_NAME, stcun.CUSTOMER_UNIT_NAME ) ) as SERVICE_UNIT_NAME,

          isnull( ps.PROVIDER_SYSTEM_NAME, tps.PROVIDER_SYSTEM_NAME ) as PROVIDER_SYSTEM_NAME,
          psdt.PROVIDER_SERVICE_CATEGORY_ID,
          isnull( psc.PROVIDER_SERVICE_CATEGORY, tpsc.PROVIDER_SERVICE_CATEGORY ) as PROVIDER_SERVICE_CATEGORY,
          isnull( psdt.SORT_ORDER, tpsdt.SORT_ORDER ) as SORT_ORDER,
          isnull( psdt.PROVIDER_SERVICE_DATA_TYPE_TEXT, tpsdt.PROVIDER_SERVICE_DATA_TYPE_TEXT ) as PROVIDER_SERVICE_DATA_TYPE_TEXT,

          COM_SERVICE_DATA = csd.COM_SERVICE_DATA_ALT_TEXT,
          ROW_ID
   from COM_SERVICE cs

   /* Joins to retrieve the service type and the service program name. */
   inner join      PROVIDER_SERVICE_TYPE pst           on ( cs.PROVIDER_SERVICE_TYPE_ID           = pst.PROVIDER_SERVICE_TYPE_ID  )
   left outer join TEMPLATE_PROVIDER_SERVICE_TYPE tpst on ( pst.TEMPLATE_PROVIDER_SERVICE_TYPE_ID = tpst.PROVIDER_SERVICE_TYPE_ID )
   inner join      PROVIDER_SYSTEM ps                  on ( pst.PROVIDER_SYSTEM_ID                = ps.PROVIDER_SYSTEM_ID         )
   left outer join TEMPLATE_PROVIDER_SYSTEM tps        on ( ps.TEMPLATE_PROVIDER_SYSTEM_ID        = tps.PROVIDER_SYSTEM_ID        )

   /* Joins to retrieve the ranking data for the child units. */
   left outer join COM_SERVICE_UNIT_VALUE csuv          on ( cs.COM_SERVICE_ID                      = csuv.COM_SERVICE_ID            )
   left outer join PROVIDER_SERVICE_VALUE psv           on ( csuv.PROVIDER_SERVICE_VALUE_ID         = psv.PROVIDER_SERVICE_VALUE_ID  )
   left outer join TEMPLATE_PROVIDER_SERVICE_VALUE tpsv on ( psv.TEMPLATE_PROVIDER_SERVICE_VALUE_ID = tpsv.PROVIDER_SERVICE_VALUE_ID )

   /* Joins to retrieve the data for the categories, fields, and field values. */
   left outer join COM_SERVICE_DATA csd                      on ( csuv.COM_SERVICE_UNIT_VALUE_ID              = csd.COM_SERVICE_UNIT_VALUE_ID       )

   left outer join PROVIDER_SERVICE_DATA_TYPE psdt           on ( csd.PROVIDER_SERVICE_DATA_TYPE_ID           = psdt.PROVIDER_SERVICE_DATA_TYPE_ID  )

   left outer join TEMPLATE_PROVIDER_SERVICE_DATA_TYPE tpsdt on ( psdt.TEMPLATE_PROVIDER_SERVICE_DATA_TYPE_ID = tpsdt.PROVIDER_SERVICE_DATA_TYPE_ID )
   left outer join PROVIDER_SERVICE_CATEGORY psc             on ( psdt.PROVIDER_SERVICE_CATEGORY_ID           = psc.PROVIDER_SERVICE_CATEGORY_ID    )
   left outer join TEMPLATE_PROVIDER_SERVICE_CATEGORY tpsc   on ( psc.TEMPLATE_PROVIDER_SERVICE_CATEGORY_ID   = tpsc.PROVIDER_SERVICE_CATEGORY_ID   )

   /* Join to retrieve the name of the technician who performed the service. */
   left outer join MEMBER_USER mu on ( cs.TECHNICIAN_ID = mu.MEMBER_USER_ID )

   /* Joins to retrieve the parent units (properties) for the service. */
   left outer join CUSTOMER_UNIT pu                            on ( cs.CUSTOMER_UNIT_ID                          = pu.CUSTOMER_UNIT_ID         )
   inner join      JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT pjcut on ( pu.CUSTOMER_UNIT_ID                          = pjcut.CUSTOMER_UNIT_ID      )
   left outer join CUSTOMER_UNIT_NAME pcun                     on ( pjcut.CUSTOMER_UNIT_NAME_ID                  = pcun.CUSTOMER_UNIT_NAME_ID  )
   left outer join TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME ptcun  on ( pcun.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME_ID = ptcun.CUSTOMER_UNIT_NAME_ID )
   inner join      CUSTOMER_UNIT_TYPE pcut                     on ( pjcut.CUSTOMER_UNIT_TYPE_ID                  = pcut.CUSTOMER_UNIT_TYPE_ID  ) and
                                                                  ( pst.PROVIDER_SYSTEM_ID                       = pcut.PROVIDER_SYSTEM_ID     )
   left outer join TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE ptcut  on ( pcut.TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE_ID = ptcut.CUSTOMER_UNIT_TYPE_ID )
   inner join      JOIN_MEMBER_GROUP_CUSTOMER_UNIT pjmgcu      on ( ( pu.UNIT_PARENT_ID   = pjmgcu.CUSTOMER_UNIT_ID ) or
                                                                    ( pu.CUSTOMER_UNIT_ID = pjmgcu.CUSTOMER_UNIT_ID ) )
   inner join      JOIN_MEMBER_GROUP_USER pjmgu                on ( pjmgcu.MEMBER_GROUP_ID = pjmgu.MEMBER_GROUP_ID )

   /* Join to retrieve the name of the customer who owns the property. */
   inner join MEMBER m on ( pu.CUSTOMER_ID = m.MEMBER_ID )

   /* Joins to retrieve the child units for the service. */
   left outer join CUSTOMER_UNIT su                            on ( csuv.CUSTOMER_UNIT_ID                        = su.CUSTOMER_UNIT_ID         )
   left outer join JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT sjcut on ( su.CUSTOMER_UNIT_ID                          = sjcut.CUSTOMER_UNIT_ID      )
   left outer join CUSTOMER_UNIT_NAME scun                     on ( sjcut.CUSTOMER_UNIT_NAME_ID                  = scun.CUSTOMER_UNIT_NAME_ID  )
   left outer join TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME stcun  on ( scun.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME_ID = stcun.CUSTOMER_UNIT_NAME_ID )
   left outer join CUSTOMER_UNIT_TYPE scut                     on ( sjcut.CUSTOMER_UNIT_TYPE_ID                  = scut.CUSTOMER_UNIT_TYPE_ID  ) and
                                                                  ( pst.PROVIDER_SYSTEM_ID                       = scut.PROVIDER_SYSTEM_ID     )
   left outer join TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE stcut  on ( scut.TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE_ID = stcut.CUSTOMER_UNIT_TYPE_ID )
   left outer join JOIN_MEMBER_GROUP_CUSTOMER_UNIT sjmgcu      on ( ( su.UNIT_PARENT_ID   = sjmgcu.CUSTOMER_UNIT_ID ) or
                                                                    ( su.CUSTOMER_UNIT_ID = sjmgcu.CUSTOMER_UNIT_ID ) )
   left outer join join_member_group_user sjmgu                on ( sjmgcu.MEMBER_GROUP_ID = sjmgu.MEMBER_GROUP_ID ) and
                                                                  ( pjmgu.MEMBER_USER_ID   = sjmgu.MEMBER_USER_ID  )

   /* Only include data for the passed customer between the specified dates. */
   where ( pjmgu.member_user_id = @MemberUserId ) and
         ( pu.unit_parent_id    = -1            ) and
         ( m.MEMBER_ID          = @CustomerId   ) and
         ( cs.COM_SERVICE_DATE >= @StartDate    ) and
         ( cs.COM_SERVICE_DATE <= @EndDate      )

   /* Sort the data by the service date. */
   order by cs.COM_SERVICE_DATE desc,
            cs.COM_SERVICE_ID,
            csuv.COM_SERVICE_UNIT_VALUE_ID,
            psdt.PROVIDER_SERVICE_CATEGORY_ID,
            ROW_ID,
            SORT_ORDER

    /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetComServicesByProviderUserGroupDateRange' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetComServicesByProviderUserGroupDateRange

   go

create procedure spGetComServicesByProviderUserGroupDateRange( @MemberUserId  integer,
                                                               @MemberGroupId integer,
                                                               @StartDate     datetime,
                                                               @EndDate       datetime ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Get the completed services between the start and end dates for the passed
      provider user and customer. */
   select START_DATE = @StartDate,
          END_DATE   = @EndDate,
          cs.COM_SERVICE_ID,
          cs.COM_SERVICE_DATE,
          cs.CUSTOMER_CONTACT,
          cs.COM_SERVICE_COMMENT,
          cs.TIME_IN,

          /* Used to handle null TIME_IN Field, so screwy looking results are
             not displayed in the report if the TIME_IN field is NULL. */
          TIME_IN_IS_NULL = case
                               when cs.TIME_IN is null then 01
                               else 00
                            end,
          cs.TIME_OUT,

          /* Used to handle null TIME_OUT Field, so screwy looking results are
             not displayed in the report if the TIME_OUT field is NULL. */
          TIME_OUT_IS_NULL = case
                                when cs.TIME_OUT is null then 01
                                else 00
                             end,

          /* Name of the technician who provided the service. */
          mu.MEMBER_USER_FNAME,
          mu.MEMBER_USER_LNAME,

          /* Name of the customer who was serviced. */
          m.MEMBER_NAME as CUSTOMER_NAME,

          /* Time stamp for the barcoding of the unit. */
          csuv.TIMESTAMP,

          TIMESTAMP_IS_NULL = case
                                 when csuv.TIMESTAMP is null then 01
                                 else 00
                              end,

          isnull( psv.PROVIDER_SERVICE_VALUE, tpsv.PROVIDER_SERVICE_VALUE ) as PROVIDER_SERVICE_VALUE,
          isnull( psv.PROVIDER_SERVICE_VALUE_TEXT, tpsv.PROVIDER_SERVICE_VALUE_TEXT ) as PROVIDER_SERVICE_VALUE_TEXT,
          isnull( pst.PROVIDER_SERVICE_TYPE_TEXT, tpst.PROVIDER_SERVICE_TYPE_TEXT ) as PROVIDER_SERVICE_TYPE_TEXT,

          /* Identifying information for the property serviced. */
          pu.CUSTOMER_UNIT_ID as PARENT_UNIT_ID,
          isnull( pcut.CUSTOMER_UNIT_TYPE_NAME, ptcut.CUSTOMER_UNIT_TYPE_NAME ) as PARENT_UNIT_TYPE_NAME,
          isnull( pu.CUSTOMER_UNIT_NAME, isnull( pcun.CUSTOMER_UNIT_NAME, ptcun.CUSTOMER_UNIT_NAME ) ) as PARENT_UNIT_NAME,

          /* Identifying information for the child units serviced. */
          su.CUSTOMER_UNIT_ID as SERVICE_UNIT_ID,
          isnull( scut.CUSTOMER_UNIT_TYPE_NAME, stcut.CUSTOMER_UNIT_TYPE_NAME ) as SERVICE_UNIT_TYPE_NAME,
          isnull( su.CUSTOMER_UNIT_NAME, isnull( scun.CUSTOMER_UNIT_NAME, stcun.CUSTOMER_UNIT_NAME ) ) as SERVICE_UNIT_NAME,

          isnull( ps.PROVIDER_SYSTEM_NAME, tps.PROVIDER_SYSTEM_NAME ) as PROVIDER_SYSTEM_NAME,
          psdt.PROVIDER_SERVICE_CATEGORY_ID,
          isnull( psc.PROVIDER_SERVICE_CATEGORY, tpsc.PROVIDER_SERVICE_CATEGORY ) as PROVIDER_SERVICE_CATEGORY,
          isnull( psdt.SORT_ORDER, tpsdt.SORT_ORDER ) as SORT_ORDER,
          isnull( psdt.PROVIDER_SERVICE_DATA_TYPE_TEXT, tpsdt.PROVIDER_SERVICE_DATA_TYPE_TEXT ) as PROVIDER_SERVICE_DATA_TYPE_TEXT,
          COM_SERVICE_DATA = csd.COM_SERVICE_DATA_ALT_TEXT,

          ROW_ID,
          mg.Member_Group_ID,
          mg.Member_Group_Name

   from COM_SERVICE cs

   /* Joins to retrieve the service type and the service program name. */
   inner join      PROVIDER_SERVICE_TYPE pst           on ( cs.PROVIDER_SERVICE_TYPE_ID           = pst.PROVIDER_SERVICE_TYPE_ID  )
   left outer join TEMPLATE_PROVIDER_SERVICE_TYPE tpst on ( pst.TEMPLATE_PROVIDER_SERVICE_TYPE_ID = tpst.PROVIDER_SERVICE_TYPE_ID )
   inner join      PROVIDER_SYSTEM ps                  on ( pst.PROVIDER_SYSTEM_ID                = ps.PROVIDER_SYSTEM_ID         )
   left outer join TEMPLATE_PROVIDER_SYSTEM tps        on ( ps.TEMPLATE_PROVIDER_SYSTEM_ID        = tps.PROVIDER_SYSTEM_ID        )

   /* Joins to retrieve the ranking data for the child units. */
   left outer join COM_SERVICE_UNIT_VALUE csuv          on ( cs.COM_SERVICE_ID                      = csuv.COM_SERVICE_ID            )
   left outer join PROVIDER_SERVICE_VALUE psv           on ( csuv.PROVIDER_SERVICE_VALUE_ID         = psv.PROVIDER_SERVICE_VALUE_ID  )
   left outer join TEMPLATE_PROVIDER_SERVICE_VALUE tpsv on ( psv.TEMPLATE_PROVIDER_SERVICE_VALUE_ID = tpsv.PROVIDER_SERVICE_VALUE_ID )

   /* Joins to retrieve the data for the categories, fields, and field values. */
   left outer join COM_SERVICE_DATA csd                      on ( csuv.COM_SERVICE_UNIT_VALUE_ID              = csd.COM_SERVICE_UNIT_VALUE_ID       )

   left outer join PROVIDER_SERVICE_DATA_TYPE psdt           on ( csd.PROVIDER_SERVICE_DATA_TYPE_ID           = psdt.PROVIDER_SERVICE_DATA_TYPE_ID  )
   left outer join TEMPLATE_PROVIDER_SERVICE_DATA_TYPE tpsdt on ( psdt.TEMPLATE_PROVIDER_SERVICE_DATA_TYPE_ID = tpsdt.PROVIDER_SERVICE_DATA_TYPE_ID )
   left outer join PROVIDER_SERVICE_CATEGORY psc             on ( psdt.PROVIDER_SERVICE_CATEGORY_ID           = psc.PROVIDER_SERVICE_CATEGORY_ID    )
   left outer join TEMPLATE_PROVIDER_SERVICE_CATEGORY tpsc   on ( psc.TEMPLATE_PROVIDER_SERVICE_CATEGORY_ID   = tpsc.PROVIDER_SERVICE_CATEGORY_ID   )

   /* Join to retrieve the name of the technician who performed the service. */
   left outer join MEMBER_USER mu on ( cs.TECHNICIAN_ID = mu.MEMBER_USER_ID )

   /* Joins to retrieve the parent units (properties) for the service. */
   left outer join CUSTOMER_UNIT pu                            on ( cs.CUSTOMER_UNIT_ID                          = pu.CUSTOMER_UNIT_ID         )
   inner join      JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT pjcut on ( pu.CUSTOMER_UNIT_ID                          = pjcut.CUSTOMER_UNIT_ID      )
   left outer join CUSTOMER_UNIT_NAME pcun                     on ( pjcut.CUSTOMER_UNIT_NAME_ID                  = pcun.CUSTOMER_UNIT_NAME_ID  )
   left outer join TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME ptcun  on ( pcun.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME_ID = ptcun.CUSTOMER_UNIT_NAME_ID )
   inner join      CUSTOMER_UNIT_TYPE pcut                     on ( pjcut.CUSTOMER_UNIT_TYPE_ID                  = pcut.CUSTOMER_UNIT_TYPE_ID  ) and
                                                                  ( pst.PROVIDER_SYSTEM_ID                       = pcut.PROVIDER_SYSTEM_ID     )
   left outer join TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE ptcut  on ( pcut.TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE_ID = ptcut.CUSTOMER_UNIT_TYPE_ID )
   inner join      JOIN_MEMBER_GROUP_CUSTOMER_UNIT pjmgcu      on ( ( pu.UNIT_PARENT_ID   = pjmgcu.CUSTOMER_UNIT_ID ) or
                                                                    ( pu.CUSTOMER_UNIT_ID = pjmgcu.CUSTOMER_UNIT_ID ) )
   inner join      JOIN_MEMBER_GROUP_USER pjmgu                on ( pjmgcu.MEMBER_GROUP_ID = pjmgu.MEMBER_GROUP_ID ) and
                                                                  ( pjmgu.MEMBER_GROUP_ID  = @MemberGroupId )

   /* Join to retrieve the name of the customer who owns the property. */
   inner join MEMBER m on ( pu.CUSTOMER_ID = m.MEMBER_ID )

   /* Joins to retrieve the child units for the service. */
   left outer join CUSTOMER_UNIT su                            on ( csuv.CUSTOMER_UNIT_ID                        = su.CUSTOMER_UNIT_ID         )
   left outer join JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT sjcut on ( su.CUSTOMER_UNIT_ID                          = sjcut.CUSTOMER_UNIT_ID      )
   left outer join CUSTOMER_UNIT_NAME scun                     on ( sjcut.CUSTOMER_UNIT_NAME_ID                  = scun.CUSTOMER_UNIT_NAME_ID  )
   left outer join TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME stcun  on ( scun.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME_ID = stcun.CUSTOMER_UNIT_NAME_ID )
   left outer join CUSTOMER_UNIT_TYPE scut                     on ( sjcut.CUSTOMER_UNIT_TYPE_ID                  = scut.CUSTOMER_UNIT_TYPE_ID  ) and
                                                                  ( pst.PROVIDER_SYSTEM_ID                       = scut.PROVIDER_SYSTEM_ID     )
   left outer join TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE stcut  on ( scut.TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE_ID = stcut.CUSTOMER_UNIT_TYPE_ID )
   left outer join JOIN_MEMBER_GROUP_CUSTOMER_UNIT sjmgcu      on ( ( su.UNIT_PARENT_ID   = sjmgcu.CUSTOMER_UNIT_ID ) or
                                                                    ( su.CUSTOMER_UNIT_ID = sjmgcu.CUSTOMER_UNIT_ID ) )
   left outer join join_member_group_user sjmgu                on ( sjmgcu.MEMBER_GROUP_ID = sjmgu.MEMBER_GROUP_ID ) and
                                                                  ( pjmgu.MEMBER_USER_ID   = sjmgu.MEMBER_USER_ID  ) and
                                                                  ( sjmgu.MEMBER_USER_ID   = @MemberGroupId )
   left outer join member_group mg                             on ( sjmgu.Member_Group_ID = mg.Member_Group_ID ) and
                                                                  ( mg.MEMBER_Group_ID    = @MemberGroupId )

   /* Only include data for the passed customer between the specified dates. */
   /* 03/01/2006 ddove moved groupid to the join statements */
   where ( pjmgu.member_user_id = @MemberUserId  ) and
         ( pu.unit_parent_id    = -1             ) and
         ( cs.COM_SERVICE_DATE >= @StartDate     ) and
         ( cs.COM_SERVICE_DATE <= @EndDate       )

   /* Sort the data by the service date. */
   order by cs.COM_SERVICE_DATE desc,
            cs.COM_SERVICE_ID,
            csuv.COM_SERVICE_UNIT_VALUE_ID,
            psdt.PROVIDER_SERVICE_CATEGORY_ID,
            ROW_ID,
            SORT_ORDER

    /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetComServicesByProviderUserTechnicianIdDateRange' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetComServicesByProviderUserTechnicianIdDateRange

   go

create procedure spGetComServicesByProviderUserTechnicianIdDateRange( @MemberUserId integer,
                                                                      @TechnicianId integer,
                                                                      @StartDate    datetime,
                                                                      @EndDate      datetime ) as

   /*  12/21/2004 jf Added distinct clause to stop the join_member_group_customer_unit
       from returning multiple records for the same service if the user belongs
       to more than one group.

       csuv.COM_SERVICE_UNIT_VALUE_ID had to be added to the select list to
       make the distinct clause happy
   */

   /* Get the completed services between the start and end dates for the passed
      provider user and customer. */

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   select distinct
          START_DATE = @StartDate,
          END_DATE   = @EndDate,
          cs.COM_SERVICE_ID,
          cs.COM_SERVICE_DATE,
          cs.CUSTOMER_CONTACT,
          cs.COM_SERVICE_COMMENT,
          cs.TIME_IN,

          /* Used to handle null TIME_IN Field, so screwy looking results are
             not displayed in the report if the TIME_IN field is NULL. */
          TIME_IN_IS_NULL = case
                               when cs.TIME_IN is null then 01
                               else 00
                            end,
          cs.TIME_OUT,

          /* Used to handle null TIME_OUT Field, so screwy looking results are
             not displayed in the report if the TIME_OUT field is NULL. */
          TIME_OUT_IS_NULL = case
                                when cs.TIME_OUT is null then 01
                                else 00
                             end,

          /* Name of the technician who provided the service. */
          mu.MEMBER_USER_FNAME,
          mu.MEMBER_USER_LNAME,

          /* Name of the customer who was serviced. */
          m.MEMBER_NAME as CUSTOMER_NAME,

          /* Time stamp for the barcoding of the unit. */
          csuv.TIMESTAMP,

          TIMESTAMP_IS_NULL = case
                                 when csuv.TIMESTAMP is null then 01
                                 else 00
                              end,

          isnull( psv.PROVIDER_SERVICE_VALUE, tpsv.PROVIDER_SERVICE_VALUE ) as PROVIDER_SERVICE_VALUE,
          isnull( psv.PROVIDER_SERVICE_VALUE_TEXT, tpsv.PROVIDER_SERVICE_VALUE_TEXT ) as PROVIDER_SERVICE_VALUE_TEXT,
          isnull( pst.PROVIDER_SERVICE_TYPE_TEXT, tpst.PROVIDER_SERVICE_TYPE_TEXT ) as PROVIDER_SERVICE_TYPE_TEXT,

          /* Identifying information for the property serviced. */
          pu.CUSTOMER_UNIT_ID as PARENT_UNIT_ID,
          isnull( pcut.CUSTOMER_UNIT_TYPE_NAME, ptcut.CUSTOMER_UNIT_TYPE_NAME ) as PARENT_UNIT_TYPE_NAME,
          isnull( pu.CUSTOMER_UNIT_NAME, isnull( pcun.CUSTOMER_UNIT_NAME, ptcun.CUSTOMER_UNIT_NAME ) ) as PARENT_UNIT_NAME,

          /* Identifying information for the child units serviced. */
          su.CUSTOMER_UNIT_ID as SERVICE_UNIT_ID,
          isnull( scut.CUSTOMER_UNIT_TYPE_NAME, stcut.CUSTOMER_UNIT_TYPE_NAME ) as SERVICE_UNIT_TYPE_NAME,
          isnull( su.CUSTOMER_UNIT_NAME, isnull( scun.CUSTOMER_UNIT_NAME, stcun.CUSTOMER_UNIT_NAME ) ) as SERVICE_UNIT_NAME,

          isnull( ps.PROVIDER_SYSTEM_NAME, tps.PROVIDER_SYSTEM_NAME ) as PROVIDER_SYSTEM_NAME,
          psdt.PROVIDER_SERVICE_CATEGORY_ID,
          isnull( psc.PROVIDER_SERVICE_CATEGORY, tpsc.PROVIDER_SERVICE_CATEGORY ) as PROVIDER_SERVICE_CATEGORY,
          isnull( psdt.SORT_ORDER, tpsdt.SORT_ORDER ) as SORT_ORDER,
          isnull( psdt.PROVIDER_SERVICE_DATA_TYPE_TEXT, tpsdt.PROVIDER_SERVICE_DATA_TYPE_TEXT ) as PROVIDER_SERVICE_DATA_TYPE_TEXT,
          COM_SERVICE_DATA = csd.COM_SERVICE_DATA_ALT_TEXT,

          ROW_ID,

         /* added for distinct clause */
         csuv.COM_SERVICE_UNIT_VALUE_ID

   from COM_SERVICE cs

   /* Joins to retrieve the service type and the service program name. */
   inner join      PROVIDER_SERVICE_TYPE pst           on ( cs.PROVIDER_SERVICE_TYPE_ID           = pst.PROVIDER_SERVICE_TYPE_ID  )
   left outer join TEMPLATE_PROVIDER_SERVICE_TYPE tpst on ( pst.TEMPLATE_PROVIDER_SERVICE_TYPE_ID = tpst.PROVIDER_SERVICE_TYPE_ID )
   inner join      PROVIDER_SYSTEM ps                  on ( pst.PROVIDER_SYSTEM_ID                = ps.PROVIDER_SYSTEM_ID         )
   left outer join TEMPLATE_PROVIDER_SYSTEM tps        on ( ps.TEMPLATE_PROVIDER_SYSTEM_ID        = tps.PROVIDER_SYSTEM_ID        )

   /* Joins to retrieve the ranking data for the child units. */
   left outer join COM_SERVICE_UNIT_VALUE csuv          on ( cs.COM_SERVICE_ID                      = csuv.COM_SERVICE_ID            )
   left outer join PROVIDER_SERVICE_VALUE psv           on ( csuv.PROVIDER_SERVICE_VALUE_ID         = psv.PROVIDER_SERVICE_VALUE_ID  )
   left outer join TEMPLATE_PROVIDER_SERVICE_VALUE tpsv on ( psv.TEMPLATE_PROVIDER_SERVICE_VALUE_ID = tpsv.PROVIDER_SERVICE_VALUE_ID )

   /* Joins to retrieve the data for the categories, fields, and field values. */
   left outer join COM_SERVICE_DATA csd                      on ( csuv.COM_SERVICE_UNIT_VALUE_ID              = csd.COM_SERVICE_UNIT_VALUE_ID       )
   left outer join PROVIDER_SERVICE_DATA_TYPE psdt           on ( csd.PROVIDER_SERVICE_DATA_TYPE_ID           = psdt.PROVIDER_SERVICE_DATA_TYPE_ID  )
   left outer join TEMPLATE_PROVIDER_SERVICE_DATA_TYPE tpsdt on ( psdt.TEMPLATE_PROVIDER_SERVICE_DATA_TYPE_ID = tpsdt.PROVIDER_SERVICE_DATA_TYPE_ID )
   left outer join PROVIDER_SERVICE_CATEGORY psc             on ( psdt.PROVIDER_SERVICE_CATEGORY_ID           = psc.PROVIDER_SERVICE_CATEGORY_ID    )
   left outer join TEMPLATE_PROVIDER_SERVICE_CATEGORY tpsc   on ( psc.TEMPLATE_PROVIDER_SERVICE_CATEGORY_ID   = tpsc.PROVIDER_SERVICE_CATEGORY_ID   )

   /* Join to retrieve the name of the technician who performed the service. */
   left outer join MEMBER_USER mu on ( cs.TECHNICIAN_ID = mu.MEMBER_USER_ID )

   /* Joins to retrieve the parent units (properties) for the service. */
   left outer join CUSTOMER_UNIT pu                            on ( cs.CUSTOMER_UNIT_ID                          = pu.CUSTOMER_UNIT_ID         )
   inner join      JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT pjcut on ( pu.CUSTOMER_UNIT_ID                          = pjcut.CUSTOMER_UNIT_ID      )
   left outer join CUSTOMER_UNIT_NAME pcun                     on ( pjcut.CUSTOMER_UNIT_NAME_ID                  = pcun.CUSTOMER_UNIT_NAME_ID  )
   left outer join TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME ptcun  on ( pcun.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME_ID = ptcun.CUSTOMER_UNIT_NAME_ID )
   inner join      CUSTOMER_UNIT_TYPE pcut                     on ( pjcut.CUSTOMER_UNIT_TYPE_ID                  = pcut.CUSTOMER_UNIT_TYPE_ID  ) and
                                                                  ( pst.PROVIDER_SYSTEM_ID                       = pcut.PROVIDER_SYSTEM_ID     )
   left outer join TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE ptcut  on ( pcut.TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE_ID = ptcut.CUSTOMER_UNIT_TYPE_ID )
   inner join      JOIN_MEMBER_GROUP_CUSTOMER_UNIT pjmgcu      on ( ( pu.UNIT_PARENT_ID   = pjmgcu.CUSTOMER_UNIT_ID ) or
                                                                    ( pu.CUSTOMER_UNIT_ID = pjmgcu.CUSTOMER_UNIT_ID ) )
   inner join      JOIN_MEMBER_GROUP_USER pjmgu                on ( pjmgcu.MEMBER_GROUP_ID = pjmgu.MEMBER_GROUP_ID )

   /* Join to retrieve the name of the customer who owns the property. */
   inner join MEMBER m on ( pu.CUSTOMER_ID = m.MEMBER_ID )

   /* Joins to retrieve the child units for the service. */
   left outer join CUSTOMER_UNIT su                            on ( csuv.CUSTOMER_UNIT_ID                        = su.CUSTOMER_UNIT_ID         )
   left outer join JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT sjcut on ( su.CUSTOMER_UNIT_ID                          = sjcut.CUSTOMER_UNIT_ID      )
   left outer join CUSTOMER_UNIT_NAME scun                     on ( sjcut.CUSTOMER_UNIT_NAME_ID                  = scun.CUSTOMER_UNIT_NAME_ID  )
   left outer join TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME stcun  on ( scun.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME_ID = stcun.CUSTOMER_UNIT_NAME_ID )
   left outer join CUSTOMER_UNIT_TYPE scut                     on ( sjcut.CUSTOMER_UNIT_TYPE_ID                  = scut.CUSTOMER_UNIT_TYPE_ID  ) and
                                                                  ( pst.PROVIDER_SYSTEM_ID                       = scut.PROVIDER_SYSTEM_ID     )
   left outer join TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE stcut  on ( scut.TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE_ID = stcut.CUSTOMER_UNIT_TYPE_ID )
   left outer join JOIN_MEMBER_GROUP_CUSTOMER_UNIT sjmgcu      on ( ( su.UNIT_PARENT_ID   = sjmgcu.CUSTOMER_UNIT_ID ) or
                                                                    ( su.CUSTOMER_UNIT_ID = sjmgcu.CUSTOMER_UNIT_ID ) )
   left outer join join_member_group_user sjmgu                on ( sjmgcu.MEMBER_GROUP_ID = sjmgu.MEMBER_GROUP_ID ) and
                                                                  ( pjmgu.MEMBER_USER_ID   = sjmgu.MEMBER_USER_ID  )

   /* Only include data for the passed customer between the specified dates. */
   where ( pjmgu.member_user_id = @MemberUserId  ) and
         ( pu.unit_parent_id    = -1             ) and
         ( cs.TECHNICIAN_ID     =  @TechnicianId ) and
         ( cs.COM_SERVICE_DATE >= @StartDate     ) and
         ( cs.COM_SERVICE_DATE <= @EndDate       )

   /* Sort the data by the service date. */
   order by cs.COM_SERVICE_DATE desc,
            cs.COM_SERVICE_ID,
            csuv.COM_SERVICE_UNIT_VALUE_ID,
            psdt.PROVIDER_SERVICE_CATEGORY_ID,
            ROW_ID,
            SORT_ORDER

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetComServicesBySystemUnit' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetComServicesBySystemUnit

   go

create procedure spGetComServicesBySystemUnit( @ProviderSystemId integer,
                                               @CustomerUnitId   integer,
                                               @StartDate        datetime,
                                               @EndDate          datetime ) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   if @StartDate <> ''
      -- new procedure
      execute @ReturnCode = spGetComServicesBySystemUnitDateRange @ProviderSystemId,
                                                                  @CustomerUnitId,
                                                                  @StartDate,
                                                                  @EndDate
   else
      -- new procedure
      execute @ReturnCode = spGetComServicesBySystemUnitNoDate @ProviderSystemId,
                                                               @CustomerUnitId

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetComServicesBySystemUnitDateRange' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetComServicesBySystemUnitDateRange

   go

create procedure spGetComServicesBySystemUnitDateRange( @ProviderSystemId integer,
                                                        @CustomerUnitId   integer,
                                                        @startdate        datetime,
                                                        @enddate          datetime ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   select a.COM_SERVICE_ID,
	  a.PROVIDER_SERVICE_TYPE_ID,
          a.TECHNICIAN_ID,
	  a.COM_SERVICE_DATE,
	  a.TIME_IN,
	  a.TIME_OUT,
	  a.CUSTOMER_CONTACT,
	  a.COM_SERVICE_COMMENT
   from com_service a
   left outer join provider_service_type b on a.provider_service_type_id = b.provider_service_type_id
   where a.customer_unit_id = @CustomerUnitId
   and b.provider_system_id = @ProviderSystemId
   and a.COM_SERVICE_DATE >= @startdate
   and a.COM_SERVICE_DATE <= @enddate

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetComServicesBySystemUnitNoDate' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetComServicesBySystemUnitNoDate

   go

create procedure spGetComServicesBySystemUnitNoDate( @ProviderSystemId integer,
                                                     @CustomerUnitId   integer ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   select a.COM_SERVICE_ID,
	  a.COM_SERVICE_DATE,
	  a.PROVIDER_SERVICE_TYPE_ID,
	  isnull( b.provider_service_type_text, c.provider_service_type_text ) as provider_service_type,
	  a.TECHNICIAN_ID,
	  d.member_user_fname+' '+d.member_user_lname as TECHNICIAN_NAME,
	  a.TIME_IN,
	  a.TIME_OUT,
	  a.CUSTOMER_CONTACT,
	  a.COM_SERVICE_COMMENT,
	  a.REVIEW_USER_ID,
	  a.REVIEW_DATE
   from com_service a
   left outer join provider_service_type b on a.provider_service_type_id = b.provider_service_type_id
   left outer join template_provider_service_type c on b.template_provider_service_type_id = c.provider_service_type_id
   left outer join member_user d on a.technician_id = d.member_user_id
   where a.customer_unit_id = @CustomerUnitId
   and b.provider_system_id = @ProviderSystemId

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetComServicesBySystemUserDateRange' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetComServicesBySystemUserDateRange

   go

create procedure spGetComServicesBySystemUserDateRange ( @ProviderSystemID integer,
                                                         @MemberUserID     integer,
                                                         @StartDate        datetime,
                                                         @EndDate          datetime ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   declare @SecurityGroupId integer
   select @SecurityGroupId = security_group_id from join_member_user_security_group where member_user_id = @MemberUserID

   if ( @SecurityGroupId = 6 ) begin

      declare @CustomerId integer
      select @CustomerId = member_id from member_user where member_user_id = @MemberUserID

      SELECT distinct
        cs.com_service_id,
	cu.customer_id,
	cu.customer_unit_id,
	cs.provider_service_type_id,
	cs.technician_id,
	cs.com_service_date,
	cs.time_in,
	cs.time_out,
	cs.customer_contact,
	cs.com_service_comment,
	isnull( cu.customer_unit_name, isnull( cun.customer_unit_name, tpcun.customer_unit_name ) ) as customer_unit_name,
	isnull( pst.provider_service_type_text, tpst.provider_service_type_text ) as provider_service_type

      from com_service cs
      inner join customer_unit cu on ( cs.customer_unit_id = cu.customer_unit_id ) and ( cu.unit_parent_id = -1 ) and
                                     ( cu.customer_id = @CustomerId )
      inner join join_customer_unit_type_customer_unit jcutcu on ( cu.customer_unit_id = jcutcu.customer_unit_id )
      inner join customer_unit_type cut on ( jcutcu.customer_unit_type_id = cut.customer_unit_type_id ) and
                                           ( cut.provider_system_id =  @ProviderSystemID )
      left outer join customer_unit_name cun on ( jcutcu.customer_unit_name_id = cun.customer_unit_name_id )
      left outer join template_provider_customer_unit_name tpcun on ( cun.template_provider_customer_unit_name_id = tpcun.customer_unit_name_id )
      inner join provider_service_type pst on ( cs.provider_service_type_id = pst.provider_service_type_id ) and
                                              ( cut.provider_system_id = pst.provider_system_id )
      left outer join template_provider_service_type tpst on ( pst.template_provider_service_type_id = tpst.provider_service_type_id )

      where ( cs.com_service_date >= @StartDate )
        and ( cs.com_service_date <= @EndDate )
        and ( cs.review_date is not null )

      order by cs.com_service_date desc

   end

   else begin

      SELECT distinct
        cs.com_service_id,
	cu.customer_id,
	cu.customer_unit_id,
	cs.provider_service_type_id,
	cs.technician_id,
	cs.com_service_date,
	cs.time_in,
	cs.time_out,
	cs.customer_contact,
	cs.com_service_comment,
	isnull( cu.customer_unit_name, isnull( cun.customer_unit_name, tpcun.customer_unit_name ) ) as customer_unit_name,
	isnull( pst.provider_service_type_text, tpst.provider_service_type_text ) as provider_service_type

      from com_service cs
      inner join customer_unit cu on ( cs.customer_unit_id = cu.customer_unit_id ) and ( cu.unit_parent_id = -1 )
      inner join join_customer_unit_type_customer_unit jcutcu on ( cu.customer_unit_id = jcutcu.customer_unit_id )
      inner join customer_unit_type cut on ( jcutcu.customer_unit_type_id = cut.customer_unit_type_id ) and
                                           ( cut.provider_system_id =  @ProviderSystemID )
      left outer join customer_unit_name cun on ( jcutcu.customer_unit_name_id = cun.customer_unit_name_id )
      left outer join template_provider_customer_unit_name tpcun on ( cun.template_provider_customer_unit_name_id = tpcun.customer_unit_name_id )
      inner join provider_service_type pst on ( cs.provider_service_type_id = pst.provider_service_type_id ) and
                                              ( cut.provider_system_id = pst.provider_system_id )
      left outer join template_provider_service_type tpst on ( pst.template_provider_service_type_id = tpst.provider_service_type_id )
      inner join join_member_group_customer_unit jmgcu on ( cu.customer_unit_id = jmgcu.customer_unit_id )
      inner join join_member_group_user jmgu on ( jmgcu.member_group_id = jmgu.member_group_id ) and
                                                ( jmgu.member_user_id = @MemberUserId )

      where ( cs.com_service_date >= @StartDate )
        and ( cs.com_service_date <= @EndDate )
        and ( cs.review_date is not null )

      order by cs.com_service_date desc

   end

   /* If there was an error... */
   if ( @@Error <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetComServicesForWorkOrdersByProviderCustomerService' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetComServicesForWorkOrdersByProviderCustomerService

   go

create procedure spGetComServicesForWorkOrdersByProviderCustomerService( @ProviderCustomerServiceId integer ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Get the completed services for the current provider, customer, and
      service program that may be associated with a work order. */
   select cs.COM_SERVICE_ID,
          cs.COM_SERVICE_DATE,
          cs.PROVIDER_SERVICE_TYPE_ID,
          IsNull( pst.PROVIDER_SERVICE_TYPE_TEXT,
                  tpst.PROVIDER_SERVICE_TYPE_TEXT ) as PROVIDER_SERVICE_TYPE_TEXT,
          cs.TECHNICIAN_ID,
          cs.TIME_IN,
          cs.TIME_OUT,
          cs.CUSTOMER_CONTACT,
          cs.COM_SERVICE_COMMENT,
          cs.REVIEW_USER_ID,
          cs.REVIEW_DATE,
          cu.CUSTOMER_UNIT_NAME,
          pcss.COM_SERVICE_ID as WORK_ORDER_SERVICE_ID
   from COM_SERVICE cs
   inner join      PROVIDER_SERVICE_TYPE pst                on cs.PROVIDER_SERVICE_TYPE_ID           = pst.PROVIDER_SERVICE_TYPE_ID
   left outer join TEMPLATE_PROVIDER_SERVICE_TYPE tpst      on pst.TEMPLATE_PROVIDER_SERVICE_TYPE_ID = tpst.PROVIDER_SERVICE_TYPE_ID
   inner join      CUSTOMER_UNIT cu                         on ( cs.CUSTOMER_UNIT_ID                 = cu.CUSTOMER_UNIT_ID ) and
                                                               ( cu.UNIT_PARENT_ID                   = -1                  )
   left outer join PROVIDER_CUSTOMER_SERVICE_SCHEDULE pcss  on ( cs.COM_SERVICE_ID                   = pcss.COM_SERVICE_ID        ) and
                                                               ( pcss.PROVIDER_CUSTOMER_SERVICE_ID   = @ProviderCustomerServiceId )
   left outer join PROVIDER_CUSTOMER_SERVICE_SCHEDULE pcss1 on ( cs.CUSTOMER_UNIT_ID                 = pcss1.CUSTOMER_UNIT_ID         ) and
                                                               ( ( pcss.COM_SERVICE_ID              <> pcss1.COM_SERVICE_ID         ) or
                                                                 ( pcss1.COM_SERVICE_ID is null                                     ) ) and
                                                               ( pcss1.PROVIDER_CUSTOMER_SERVICE_ID  = @ProviderCustomerServiceId     )
   inner join      PROVIDER_CUSTOMER pc                     on cu.CUSTOMER_ID                        = pc.CUSTOMER_ID
   inner join      PROVIDER_CUSTOMER_SERVICE pcs            on pc.PROVIDER_CUSTOMER_ID               = pcs.PROVIDER_CUSTOMER_ID
   where pcs.PROVIDER_CUSTOMER_SERVICE_ID = @ProviderCustomerServiceId

   /* If there was an error... */
   if ( @@Error <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetComServiceSummaryByCustomerId' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetComServiceSummaryByCustomerId

   go

create procedure spGetComServiceSummaryByCustomerId( @CustomerId             integer,
                                                     @MemberUserId           integer,
                                                     @ProviderSystemId       integer,
                                                     @ProviderServiceValue   integer,
                                                     @StartDate              datetime,
                                                     @EndDate                datetime ) as

   declare @MemberUserEmail                varchar(50) /* Email address of the user */
   declare @MemberUserName                 varchar(51) /* Full name of the user */
   declare @ReplyToEmail                   varchar(50) /* Reply to address from the system or provider */
   declare @ReplyToName                    varchar(51) /* Reply to name from the provider */
   declare @SendEmailHTML                  integer         /* Temp holder for HTML option */
   declare @SecurityGroupTypeId            integer         /* Security Group type provider or customer */
   declare @SecurityGroupId                integer         /* Secuity Group of the member user */
   declare @ProviderId                     integer         /* Provider id */
   declare @ProviderName                   varchar(50) /* Provider Name used in email attachment */
   declare @ProviderServiceValueFilter     integer         /* Service Value used in report */
   declare @ProviderServiceValueTextFilter varchar(50) /* Service Value Text used in report */

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   declare @SQL                 varchar(6000)

   set nocount on

   set @SendEmailHTML = 0
   set @ReplyToEmail = ''
   set @ReplyToName  = ''

   if @ProviderServiceValue is null begin
      set @ProviderServiceValueFilter     = -1
      set @ProviderServiceValueTextFilter = ''
   end
   else
      set @ProviderServiceValueFilter = @ProviderServiceValue

    /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   if @ProviderServiceValue > -1
      select @ProviderServiceValueTextFilter = ISNULL( psv.PROVIDER_SERVICE_VALUE_TEXT, tpsv.PROVIDER_SERVICE_VALUE_TEXT )
      from PROVIDER_SERVICE_VALUE psv
      left outer join TEMPLATE_PROVIDER_SERVICE_VALUE tpsv on ( psv.TEMPLATE_PROVIDER_SERVICE_VALUE_ID = tpsv.PROVIDER_SERVICE_VALUE_ID )
      where ( psv.PROVIDER_SERVICE_VALUE = @ProviderServiceValueFilter or tpsv.PROVIDER_SERVICE_VALUE = @ProviderServiceValueFilter )
      and psv.PROVIDER_SYSTEM_ID = @ProviderSystemId

        /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   select @ReplyToName  = m.member_name,
          @ProviderName = m.member_name,
          @ProviderId   = ps.provider_id from member m
                         inner join provider_system ps on m.member_id = ps.provider_id and
                                                          ps.provider_system_id = @ProviderSystemId

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* get the reply to email from the provider system */

   SELECT @ReplyToEmail = CONTACT_INFO
   FROM CONTACT a
   LEFT OUTER JOIN CONTACT_JOIN b ON a.CONTACT_ID = b.CONTACT_ID
   LEFT OUTER JOIN CONTACT_TYPE c ON a.contact_type_id = c.contact_type_id
   WHERE b.ENTITY_ID = @ProviderSystemId
   AND b.ENTITY_TYPE_ID = 6
   AND a.CONTACT_TYPE_ID = 12

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* if not from the provider system get from the provider */
   if @ReplyToEmail = '' begin

      SELECT @ReplyToEmail = CONTACT_INFO
      FROM CONTACT a
      LEFT OUTER JOIN CONTACT_JOIN b ON a.CONTACT_ID = b.CONTACT_ID
      LEFT OUTER JOIN CONTACT_TYPE c ON a.contact_type_id = c.contact_type_id
      WHERE b.ENTITY_ID = @ProviderId
      AND b.ENTITY_TYPE_ID = 3
      AND a.CONTACT_TYPE_ID = 12

       /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
      select @ErrorCode = @@Error

      /* If there was an error... */
      if ( @ErrorCode <> 00 ) begin

         /* Rollback the transaction. */
         rollback transaction

         /* Return the failure. */
         return 01

      end

   end

   select @MemberUserEmail     = mu.member_user_email,
          @MemberUserName      = mu.member_user_fname + ' ' + mu.member_user_lname,
          @SecurityGroupTypeId = sg.security_group_type_id,
          @SecurityGroupId     = jmusg.security_group_id
          from member_user mu
          inner join member m on mu.member_id = m.member_id
          inner join join_member_user_security_group jmusg on jmusg.member_user_id = mu.member_user_id
          inner join security_group sg on sg.security_group_id = jmusg.security_group_id
          where mu.member_user_id = @MemberUserId

    /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   set @MemberUserEmail = 'ddove@eyeonsolutions.com'

  set @SQL = ''
  /* Get the completed services between the start and end dates for the passed
      provider user and customer. */
   set @SQL = 'select distinct csuv.COM_SERVICE_UNIT_VALUE_ID, ' +
          'cs.COM_SERVICE_ID, ' +
          'cs.COM_SERVICE_DATE, ' +

          /* Name of the customer who was serviced. */
          'm.MEMBER_NAME as CUSTOMER_NAME, ' +
          /* Time stamp for the barcoding of the unit. */
          'csuv.TIMESTAMP, ' +

          'isnull( psv.PROVIDER_SERVICE_VALUE, tpsv.PROVIDER_SERVICE_VALUE ) as PROVIDER_SERVICE_VALUE, ' +
          'isnull( psv.PROVIDER_SERVICE_VALUE_TEXT, tpsv.PROVIDER_SERVICE_VALUE_TEXT ) as PROVIDER_SERVICE_VALUE_TEXT, ' +
          'isnull( pst.PROVIDER_SERVICE_TYPE_TEXT, tpst.PROVIDER_SERVICE_TYPE_TEXT ) as PROVIDER_SERVICE_TYPE_TEXT, ' +

          /* Identifying information for the property serviced. */
          'pu.CUSTOMER_UNIT_ID as PARENT_UNIT_ID, ' +
          'isnull( pcut.CUSTOMER_UNIT_TYPE_NAME, ptcut.CUSTOMER_UNIT_TYPE_NAME ) as PARENT_UNIT_TYPE_NAME, ' +
          'isnull( pu.CUSTOMER_UNIT_NAME, isnull( pcun.CUSTOMER_UNIT_NAME, ptcun.CUSTOMER_UNIT_NAME ) ) as PARENT_UNIT_NAME, ' +

          /* Identifying information for the child units serviced. */
          'su.CUSTOMER_UNIT_ID as SERVICE_UNIT_ID, ' +
          'isnull( scut.CUSTOMER_UNIT_TYPE_NAME, stcut.CUSTOMER_UNIT_TYPE_NAME ) as SERVICE_UNIT_TYPE_NAME, ' +
          'isnull( su.CUSTOMER_UNIT_NAME, isnull( scun.CUSTOMER_UNIT_NAME, stcun.CUSTOMER_UNIT_NAME ) ) as SERVICE_UNIT_NAME, ' +

          'isnull( ps.PROVIDER_SYSTEM_NAME, tps.PROVIDER_SYSTEM_NAME ) as PROVIDER_SYSTEM_NAME, ' +

          'START_DATE = ''' + convert(varchar(10), @StartDate, 01) + ''', ' +
          'END_DATE   = ''' + convert(varchar(10), @EndDate, 01)   + ''', ' +
          'MEMBER_USER_NAME  = ''' + @MemberUserName  + ''', ' +
          'USER_EMAIL        = ''' + @MemberUserEmail + ''', ' +
          'REPLY_TO_EMAIL    = ''' + @ReplyToEmail    +''', ' +
          'REPLY_TO_NAME     = ''' + @ReplyToName + ''', ' +
          'PROVIDER_ID       = '   + cast( @ProviderId  as varchar(10 ) ) + ', ' +
          'PROVIDER_NAME     = ''' + @Providername + ''', ' +
          'SECURITY_GROUP_TYPE_ID      = ' + cast( @SecurityGroupTypeId as varchar(10))    + ', ' +
          'SECURITY_GROUP_ID   = ' + cast( @SecurityGroupId as varchar(10)) + ', ' +
          'PROVIDER_SERVICE_VALUE_FILTER = ' + cast( @ProviderServiceValueFilter as varchar(10 )) + ', ' +
          'PROVIDER_SERVICE_VALUE_TEXT_FILTER = ''' +  @ProviderServiceValueTextFilter + ''', ' +
          'EMAIL_SEND_HTML   = '  + cast( @SendEmailHTML as varchar(1)) + ' ' +

   'from COM_SERVICE cs ' +

   /* Joins to retrieve the service type and the service program name. */
   'inner join      PROVIDER_SERVICE_TYPE pst           on ( cs.PROVIDER_SERVICE_TYPE_ID           = pst.PROVIDER_SERVICE_TYPE_ID  ) ' +
   'left outer join TEMPLATE_PROVIDER_SERVICE_TYPE tpst on ( pst.TEMPLATE_PROVIDER_SERVICE_TYPE_ID = tpst.PROVIDER_SERVICE_TYPE_ID ) ' +
   'inner join      PROVIDER_SYSTEM ps                  on ( pst.PROVIDER_SYSTEM_ID                = ps.PROVIDER_SYSTEM_ID         ) and ' +
                                                          '( ps.PROVIDER_SYSTEM_ID             = ' + cast( @ProviderSystemId as varchar(10)) + ' ) ' +
   'left outer join TEMPLATE_PROVIDER_SYSTEM tps        on ( ps.TEMPLATE_PROVIDER_SYSTEM_ID        = tps.PROVIDER_SYSTEM_ID        ) ' +

   /* Joins to retrieve the ranking data for the child units. */
   'left outer join COM_SERVICE_UNIT_VALUE csuv          on ( cs.COM_SERVICE_ID                      = csuv.COM_SERVICE_ID            ) ' +
   'left outer join PROVIDER_SERVICE_VALUE psv           on ( csuv.PROVIDER_SERVICE_VALUE_ID         = psv.PROVIDER_SERVICE_VALUE_ID  ) ' +
   'left outer join TEMPLATE_PROVIDER_SERVICE_VALUE tpsv on ( psv.TEMPLATE_PROVIDER_SERVICE_VALUE_ID = tpsv.PROVIDER_SERVICE_VALUE_ID ) ' +

   /* Joins to retrieve the parent units (properties) for the service. */
   'inner join      CUSTOMER_UNIT pu                            on ( cs.CUSTOMER_UNIT_ID                          = pu.CUSTOMER_UNIT_ID         ) and  ' +
                                                                  '( pu.unit_parent_id                            = -1                          )  ' +
   'inner join      JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT pjcut on ( pu.CUSTOMER_UNIT_ID                          = pjcut.CUSTOMER_UNIT_ID      )  ' +
   'left outer join CUSTOMER_UNIT_NAME pcun                     on ( pjcut.CUSTOMER_UNIT_NAME_ID                  = pcun.CUSTOMER_UNIT_NAME_ID  )  ' +
   'left outer join TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME ptcun  on ( pcun.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME_ID = ptcun.CUSTOMER_UNIT_NAME_ID ) ' +
   'inner join      CUSTOMER_UNIT_TYPE pcut                     on ( pjcut.CUSTOMER_UNIT_TYPE_ID                  = pcut.CUSTOMER_UNIT_TYPE_ID  )  and ' +
                                                                  '( pcut.PROVIDER_SYSTEM_ID                      = ' + cast( @ProviderSystemId as varchar(10)) + ' ) ' +

   'left outer join TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE ptcut  on ( pcut.TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE_ID = ptcut.CUSTOMER_UNIT_TYPE_ID ) ' +

   /* Join to retrieve the name of the customer who owns the property. */
   'inner join MEMBER m on ( pu.CUSTOMER_ID = m.MEMBER_ID ) and m.MEMBER_ID = ' + cast( @CustomerId as varchar(10) ) + ' ' +

   /* Joins to retrieve the child units for the service. */
   'left outer join CUSTOMER_UNIT su                            on ( csuv.CUSTOMER_UNIT_ID                        = su.CUSTOMER_UNIT_ID         ) ' +
   'left outer join JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT sjcut on ( su.CUSTOMER_UNIT_ID                          = sjcut.CUSTOMER_UNIT_ID      ) ' +
   'left outer join CUSTOMER_UNIT_NAME scun                     on ( sjcut.CUSTOMER_UNIT_NAME_ID                  = scun.CUSTOMER_UNIT_NAME_ID  ) ' +
   'left outer join TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME stcun  on ( scun.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME_ID = stcun.CUSTOMER_UNIT_NAME_ID ) ' +
   'left outer join CUSTOMER_UNIT_TYPE scut                     on ( sjcut.CUSTOMER_UNIT_TYPE_ID                  = scut.CUSTOMER_UNIT_TYPE_ID  ) and ' +
                                                                  '( scut.PROVIDER_SYSTEM_ID                      = ' + cast( @ProviderSystemId as varchar(10) ) + ' ) ' +
   'left outer join TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE stcut  on ( scut.TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE_ID = stcut.CUSTOMER_UNIT_TYPE_ID ) ' +

   /* Only include data for the passed customer between the specified dates.  */
   'where ( pu.unit_parent_id    = -1            ) and ' +
   '      ( cs.PROVIDER_INPUT_DATE >= ''' + convert(varchar(10), @StartDate, 01) +''' ) and ' +
   '      ( cs.PROVIDER_INPUT_DATE <= ''' + convert(varchar(10), @EndDate, 01) + ''' ) '

   if @ProviderServiceValue is not null
      set @SQL = @SQL +
                'and ( ( psv.PROVIDER_SERVICE_VALUE  >= ' + cast( @ProviderServiceValue as varchar(10) ) + ') or ' +
                '( tpsv.PROVIDER_SERVICE_VALUE >= ' + cast( @ProviderServiceValue as varchar(10) ) + ' ) ) '

   /* Sort the data by the service date. */
  set @SQL = @SQL +
  ' order by m.MEMBER_NAME, ' +
            'cs.COM_SERVICE_DATE desc, ' +
            'cs.COM_SERVICE_ID, ' +
            'SERVICE_UNIT_TYPE_NAME, ' +
            'SERVICE_UNIT_NAME, ' +
            'csuv.COM_SERVICE_UNIT_VALUE_ID '

  exec( @SQL )

    /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

      /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetComServiceSummaryByCustomerUserId' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetComServiceSummaryByCustomerUserId

   go

create procedure spGetComServiceSummaryByCustomerUserId( @CustomerId               integer,
                                                         @MemberUserId             integer,
                                                         @ProviderSystemId         integer,
                                                         @ProviderServiceValue     integer,
                                                         @StartDate                datetime,
                                                         @EndDate                  datetime ) as

   declare @MemberUserEmail                varchar(50) /* Email address of the user */
   declare @MemberUserName                 varchar(51) /* Full name of the user */
   declare @ReplyToEmail                   varchar(50) /* Reply to address from the system or provider */
   declare @ReplyToName                    varchar(51) /* Reply to name from the provider */
   declare @SendEmailHTML                  integer         /* Temp holder for HTML option */
   declare @SecurityGroupTypeId            integer         /* Security Group type provider or customer */
   declare @SecurityGroupId                integer         /* Secuity Group of the member user */
   declare @ProviderId                     integer         /* Provider id */
   declare @ProviderName                   varchar(50) /* Provider Name used in email attachment */
   declare @ProviderServiceValueFilter     integer         /* Service Value used in report */
   declare @ProviderServiceValueTextFilter varchar(50) /* Service Value Text used in report */

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   declare @SQL varchar(6000)

   set nocount on

   set @ReplyToEmail = ''
   set @ReplyToName  = ''
   set @SendEmailHTML = 0

   if @ProviderServiceValue is null begin
      set @ProviderServiceValueFilter     = -1
      set @ProviderServiceValueTextFilter = ''
   end
   else
      set @ProviderServiceValueFilter = @ProviderServiceValue

    /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   if @ProviderServiceValue > -1
      select @ProviderServiceValueTextFilter = ISNULL( psv.PROVIDER_SERVICE_VALUE_TEXT, tpsv.PROVIDER_SERVICE_VALUE_TEXT )
      from PROVIDER_SERVICE_VALUE psv
      left outer join TEMPLATE_PROVIDER_SERVICE_VALUE tpsv on ( psv.TEMPLATE_PROVIDER_SERVICE_VALUE_ID = tpsv.PROVIDER_SERVICE_VALUE_ID )
      where ( psv.PROVIDER_SERVICE_VALUE = @ProviderServiceValueFilter or tpsv.PROVIDER_SERVICE_VALUE = @ProviderServiceValueFilter )
      and psv.PROVIDER_SYSTEM_ID = @ProviderSystemId

        /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   select @ReplyToName = m.member_name,
          @ProviderName = m.member_name,
          @ProviderId  = ps.provider_id from member m
                         inner join provider_system ps on m.member_id = ps.provider_id and
                                                          ps.provider_system_id = @ProviderSystemId

       /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

      /* get the reply to email from the provider system */

   SELECT @ReplyToEmail = CONTACT_INFO
   FROM CONTACT a
   LEFT OUTER JOIN CONTACT_JOIN b ON a.CONTACT_ID = b.CONTACT_ID
   LEFT OUTER JOIN CONTACT_TYPE c ON a.contact_type_id = c.contact_type_id
   WHERE b.ENTITY_ID = @ProviderSystemId
   AND b.ENTITY_TYPE_ID = 6
   AND a.CONTACT_TYPE_ID = 12

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* if not from the provider system get from the provider */
   if @ReplyToEmail = '' begin

      SELECT @ReplyToEmail = CONTACT_INFO
      FROM CONTACT a
      LEFT OUTER JOIN CONTACT_JOIN b ON a.CONTACT_ID = b.CONTACT_ID
      LEFT OUTER JOIN CONTACT_TYPE c ON a.contact_type_id = c.contact_type_id
      WHERE b.ENTITY_ID = @ProviderId
      AND b.ENTITY_TYPE_ID = 3
      AND a.CONTACT_TYPE_ID = 12

       /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
      select @ErrorCode = @@Error

      /* If there was an error... */
      if ( @ErrorCode <> 00 ) begin

         /* Rollback the transaction. */
         rollback transaction

         /* Return the failure. */
         return 01

      end

   end

  select @MemberUserEmail     = mu.member_user_email,
          @MemberUserName      = mu.member_user_fname + ' ' + mu.member_user_lname,
          @SecurityGroupTypeId = sg.security_group_type_id,
          @SecurityGroupId     = jmusg.security_group_id
          from member_user mu
          inner join member m on mu.member_id = m.member_id
          inner join join_member_user_security_group jmusg on jmusg.member_user_id = mu.member_user_id
          inner join security_group sg on sg.security_group_id = jmusg.security_group_id
          where mu.member_user_id = @MemberUserId

    /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   set @MemberUserEmail = 'ddove@eyeonsolutions.com'
   set @SQL =

  /* Get the completed services between the start and end dates for the passed
      provider user and customer. */
   'select distinct csuv.COM_SERVICE_UNIT_VALUE_ID, ' +
          'cs.COM_SERVICE_ID, ' +
          'cs.COM_SERVICE_DATE, ' +

          /* Name of the customer who was serviced. */
          'm.MEMBER_NAME as CUSTOMER_NAME, ' +
          /* Time stamp for the barcoding of the unit. */
          'csuv.TIMESTAMP, ' +

          'isnull( psv.PROVIDER_SERVICE_VALUE, tpsv.PROVIDER_SERVICE_VALUE ) as PROVIDER_SERVICE_VALUE, ' +
          'isnull( psv.PROVIDER_SERVICE_VALUE_TEXT, tpsv.PROVIDER_SERVICE_VALUE_TEXT ) as PROVIDER_SERVICE_VALUE_TEXT, ' +
          'isnull( pst.PROVIDER_SERVICE_TYPE_TEXT, tpst.PROVIDER_SERVICE_TYPE_TEXT ) as PROVIDER_SERVICE_TYPE_TEXT, ' +

          /* Identifying information for the property serviced. */
          'pu.CUSTOMER_UNIT_ID as PARENT_UNIT_ID, ' +
          'isnull( pcut.CUSTOMER_UNIT_TYPE_NAME, ptcut.CUSTOMER_UNIT_TYPE_NAME ) as PARENT_UNIT_TYPE_NAME, ' +
          'isnull( pu.CUSTOMER_UNIT_NAME, isnull( pcun.CUSTOMER_UNIT_NAME, ptcun.CUSTOMER_UNIT_NAME ) ) as PARENT_UNIT_NAME, ' +

          /* Identifying information for the child units serviced. */
          'su.CUSTOMER_UNIT_ID as SERVICE_UNIT_ID, ' +
          'isnull( scut.CUSTOMER_UNIT_TYPE_NAME, stcut.CUSTOMER_UNIT_TYPE_NAME ) as SERVICE_UNIT_TYPE_NAME, ' +
          'isnull( su.CUSTOMER_UNIT_NAME, isnull( scun.CUSTOMER_UNIT_NAME, stcun.CUSTOMER_UNIT_NAME ) ) as SERVICE_UNIT_NAME, ' +

          'isnull( ps.PROVIDER_SYSTEM_NAME, tps.PROVIDER_SYSTEM_NAME ) as PROVIDER_SYSTEM_NAME, ' +

          'START_DATE = ''' + convert(varchar(10), @StartDate, 01) + ''', ' +
          'END_DATE   = ''' + convert(varchar(10), @EndDate, 01)   + ''', ' +
          'MEMBER_USER_NAME  = ''' + @MemberUserName  + ''', ' +
          'USER_EMAIL        = ''' + @MemberUserEmail + ''', ' +
          'REPLY_TO_EMAIL    = ''' + @ReplyToEmail    +''', ' +
          'REPLY_TO_NAME     = ''' + @ReplyToName + ''', ' +
          'PROVIDER_ID       = '   + cast( @ProviderId  as varchar(10 ) ) + ', ' +
          'PROVIDER_NAME     = ''' + @Providername + ''', ' +
          'SECURITY_GROUP_TYPE_ID = ' + cast( @SecurityGroupTypeId as varchar(10))    + ', ' +
          'SECURITY_GROUP_ID   = ' + cast( @SecurityGroupId as varchar(10)) + ', ' +
          'PROVIDER_SERVICE_VALUE_FILTER = ' + cast( @ProviderServiceValue as varchar(10 )) + ', ' +
          'PROVIDER_SERVICE_VALUE_TEXT_FILTER = ''' +  @ProviderServiceValueTextFilter + ''', ' +
          'EMAIL_SEND_HTML   = '  + cast( @SendEmailHTML as varchar(1)) + ' ' +

   'from COM_SERVICE cs ' +

   /* Joins to retrieve the service type and the service program name. */
   'inner join      PROVIDER_SERVICE_TYPE pst           on ( cs.PROVIDER_SERVICE_TYPE_ID           = pst.PROVIDER_SERVICE_TYPE_ID  ) ' +
   'left outer join TEMPLATE_PROVIDER_SERVICE_TYPE tpst on ( pst.TEMPLATE_PROVIDER_SERVICE_TYPE_ID = tpst.PROVIDER_SERVICE_TYPE_ID ) ' +
   'inner join      PROVIDER_SYSTEM ps                  on ( pst.PROVIDER_SYSTEM_ID                = ps.PROVIDER_SYSTEM_ID         ) and ' +
                                                          '( ps.PROVIDER_SYSTEM_ID             = ' + cast( @ProviderSystemId as varchar(10)) + ' ) ' +
   'left outer join TEMPLATE_PROVIDER_SYSTEM tps        on ( ps.TEMPLATE_PROVIDER_SYSTEM_ID        = tps.PROVIDER_SYSTEM_ID        ) ' +

   /* Joins to retrieve the ranking data for the child units. */
   'left outer join COM_SERVICE_UNIT_VALUE csuv          on ( cs.COM_SERVICE_ID                      = csuv.COM_SERVICE_ID            ) ' +
   'left outer join PROVIDER_SERVICE_VALUE psv           on ( csuv.PROVIDER_SERVICE_VALUE_ID         = psv.PROVIDER_SERVICE_VALUE_ID  ) ' +
   'left outer join TEMPLATE_PROVIDER_SERVICE_VALUE tpsv on ( psv.TEMPLATE_PROVIDER_SERVICE_VALUE_ID = tpsv.PROVIDER_SERVICE_VALUE_ID ) ' +

   /* Joins to retrieve the parent units (properties) for the service. */
   'inner join      CUSTOMER_UNIT pu                            on ( cs.CUSTOMER_UNIT_ID                          = pu.CUSTOMER_UNIT_ID         ) and  ' +
                                                                  '( pu.unit_parent_id                            = -1                          )  ' +
   'inner join      JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT pjcut on ( pu.CUSTOMER_UNIT_ID                          = pjcut.CUSTOMER_UNIT_ID      )  ' +
   'left outer join CUSTOMER_UNIT_NAME pcun                     on ( pjcut.CUSTOMER_UNIT_NAME_ID                  = pcun.CUSTOMER_UNIT_NAME_ID  )  ' +
   'left outer join TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME ptcun  on ( pcun.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME_ID = ptcun.CUSTOMER_UNIT_NAME_ID ) ' +
   'inner join      CUSTOMER_UNIT_TYPE pcut                     on ( pjcut.CUSTOMER_UNIT_TYPE_ID                  = pcut.CUSTOMER_UNIT_TYPE_ID  )  and ' +
                                                                  '( pcut.PROVIDER_SYSTEM_ID                      = ' + cast( @ProviderSystemId as varchar(10)) + ' ) ' +

   'left outer join TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE ptcut  on ( pcut.TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE_ID = ptcut.CUSTOMER_UNIT_TYPE_ID ) ' +

   /* Join to retrieve the name of the customer who owns the property. */
   'inner join MEMBER m on ( pu.CUSTOMER_ID = m.MEMBER_ID ) and m.MEMBER_ID = ' + cast( @CustomerId as varchar(10) ) + ' ' +

   /* Joins to retrieve the child units for the service. */
   'left outer join CUSTOMER_UNIT su                            on ( csuv.CUSTOMER_UNIT_ID                        = su.CUSTOMER_UNIT_ID         ) ' +
   'left outer join JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT sjcut on ( su.CUSTOMER_UNIT_ID                          = sjcut.CUSTOMER_UNIT_ID      ) ' +
   'left outer join CUSTOMER_UNIT_NAME scun                     on ( sjcut.CUSTOMER_UNIT_NAME_ID                  = scun.CUSTOMER_UNIT_NAME_ID  ) ' +
   'left outer join TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME stcun  on ( scun.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME_ID = stcun.CUSTOMER_UNIT_NAME_ID ) ' +
   'left outer join CUSTOMER_UNIT_TYPE scut                     on ( sjcut.CUSTOMER_UNIT_TYPE_ID                  = scut.CUSTOMER_UNIT_TYPE_ID  ) and ' +
                                                                  '( scut.PROVIDER_SYSTEM_ID                      = ' + cast( @ProviderSystemId as varchar(10) ) + ' ) ' +
   'left outer join TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE stcut  on ( scut.TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE_ID = stcut.CUSTOMER_UNIT_TYPE_ID ) ' +

   'inner join JOIN_MEMBER_GROUP_CUSTOMER_UNIT pjmgcu      on   ( cs.CUSTOMER_UNIT_ID   = pjmgcu.CUSTOMER_UNIT_ID ) ' +
   'inner join JOIN_MEMBER_GROUP_USER pjmgu                on ( ( pjmgu.MEMBER_USER_ID = ' + cast( @MemberUserId as varchar(10)) + ' ) and ' +
                                                             '( pjmgcu.MEMBER_GROUP_ID = pjmgu.MEMBER_GROUP_ID ) ) ' +

   /* Only include data for the passed customer between the specified dates.  */
   'where ( pu.unit_parent_id    = -1            ) and ' +
   '      ( cs.PROVIDER_INPUT_DATE >= ''' + convert(varchar(10), @StartDate, 01) +''' ) and ' +
   '      ( cs.PROVIDER_INPUT_DATE <= ''' + convert(varchar(10), @EndDate, 01) + ''' ) '

   if @ProviderServiceValue is not null
      set @SQL = @SQL +
                'and ( ( psv.PROVIDER_SERVICE_VALUE  >= ' + cast( @ProviderServiceValue as varchar(10) ) + ') or ' +
                '( tpsv.PROVIDER_SERVICE_VALUE >= ' + cast( @ProviderServiceValue as varchar(10) ) + ' ) ) '

   /* Sort the data by the service date. */
  set @SQL = @SQL +
  ' order by m.MEMBER_NAME, ' +
            'cs.COM_SERVICE_DATE desc, ' +
            'cs.COM_SERVICE_ID, ' +
            'SERVICE_UNIT_TYPE_NAME, ' +
            'SERVICE_UNIT_NAME, ' +
            'csuv.COM_SERVICE_UNIT_VALUE_ID '

   exec( @SQL )

    /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

      /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetComServiceSummaryByMemberUserId' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetComServiceSummaryByMemberUserId

   go

create procedure spGetComServiceSummaryByMemberUserId( @MemberUserId         integer,
                                                       @ProviderSystemId     integer,
                                                       @ProviderServiceValue integer,
                                                       @StartDate            datetime,
                                                       @EndDate              datetime ) as

   declare @SecurityGroupId      integer
   declare @SecurityGroupTypeId  integer
   declare @MemberId             integer

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */
   declare @ReturnCode   integer /* Result code returned by the execution of the stored procedure */

   /* Get the number of active transactions at the start of this procedure. */
      set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was executed... */
      if ( @Transactions = 00 ) begin

   /* Start the transaction. */
         begin transaction

      end

   select @SecurityGroupId     = jmusg.security_group_id,
          @SecurityGroupTypeId = sg.security_group_type_id,
          @MemberId             = m.member_id
          from member_user mu
          inner join member m on mu.member_id = m.member_id
          inner join join_member_user_security_group jmusg on jmusg.member_user_id = mu.member_user_id
          inner join security_group sg on sg.security_group_id = jmusg.security_group_id
          where mu.member_user_id = @MemberUserId

    /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   -- Customer

   if @SecurityGroupTypeId = 1 begin

      -- Customer SuperUser get data for all groups

      if @SecurityGroupId = 6 begin
         execute @ReturnCode = spGetComServiceSummaryByCustomerId @MemberId,
                                                                  @MemberUserId,
                                                                  @ProviderSystemId,
                                                                  @ProviderServiceValue,
                                                                  @StartDate,
                                                                  @EndDate
      end
      else begin
      -- Customer User get data only for groups assigned
         execute @ReturnCode = spGetComServiceSummaryByCustomerUserId @MemberId,
                                                                      @MemberUserId,
                                                                      @ProviderSystemId,
                                                                      @ProviderServiceValue,
                                                                      @StartDate,
                                                                      @EndDate

      end

   end
   else begin
      -- Provider User Admin or Backup Admin
      if @SecurityGroupId = 12 or @SecurityGroupId = 13 begin
         execute @ReturnCode = spGetComServiceSummaryByProviderId @MemberUserId,
                                                                  @ProviderSystemId,
                                                                  @ProviderServiceValue,
                                                                  @StartDate,
                                                                  @EndDate

      end
      else begin
      -- Provider User get data only for groups assigned
         execute @ReturnCode = spGetComServiceSummaryByProviderUserId @MemberUserId,
                                                                      @ProviderSystemId,
                                                                      @ProviderServiceValue,
                                                                      @StartDate,
                                                                      @EndDate

      end

   end

     /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

    /* If there were no active transactions when this stored procedure was executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetComServiceSummaryByProviderId' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetComServiceSummaryByProviderId

   go

create procedure spGetComServiceSummaryByProviderId( @MemberUserId         integer,
                                                     @ProviderSystemId     integer,
                                                     @ProviderServiceValue integer,
                                                     @StartDate            datetime,
                                                     @EndDate              datetime ) as

   declare @MemberUserEmail                varchar(50) /* Email address of the user */
   declare @MemberUserName                 varchar(51) /* Full name of the user */
   declare @ReplyToEmail                   varchar(50) /* Reply to address from the system or provider */
   declare @ReplyToName                    varchar(51) /* Reply to name from the provider */
   declare @SendEmailHTML                  integer         /* Temp holder for HTML option */
   declare @SecurityGroupTypeId            integer         /* Security Group type provider or customer */
   declare @SecurityGroupId                integer         /* Secuity Group of the member user */
   declare @ProviderId                     integer         /* Provider id */
   declare @ProviderName                   varchar(50) /* Provider Name used in email attachment */
   declare @ProviderServiceValueFilter     integer         /* Service Value used in report */
   declare @ProviderServiceValueTextFilter varchar(50) /* Service Value Text used in report */

   declare @SQL             varchar(6000)

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   set nocount on

   set @ReplyToEmail = ''
   set @ReplyToName  = ''
   set @SendEmailHTML = 0

   if @ProviderServiceValue is null
      set @ProviderServiceValueFilter = -1
   else
      set @ProviderServiceValueFilter = @ProviderServiceValue

    /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   if @ProviderServiceValue is null begin
      set @ProviderServiceValueFilter     = -1
      set @ProviderServiceValueTextFilter = ''
   end
   else
      set @ProviderServiceValueFilter = @ProviderServiceValue

      if @ProviderServiceValue > -1
      select @ProviderServiceValueTextFilter = ISNULL( psv.PROVIDER_SERVICE_VALUE_TEXT, tpsv.PROVIDER_SERVICE_VALUE_TEXT )
      from PROVIDER_SERVICE_VALUE psv
      left outer join TEMPLATE_PROVIDER_SERVICE_VALUE tpsv on ( psv.TEMPLATE_PROVIDER_SERVICE_VALUE_ID = tpsv.PROVIDER_SERVICE_VALUE_ID )
      where ( psv.PROVIDER_SERVICE_VALUE = @ProviderServiceValueFilter or tpsv.PROVIDER_SERVICE_VALUE = @ProviderServiceValueFilter )
      and psv.PROVIDER_SYSTEM_ID = @ProviderSystemId

        /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   select @ReplyToName = m.member_name,
          @ProviderName = m.member_name,
          @ProviderId  = ps.provider_id from member m
                         inner join provider_system ps on m.member_id = ps.provider_id and
                                                          ps.provider_system_id = @ProviderSystemId

       /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

      /* get the reply to email from the provider system */

   SELECT @ReplyToEmail = CONTACT_INFO
   FROM CONTACT a
   LEFT OUTER JOIN CONTACT_JOIN b ON a.CONTACT_ID = b.CONTACT_ID
   LEFT OUTER JOIN CONTACT_TYPE c ON a.contact_type_id = c.contact_type_id
   WHERE b.ENTITY_ID = @ProviderSystemId
   AND b.ENTITY_TYPE_ID = 6
   AND a.CONTACT_TYPE_ID = 12

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* if not from the provider system get from the provider */
   if @ReplyToEmail = '' begin

      SELECT @ReplyToEmail = CONTACT_INFO
      FROM CONTACT a
      LEFT OUTER JOIN CONTACT_JOIN b ON a.CONTACT_ID = b.CONTACT_ID
      LEFT OUTER JOIN CONTACT_TYPE c ON a.contact_type_id = c.contact_type_id
      WHERE b.ENTITY_ID = @ProviderId
      AND b.ENTITY_TYPE_ID = 3
      AND a.CONTACT_TYPE_ID = 12

       /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
      select @ErrorCode = @@Error

      /* If there was an error... */
      if ( @ErrorCode <> 00 ) begin

         /* Rollback the transaction. */
         rollback transaction

         /* Return the failure. */
         return 01

      end

   end

   select @MemberUserEmail     = mu.member_user_email,
          @MemberUserName      = mu.member_user_fname + ' ' + mu.member_user_lname,
          @SecurityGroupTypeId = sg.security_group_type_id,
          @SecurityGroupId     = jmusg.security_group_id
          from member_user mu
          inner join member m on mu.member_id = m.member_id
          inner join join_member_user_security_group jmusg on jmusg.member_user_id = mu.member_user_id
          inner join security_group sg on sg.security_group_id = jmusg.security_group_id
          where mu.member_user_id = @MemberUserId

      /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   set @MemberUserEmail = 'ddove@eyeonsolutions.com'

  /* Get the completed services between the start and end dates for the passed
      provider user and customer. */
    set @SQL = 'select distinct csuv.COM_SERVICE_UNIT_VALUE_ID, ' +
          'cs.COM_SERVICE_ID, ' +
          'cs.COM_SERVICE_DATE, ' +

          /* Name of the customer who was serviced. */
          'm.MEMBER_NAME as CUSTOMER_NAME, ' +
          /* Time stamp for the barcoding of the unit. */
          'csuv.TIMESTAMP, ' +

          'isnull( psv.PROVIDER_SERVICE_VALUE, tpsv.PROVIDER_SERVICE_VALUE ) as PROVIDER_SERVICE_VALUE, ' +
          'isnull( psv.PROVIDER_SERVICE_VALUE_TEXT, tpsv.PROVIDER_SERVICE_VALUE_TEXT ) as PROVIDER_SERVICE_VALUE_TEXT, ' +
          'isnull( pst.PROVIDER_SERVICE_TYPE_TEXT, tpst.PROVIDER_SERVICE_TYPE_TEXT ) as PROVIDER_SERVICE_TYPE_TEXT, ' +

          /* Identifying information for the property serviced. */
          'pu.CUSTOMER_UNIT_ID as PARENT_UNIT_ID, ' +
          'isnull( pcut.CUSTOMER_UNIT_TYPE_NAME, ptcut.CUSTOMER_UNIT_TYPE_NAME ) as PARENT_UNIT_TYPE_NAME, ' +
          'isnull( pu.CUSTOMER_UNIT_NAME, isnull( pcun.CUSTOMER_UNIT_NAME, ptcun.CUSTOMER_UNIT_NAME ) ) as PARENT_UNIT_NAME, ' +

          /* Identifying information for the child units serviced. */
          'su.CUSTOMER_UNIT_ID as SERVICE_UNIT_ID, ' +
          'isnull( scut.CUSTOMER_UNIT_TYPE_NAME, stcut.CUSTOMER_UNIT_TYPE_NAME ) as SERVICE_UNIT_TYPE_NAME, ' +
          'isnull( su.CUSTOMER_UNIT_NAME, isnull( scun.CUSTOMER_UNIT_NAME, stcun.CUSTOMER_UNIT_NAME ) ) as SERVICE_UNIT_NAME, ' +

          'isnull( ps.PROVIDER_SYSTEM_NAME, tps.PROVIDER_SYSTEM_NAME ) as PROVIDER_SYSTEM_NAME, ' +

          'START_DATE = ''' + convert(varchar(10), @StartDate, 01) + ''' , ' +
          'END_DATE   = ''' + convert(varchar(10), @EndDate, 01) + ''' , ' +
          'MEMBER_USER_NAME  = ''' + @MemberUserName + ''', ' +
          'USER_EMAIL        = ''' + @MemberUserEmail +''', ' +
          'REPLY_TO_EMAIL    = ''' + @ReplyToEmail +  ''', ' +
          'REPLY_TO_NAME     = ''' + @ReplyToName + ''', ' +
          'PROVIDER_ID       = '   + cast( @ProviderId  as varchar(10 ) ) + ', ' +
          'PROVIDER_NAME     = ''' + @Providername + ''', ' +
          'SECURITY_GROUP_TYPE_ID = ' + cast( @SecurityGroupTypeId as varchar(10))    + ', ' +
          'SECURITY_GROUP_ID   = ' + cast( @SecurityGroupId as varchar(10)) + ', ' +
          'PROVIDER_SERVICE_VALUE_FILTER = ' + cast( @ProviderServiceValueFilter as varchar(10 )) + ', ' +
          'PROVIDER_SERVICE_VALUE_TEXT_FILTER = ''' +  @ProviderServiceValueTextFilter + ''', ' +
          'EMAIL_SEND_HTML   = ' + cast( @SendEmailHTML as varchar(1) ) + ' ' +

   'from COM_SERVICE cs ' +

   /* Joins to retrieve the service type and the service program name. */
   'inner join      PROVIDER_SERVICE_TYPE pst           on ( cs.PROVIDER_SERVICE_TYPE_ID           = pst.PROVIDER_SERVICE_TYPE_ID  ) ' +
   'left outer join TEMPLATE_PROVIDER_SERVICE_TYPE tpst on ( pst.TEMPLATE_PROVIDER_SERVICE_TYPE_ID = tpst.PROVIDER_SERVICE_TYPE_ID ) ' +
   'inner join      PROVIDER_SYSTEM ps                  on ( pst.PROVIDER_SYSTEM_ID                = ps.PROVIDER_SYSTEM_ID         ) and ' +
                                                          '( ps.PROVIDER_SYSTEM_ID                 = ' + cast( @ProviderSystemId as varchar(10)) + ' ) ' +
   'left outer join TEMPLATE_PROVIDER_SYSTEM tps        on ( ps.TEMPLATE_PROVIDER_SYSTEM_ID        = tps.PROVIDER_SYSTEM_ID        ) ' +

   /* Joins to retrieve the ranking data for the child units.  */
   'left outer join COM_SERVICE_UNIT_VALUE csuv          on ( cs.COM_SERVICE_ID                      = csuv.COM_SERVICE_ID            ) ' +
   'left outer join PROVIDER_SERVICE_VALUE psv           on ( csuv.PROVIDER_SERVICE_VALUE_ID         = psv.PROVIDER_SERVICE_VALUE_ID  ) ' +
   'left outer join TEMPLATE_PROVIDER_SERVICE_VALUE tpsv on ( psv.TEMPLATE_PROVIDER_SERVICE_VALUE_ID = tpsv.PROVIDER_SERVICE_VALUE_ID ) ' +

   /* Joins to retrieve the parent units (properties) for the service. */
   'inner join      CUSTOMER_UNIT pu                            on ( cs.CUSTOMER_UNIT_ID                          = pu.CUSTOMER_UNIT_ID         ) and ' +
                                                                  '( pu.unit_parent_id                            = -1                          ) ' +
   'inner join      JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT pjcut on ( pu.CUSTOMER_UNIT_ID                          = pjcut.CUSTOMER_UNIT_ID      ) ' +
   'left outer join CUSTOMER_UNIT_NAME pcun                     on ( pjcut.CUSTOMER_UNIT_NAME_ID                  = pcun.CUSTOMER_UNIT_NAME_ID  ) ' +
   'left outer join TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME ptcun  on ( pcun.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME_ID = ptcun.CUSTOMER_UNIT_NAME_ID ) ' +
   'inner join      CUSTOMER_UNIT_TYPE pcut                     on ( pjcut.CUSTOMER_UNIT_TYPE_ID                  = pcut.CUSTOMER_UNIT_TYPE_ID  ) and ' +
                                                                  '( pcut.PROVIDER_SYSTEM_ID                      = ' + cast(@ProviderSystemId as varchar(10)) + ' ) ' +
   'left outer join TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE ptcut  on ( pcut.TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE_ID = ptcut.CUSTOMER_UNIT_TYPE_ID ) ' +

   /* Join to retrieve the name of the customer who owns the property.*/
   'inner join MEMBER m on ( pu.CUSTOMER_ID = m.MEMBER_ID )  ' +

   /* Joins to retrieve the child units for the service. */
   'left outer join CUSTOMER_UNIT su                            on ( csuv.CUSTOMER_UNIT_ID                        = su.CUSTOMER_UNIT_ID     
    ) ' +
   'left outer join JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT sjcut on ( su.CUSTOMER_UNIT_ID                          = sjcut.CUSTOMER_UNIT_ID      ) ' +
   'left outer join CUSTOMER_UNIT_NAME scun                     on ( sjcut.CUSTOMER_UNIT_NAME_ID                  = scun.CUSTOMER_UNIT_NAME_ID  ) ' +
   'left outer join TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME stcun  on ( scun.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME_ID = stcun.CUSTOMER_UNIT_NAME_ID ) ' +
   'left outer join CUSTOMER_UNIT_TYPE scut                     on ( sjcut.CUSTOMER_UNIT_TYPE_ID                  = scut.CUSTOMER_UNIT_TYPE_ID  ) and ' +
                                                                  '( pcut.PROVIDER_SYSTEM_ID                      = ' + cast(@ProviderSystemId as varchar(10)) + ' ) ' +
   'left outer join TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE stcut  on ( scut.TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE_ID = stcut.CUSTOMER_UNIT_TYPE_ID ) ' +

   /* Only include data for the passed provider. */
   'where ( ps.provider_system_id       = ' + cast( @ProviderSystemId as varchar(10)) + '  ) and  ' +
         '( cs.PROVIDER_INPUT_DATE >= ''' + convert(varchar(10), @StartDate, 01 ) + ''' ) and ' +
         '( cs.PROVIDER_INPUT_DATE <= ''' + convert(varchar(10), @EndDate, 01)   + ''' ) '

     if @ProviderServiceValue is not null
      set @SQL = @SQL +
                'and ( ( psv.PROVIDER_SERVICE_VALUE  >= ' + cast( @ProviderServiceValue as varchar(10) ) + ') or ' +
                '( tpsv.PROVIDER_SERVICE_VALUE >= ' + cast( @ProviderServiceValue as varchar(10) ) + ' ) ) '

   set @SQL = @SQL +

   /* Sort the data by the service date. */
   'order by m.MEMBER_NAME, ' +
            'PARENT_UNIT_NAME, ' +
            'SERVICE_UNIT_TYPE_NAME,  ' +
            'SERVICE_UNIT_NAME,  ' +
            'SERVICE_UNIT_ID, ' +
            'cs.COM_SERVICE_DATE desc,  ' +
            'cs.COM_SERVICE_ID,  ' +
            'csuv.COM_SERVICE_UNIT_VALUE_ID  '

  exec( @SQL )

     /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

      /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetComServiceSummaryByProviderUserId' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetComServiceSummaryByProviderUserId

   go

create procedure spGetComServiceSummaryByProviderUserId( @MemberUserId         integer,
                                                         @ProviderSystemId     integer,
                                                         @ProviderServiceValue integer,
                                                         @StartDate            datetime,
                                                         @EndDate              datetime ) as

   declare @MemberUserEmail                varchar(50) /* Email address of the user */
   declare @MemberUserName                 varchar(51) /* Full name of the user */
   declare @ReplyToEmail                   varchar(50) /* Reply to address from the system or provider */
   declare @ReplyToName                    varchar(51) /* Reply to name from the provider */
   declare @SendEmailHTML                  integer         /* Temp holder for HTML option */
   declare @SecurityGroupTypeId            integer         /* Security Group type provider or customer */
   declare @SecurityGroupId                integer         /* Secuity Group of the member user */
   declare @ProviderId                     integer         /* Provider id */
   declare @ProviderName                   varchar(50) /* Provider Name used in email attachment */
   declare @ProviderServiceValueFilter     integer         /* Service Value used in report */
   declare @ProviderServiceValueTextFilter varchar(50) /* Service Value Text used in report */

   declare @SQL             varchar(6000)

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   set nocount on

   set @ReplyToEmail = ''
   set @ReplyToName  = ''
   set @SendEmailHTML = 0

    if @ProviderServiceValue is null begin
      set @ProviderServiceValueFilter     = -1
      set @ProviderServiceValueTextFilter = ''
   end
   else
      set @ProviderServiceValueFilter = @ProviderServiceValue

    /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   if @ProviderServiceValue > -1
      select @ProviderServiceValueTextFilter = ISNULL( psv.PROVIDER_SERVICE_VALUE_TEXT, tpsv.PROVIDER_SERVICE_VALUE_TEXT )
      from PROVIDER_SERVICE_VALUE psv
      left outer join TEMPLATE_PROVIDER_SERVICE_VALUE tpsv on ( psv.TEMPLATE_PROVIDER_SERVICE_VALUE_ID = tpsv.PROVIDER_SERVICE_VALUE_ID )
      where ( psv.PROVIDER_SERVICE_VALUE = @ProviderServiceValueFilter or tpsv.PROVIDER_SERVICE_VALUE = @ProviderServiceValueFilter )
      and psv.PROVIDER_SYSTEM_ID = @ProviderSystemId

        /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   select @ReplyToName = m.member_name,
          @ProviderName = m.member_name,
          @ProviderId  = ps.provider_id from member m
                         inner join provider_system ps on m.member_id = ps.provider_id and
                                                          ps.provider_system_id = @ProviderSystemId

       /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

      /* get the reply to email from the provider system */

   SELECT @ReplyToEmail = CONTACT_INFO
   FROM CONTACT a
   LEFT OUTER JOIN CONTACT_JOIN b ON a.CONTACT_ID = b.CONTACT_ID
   LEFT OUTER JOIN CONTACT_TYPE c ON a.contact_type_id = c.contact_type_id
   WHERE b.ENTITY_ID = @ProviderSystemId
   AND b.ENTITY_TYPE_ID = 6
   AND a.CONTACT_TYPE_ID = 12

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* if not from the provider system get from the provider */
   if @ReplyToEmail = '' begin

      SELECT @ReplyToEmail = CONTACT_INFO
      FROM CONTACT a
      LEFT OUTER JOIN CONTACT_JOIN b ON a.CONTACT_ID = b.CONTACT_ID
      LEFT OUTER JOIN CONTACT_TYPE c ON a.contact_type_id = c.contact_type_id
      WHERE b.ENTITY_ID = @ProviderId
      AND b.ENTITY_TYPE_ID = 3
      AND a.CONTACT_TYPE_ID = 12

       /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
      select @ErrorCode = @@Error

      /* If there was an error... */
      if ( @ErrorCode <> 00 ) begin

         /* Rollback the transaction. */
         rollback transaction

         /* Return the failure. */
         return 01

      end

   end

   select @MemberUserEmail     = mu.member_user_email,
          @MemberUserName      = mu.member_user_fname + ' ' + mu.member_user_lname,
          @SecurityGroupTypeId = sg.security_group_type_id,
          @SecurityGroupId     = jmusg.security_group_id
          from member_user mu
          inner join member m on mu.member_id = m.member_id
          inner join join_member_user_security_group jmusg on jmusg.member_user_id = mu.member_user_id
          inner join security_group sg on sg.security_group_id = jmusg.security_group_id

          where mu.member_user_id = @MemberUserId

      /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   set @MemberUserEmail = 'ddove@eyeonsolutions.com'

  /* Get the completed services between the start and end dates for the passed
      provider user and customer. */
    set @SQL = 'select distinct csuv.COM_SERVICE_UNIT_VALUE_ID, ' +
          'cs.COM_SERVICE_ID, ' +
          'cs.COM_SERVICE_DATE, ' +

          /* Name of the customer who was serviced. */
          'm.MEMBER_NAME as CUSTOMER_NAME, ' +
          /* Time stamp for the barcoding of the unit. */
          'csuv.TIMESTAMP, ' +

          'isnull( psv.PROVIDER_SERVICE_VALUE, tpsv.PROVIDER_SERVICE_VALUE ) as PROVIDER_SERVICE_VALUE, ' +
          'isnull( psv.PROVIDER_SERVICE_VALUE_TEXT, tpsv.PROVIDER_SERVICE_VALUE_TEXT ) as PROVIDER_SERVICE_VALUE_TEXT, ' +
          'isnull( pst.PROVIDER_SERVICE_TYPE_TEXT, tpst.PROVIDER_SERVICE_TYPE_TEXT ) as PROVIDER_SERVICE_TYPE_TEXT, ' +

          /* Identifying information for the property serviced. */
          'pu.CUSTOMER_UNIT_ID as PARENT_UNIT_ID, ' +
          'isnull( pcut.CUSTOMER_UNIT_TYPE_NAME, ptcut.CUSTOMER_UNIT_TYPE_NAME ) as PARENT_UNIT_TYPE_NAME, ' +
          'isnull( pu.CUSTOMER_UNIT_NAME, isnull( pcun.CUSTOMER_UNIT_NAME, ptcun.CUSTOMER_UNIT_NAME ) ) as PARENT_UNIT_NAME, ' +

          /* Identifying information for the child units serviced. */
          'su.CUSTOMER_UNIT_ID as SERVICE_UNIT_ID, ' +
          'isnull( scut.CUSTOMER_UNIT_TYPE_NAME, stcut.CUSTOMER_UNIT_TYPE_NAME ) as SERVICE_UNIT_TYPE_NAME, ' +
          'isnull( su.CUSTOMER_UNIT_NAME, isnull( scun.CUSTOMER_UNIT_NAME, stcun.CUSTOMER_UNIT_NAME ) ) as SERVICE_UNIT_NAME, ' +

          'isnull( ps.PROVIDER_SYSTEM_NAME, tps.PROVIDER_SYSTEM_NAME ) as PROVIDER_SYSTEM_NAME, ' +

          'START_DATE = ''' + convert(varchar(10), @StartDate, 01) + ''' , ' +
          'END_DATE   = ''' + convert(varchar(10), @EndDate, 01) + ''' , ' +
          'MEMBER_USER_NAME  = ''' + @MemberUserName + ''', ' +
          'USER_EMAIL        = ''' + @MemberUserEmail +''', ' +
          'REPLY_TO_EMAIL    = ''' + @ReplyToEmail +  ''', ' +
          'REPLY_TO_NAME     = ''' + @ReplyToName + ''', ' +
          'PROVIDER_ID       = '   + cast( @ProviderId  as varchar(10 ) ) + ', ' +
          'PROVIDER_NAME     = ''' + @Providername + ''', ' +
          'SECURITY_GROUP_TYPE_ID      = ' + cast( @SecurityGroupId as varchar(10))    + ', ' +
          'SECURITY_GROUP_ID   = ' + cast( @SecurityGroupId as varchar(10)) + ', ' +
          'PROVIDER_SERVICE_VALUE_FILTER = ' + cast( @ProviderServiceValueFilter as varchar(10 )) + ', ' +
            'PROVIDER_SERVICE_VALUE_TEXT_FILTER = ''' +  @ProviderServiceValueTextFilter + ''', ' +
          'EMAIL_SEND_HTML   = ' + cast( @SendEmailHTML as varchar(1) ) + ' ' +

   'from COM_SERVICE cs ' +

   /* Joins to retrieve the service type and the service program name. */
   'inner join      PROVIDER_SERVICE_TYPE pst           on ( cs.PROVIDER_SERVICE_TYPE_ID           = pst.PROVIDER_SERVICE_TYPE_ID  ) ' +
   'left outer join TEMPLATE_PROVIDER_SERVICE_TYPE tpst on ( pst.TEMPLATE_PROVIDER_SERVICE_TYPE_ID = tpst.PROVIDER_SERVICE_TYPE_ID ) ' +
   'inner join      PROVIDER_SYSTEM ps                  on ( pst.PROVIDER_SYSTEM_ID                = ps.PROVIDER_SYSTEM_ID         ) and ' +
                                                          '( ps.PROVIDER_SYSTEM_ID                 = ' + cast( @ProviderSystemId as varchar(10)) + ' )  ' +
   'left outer join TEMPLATE_PROVIDER_SYSTEM tps        on ( ps.TEMPLATE_PROVIDER_SYSTEM_ID        = tps.PROVIDER_SYSTEM_ID        ) ' +

   /* Joins to retrieve the ranking data for the child units. */
   'left outer join COM_SERVICE_UNIT_VALUE csuv          on ( cs.COM_SERVICE_ID                      = csuv.COM_SERVICE_ID            ) ' +
   'left outer join PROVIDER_SERVICE_VALUE psv           on ( csuv.PROVIDER_SERVICE_VALUE_ID         = psv.PROVIDER_SERVICE_VALUE_ID  ) ' +
   'left outer join TEMPLATE_PROVIDER_SERVICE_VALUE tpsv on ( psv.TEMPLATE_PROVIDER_SERVICE_VALUE_ID = tpsv.PROVIDER_SERVICE_VALUE_ID ) ' +

   /* Joins to retrieve the parent units (properties) for the service. */
   'inner join      CUSTOMER_UNIT pu                            on ( cs.CUSTOMER_UNIT_ID                          = pu.CUSTOMER_UNIT_ID         ) and ' +
                                                                  '( pu.unit_parent_id                            = -1                          ) ' +
   'inner join      JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT pjcut on ( pu.CUSTOMER_UNIT_ID                          = pjcut.CUSTOMER_UNIT_ID      ) ' +
   'left outer join CUSTOMER_UNIT_NAME pcun                     on ( pjcut.CUSTOMER_UNIT_NAME_ID                  = pcun.CUSTOMER_UNIT_NAME_ID  ) ' +
   'left outer join TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME ptcun  on ( pcun.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME_ID = ptcun.CUSTOMER_UNIT_NAME_ID ) ' +
   'inner join      CUSTOMER_UNIT_TYPE pcut                     on ( pjcut.CUSTOMER_UNIT_TYPE_ID                  = pcut.CUSTOMER_UNIT_TYPE_ID  ) and ' +
                                                                  '( pcut.PROVIDER_SYSTEM_ID                      = ' + cast(@ProviderSystemId as varchar(10)) + ' ) ' +
   'left outer join TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE ptcut  on ( pcut.TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE_ID = ptcut.CUSTOMER_UNIT_TYPE_ID ) ' +

   /* Join to retrieve the name of the customer who owns the property. */
   'inner join MEMBER m on ( pu.CUSTOMER_ID = m.MEMBER_ID )  ' +

   /* Joins to retrieve the child units for the service. */
   'left outer join CUSTOMER_UNIT su                            on ( csuv.CUSTOMER_UNIT_ID                        = su.CUSTOMER_UNIT_ID         ) ' +
   'left outer join JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT sjcut on ( su.CUSTOMER_UNIT_ID                          = sjcut.CUSTOMER_UNIT_ID      ) ' +
   'left outer join CUSTOMER_UNIT_NAME scun                     on ( sjcut.CUSTOMER_UNIT_NAME_ID                  = scun.CUSTOMER_UNIT_NAME_ID  ) ' +
   'left outer join TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME stcun  on ( scun.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME_ID = stcun.CUSTOMER_UNIT_NAME_ID ) ' +
   'left outer join CUSTOMER_UNIT_TYPE scut                     on ( sjcut.CUSTOMER_UNIT_TYPE_ID                  = scut.CUSTOMER_UNIT_TYPE_ID  ) and ' +
                                                                  '( pcut.PROVIDER_SYSTEM_ID                      = ' + cast(@ProviderSystemId as varchar(10)) + ' ) ' +
   'left outer join TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE stcut  on ( scut.TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE_ID = stcut.CUSTOMER_UNIT_TYPE_ID ) ' +

    'inner join JOIN_MEMBER_GROUP_CUSTOMER_UNIT pjmgcu      on  ( cs.CUSTOMER_UNIT_ID   = pjmgcu.CUSTOMER_UNIT_ID ) ' +
    'inner join JOIN_MEMBER_GROUP_USER pjmgu                on ( pjmgu.MEMBER_USER_ID = ' + cast( @MemberUserId as varchar(10)) + ' ) and ' +
                                                              '( pjmgcu.MEMBER_GROUP_ID = pjmgu.MEMBER_GROUP_ID ) ' +

   /* Only include data for the passed customer between the specified dates. */
   'where ( ps.provider_system_id       = ' + cast( @ProviderSystemId as varchar(10)) + '  ) and  ' +
         '( cs.PROVIDER_INPUT_DATE >= ''' + convert(varchar(10), @StartDate, 01 ) + ''' ) and ' +
         '( cs.PROVIDER_INPUT_DATE <= ''' + convert(varchar(10), @EndDate, 01)   + ''' ) '

   if @ProviderServiceValue is not null
      set @SQL = @SQL +
                'and ( ( psv.PROVIDER_SERVICE_VALUE  >= ' + cast( @ProviderServiceValue as varchar(10) ) + ') or ' +
                '( tpsv.PROVIDER_SERVICE_VALUE >= ' + cast( @ProviderServiceValue as varchar(10) ) + ' ) ) '

   set @SQL = @SQL +

   /* Sort the data by the service date. */
   'order by m.MEMBER_NAME, ' +
            'cs.COM_SERVICE_DATE desc,  ' +
            'cs.COM_SERVICE_ID,  ' +
            'SERVICE_UNIT_TYPE_NAME,  ' +
            'SERVICE_UNIT_NAME,  ' +
            'csuv.COM_SERVICE_UNIT_VALUE_ID  '

   exec( @SQL )

     /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

      /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetComServiceUnitValuesByComService' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetComServiceUnitValuesByComService

   go

create procedure spGetComServiceUnitValuesByComService( @ComServiceId integer ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Get the completed service details for the current completed service. */
   select csuv.COM_SERVICE_UNIT_VALUE_ID,
          csuv.PROVIDER_SERVICE_VALUE_ID,
          IsNull( psv.PROVIDER_SERVICE_VALUE, tpsv.PROVIDER_SERVICE_VALUE ) as PROVIDER_SERVICE_VALUE,
          IsNull( psv.PROVIDER_SERVICE_VALUE_TEXT, tpsv.PROVIDER_SERVICE_VALUE_TEXT ) as PROVIDER_SERVICE_VALUE_TEXT,
          csuv.CUSTOMER_UNIT_ID,
          isnull( cu.CUSTOMER_UNIT_NAME, isnull( cun.CUSTOMER_UNIT_NAME, tpcun.CUSTOMER_UNIT_NAME ) ) as CUSTOMER_UNIT_NAME,
          csuv.TIMESTAMP
   from COM_SERVICE_UNIT_VALUE csuv
   left outer join PROVIDER_SERVICE_VALUE psv                   on csuv.PROVIDER_SERVICE_VALUE_ID              = psv.PROVIDER_SERVICE_VALUE_ID
   left outer join TEMPLATE_PROVIDER_SERVICE_VALUE tpsv         on psv.TEMPLATE_PROVIDER_SERVICE_VALUE_ID      = tpsv.PROVIDER_SERVICE_VALUE_ID
   inner join      CUSTOMER_UNIT cu                             on csuv.CUSTOMER_UNIT_ID                       = cu.CUSTOMER_UNIT_ID
   inner join      JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT jcutcu on cu.CUSTOMER_UNIT_ID                         = jcutcu.CUSTOMER_UNIT_ID
   left outer join CUSTOMER_UNIT_NAME cun                       on jcutcu.CUSTOMER_UNIT_NAME_ID                = cun.CUSTOMER_UNIT_NAME_ID
   left outer join TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME tpcun   on cun.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME_ID = tpcun.CUSTOMER_UNIT_NAME_ID
   inner join      COM_SERVICE cs                               on csuv.COM_SERVICE_ID                         = cs.COM_SERVICE_ID
   inner join      PROVIDER_SERVICE_TYPE pst                    on cs.PROVIDER_SERVICE_TYPE_ID                 = pst.PROVIDER_SERVICE_TYPE_ID
   inner join      CUSTOMER_UNIT_TYPE cut                       on jcutcu.CUSTOMER_UNIT_TYPE_ID                = cut.CUSTOMER_UNIT_TYPE_ID and
                                                                   cut.PROVIDER_SYSTEM_ID                      = pst.PROVIDER_SYSTEM_ID
   where csuv.COM_SERVICE_ID = @ComServiceId

   /* If there was an error... */
   if ( @@Error <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetComServiceUnitValuesByCustomerUnit' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetComServiceUnitValuesByCustomerUnit

   go

create procedure spGetComServiceUnitValuesByCustomerUnit( @ProviderSystemId integer,
                                                          @CustomerUnitId   integer ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   SELECT i.com_service_id,
	  isnull( f.PROVIDER_SERVICE_VALUE, g.PROVIDER_SERVICE_VALUE ) as PROVIDER_SERVICE_VALUE,
	  isnull( f.PROVIDER_SERVICE_VALUE_TEXT, g.PROVIDER_SERVICE_VALUE_TEXT ) as PROVIDER_SERVICE_VALUE_TEXT,
	  isnull( h.CUSTOMER_UNIT_TYPE_NAME, j.CUSTOMER_UNIT_TYPE_NAME ) as CUSTOMER_UNIT_TYPE_NAME,
	  isnull( b.CUSTOMER_UNIT_NAME, isnull( d.CUSTOMER_UNIT_NAME, e.CUSTOMER_UNIT_NAME ) as CUSTOMER_UNIT_NAME,
	  i.com_service_date,
	  TIMESTAMP
   FROM COM_SERVICE_UNIT_VALUE a
   LEFT OUTER JOIN PROVIDER_SERVICE_VALUE f ON a.provider_service_value_id = f.provider_service_value_id
   LEFT OUTER JOIN TEMPLATE_PROVIDER_SERVICE_VALUE g ON f.template_provider_service_value_id = g.provider_service_value_id
   LEFT OUTER JOIN CUSTOMER_UNIT b ON a.customer_unit_id = b.customer_unit_id
   LEFT OUTER JOIN JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT c ON b.customer_unit_id = c.customer_unit_id
   LEFT OUTER JOIN CUSTOMER_UNIT_NAME d ON c.customer_unit_name_id = d.customer_unit_name_id
   LEFT OUTER JOIN TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME e ON d.template_provider_customer_unit_name_id = e.customer_unit_name_id
   LEFT OUTER JOIN CUSTOMER_UNIT_TYPE h ON c.customer_unit_type_id = h.customer_unit_type_id
   LEFT OUTER JOIN TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE j ON h.template_provider_customer_unit_type_id = j.customer_unit_type_id
   LEFT OUTER JOIN COM_SERVICE i on a.com_service_id = i.com_service_id
   WHERE a.CUSTOMER_UNIT_ID = @customerunitid
   and h.provider_system_id = @providersystemid
   order by com_service_date desc, i.com_service_id, timestamp

 /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetComServiceUnitValuesBySystemUnit' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetComServiceUnitValuesBySystemUnit

   go

create procedure spGetComServiceUnitValuesBySystemUnit( @ProviderSystemId integer,
                                                        @CustomerUnitId   integer ) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */
   -- new stored procedure
   execute @ReturnCode = spGetComServiceUnitValuesByCustomerUnit @ProviderSystemId,
                                                                 @CustomerUnitId

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetComServiceUnitValuesBySystemUserDateRange' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetComServiceUnitValuesBySystemUserDateRange

   go

create procedure spGetComServiceUnitValuesBySystemUserDateRange ( @ProviderSystemId integer,
                                                                  @MemberUserId     integer,
                                                                  @StartDate        datetime,
                                                                  @EndDate          datetime ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   declare @SecurityGroupId integer
   select @SecurityGroupId = security_group_id from join_member_user_security_group where member_user_id = @MemberUserId

   if ( @SecurityGroupId = 6 ) begin

   declare @CustomerId integer
   select @CustomerId = member_id from member_user where member_user_id = @MemberUserId

      SELECT distinct
          csuv.com_service_unit_value_id,
          csuv.provider_service_value_id,
          isnull( psv.provider_service_value, tpsv.provider_service_value ) as provider_service_value,
          isnull( psv.provider_service_value_text, tpsv.provider_service_value_text ) as provider_service_value_text,
          cs.com_service_id,
          cu.customer_id,
          csuv.customer_unit_id,
          isnull( su.customer_unit_name, isnull( cun.customer_unit_name, tpcun.customer_unit_name ) ) as customer_unit_name,
          csuv.timestamp

      from com_service cs
      inner join customer_unit cu on ( cs.customer_unit_id = cu.customer_unit_id ) and ( cu.unit_parent_id = -1 ) and
                                     ( cu.customer_id = @CustomerId )
      inner join join_customer_unit_type_customer_unit jcutcu on ( cu.customer_unit_id = jcutcu.customer_unit_id )
      inner join customer_unit_type cut on ( jcutcu.customer_unit_type_id = cut.customer_unit_type_id ) and
                                           ( cut.provider_system_id = @ProviderSystemId )
      inner join com_service_unit_value csuv on ( cs.com_service_id = csuv.com_service_id )
      inner join customer_unit su on ( csuv.customer_unit_id = su.customer_unit_id )
      inner join join_customer_unit_type_customer_unit jcutsu on ( su.customer_unit_id = jcutsu.customer_unit_id )
      left outer join customer_unit_name cun on ( jcutsu.customer_unit_name_id = cun.customer_unit_name_id )
      left outer join template_provider_customer_unit_name tpcun on ( cun.template_provider_customer_unit_name_id = tpcun.customer_unit_name_id )
      inner join provider_service_value psv on ( csuv.provider_service_value_id = psv.provider_service_value_id ) and
                                               ( cut.provider_system_id = psv.provider_system_id )
      left outer join template_provider_service_value tpsv on ( psv.template_provider_service_value_id = tpsv.provider_service_value_id )

      where ( cs.com_service_date >= @StartDate )
        and ( cs.com_service_date <= @EndDate )
        and ( cs.review_date is not null )

   end

   else begin

      SELECT distinct
          csuv.com_service_unit_value_id,
          csuv.provider_service_value_id,
          isnull( psv.provider_service_value, tpsv.provider_service_value ) as provider_service_value,
          isnull( psv.provider_service_value_text, tpsv.provider_service_value_text ) as provider_service_value_text,
          cs.com_service_id,
          cu.customer_id,
          csuv.customer_unit_id,
          isnull( su.customer_unit_name, isnull( cun.customer_unit_name, tpcun.customer_unit_name ) ) as customer_unit_name,
          csuv.timestamp

      from com_service cs
      inner join customer_unit cu on ( cs.customer_unit_id = cu.customer_unit_id ) and ( cu.unit_parent_id = -1 )
      inner join join_customer_unit_type_customer_unit jcutcu on ( cu.customer_unit_id = jcutcu.customer_unit_id )
      inner join customer_unit_type cut on ( jcutcu.customer_unit_type_id = cut.customer_unit_type_id ) and
                                           ( cut.provider_system_id = @ProviderSystemId )
      inner join com_service_unit_value csuv on ( cs.com_service_id = csuv.com_service_id )
      inner join customer_unit su on ( csuv.customer_unit_id = su.customer_unit_id )
      inner join join_customer_unit_type_customer_unit jcutsu on ( su.customer_unit_id = jcutsu.customer_unit_id )
      left outer join customer_unit_name cun on ( jcutsu.customer_unit_name_id = cun.customer_unit_name_id )
      left outer join template_provider_customer_unit_name tpcun on ( cun.template_provider_customer_unit_name_id = tpcun.customer_unit_name_id )
      inner join provider_service_value psv on ( csuv.provider_service_value_id = psv.provider_service_value_id ) and
                                               ( cut.provider_system_id = psv.provider_system_id )
      left outer join template_provider_service_value tpsv on ( psv.template_provider_service_value_id = tpsv.provider_service_value_id )
      inner join join_member_group_customer_unit jmgcu on ( cu.customer_unit_id = jmgcu.customer_unit_id )
      inner join join_member_group_user jmgu on ( jmgcu.member_group_id = jmgu.member_group_id ) and
                                                ( jmgu.member_user_id = @MemberUserId )

      where ( cs.com_service_date >= @StartDate )
        and ( cs.com_service_date <= @EndDate )
        and ( cs.review_date is not null )

   end

   /* If there was an error... */
   if ( @@Error <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetComServiceValuesByCustomerUnitType' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetComServiceValuesByCustomerUnitType

   go

create procedure spGetComServiceValuesByCustomerUnitType( @parentunitid       integer,
                                                          @customerunittypeid integer,
                                                          @startdate          datetime,
                                                          @enddate            datetime ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   select
   ISNULL(d.customer_unit_type_name, e.customer_unit_type_name) as CUSTOMER_UNIT_TYPE,
   CAST( DATENAME(m, b.com_service_date) as varchar ) as SERVICE_MONTH,
   CAST( DATENAME(yyyy, b.com_service_date) as varchar ) as SERVICE_YEAR,
   ISNULL(SUM(ISNULL(f.provider_service_value, g.provider_service_value)), 0) as PROVIDER_SERVICE_VALUE
   from com_service_unit_value a
   left outer join com_service b on a.com_service_id = b.com_service_id
   left outer join customer_unit h on a.customer_unit_id = h.customer_unit_id
   left outer join join_customer_unit_type_customer_unit c on h.customer_unit_id = c.customer_unit_id
   left outer join customer_unit_type d on c.customer_unit_type_id = d.customer_unit_type_id
   left outer join template_provider_customer_unit_type e on d.template_provider_customer_unit_type_id = e.customer_unit_type_id
   left outer join provider_service_value f on a.provider_service_value_id = f.provider_service_value_id
   left outer join template_provider_service_value g on f.template_provider_service_value_id = g.provider_service_value_id
   where b.customer_unit_id = @parentunitid
   and c.customer_unit_type_id = @customerunittypeid
   and (com_service_date >= @startdate and com_service_date <= @enddate)
   group by h.CUSTOMER_ID, c.customer_unit_type_id, ISNULL(d.customer_unit_type_name, e.customer_unit_type_name), DATEPART(m,b.com_service_date), CAST( DATENAME(m, b.com_service_date) as varchar ), CAST( DATENAME(yyyy, b.com_service_date) as varchar )
   order by customer_id, c.customer_unit_type_id, service_year, DATEPART(m,b.com_service_date)

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetContactInfoByCustomer' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetContactInfoByCustomer

   go

create procedure spGetContactInfoByCustomer( @CustomerId integer ) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   -- new procedure
   execute @ReturnCode = spGetContactInfoForEntity @CustomerId, 4

    /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetContactInfoByCustomerUnit' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetContactInfoByCustomerUnit

   go

create procedure spGetContactInfoByCustomerUnit( @CustomerUnitId integer ) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */
    -- new stored procedure
   execute @ReturnCode = spGetContactInfoForEntity @CustomerUnitId,
                                                   5

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetContactInfoByCustomerUser' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetContactInfoByCustomerUser

   go

create procedure spGetContactInfoByCustomerUser( @CustomerUserId integer ) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */
   -- new stored procedure
   execute @ReturnCode = spGetContactInfoForEntity @CustomerUserId,
                                                   2

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetContactInfoByProvider' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetContactInfoByProvider

   go

create procedure spGetContactInfoByProvider( @ProviderId integer ) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   --new procedure
   execute @ReturnCode = spGetContactInfoForEntity @ProviderId, 3

    /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetContactInfoByProviderUser' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetContactInfoByProviderUser

   go

create procedure spGetContactInfoByProviderUser( @ProviderUserId integer) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   -- new procedure
   execute @ReturnCode = spGetContactInfoForEntity @ProviderUserId, 1

    /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetContactInfoForEntity' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetContactInfoForEntity

   go

create procedure spGetContactInfoForEntity( @entityid     integer,
                                            @entitytypeid integer ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   SELECT a.CONTACT_ID,
	  a.CONTACT_TYPE_ID,
	  c.CONTACT_TYPE_NAME,
	  CONTACT_INFO
   FROM CONTACT a
   LEFT OUTER JOIN CONTACT_JOIN b ON a.CONTACT_ID = b.CONTACT_ID
   LEFT OUTER JOIN CONTACT_TYPE c ON a.contact_type_id = c.contact_type_id
   WHERE b.ENTITY_ID = @entityid
   AND b.ENTITY_TYPE_ID = @entitytypeid

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 )  begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetContactInfoForEntityByType' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetContactInfoForEntityByType

   go

create procedure spGetContactInfoForEntityByType( @entityid      integer,
                                                  @entitytypeid  integer,
                                                  @contacttypeid integer ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   SELECT a.CONTACT_ID,
          a.CONTACT_TYPE_ID,
	  CONTACT_INFO
   FROM CONTACT a
   LEFT JOIN CONTACT_JOIN b ON a.CONTACT_ID = b.CONTACT_ID
   LEFT JOIN CONTACT_TYPE c ON a.contact_type_id = c.contact_type_id
   WHERE b.ENTITY_ID = @entityid
   AND b.ENTITY_TYPE_ID = @entitytypeid
   AND c.CONTACT_TYPE_ID = @contacttypeid

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetCustomerAgreement' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetCustomerAgreement

   go

create procedure spGetCustomerAgreement as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   -- new stored proc
   execute @ReturnCode = spGetAgreementById 2

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetCustomerContactInfo' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetCustomerContactInfo

   go

create procedure spGetCustomerContactInfo( @CustomerContactId integer ) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */
   -- new stored procedure
   execute @ReturnCode = spGetContactInfoForEntity @CustomerContactId,
                                                   4

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetCustomerGroupsByGroupTypeUser' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetCustomerGroupsByGroupTypeUser

   go

create procedure spGetCustomerGroupsByGroupTypeUser( @MemberGroupTypeId integer,
                                                     @MemberUserId      integer ) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   -- new procedure
   execute @ReturnCode = spGetMemberGroupsByGroupTypeUser @MemberGroupTypeId, @MemberUserId

    /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetCustomerGroupTypesByUser' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetCustomerGroupTypesByUser

   go

create procedure spGetCustomerGroupTypesByUser( @ProviderSystemId integer,
                                                @MemberUserId     integer ) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   -- new procedure
   execute @ReturnCode = spGetMemberGroupTypesByMemberUser @ProviderSystemId, @MemberUserId

    /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetCustomerIdByCustomerUserId' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetCustomerIdByCustomerUserId

   go

create procedure spGetCustomerIdByCustomerUserId( @CustomerUserId integer,
                                                  @CustomerId     integer output ) as

   /* Get the identifier of the customer. */
   execute spGetMemberIdByMemberUserId @CustomerUserId,
                                       @CustomerId output

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetCustomerNameByCustomerId' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetCustomerNameByCustomerId

   go

create procedure spGetCustomerNameByCustomerId( @CustomerId   integer,
                                                @CustomerName varchar(100) output ) as

   /* Get the name of the customer. */
   execute spGetMemberNameByMemberId @CustomerId,
                                     @CustomerName output

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetCustomersByProvider' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetCustomersByProvider

   go

create procedure spGetCustomersByProvider( @ProviderId integer,
                                           @SubString  char(1) = null ) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   if ( ( @SubString = '' ) or ( @SubString is null ) )
      -- new stored proc
      execute @ReturnCode = spGetCustomersByProviderNoSubString @ProviderId
    else
      execute @ReturnCode = spGetCustomersByProviderSubString @ProviderId, @SubString

    /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetCustomersByProviderNoSubString' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetCustomersByProviderNoSubString

   go

create procedure spGetCustomersByProviderNoSubString( @ProviderId integer ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   SELECT MEMBER_ID, MEMBER_NAME, b.PROVIDER_CUSTOMER_ID
   FROM MEMBER a
   LEFT OUTER JOIN PROVIDER_CUSTOMER b ON a.MEMBER_ID = b.CUSTOMER_ID
   WHERE b.PROVIDER_ID = @ProviderId
   ORDER BY MEMBER_NAME

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@Error. */
   select  @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 )  begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetCustomersByProviderSubstring' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetCustomersByProviderSubstring

   go

create procedure spGetCustomersByProviderSubstring( @providerid integer,
                                                    @letter     char(1) ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   select member_id, member_name, b.provider_customer_id
   from member a
   left outer join provider_customer b on a.member_id = b.customer_id
   where b.provider_id = @providerid
   and substring(a.member_name, 1, 1) = @letter
   order by member_name

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 )  begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetCustomerSecurityGroups' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetCustomerSecurityGroups

   go

create procedure spGetCustomerSecurityGroups as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   -- new stored procedure
   execute @ReturnCode = spGetSecurityGroupsByType 1

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetCustomerServiceByCustomer' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetCustomerServiceByCustomer

   go

create procedure spGetCustomerServiceByCustomer( @CustomerId                integer,
                                                 @ComServiceId              integer           = 0,
                                                 @ProviderServiceCategoryId integer           = 0,
                                                 @StartDate                 datetime      = 0,
                                                 @EndDate                   datetime      = 0,
                                                 @CustomerUnitIds           varchar(1000) = null,
                                                 @ProviderServiceDataIds    varchar(500)  = null,
                                                 @ProviderServiceValueIds   varchar(500)  = null ) as

   declare @SqlSelect      varchar(4000)
   declare @SqlGroupWhere  varchar(4000)
   declare @SqlOrderBy     varchar(4000)

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   set nocount on

   set @SqlSelect = 'select * from vwServicesBySystemCustomer vw ' +
                    'where customer_id = ' + cast( @CustomerId as varchar(10))

   if ( @ComServiceId > 0 )
      set @SqlSelect = @SqlSelect + ' and com_service_id = ' + cast( @ComServiceId as varchar(10))

   if ( @ProviderServiceCategoryId > 0 )
       set @SqlSelect = @SqlSelect + ' and provider_service_category_id = ' + cast( @ProviderServiceCategoryId as varchar(10))

   if ( @StartDate > 0 )
      set @SqlSelect = @SqlSelect + ' and com_service_date >= ''' +  convert( varchar(10),@StartDate,01) + ''''

   if ( @EndDate > 0 )
      set @SqlSelect = @SqlSelect + ' and com_service_date <= ''' + convert( varchar(10), @EndDate, 01) + ''''

   if @CustomerUnitIds <> ''
      set @SqlSelect = @SqlSelect + ' and ( parent_unit_id in ( ' + @CustomerUnitIds + ') )'

   if @ProviderServiceValueIds <> ''
      set @SqlSelect = @SqlSelect + ' and ( provider_service_value_id in (' +
                                      @ProviderServiceValueIds + ') )'

   if @ProviderServiceDataIds <> ''
      set @SqlGroupWhere = ' group by'        +
         ' com_service_id,'                   +
         ' com_service_date,'                 +
         ' time_in,'                          +
         ' time_out,'                         +
         ' customer_id,'                      +
         ' parent_unit_id,'                   +
         ' parent_unit_type_name,'            +
         ' parent_unit_name,'                 +
         ' provider_service_type_text,'       +
         ' technician_name,'                  +
         ' customer_contact,'                 +
         ' com_service_comment,'              +
         ' com_service_unit_value_id,'        +
         ' service_unit_id,'                  +
         ' service_unit_type_name,'           +
         ' service_unit_name,'                +
         ' provider_service_value_id,'        +
         ' provider_service_value,'           +
         ' provider_service_value_text,'      +
         ' provider_system_id,'               +
         ' provider_service_category_id,'     +
         ' provider_service_category,'        +
         ' vw.Provider_Service_Data_Type_ID,' +
         ' vw.provider_service_data_type,'    +
         ' sort_order,'                       +
         ' provider_service_data_id,'         +
         ' com_service_data_id,'              +
         ' com_service_data, '                +
         ' Web_Query, '                       +
         ' ROW_ID '                           +
         ' having ( row_id in ('              +
         ' select row_id from com_service_data' +
         ' where provider_service_data_id in (' +
           @ProviderServiceDataIds +  ')'       +
         ' and com_service_unit_value_id = vw.com_service_unit_value_id)) '

   /* order by */
   set @SqlOrderBy = ' order by ' +
      ' Parent_Unit_ID, ' +
      ' Com_Service_Date, ' +
      ' Com_Service_ID, ' +
      ' Com_Service_Unit_Value_ID, ' +
      ' Provider_Service_Category_ID, ' +
      ' ROW_ID, ' +
      ' Sort_Order'

   exec( @SqlSelect + @SqlGroupWhere + @SqlOrderBy )

    /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

    /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetCustomerServiceByGroup' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetCustomerServiceByGroup

   go

create procedure spGetCustomerServiceByGroup( @ProviderSystemId          integer,
                                              @ComServiceId              integer           = 0,
                                              @ProviderServiceCategoryId integer           = 0,
                                              @StartDate                 datetime      = 0,
                                              @EndDate                   datetime      = 0,
                                              @CustomerUnitIds           varchar(1000) = null,
                                              @ProviderServiceDataIds    varchar(500)  = null,
                                              @ProviderServiceValueIds   varchar(500)  = null,
                                              @MemberGroupIds            varchar(500)  = null ) as

   declare @SqlSelect      varchar(4000)
   declare @SqlGroupWhere  varchar(4000)
   declare @SqlOrderBy     varchar(4000)

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   set nocount on

   set @SqlSelect = 'select * from vwServicesBySystemGroup vw  ' +
                    'where provider_system_id = ' + cast( @ProviderSystemId as varchar(10))

  if ( @ComServiceId > 0 )
     set @SqlSelect = @SqlSelect + ' and com_service_id = ' + cast( @ComServiceId as varchar(10))

  if ( @ProviderServiceCategoryId > 0 )
     set @SqlSelect = @SqlSelect + ' and provider_service_category_id = ' + cast( @ProviderServiceCategoryId as varchar(10))

   if ( @StartDate > 0 )
      set @SqlSelect = @SqlSelect + ' and com_service_date >= ''' +  convert( varchar(10),@StartDate,01) + ''''

   if ( @EndDate > 0 )
      set @SqlSelect = @SqlSelect + ' and com_service_date <= ''' + convert( varchar(10), @EndDate, 01) + ''''

   if @CustomerUnitIds <> ''
      set @SqlSelect = @SqlSelect + ' and ( parent_unit_id in ( ' + @CustomerUnitIds + ') )'

   if @ProviderServiceDataIds <> ''
      set @SqlSelect = @SqlSelect +  ' and Com_Service_Unit_Value_ID in '  +
                                     '( select Com_Service_Unit_Value_ID ' +
                                     '  from Com_Service_Data b ' +
                                     '  where Com_Service_Unit_Value_ID = ' +
                                     '  b.Com_Service_Unit_Value_ID and ' +
                                     '  provider_service_data_id in ( ' +
                                      @ProviderServiceDataIds  + ' ) )'

   if @ProviderServiceValueIds <> ''
      set @SqlSelect = @SqlSelect + ' and ( provider_service_value_id in (' +
                                      @ProviderServiceValueIds + ') )'

   if @MemberGroupIds <> ''
      set @SqlSelect = @SqlSelect + ' and ( member_group_id in ( ' +
                                    @MemberGroupIds + ') )'

   if @ProviderServiceDataIds <> ''
      set @SqlGroupWhere = ' group by'        +
         ' com_service_id,'                   +
         ' com_service_date,'                 +
         ' time_in,'                          +
         ' time_out,'                         +
         ' customer_id,'                      +
         ' parent_unit_id,'                   +
         ' parent_unit_type_name,'            +
         ' parent_unit_name,'                 +
         ' provider_service_type_text,'       +
         ' technician_name,'                  +
         ' customer_contact,'                 +
         ' com_service_comment,'              +
         ' com_service_unit_value_id,'        +
         ' service_unit_id,'                  +
         ' service_unit_type_name,'           +
         ' service_unit_name,'                +
         ' provider_service_value_id,'        +
         ' provider_service_value,'           +
         ' provider_service_value_text,'      +
         ' provider_system_id,'               +
         ' provider_service_category_id,'     +
         ' provider_service_category,'        +
         ' vw.Provider_Service_Data_Type_ID,' +
         ' vw.provider_service_data_type,'    +
         /*group only */
         ' vw.member_group_id,'               +
         ' vw.member_group_name,'             +
         ' vw.member_group_type_name,'        +
         /*group only */
         ' sort_order,'                       +
         ' provider_service_data_id,'         +
         ' com_service_data_id,'              +
         ' com_service_data, '                +
         ' Web_Query, '                       +
         ' ROW_ID '                           +
         ' having ( row_id in ('              +
         ' select row_id from com_service_data' +
         ' where provider_service_data_id in (' +
           @ProviderServiceDataIds +  ')'       +
         ' and com_service_unit_value_id = vw.com_service_unit_value_id)) '

   /* order by */
   set @SqlOrderBy = ' order by ' +
      ' Parent_Unit_ID, ' +
      ' Com_Service_Date, ' +
      ' Com_Service_ID, ' +
      ' Com_Service_Unit_Value_ID, ' +
      ' Provider_Service_Category_ID, ' +
      ' ROW_ID, ' +
      ' Sort_Order'

   exec( @SqlSelect + @SqlGroupWhere + @SqlOrderBy )

    /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

    /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetCustomerServiceByUser' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetCustomerServiceByUser

   go

create procedure spGetCustomerServiceByUser( @MemberUserId              integer,
                                             @ComServiceId              integer           = 0,
                                             @ProviderServiceCategoryId integer           = 0,
                                             @StartDate                 datetime      = 0,
                                             @EndDate                   datetime      = 0,
                                             @CustomerUnitIds           varchar(1000) = null,
                                             @ProviderServiceDataIds    varchar(500)  = null,
                                             @ProviderServiceValueIds   varchar(500)  = null ) as

   declare @SqlSelect      varchar(4000)
   declare @SqlGroupWhere  varchar(4000)
   declare @SqlOrderBy     varchar(4000)

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   set nocount on

   set @SqlSelect = 'select * from vwServicesBySystemUser vw ' +
                    'where Member_User_ID = ' + cast( @MemberUserId as varchar(10) )

   if ( @ComServiceId > 0 )
      set @SqlSelect = @SqlSelect + ' and com_service_id = ' + cast( @ComServiceId as varchar(10))

   if ( @ProviderServiceCategoryId > 0 )
       set @SqlSelect = @SqlSelect + ' and provider_service_category_id = ' + cast( @ProviderServiceCategoryId as varchar(10))

   if ( @StartDate > 0 )
      set @SqlSelect = @SqlSelect + ' and com_service_date >= ''' +  convert( varchar(10),@StartDate,01) + ''''

   if ( @EndDate > 0 )
      set @SqlSelect = @SqlSelect + ' and com_service_date <= ''' + convert( varchar(10), @EndDate, 01) + ''''

   if @CustomerUnitIds <> ''
      set @SqlSelect = @SqlSelect + ' and ( parent_unit_id in ( ' + @CustomerUnitIds + ') )'

   if @ProviderServiceValueIds <> ''
      set @SqlSelect = @SqlSelect + ' and ( provider_service_value_id in (' +
                                      @ProviderServiceValueIds + ') )'

   if @ProviderServiceDataIds <> ''
      set @SqlGroupWhere = ' group by'        +
         ' com_service_id,'                   +
         ' com_service_date,'                 +
         ' time_in,'                          +
         ' time_out,'                         +
         ' customer_id,'                      +
         ' parent_unit_id,'                   +
         ' parent_unit_type_name,'            +
         ' parent_unit_name,'                 +
         ' provider_service_type_text,'       +
         ' technician_name,'                  +
         ' customer_contact,'                 +
         ' com_service_comment,'              +
         ' com_service_unit_value_id,'        +
         ' service_unit_id,'                  +
         ' service_unit_type_name,'           +
         ' service_unit_name,'                +
         ' provider_service_value_id,'        +
         ' provider_service_value,'           +
         ' provider_service_value_text,'      +
         ' provider_system_id,'               +
         ' provider_service_category_id,'     +
         ' provider_service_category,'        +
         ' vw.Provider_Service_Data_Type_ID,' +
         ' vw.provider_service_data_type,'    +
         ' sort_order,'                       +
         ' provider_service_data_id,'         +
         ' com_service_data_id,'              +
         ' com_service_data, '                +
         ' Web_Query, '                       +
         ' ROW_ID '                           +
         ' having ( row_id in ('              +
         ' select row_id from com_service_data' +
         ' where provider_service_data_id in (' +
           @ProviderServiceDataIds +  ')'       +
         ' and com_service_unit_value_id = vw.com_service_unit_value_id)) '

   /* order by */
   set @SqlOrderBy = ' order by ' +
      ' Parent_Unit_ID, ' +
      ' Com_Service_Date, ' +
      ' Com_Service_ID, ' +
      ' Com_Service_Unit_Value_ID, ' +
      ' Provider_Service_Category_ID, ' +
      ' ROW_ID, ' +
      ' Sort_Order'

   exec( @SqlSelect + @SqlGroupWhere + @SqlOrderBy )

    /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

    /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetCustomerSubUnitsBySystemCustomerType' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetCustomerSubUnitsBySystemCustomerType

   go

create procedure spGetCustomerSubUnitsBySystemCustomerType( @ProviderSystemId   integer,
                                                            @CustomerId         integer,
                                                            @CustomerUnitTypeId integer ) as

   /* Return the result set containing the customer unit types for the passed
      provider system identifier. */
   select a.CUSTOMER_UNIT_ID,
          c.CUSTOMER_UNIT_TYPE_ID,
          isnull( c.CUSTOMER_UNIT_TYPE_NAME, d.CUSTOMER_UNIT_TYPE_NAME ) as CUSTOMER_UNIT_TYPE_NAME,
          isnull( a.CUSTOMER_UNIT_NAME, isnull( e.CUSTOMER_UNIT_NAME, f.CUSTOMER_UNIT_NAME ) ) as CUSTOMER_UNIT_NAME,
          isnull( a.CUSTOMER_UNIT_NUMBER, isnull( e.CUSTOMER_UNIT_NUMBER, f.CUSTOMER_UNIT_NUMBER ) ) as CUSTOMER_UNIT_NUMBER,
          CUSTOMER_UNIT_LAYOUT_IMAGE_ID,
          a.UNIT_PARENT_ID
          from CUSTOMER_UNIT a
          left outer join JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT b on a.CUSTOMER_UNIT_ID                        = b.CUSTOMER_UNIT_ID
          left outer join CUSTOMER_UNIT_TYPE c                    on b.CUSTOMER_UNIT_TYPE_ID                   = c.CUSTOMER_UNIT_TYPE_ID
          left outer join TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE d  on c.TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE_ID = d.CUSTOMER_UNIT_TYPE_ID
          left outer join CUSTOMER_UNIT_NAME e                    on b.CUSTOMER_UNIT_NAME_ID                   = e.CUSTOMER_UNIT_NAME_ID
          left outer join TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME f  on e.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME_ID = f.CUSTOMER_UNIT_NAME_ID
          left outer join CUSTOMER_UNIT_LAYOUT_IMAGE g            on a.CUSTOMER_UNIT_ID                        = g.CUSTOMER_UNIT_ID
          where c.PROVIDER_SYSTEM_ID    = @ProviderSystemId   and
                a.CUSTOMER_ID           = @CustomerId         and
                c.CUSTOMER_UNIT_TYPE_ID = @CustomerUnitTypeId
          order by CUSTOMER_UNIT_NAME

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetCustomerSubUnitsBySystemCustomerTypeParent' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetCustomerSubUnitsBySystemCustomerTypeParent

   go

create procedure spGetCustomerSubUnitsBySystemCustomerTypeParent( @ProviderSystemId   integer,
                                                                  @CustomerId         integer,
                                                                  @CustomerUnitTypeId integer,
                                                                  @UnitParentId       integer ) as

   /* Return the result set containing the customer unit types for the passed
      provider system identifier. */
   select a.CUSTOMER_UNIT_ID,
          c.CUSTOMER_UNIT_TYPE_ID,
          isnull( c.CUSTOMER_UNIT_TYPE_NAME, d.CUSTOMER_UNIT_TYPE_NAME ) as CUSTOMER_UNIT_TYPE_NAME,
          isnull( a.CUSTOMER_UNIT_NAME, isnull( e.CUSTOMER_UNIT_NAME, f.CUSTOMER_UNIT_NAME ) ) as CUSTOMER_UNIT_NAME,
          isnull( a.CUSTOMER_UNIT_NUMBER, isnull( e.CUSTOMER_UNIT_NUMBER, f.CUSTOMER_UNIT_NUMBER ) ) as CUSTOMER_UNIT_NUMBER,
          CUSTOMER_UNIT_LAYOUT_IMAGE_ID,
          a.UNIT_PARENT_ID
          from CUSTOMER_UNIT a
          left outer join JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT b on a.CUSTOMER_UNIT_ID                        = b.CUSTOMER_UNIT_ID
          left outer join CUSTOMER_UNIT_TYPE c                    on b.CUSTOMER_UNIT_TYPE_ID                   = c.CUSTOMER_UNIT_TYPE_ID
          left outer join TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE d  on c.TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE_ID = d.CUSTOMER_UNIT_TYPE_ID
          left outer join CUSTOMER_UNIT_NAME e                    on b.CUSTOMER_UNIT_NAME_ID                   = e.CUSTOMER_UNIT_NAME_ID
          left outer join TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME f  on e.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME_ID = f.CUSTOMER_UNIT_NAME_ID
          left outer join CUSTOMER_UNIT_LAYOUT_IMAGE g            on a.CUSTOMER_UNIT_ID                        = g.CUSTOMER_UNIT_ID
          where c.PROVIDER_SYSTEM_ID    = @ProviderSystemId   and
                a.CUSTOMER_ID           = @CustomerId         and
                c.CUSTOMER_UNIT_TYPE_ID = @CustomerUnitTypeId and
                a.UNIT_PARENT_ID        = @UnitParentId
          order by CUSTOMER_UNIT_NAME

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetCustomerSubUnitsBySystemTypeParent' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetCustomerSubUnitsBySystemTypeParent

   go

create procedure spGetCustomerSubUnitsBySystemTypeParent( @ProviderSystemId   integer,
                                                          @CustomerUnitTypeId integer,
                                                          @UnitParentId       integer ) as

   /* Generate the local temporary table that will be filled with the units
      found during the traversal of the unit heirarchy.  This temporary
      table can be seen by the current connection, however, it is
      invisible to all other connections. */
   create table #tblUnitsTemp ( CUSTOMER_UNIT_ID        integer,
                                UNIT_PARENT_ID          integer,
                                UNIT_TOP_PARENT_ID      integer,
                                CUSTOMER_UNIT_TYPE_ID   integer,
                                CUSTOMER_UNIT_TYPE_NAME varchar(50),
                                CUSTOMER_UNIT_NAME      varchar(50) )

   declare @UnitId       integer         /* Identifier for the current customer unit      */
   declare @UnitTypeId   integer         /* Identifier for the current customer unit type */
   declare @UnitTypeName varchar(50) /* Name for the current customer unit type       */
   declare @UnitName     varchar(50) /* Name of the current default customer unit     */

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Declare the cursor that will contain the units to add to the
      temporary table. */
   declare csrParentUnits cursor local for
      select cu.CUSTOMER_UNIT_ID,
             cut.CUSTOMER_UNIT_TYPE_ID,
             isnull( cut.CUSTOMER_UNIT_TYPE_NAME, tcut.CUSTOMER_UNIT_TYPE_NAME ) as CUSTOMER_UNIT_TYPE_NAME,
             isnull( cu.CUSTOMER_UNIT_NAME, isnull( cun.CUSTOMER_UNIT_NAME, tcun.CUSTOMER_UNIT_NAME ) ) as CUSTOMER_UNIT_NAME
      from customer_unit cu
      left outer join join_customer_unit_type_customer_unit jcutcu on cu.customer_unit_id                         = jcutcu.customer_unit_id
      left outer join customer_unit_type                    cut    on jcutcu.customer_unit_type_id                = cut.customer_unit_type_id
      left outer join template_provider_customer_unit_type  tcut   on cut.template_provider_customer_unit_type_id = tcut.customer_unit_type_id
      left outer join customer_unit_name                    cun    on jcutcu.customer_unit_name_id                = cun.customer_unit_name_id
      left outer join template_provider_customer_unit_name  tcun   on cun.template_provider_customer_unit_name_id = tcun.customer_unit_name_id
      where cut.provider_system_id = @ProviderSystemId and
            cu.customer_unit_id    = @UnitParentId

    /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   open csrParentUnits

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   fetch next from csrParentUnits into @UnitId,
                                       @UnitTypeId,
                                       @UnitTypeName,
                                       @UnitName

   while ( @@FETCH_STATUS = 00 ) begin

      insert into #tblUnitsTemp
      ( CUSTOMER_UNIT_ID,
        UNIT_PARENT_ID,
        UNIT_TOP_PARENT_ID,
        CUSTOMER_UNIT_TYPE_ID,
        CUSTOMER_UNIT_TYPE_NAME,
        CUSTOMER_UNIT_NAME )
      values
      ( @UnitId,
        -1,
        -1,
        @UnitTypeId,
        @UnitTypeName,
        @UnitName )

      execute spGetCustomerSubUnitsBySystemTypeParentParent @ProviderSystemId,
                                                            @UnitId,
                                                            @UnitId

      fetch next from csrParentUnits into @UnitId,
                                          @UnitTypeId,
                                          @UnitTypeName,
                                          @UnitName
   end

   close csrParentUnits

   deallocate csrParentUnits

   select CUSTOMER_UNIT_ID,
          UNIT_PARENT_ID,
          UNIT_TOP_PARENT_ID,
          CUSTOMER_UNIT_TYPE_ID,
          CUSTOMER_UNIT_TYPE_NAME,
          CUSTOMER_UNIT_NAME
   from #tblUnitsTemp
   where CUSTOMER_UNIT_TYPE_ID = @CustomerUnitTypeId

   /* If there were no active transactions when this stored procedure was
   executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */

      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetCustomerSubUnitsBySystemTypeParentParent' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetCustomerSubUnitsBySystemTypeParentParent

   go

create procedure spGetCustomerSubUnitsBySystemTypeParentParent( @ProviderSystemId integer,
                                                                @UnitParentId     integer,
                                                                @TopUnitParentId  integer ) as

   declare @UnitId       integer         /* Identifier for the current customer unit      */
   declare @UnitTypeId   integer         /* Identifier for the current customer unit type */
   declare @UnitTypeName varchar(50) /* Name for the current customer unit type       */
   declare @UnitName     varchar(50) /* Name of the current default customer unit     */

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

    /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

  /* Declare the cursor that will contain the units to add to the
      temporary table. */
   declare csrChildUnits cursor local for
      select cu.CUSTOMER_UNIT_ID,
             cut.CUSTOMER_UNIT_TYPE_ID,
             isnull( cut.CUSTOMER_UNIT_TYPE_NAME, tcut.CUSTOMER_UNIT_TYPE_NAME ) as CUSTOMER_UNIT_TYPE_NAME,
             isnull( cu.CUSTOMER_UNIT_NAME, isnull( cun.CUSTOMER_UNIT_NAME, tcun.CUSTOMER_UNIT_NAME ) ) as CUSTOMER_UNIT_NAME
      from customer_unit cu
      left outer join join_customer_unit_type_customer_unit jcutcu on cu.customer_unit_id                         = jcutcu.customer_unit_id
      left outer join customer_unit_type                    cut    on jcutcu.customer_unit_type_id                = cut.customer_unit_type_id
      left outer join template_provider_customer_unit_type  tcut   on cut.template_provider_customer_unit_type_id = tcut.customer_unit_type_id
      left outer join customer_unit_name                    cun    on jcutcu.customer_unit_name_id                = cun.customer_unit_name_id
      left outer join template_provider_customer_unit_name  tcun   on cun.template_provider_customer_unit_name_id = tcun.customer_unit_name_id
      where cut.provider_system_id = @ProviderSystemId and
            cu.unit_parent_id      = @UnitParentId

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   open csrChildUnits

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   fetch next from csrChildUnits into @UnitId,
                                      @UnitTypeId,
                                      @UnitTypeName,
                                      @UnitName

   while ( @@FETCH_STATUS = 00 ) begin

      insert into #tblUnitsTemp
      ( CUSTOMER_UNIT_ID,
        UNIT_PARENT_ID,
        UNIT_TOP_PARENT_ID,
        CUSTOMER_UNIT_TYPE_ID,
        CUSTOMER_UNIT_TYPE_NAME,
        CUSTOMER_UNIT_NAME )
      values
      ( @UnitId,
        @UnitParentId,
        @TopUnitParentId,
        @UnitTypeId,
        @UnitTypeName,
        @UnitName )

      execute spGetCustomerSubUnitsBySystemTypeParentParent @ProviderSystemId,
                                                            @UnitId,
                                                            @TopUnitParentId

      fetch next from csrChildUnits into @UnitId,
                                         @UnitTypeId,
                                         @UnitTypeName,
                                         @UnitName

   end

   close csrChildUnits

   deallocate csrChildUnits

    /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetCustomerTransactionsByInterfaceId' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetCustomerTransactionsByInterfaceId

   go

create procedure spGetCustomerTransactionsByInterfaceId ( @InterfaceId integer ) as

   select
   m.MEMBER_ID           as CustomerId,
   m.MEMBER_NAME         as CustomerName,
   address1.CONTACT_INFO as Address1,
   address2.CONTACT_INFO as Address2,
   address3.CONTACT_INFO as Address3,
   city.CONTACT_INFO     as City,
   state.CONTACT_INFO    as State,
   zip.CONTACT_INFO      as Zip,
   country.CONTACT_INFO  as Country,
   phone.CONTACT_INFO    as Phone,
   fax.CONTACT_INFO      as Fax,
   mobile.CONTACT_INFO   as Mobile,
   pager.CONTACT_INFO    as Pager,
   email.CONTACT_INFO    as Email,
   me.FOREIGN_ID         as ForeignId,
   me.FOREIGN_TYPE       as ForeignType
   from MEMBER m
   left outer join vwContactCrosstab vw on m.MEMBER_ID       = vw.ENTITY_ID and
                                           vw.ENTITY_TYPE_ID = 4
   left outer join CONTACT address1     on vw.Address1       = address1.contact_id
   left outer join CONTACT address2     on vw.Address2       = address2.contact_id
   left outer join CONTACT address3     on vw.Address3       = address3.contact_id
   left outer join CONTACT city         on vw.City           = city.contact_id
   left outer join CONTACT state        on vw.State          = state.contact_id
   left outer join CONTACT zip          on vw.Zip            = zip.contact_id
   left outer join CONTACT country      on vw.Country        = country.contact_id
   left outer join CONTACT phone        on vw.Phone          = phone.contact_id
   left outer join CONTACT fax          on vw.Fax            = fax.contact_id
   left outer join CONTACT mobile       on vw.Mobile         = mobile.contact_id
   left outer join CONTACT pager        on vw.Pager          = pager.contact_id
   left outer join CONTACT email        on vw.Email          = email.contact_id

   inner join mapping_interface mi      on mi.interface_id   = @InterfaceId
   inner join TRANSACTION_LOG tl        on mi.INTERFACE_ID   = tl.INTERFACE_ID and
                                           m.MEMBER_ID       = tl.ENTITY_ID and
                                           tl.ENTITY_TYPE_ID = 4
   left outer join MAPPING_ENTITY me    on tl.INTERFACE_ID   = me.INTERFACE_ID and
                                           tl.ENTITY_ID      = me.ENTITY_ID and
                                           tl.ENTITY_TYPE_ID = me.ENTITY_TYPE_ID

   where tl.TRANSMITTED = 0
   order by MEMBER_ID, FOREIGN_ID

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetCustomerUnitBarCodeIdIsUniqueByCustomer' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetCustomerUnitBarCodeIdIsUniqueByCustomer

   go

create procedure spGetCustomerUnitBarCodeIdIsUniqueByCustomer( @CustomerId        integer,
                                                               @BarCodeId         varchar(50),
                                                               @CustomerUnitId    integer,
                                                               @BarCodeCount      integer output,
                                                               @BarCodeIdIsUnique varchar(5) = 'FALSE' output ) as

   declare @ErrorCode            integer         /* Error code returned by the execution of the last statement   */
   declare @Transactions         integer         /* Number of active transactions at the start of this procedure */

    /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* If the user is inserting a new customer unit... */
   if ( @CustomerUnitId is null ) begin

      /* Get the number of barcode identifiers that match the passed barcode
         identifier value.  This should be zero, however, if it is nonzero,
         then the user has created a duplicate. */
      select @BarCodeCount = count(*)
      from CUSTOMER_UNIT cu
      where cu.CUSTOMER_ID          = @CustomerId and
            cu.CUSTOMER_UNIT_NUMBER = @BarCodeId

   end

   else begin /* Updating an existing customer unit...  */

      /* Get the number of barcode identifiers that match the passed barcode
         identifier value and are not contained by the passed customer unit.
         This should be zero, however, if it is nonzero, then the user has
         created a duplicate by updating the barcode identifier to a value that
         matches another barcode identifier.  This test handles the special
         case of an updated row finding itself as a duplicate. */
      select @BarCodeCount = count(*)
      from CUSTOMER_UNIT cu
      where cu.CUSTOMER_ID          = @CustomerId and
            cu.CUSTOMER_UNIT_NUMBER = @BarCodeId  and
            cu.CUSTOMER_UNIT_ID    <> @CustomerUnitId

   end

    /* Get the rows affected and the error code for the previous
       statement.  Error checking MUST be done this way since any single
       statement executed will affect both of the global functions,
       @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   if @BarCodeCount = 00
      set @BarCodeIdIsUnique = 'TRUE'
   else
      set @BarCodeIdIsUnique = 'FALSE'

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetCustomerUnitChildren' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetCustomerUnitChildren

   go

create procedure spGetCustomerUnitChildren( @ProviderSystemId integer,
                                            @CustomerUnitId   integer ) as

   declare @UnitId integer
   declare @CustomerUnitName varchar(100)
   declare @CustomerUnitTypeName varchar(50)
   declare @ParentUnitId integer

   set nocount on

   set @UnitId = @CustomerUnitId

   declare child_cursor cursor local fast_forward for

   select
   cu.customer_unit_id,
   ISNULL( cu.CUSTOMER_UNIT_NAME,   ISNULL( cun.CUSTOMER_UNIT_NAME,   tpcun.CUSTOMER_UNIT_NAME   ) ) as CUSTOMER_UNIT_NAME,
   ISNULL( cut.CUSTOMER_UNIT_TYPE_NAME, tpcut.CUSTOMER_UNIT_TYPE_NAME ) as CUSTOMER_UNIT_TYPE_NAME,
   cu.UNIT_PARENT_ID
   from
   customer_unit cu
   inner join dbo.JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT jcutcu on cu.CUSTOMER_UNIT_ID = jcutcu.CUSTOMER_UNIT_ID
   inner join dbo.CUSTOMER_UNIT_TYPE cut on ( cut.customer_unit_type_id = jcutcu.customer_unit_type_id ) and
                                            ( cut.provider_system_id = @ProviderSystemId )
   left outer join dbo.CUSTOMER_UNIT_NAME cun on jcutcu.CUSTOMER_UNIT_NAME_ID = cun.CUSTOMER_UNIT_NAME_ID
   left outer join dbo.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME tpcun on cun.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME_ID = tpcun.CUSTOMER_UNIT_NAME_ID
   left outer join dbo.TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE tpcut on cut.template_provider_customer_unit_type_id = tpcut.CUSTOMER_UNIT_TYPE_ID
   where cu.unit_parent_id = @UnitId

   open child_cursor fetch next from child_cursor into @UnitId,
                                                       @CustomerUnitName,
                                                       @CustomerUnitTypeName,
                                                       @ParentUnitId

   while ( @@Fetch_Status = 0 ) begin

        insert into #TEMP_UNIT
         values(@UnitId,
                @ParentUnitId,
                @CustomerUnitName,
                @CustomerUnitTypeName )

        exec spGetCustomerUnitChildren @ProviderSystemId, @UnitId

      fetch next from child_cursor into @UnitId,
                                        @CustomerUnitName,
                                        @CustomerUnitTypeName,
                                        @ParentUnitId

   end

   close child_cursor
   deallocate child_cursor

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetCustomerUnitChildrenByType' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetCustomerUnitChildrenByType

   go

create procedure spGetCustomerUnitChildrenByType(  @ParentId       integer,
                                                   @UnitTypeId     integer,
                                                   @UnitTypeIds    varchar(500),
                                                   @UserUnitTypeId integer ) as

   declare @CustomerUnitId integer
   declare @CustomerUnitName varchar(100)
   declare @CustomerUnitTypeName varchar(50)
   declare @ParentUnitId integer
   declare @ParentUnitName varchar(100)
   declare @ParentUnitTypeName varchar(50)
   declare @RowCount integer
   declare @FindUnitTypeId integer
   declare @Pos integer
   declare @CustomerUnitTypeId integer

   set nocount on

   declare child_cursor cursor local fast_forward for
      select cu.customer_unit_id,
             cu.unit_parent_id,
      ISNULL( cu.CUSTOMER_UNIT_NAME,   ISNULL( cun.CUSTOMER_UNIT_NAME,   tpcun.CUSTOMER_UNIT_NAME   ) ) as CUSTOMER_UNIT_NAME,
      ISNULL( cut.CUSTOMER_UNIT_TYPE_NAME, tpcut.CUSTOMER_UNIT_TYPE_NAME ) as CUSTOMER_UNIT_TYPE_NAME,
      cut.customer_unit_type_id
      from
      customer_unit cu
      inner join dbo.JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT jcutcu on cu.CUSTOMER_UNIT_ID = jcutcu.CUSTOMER_UNIT_ID
      inner join dbo.CUSTOMER_UNIT_TYPE cut on cut.customer_unit_type_id = jcutcu.customer_unit_type_id
      left outer join dbo.TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE tpcut on cut.template_provider_customer_unit_type_id = tpcut.CUSTOMER_UNIT_TYPE_ID
      left outer join dbo.CUSTOMER_UNIT_NAME cun on jcutcu.CUSTOMER_UNIT_NAME_ID = cun.CUSTOMER_UNIT_NAME_ID
      left outer join dbo.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME tpcun on cun.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME_ID = tpcun.CUSTOMER_UNIT_NAME_ID

      where ( cu.unit_parent_id            = @ParentId   )
        and ( jcutcu.CUSTOMER_UNIT_TYPE_ID = @UnitTypeId )

   open child_cursor fetch next from child_cursor into @CustomerUnitId,
                                                       @ParentUnitId,
                                                       @CustomerUnitName,
                                                       @CustomerUnitTypeName,
                                                       @CustomerUnitTypeId

   if @UnitTypeIds <> '' begin
      set @Pos = CHARINDEX(',',@UnitTypeIds)
      set @UnitTypeIds = SUBSTRING(@UnitTypeIds, @Pos+1, LEN(@UnitTypeIds) - @Pos )
   end

   while ( @@Fetch_Status = 0 ) begin

      if @UnitTypeIds <> '' begin
         set @Pos = CHARINDEX(',',@UnitTypeIds)
         set @FindUnitTypeId = CAST( SUBSTRING(@UnitTypeIds, 1, @Pos-1 )  as integer )

      end
      else
         set @FindUnitTypeId = 0

      if @FindUnitTypeId > 0 begin

         /*get children of the next unit type in the hierarchy*/
         select @RowCount = count(*)
         from dbo.CUSTOMER_UNIT CU
         inner join dbo.JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT jcutcu on cu.CUSTOMER_UNIT_ID = jcutcu.CUSTOMER_UNIT_ID
         where cu.UNIT_PARENT_ID      = @CustomerUnitId
         and jcutcu.CUSTOMER_UNIT_TYPE_ID = @FindUnitTypeId

         if @RowCount > 0 begin
            insert into #TEMP_UNIT
            values(@CustomerUnitId,
                   @ParentUnitId,
                   @CustomerUnitName,
                   @CustomerUnitTypeName,
                   @CustomerUnitTypeId )
             /* pass the top parent, the unit type looking for and the other unit types looking for */
           execute spGetCustomerUnitChildrenByType @CustomerUnitId, @FindUnitTypeId, @UnitTypeIds, @UserUnitTypeId
         end

      end
      else begin
           insert into #TEMP_UNIT
           values(@CustomerUnitId,
                  @ParentUnitId,
                  @CustomerUnitName,
                  @CustomerUnitTypeName,
                  @CustomerUnitTypeId )
      end

      fetch next from child_cursor into @CustomerUnitId,
                                        @ParentUnitId,
                                        @CustomerUnitName,
                                        @CustomerUnitTypeName,
                                        @CustomerUnitTypeId

   end

   close child_cursor
   deallocate child_cursor

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetCustomerUnitChildrenInfrastructure' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetCustomerUnitChildrenInfrastructure

   go

create procedure spGetCustomerUnitChildrenInfrastructure( @ProviderSystemId integer,
                                                          @CustomerUnitId   integer,
                                                          @DisplayOrder     integer output ) as

   declare @UnitId integer
   declare @CustomerUnitName varchar(100)
   declare @CustomerUnitTypeName varchar(50)
   declare @ParentUnitId integer

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   set nocount on

   set @UnitId = @CustomerUnitId

   declare child_cursor cursor local fast_forward for

   select
   cu.customer_unit_id,
   ISNULL( cu.CUSTOMER_UNIT_NAME,   ISNULL( cun.CUSTOMER_UNIT_NAME,   tpcun.CUSTOMER_UNIT_NAME   ) ) as CUSTOMER_UNIT_NAME,
   ISNULL( cut.CUSTOMER_UNIT_TYPE_NAME, tpcut.CUSTOMER_UNIT_TYPE_NAME ) as CUSTOMER_UNIT_TYPE_NAME,
   cu.UNIT_PARENT_ID
   from
   customer_unit cu
   inner join dbo.JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT jcutcu on cu.CUSTOMER_UNIT_ID = jcutcu.CUSTOMER_UNIT_ID
   inner join dbo.CUSTOMER_UNIT_TYPE cut on ( cut.customer_unit_type_id = jcutcu.customer_unit_type_id ) and
                                            ( cut.provider_system_id = @ProviderSystemId )
   left outer join dbo.CUSTOMER_UNIT_NAME cun on jcutcu.CUSTOMER_UNIT_NAME_ID = cun.CUSTOMER_UNIT_NAME_ID
   left outer join dbo.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME tpcun on cun.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME_ID = tpcun.CUSTOMER_UNIT_NAME_ID
   left outer join dbo.TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE tpcut on cut.template_provider_customer_unit_type_id = tpcut.CUSTOMER_UNIT_TYPE_ID
   where cu.unit_parent_id = @UnitId
   order by CUSTOMER_UNIT_TYPE_NAME, CUSTOMER_UNIT_NAME

    /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 )  begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   open child_cursor fetch next from child_cursor into @UnitId,
                                                       @CustomerUnitName,
                                                       @CustomerUnitTypeName,
                                                       @ParentUnitId

    /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 )  begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   while ( @@Fetch_Status = 0 ) begin
        set @DisplayOrder = @DisplayOrder + 1
        insert into #TEMP_UNIT
         values(@UnitId,
                @ParentUnitId,
                @CustomerUnitName,
                @CustomerUnitTypeName,
                null,
                @DisplayOrder )

     execute spGetCustomerUnitChildrenInfrastructure @ProviderSystemId, @UnitId, @DisplayOrder output

     fetch next from child_cursor into @UnitId,
                                        @CustomerUnitName,
                                        @CustomerUnitTypeName,
                                        @ParentUnitId

   end

   close child_cursor
   deallocate child_cursor

     /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetCustomerUnitLayoutImageByCustomerUnit' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetCustomerUnitLayoutImageByCustomerUnit

   go

create procedure spGetCustomerUnitLayoutImageByCustomerUnit( @customerunitid integer ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   SELECT CUSTOMER_UNIT_LAYOUT_IMAGE_ID,
        CUSTOMER_UNIT_ID,
	CUSTOMER_UNIT_LAYOUT_IMAGE
   FROM CUSTOMER_UNIT_LAYOUT_IMAGE
   WHERE CUSTOMER_UNIT_ID = @customerunitid

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetCustomerUnitNameBarCodeIdIsUniqueBySystem' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetCustomerUnitNameBarCodeIdIsUniqueBySystem

   go

create procedure spGetCustomerUnitNameBarCodeIdIsUniqueBySystem( @ProviderSystemId   integer,
                                                                 @BarCodeId          varchar(10),
                                                                 @CustomerUnitNameId integer,
                                                                 @BarCodeCount       integer output ) as

   declare @ErrorCode            integer         /* Error code returned by the execution of the last statement   */
   declare @Transactions         integer         /* Number of active transactions at the start of this procedure */

     /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

    /* If the user is inserting a new customer unit name... */
   if ( @CustomerUnitNameId is null ) begin

      /* Get the number of barcode identifiers that match the passed barcode
         identifier value.  This should be zero, however, if it is nonzero,
         then the user has created a duplicate. */
      select @BarCodeCount = count(*)
      from CUSTOMER_UNIT_NAME un
           left outer join TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME tn on un.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME_ID = tn.CUSTOMER_UNIT_NAME_ID
           inner join      CUSTOMER_UNIT_TYPE                   ut on un.CUSTOMER_UNIT_TYPE_ID                   = ut.CUSTOMER_UNIT_TYPE_ID
      where ut.PROVIDER_SYSTEM_ID = @ProviderSystemId and
            ( ( un.CUSTOMER_UNIT_NUMBER = @BarCodeId ) or
              ( tn.CUSTOMER_UNIT_NUMBER = @BarCodeId ) )

   end

   else begin /* Updating an existing customer unit name...  */

      /* Get the number of barcode identifiers that match the passed barcode
         identifier value and are not contained by the passed customer unit
         name.  This should be zero, however, if it is nonzero, then the user
         has created a duplicate by updating the barcode identifier to a value
         that matches another barcode identifier.  This test handles the
         special case of an updated row finding itself as a duplicate. */
      select @BarCodeCount = count(*)
      from CUSTOMER_UNIT_NAME un
           left outer join TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME tn on un.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME_ID = tn.CUSTOMER_UNIT_NAME_ID
           inner join      CUSTOMER_UNIT_TYPE                   ut on un.CUSTOMER_UNIT_TYPE_ID                   = ut.CUSTOMER_UNIT_TYPE_ID
      where ut.PROVIDER_SYSTEM_ID = @ProviderSystemId and
            ( ( un.CUSTOMER_UNIT_NUMBER = @BarCodeId ) or
              ( tn.CUSTOMER_UNIT_NUMBER = @BarCodeId ) ) and
            un.CUSTOMER_UNIT_NAME_ID <> @CustomerUnitNameId

   end

    /* Get the rows affected and the error code for the previous
       statement.  Error checking MUST be done this way since any single
       statement executed will affect both of the global functions,
       @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetCustomerUnitNamesByCustomerUnitType' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetCustomerUnitNamesByCustomerUnitType

   go

create procedure spGetCustomerUnitNamesByCustomerUnitType( @customerunittypeid integer ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   SELECT a.CUSTOMER_UNIT_NAME_ID,
	  isnull( a.CUSTOMER_UNIT_NAME, b.CUSTOMER_UNIT_NAME ) as CUSTOMER_UNIT_NAME,
	  ISNULL(b.CUSTOMER_UNIT_NAME_MOD,1) AS CUSTOMER_UNIT_NAME_MOD,
	  isnull( a.CUSTOMER_UNIT_NUMBER, b.CUSTOMER_UNIT_NUMBER ) as CUSTOMER_UNIT_NUMBER,
	  ISNULL(b.CUSTOMER_UNIT_NAME_MOD,1) AS CUSTOMER_UNIT_NAME_MOD,
	  TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME_ID
   FROM CUSTOMER_UNIT_NAME a
   LEFT OUTER JOIN TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME b ON a.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME_ID = b.CUSTOMER_UNIT_NAME_ID
   WHERE a.CUSTOMER_UNIT_TYPE_ID = @customerunittypeid

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 )  begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetCustomerUnitNamesByType' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetCustomerUnitNamesByType

   go

create procedure spGetCustomerUnitNamesByType( @CustomerUnitTypeId integer ) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   -- new procedure
   execute @ReturnCode = spGetCustomerUnitnamesByCustomerUnitType @CustomerUnitTypeId

    /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetCustomerUnitsAndChildrenByParentType' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetCustomerUnitsAndChildrenByParentType

   go

create procedure spGetCustomerUnitsAndChildrenByParentType(  @CustomerUnitId     integer,
                                                             @CustomerUnitTypeId integer ) as

  set nocount on

   create table #TEMP_UNIT( CUSTOMER_UNIT_ID  integer,
                            PARENT_UNIT_ID    integer,
                            UNIT_NAME         varchar(100),
                            UNIT_TYPE_NAME    varchar(50),
                            UNIT_TYPE_ID      integer )

   declare @UnitId integer
   declare @CustomerUnitName varchar(100)
   declare @CustomerUnitTypeName varchar(50)
   declare @CustomerId integer
   declare @ChildUnitTypeId integer
   declare @UnitParentId integer
   declare @ParentUnitTypeId integer
   declare @RowCount integer
   declare @UnitTypeIds varchar(500)
   declare @FindUnitTypeId integer
   declare @Pos integer
   declare @UnitTypeId integer
   declare @ParentId integer
   declare @CustomerUnitTable table ( UnitId integer )

   set @ChildUnitTypeId = @CustomerUnitTypeId
   set @UnitTypeIds     = ''

   while (@ChildUnitTypeId > 0) begin

      select @ParentUnitTypeId = customer_unit_type_parent_id
      from customer_unit_type
      where customer_unit_type_id = @ChildUnitTypeId

      if @UnitTypeIds <> ''
         set @UnitTypeIds = CAST( @ChildUnitTypeId as varchar(10) ) + ',' + @UnitTypeIds
      else
         set @UnitTypeIds = CAST( @ChildUnitTypeId as varchar(10) ) + ','

      set @ChildUnitTypeId = @ParentUnitTypeId

   end

   if @UnitTypeIds <> ''  begin
      set @Pos = CHARINDEX(',',@UnitTypeIds)
      set @FindUnitTypeId = CAST( SUBSTRING(@UnitTypeIds, 1, @Pos-1 )  as integer )
      set @UnitTypeIds = SUBSTRING(@UnitTypeIds, @Pos+1, LEN(@UnitTypeIds) - @Pos )

   end

   declare main_cursor cursor local fast_forward for
      select
      cu.customer_unit_id,
      ISNULL( cu.CUSTOMER_UNIT_NAME,   ISNULL( cun.CUSTOMER_UNIT_NAME,   tpcun.CUSTOMER_UNIT_NAME   ) ) as CUSTOMER_UNIT_NAME,
      ISNULL( cut.CUSTOMER_UNIT_TYPE_NAME, tpcut.CUSTOMER_UNIT_TYPE_NAME ) as CUSTOMER_UNIT_TYPE_NAME,
      cu.unit_parent_id,
      cut.customer_unit_type_id
      from
      customer_unit cu

      inner join dbo.JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT jcutcu on ( cu.CUSTOMER_UNIT_ID = jcutcu.CUSTOMER_UNIT_ID )
                                                                  and ( jcutcu.CUSTOMER_UNIT_TYPE_ID = @FindUnitTypeId )
      inner join dbo.CUSTOMER_UNIT_TYPE cut on cut.customer_unit_type_id = jcutcu.customer_unit_type_id
      left outer join dbo.CUSTOMER_UNIT_NAME cun on jcutcu.CUSTOMER_UNIT_NAME_ID = cun.CUSTOMER_UNIT_NAME_ID
      left outer join dbo.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME tpcun on cun.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME_ID = tpcun.CUSTOMER_UNIT_NAME_ID
      left outer join dbo.TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE tpcut on cut.template_provider_customer_unit_type_id = tpcut.CUSTOMER_UNIT_TYPE_ID
      where cu.customer_unit_id = @CustomerUnitId and cu.unit_parent_id = -1

   open main_cursor fetch next from main_cursor into @UnitId,
                                                     @CustomerUnitName,
                                                     @CustomerUnitTypeName,
                                                     @UnitParentId,
                                                     @UnitTypeId

   while ( @@Fetch_Status = 0 ) begin

      if @UnitTypeIds <> '' begin
         set @Pos = CHARINDEX(',',@UnitTypeIds)
         set @FindUnitTypeId = CAST( SUBSTRING(@UnitTypeIds, 1, @Pos-1 )  as integer )

         /*get children of the next unit type in the hierarchy*/
         select @RowCount = count(*)
         from dbo.CUSTOMER_UNIT CU
         inner join dbo.JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT jcutcu on cu.CUSTOMER_UNIT_ID = jcutcu.CUSTOMER_UNIT_ID
         inner join dbo.CUSTOMER_UNIT_TYPE cut on jcutcu.CUSTOMER_UNIT_TYPE_ID = cut.CUSTOMER_UNIT_TYPE_ID
         where cu.UNIT_PARENT_ID      = @UnitId
         and jcutcu.CUSTOMER_UNIT_TYPE_ID = @FindUnitTypeId

         if @RowCount > 0 begin
            insert into #TEMP_UNIT
            values( @UnitId,
              @UnitParentId,
              @CustomerUnitName,
              @CustomerUnitTypeName,
              @UnitTypeId )

            /* pass the top parent, the unit type looking for and the other unit types looking for, the unit type the the user picked */
           exec spGetCustomerUnitChildrenByType @UnitId, @FindUnitTypeId, @UnitTypeIds, @CustomerUnitTypeId
         end

      end
      else begin
         insert into #TEMP_UNIT
         values( @UnitId,
                 @UnitParentId,
                 @CustomerUnitName,
                 @CustomerUnitTypeName,
                 @UnitTypeId )

      end

     fetch next from main_cursor into @UnitId,
                                      @CustomerUnitName,
                                      @CustomerUnitTypeName,
                                      @UnitParentId,
                                      @UnitTypeId

   end

   close main_cursor
   deallocate main_cursor

   declare parent_cursor cursor local fast_forward for
      select tu.CUSTOMER_UNIT_ID, tu.UNIT_TYPE_ID
      from #TEMP_UNIT tu

      open parent_cursor fetch next from parent_cursor into
         @ParentId, @UnitTypeId

      while ( @@Fetch_Status = 0 ) begin
         if @UnitTypeId = @CustomerUnitTypeId begin
            insert into @CustomerUnitTable values ( @ParentId )
         end
         else begin
            select @RowCount = count(*) from #TEMP_UNIT tu WHERE tu.PARENT_UNIT_ID = @ParentId
            if ( @RowCount > 0 )
               insert into @CustomerUnitTable values ( @ParentId )

         end
         fetch next from parent_cursor into @ParentId, @UnitTypeId

      end

   close parent_cursor
   deallocate parent_cursor

   select tu.CUSTOMER_UNIT_ID,
          tu.PARENT_UNIT_ID,
          tu.UNIT_NAME,
          tu.UNIT_TYPE_NAME
   from #TEMP_UNIT tu
   inner join @CustomerUnitTable cut on tu.CUSTOMER_UNIT_ID = cut.UnitId

   order by tu.PARENT_UNIT_ID, tu.UNIT_NAME

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetCustomerUnitsAndChildrenBySystemParent' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetCustomerUnitsAndChildrenBySystemParent

   go

create procedure spGetCustomerUnitsAndChildrenBySystemParent( @ProviderSystemId integer,
                                                              @CustomerUnitId   integer ) as

  set nocount on

   create table #TEMP_UNIT(    CUSTOMER_UNIT_ID      integer,
                               PARENT_UNIT_ID        integer,
                               UNIT_NAME             varchar(100),
                               UNIT_TYPE_NAME        varchar(50) )

   declare @UnitId integer
   declare @CustomerUnitName varchar(100)
   declare @CustomerUnitTypeName varchar(50)
   declare @ParentUnitId integer

   declare top_cursor cursor local fast_forward for

   select
   cu.customer_unit_id,
   ISNULL( cu.CUSTOMER_UNIT_NAME,   ISNULL( cun.CUSTOMER_UNIT_NAME,   tpcun.CUSTOMER_UNIT_NAME   ) ) as CUSTOMER_UNIT_NAME,
   ISNULL( cut.CUSTOMER_UNIT_TYPE_NAME, tpcut.CUSTOMER_UNIT_TYPE_NAME ) as CUSTOMER_UNIT_TYPE_NAME,
   cu.unit_parent_id
   from
   customer_unit cu
   inner join dbo.JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT jcutcu on cu.CUSTOMER_UNIT_ID = jcutcu.CUSTOMER_UNIT_ID
   inner join dbo.CUSTOMER_UNIT_TYPE cut on ( cut.customer_unit_type_id = jcutcu.customer_unit_type_id ) and
                                            ( cut.provider_system_id = @ProviderSystemId )
   left outer join dbo.CUSTOMER_UNIT_NAME cun on jcutcu.CUSTOMER_UNIT_NAME_ID = cun.CUSTOMER_UNIT_NAME_ID
   left outer join dbo.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME tpcun on cun.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME_ID = tpcun.CUSTOMER_UNIT_NAME_ID
   left outer join dbo.TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE tpcut on cut.template_provider_customer_unit_type_id = tpcut.CUSTOMER_UNIT_TYPE_ID
   where cu.customer_unit_id = @CustomerUnitId and cu.unit_parent_id = -1

   open top_cursor fetch next from top_cursor into   @UnitId,
                                                     @CustomerUnitName,
                                                     @CustomerUnitTypeName,
                                                     @ParentUnitId

   insert into #TEMP_UNIT
         values(@UnitId,
                @ParentUnitId,
                @CustomerUnitName,
                @CustomerUnitTypeName
                 )

   close top_cursor
   deallocate top_cursor

   declare main_cursor cursor local fast_forward for

   select
   cu.customer_unit_id,
   ISNULL( cu.CUSTOMER_UNIT_NAME,   ISNULL( cun.CUSTOMER_UNIT_NAME,   tpcun.CUSTOMER_UNIT_NAME   ) ) as CUSTOMER_UNIT_NAME,
   ISNULL( cut.CUSTOMER_UNIT_TYPE_NAME, tpcut.CUSTOMER_UNIT_TYPE_NAME ) as CUSTOMER_UNIT_TYPE_NAME,
   cu.UNIT_PARENT_ID
   from
   customer_unit cu
   inner join dbo.JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT jcutcu on cu.CUSTOMER_UNIT_ID = jcutcu.CUSTOMER_UNIT_ID
   inner join dbo.CUSTOMER_UNIT_TYPE cut on ( cut.customer_unit_type_id = jcutcu.customer_unit_type_id ) and
                                            ( cut.provider_system_id = @ProviderSystemId )
   left outer join dbo.CUSTOMER_UNIT_NAME cun on jcutcu.CUSTOMER_UNIT_NAME_ID = cun.CUSTOMER_UNIT_NAME_ID
   left outer join dbo.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME tpcun on cun.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME_ID = tpcun.CUSTOMER_UNIT_NAME_ID
   left outer join dbo.TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE tpcut on cut.template_provider_customer_unit_type_id = tpcut.CUSTOMER_UNIT_TYPE_ID
   where cu.unit_parent_id = @CustomerUnitId

   open main_cursor fetch next from main_cursor into @UnitId,
                                                     @CustomerUnitName,
                                                     @CustomerUnitTypeName,
                                                     @ParentUnitId

   while ( @@Fetch_Status = 0 ) begin
      insert into #TEMP_UNIT
         values(@UnitId,
                @ParentUnitId,
                @CustomerUnitName,
                @CustomerUnitTypeName )

      exec spGetCustomerUnitChildren @ProviderSystemId, @UnitId

      fetch next from main_cursor into @UnitId,
                                       @CustomerUnitName,
                                       @CustomerUnitTypeName,
                                       @ParentUnitId

   end

   close main_cursor
   deallocate main_cursor

   select tu.CUSTOMER_UNIT_ID,
          PARENT_UNIT_ID,
          tu.UNIT_NAME,
          tu.UNIT_TYPE_NAME from #TEMP_UNIT tu
   order by tu.PARENT_UNIT_ID, tu.UNIT_NAME

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetCustomerUnitsByCustomerParent' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetCustomerUnitsByCustomerParent

   go

create procedure spGetCustomerUnitsByCustomerParent( @customerid   integer,
                                                     @UnitParentId integer=-1 ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   SELECT a.CUSTOMER_UNIT_ID,
	  a.CUSTOMER_UNIT_NAME,
	  a.CUSTOMER_UNIT_NUMBER
   from	customer_unit a
   WHERE a.CUSTOMER_ID = @customerid
   AND a.UNIT_PARENT_ID = @UnitParentId
   order by a.customer_unit_name

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 )  begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetCustomerUnitsByCustomerParentUser' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetCustomerUnitsByCustomerParentUser

   go

create procedure spGetCustomerUnitsByCustomerParentUser ( @CustomerId   integer,
                                                          @ParentId     integer=-1,
                                                          @MemberUserId integer ) as
   select cu.customer_unit_id,
	  cu.customer_unit_name,
          cu.customer_unit_number
   from customer_unit cu
   inner join join_member_group_customer_unit jmgcu on cu.customer_unit_id = jmgcu.customer_unit_id
     and cu.customer_id = @CustomerId
     and cu.unit_parent_id = @ParentId
   inner join join_member_group_user jmgu on jmgcu.member_group_id = jmgu.member_group_id
     and jmgu.member_user_id = @MemberUserId
   order by cu.customer_unit_name

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetCustomerUnitsBySystemBarcode' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetCustomerUnitsBySystemBarcode

   go

create procedure spGetCustomerUnitsBySystemBarcode( @ProviderSystemId integer,
                                                    @BarCode          varchar(50) ) as

   set nocount on

   declare @CustomerUnitId integer
   declare @UnitParentId   integer
   declare @RowCount       integer

   /* Get the CUSTOMER_UNIT_ID and UNIT_PARENT_ID for the Barcode passed into
      the proc as parameter. */
   select @CustomerUnitId = cu.CUSTOMER_UNIT_ID,
          @UnitParentId   = cu.UNIT_PARENT_ID
   from CUSTOMER_UNIT cu,
        JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT jcutcu,
        CUSTOMER_UNIT_TYPE cut
   where cu.CUSTOMER_UNIT_ID          = jcutcu.CUSTOMER_UNIT_ID   and
         jcutcu.CUSTOMER_UNIT_TYPE_ID = cut.CUSTOMER_UNIT_TYPE_ID and
         cu.CUSTOMER_UNIT_NUMBER      = @BarCode                  and
         cut.PROVIDER_SYSTEM_ID       = @ProviderSystemId

   /* If the UNIT_PARENT_ID is not -1 and the CUSTOEMR_UNIT_ID is not null then
      loop through the select statement, passing the UNIT_PARENT_ID as a
      parameter until it equals -1 (TopParentId). */
   while ( @UnitParentId <> -1 ) and ( @CustomerUnitId is not null ) begin

      select @CustomerUnitId = cu.CUSTOMER_UNIT_ID,
             @UnitParentId   = cu.UNIT_PARENT_ID
      from CUSTOMER_UNIT cu,
           JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT jcutcu,
           CUSTOMER_UNIT_TYPE cut
      where cu.CUSTOMER_UNIT_ID          = jcutcu.CUSTOMER_UNIT_ID   and
            jcutcu.CUSTOMER_UNIT_TYPE_ID = cut.CUSTOMER_UNIT_TYPE_ID and
            cu.CUSTOMER_UNIT_ID          = @UnitParentId             and
            cut.PROVIDER_SYSTEM_ID       = @ProviderSystemId

   end

   /* Generate a Temp table to store the data of the recursive stored
      procedures. */
   create table #TEMP_UNIT( CUSTOMER_UNIT_ID      integer,
                            CUSTOMER_ID           integer,
                            CUSTOMER_UNIT_TYPE_ID integer,
                            PROVIDER_SYSTEM_ID    integer,
                            UNIT_PARENT_ID        integer,
                            UNIT_TOP_PARENT_ID    integer,
                            CUSTOMER_UNIT_NUMBER  varchar(50),
                            CUSTOMER_UNIT_NAME    varchar(50),
                            INSTALL_DATE          datetime)

   /* Insert Top Parent Unit into Temp table */
   insert into #TEMP_UNIT
   select cu.CUSTOMER_UNIT_ID,
          cu.CUSTOMER_ID,
          cut.CUSTOMER_UNIT_TYPE_ID,
          @ProviderSystemId,
          @UnitParentId,
          @CustomerUnitId,
          ISNULL( cu.CUSTOMER_UNIT_NUMBER, ISNULL( cun.CUSTOMER_UNIT_NUMBER, tpcun.CUSTOMER_UNIT_NUMBER ) ),
          ISNULL( cu.CUSTOMER_UNIT_NAME,   ISNULL( cun.CUSTOMER_UNIT_NAME,   tpcun.CUSTOMER_UNIT_NAME   ) ),
          cu.INSTALL_DATE
   from CUSTOMER_UNIT cu
   inner join      JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT jcutcu on cu.CUSTOMER_UNIT_ID                         = jcutcu.CUSTOMER_UNIT_ID
   left outer join CUSTOMER_UNIT_NAME cun                       on jcutcu.CUSTOMER_UNIT_NAME_ID                = cun.CUSTOMER_UNIT_NAME_ID
   left outer join TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME tpcun   on cun.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME_ID = tpcun.CUSTOMER_UNIT_NAME_ID
   inner join      CUSTOMER_UNIT_TYPE cut                       on jcutcu.CUSTOMER_UNIT_TYPE_ID                = cut.CUSTOMER_UNIT_TYPE_ID
   where cut.PROVIDER_SYSTEM_ID = @ProviderSystemId and
         cu.CUSTOMER_UNIT_ID = @CustomerUnitId

   /* Get count of direct descendants of Top Parent Unit */
   select @RowCount = count(*)
   from dbo.CUSTOMER_UNIT CU
   inner join dbo.JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT jcutcu on cu.CUSTOMER_UNIT_ID          = jcutcu.CUSTOMER_UNIT_ID
   inner join dbo.CUSTOMER_UNIT_TYPE cut                       on jcutcu.CUSTOMER_UNIT_TYPE_ID = cut.CUSTOMER_UNIT_TYPE_ID
   where cut.PROVIDER_SYSTEM_ID = @ProviderSystemId and
         cu.UNIT_PARENT_ID      = @CustomerUnitId

   /* If RowCount > 0 then execute recursive stored proc
      spGetCustomerUnitsBySystemUserParent. */
   if ( @RowCount > 00 ) begin

      execute spGetCustomerUnitsBySystemUserParent @ProviderSystemId, 00,
                                                   @CustomerUnitId,
                                                   @CustomerUnitId

   end

   /* Select reults from Temp table */
   select CUSTOMER_UNIT_ID,
          CUSTOMER_ID,
          CUSTOMER_UNIT_TYPE_ID,
          PROVIDER_SYSTEM_ID,
          UNIT_PARENT_ID,
          UNIT_TOP_PARENT_ID,
          CUSTOMER_UNIT_NUMBER,
          CUSTOMER_UNIT_NAME,
          convert( varchar( 10 ), INSTALL_DATE, 01 ) as INSTALL_DATE
   from #TEMP_UNIT
   order by UNIT_PARENT_ID,
            UNIT_TOP_PARENT_ID,
            CUSTOMER_UNIT_TYPE_ID,
            CUSTOMER_UNIT_ID

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetCustomerUnitsBySystemParent' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetCustomerUnitsBySystemParent

   go

create procedure spGetCustomerUnitsBySystemParent( @ProviderSystemId integer,
                                                   @UnitParentId     integer ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @RowsAffected integer /* Number of rows affected by the previously executed statement */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */
   declare @ReturnCode   integer /* Result code returned by the execution of the stored procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   CREATE TABLE #temp_unit (
   CUSTOMER_UNIT_ID integer,
   UNIT_PARENT_ID integer,
   UNIT_TOP_PARENT_ID integer,
   CUSTOMER_UNIT_TYPE_NAME varchar(50),
   CUSTOMER_UNIT_NAME varchar(50),
   CUSTOMER_UNIT_NUMBER varchar(50),
   PROVIDER_SERVICE_VALUE_ID integer)

   declare @serviceid integer
   SELECT @serviceid = MAX(COM_SERVICE_ID) FROM COM_SERVICE WHERE CUSTOMER_UNIT_ID = @UnitParentId

    /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   declare @unitid integer
   declare @unittypename varchar(50)
   declare @unitname varchar(50)
   declare @unitnumber varchar(50)
   declare @valueid integer

   declare UNIT_CURSOR cursor local for
   select a.CUSTOMER_UNIT_ID,
   isnull( c.customer_unit_type_name, d.customer_unit_type_name ),
   isnull( a.customer_unit_name, isnull( e.customer_unit_name, f.customer_unit_name ) ),
   isnull( a.customer_unit_number, isnull( e.customer_unit_number, f.customer_unit_number ) ),
   PROVIDER_SERVICE_VALUE_ID
   from customer_unit a
   left outer join join_customer_unit_type_customer_unit b on a.customer_unit_id = b.customer_unit_id
   left outer join customer_unit_type c on b.customer_unit_type_id = c.customer_unit_type_id
   left outer join template_provider_customer_unit_type d on c.template_provider_customer_unit_type_id = d.customer_unit_type_id
   left outer join customer_unit_name e on b.customer_unit_name_id = e.customer_unit_name_id
   left outer join template_provider_customer_unit_name f on e.template_provider_customer_unit_name_id = f.customer_unit_name_id
   left outer join com_service_unit_value g on a.customer_unit_id = g.customer_unit_id and g.com_service_id = @serviceid
   where c.provider_system_id = @ProviderSystemId
   and a.customer_unit_id = @UnitParentId

    /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if (  @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   OPEN UNIT_CURSOR
   FETCH NEXT FROM UNIT_CURSOR INTO
   @unitid,
   @unittypename,
   @unitname,
   @unitnumber,
   @valueid

   WHILE ( @@FETCH_STATUS = 0 ) BEGIN

      insert into #temp_unit
      VALUES(
      @unitid,
      -1,
      -1,
      @unittypename,
      @unitname,
      @unitnumber,
      @valueid)

      execute @ReturnCode = spGetCustomerUnitsBySystemParentParent @ProviderSystemId, @unitid, @unitid, @serviceid

      /* If there was an error... */
      if ( @ReturnCode <> 00 ) begin

        /* Return the failure. */
         return @ReturnCode

      end

      FETCH NEXT FROM UNIT_CURSOR INTO
      @unitid,
      @unittypename,
      @unitname,
      @unitnumber,
      @valueid

   END

   CLOSE UNIT_CURSOR
   DEALLOCATE UNIT_CURSOR

   SELECT
   CUSTOMER_UNIT_ID,
   UNIT_PARENT_ID,
   UNIT_TOP_PARENT_ID,
   CUSTOMER_UNIT_TYPE_NAME,
   CUSTOMER_UNIT_NAME,
   CUSTOMER_UNIT_NUMBER,
   PROVIDER_SERViCE_VALUE_ID
   FROM #temp_unit

    /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

    /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetCustomerUnitsBySystemParentParent' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetCustomerUnitsBySystemParentParent

   go

create procedure spGetCustomerUnitsBySystemParentParent( @ProviderSystemId integer,
                                                         @parentid         integer,
                                                         @topparentid      integer,
                                                         @serviceid        integer = NULL ) as

   declare @unitid integer
   declare @unittypename varchar(50)
   declare @unitname varchar(50)
   declare @unitnumber varchar(50)
   declare @valueid integer
   declare @ReturnCode   integer /* Result code returned by the execution of the stored procedure */
   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

    /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   declare CHILD_CURSOR cursor local for
   select a.CUSTOMER_UNIT_ID,
   isnull( c.customer_unit_type_name, d.customer_unit_type_name ),
   isnull( a.customer_unit_name, isnull( e.customer_unit_name, f.customer_unit_name ) ),
   isnull( a.customer_unit_number, isnull( e.customer_unit_number, f.customer_unit_number ) ),
   PROVIDER_SERVICE_VALUE_ID
   from customer_unit a
   left outer join join_customer_unit_type_customer_unit b on a.customer_unit_id = b.customer_unit_id
   left outer join customer_unit_type c on b.customer_unit_type_id = c.customer_unit_type_id
   left outer join template_provider_customer_unit_type d on c.template_provider_customer_unit_type_id = d.customer_unit_type_id
   left outer join customer_unit_name e on b.customer_unit_name_id = e.customer_unit_name_id
   left outer join template_provider_customer_unit_name f on e.template_provider_customer_unit_name_id = f.customer_unit_name_id
   left outer join com_service_unit_value g on a.customer_unit_id = g.customer_unit_id and g.com_service_id = @serviceid
   where c.provider_system_id = @ProviderSystemId
   and a.unit_parent_id = @parentid

   OPEN CHILD_CURSOR

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   FETCH NEXT FROM CHILD_CURSOR INTO
   @unitid,
   @unittypename,
   @unitname,
   @unitnumber,
   @valueid

   WHILE ( @@FETCH_STATUS = 0 ) BEGIN

      insert into #temp_unit
      VALUES(
      @unitid,
      @parentid,
      @topparentid,
      @unittypename,
      @unitname,
      @unitnumber,
      @valueid)

      execute @ReturnCode = spGetCustomerUnitsBySystemParentParent @ProviderSystemid, @unitid, @topparentid, @serviceid

      /* If there was an error... */
      if ( @ReturnCode <> 00 ) begin

         /* Return the failure. */
         return @ReturnCode

      end

      FETCH NEXT FROM CHILD_CURSOR INTO
      @unitid,
      @unittypename,
      @unitname,
      @unitnumber,
      @valueid

   END

   CLOSE CHILD_CURSOR
   DEALLOCATE CHILD_CURSOR

    /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetCustomerUnitsBySystemUser' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetCustomerUnitsBySystemUser

   go

create procedure spGetCustomerUnitsBySystemUser( @ProviderSystemId integer,
                                                 @MemberUserId     integer,
                                                 @UnitParentId     integer=-1 ) as

   set nocount on

   create table #TEMP_UNIT(
                CUSTOMER_UNIT_ID integer,
                CUSTOMER_ID integer,
                CUSTOMER_UNIT_TYPE_ID integer,
                PROVIDER_SYSTEM_ID integer,
                UNIT_PARENT_ID integer,
                UNIT_TOP_PARENT_ID integer,
                CUSTOMER_UNIT_NUMBER varchar(50),
                CUSTOMER_UNIT_NAME varchar(50),
                INSTALL_DATE datetime)

   declare @UnitId integer,
           @UnitName varchar(50),
           @UnitNumber varchar(50),
           @UnitTypeId integer,
           @CustomerId integer,
           @InstallDate datetime,
           @RowCount integer

   declare parent_cursor cursor local fast_forward for
   select distinct cu.CUSTOMER_UNIT_ID,
                   ISNULL( cu.CUSTOMER_UNIT_NAME,   ISNULL( cun.CUSTOMER_UNIT_NAME,   tpcun.CUSTOMER_UNIT_NAME   ) ) as CUSTOMER_UNIT_NAME,
                   ISNULL( cu.CUSTOMER_UNIT_NUMBER, ISNULL( cun.CUSTOMER_UNIT_NUMBER, tpcun.CUSTOMER_UNIT_NUMBER ) ) as CUSTOMER_UNIT_NUMBER,
                   cut.CUSTOMER_UNIT_TYPE_ID,
                   cu.CUSTOMER_ID,
                   cu.INSTALL_DATE
   from CUSTOMER_UNIT cu
   inner join JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT jcutcu on cu.CUSTOMER_UNIT_ID = jcutcu.CUSTOMER_UNIT_ID
   left join CUSTOMER_UNIT_NAME cun on jcutcu.CUSTOMER_UNIT_NAME_ID = cun.CUSTOMER_UNIT_NAME_ID
   left join TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME tpcun on cun.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME_ID = tpcun.CUSTOMER_UNIT_NAME_ID
   inner join CUSTOMER_UNIT_TYPE cut on jcutcu.CUSTOMER_UNIT_TYPE_ID = cut.CUSTOMER_UNIT_TYPE_ID
   inner join JOIN_MEMBER_GROUP_CUSTOMER_UNIT jmgcu on ( cu.UNIT_PARENT_ID = jmgcu.CUSTOMER_UNIT_ID ) or ( cu.CUSTOMER_UNIT_ID = jmgcu.CUSTOMER_UNIT_ID )
   inner join JOIN_MEMBER_GROUP_USER jmgu on jmgcu.MEMBER_GROUP_ID = jmgu.MEMBER_GROUP_ID
   where jmgu.MEMBER_USER_ID = @MemberUserId
   AND cut.PROVIDER_SYSTEM_ID = @ProviderSystemId
   AND cu.UNIT_PARENT_ID = @UnitParentId

   open parent_cursor
   fetch next from parent_cursor into
   @UnitId,
   @UnitName,
   @UnitNumber,
   @UnitTypeId,
   @CustomerId,
   @InstallDate

   while ( @@Fetch_Status = 0 ) begin

      insert into #TEMP_UNIT
      values(
         @UnitId,
         @CustomerId,
         @UnitTypeId,
         @ProviderSystemId,
         @UnitParentId,
         -1,
         @UnitNumber,
         @UnitName,
         @InstallDate)

      select @RowCount = count(*)
      from dbo.CUSTOMER_UNIT CU
      inner join dbo.JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT jcutcu on cu.CUSTOMER_UNIT_ID = jcutcu.CUSTOMER_UNIT_ID
      inner join dbo.CUSTOMER_UNIT_TYPE cut on jcutcu.CUSTOMER_UNIT_TYPE_ID = cut.CUSTOMER_UNIT_TYPE_ID
      where cut.PROVIDER_SYSTEM_ID = @ProviderSystemId
      and cu.UNIT_PARENT_ID = @UnitId

      if @RowCount > 0 begin

         execute spGetCustomerUnitsBySystemUserParent @ProviderSystemId, @MemberUserId, @UnitId, @UnitId

      end

      fetch next from parent_cursor into
      @UnitId,
      @UnitName,
      @UnitNumber,
      @UnitTypeId,
      @CustomerId,
      @InstallDate

   end

   close parent_cursor
   deallocate parent_cursor

   select
   CUSTOMER_UNIT_ID,
   CUSTOMER_ID,
   CUSTOMER_UNIT_TYPE_ID,
   PROVIDER_SYSTEM_ID,
   UNIT_PARENT_ID,
   UNIT_TOP_PARENT_ID,
   CUSTOMER_UNIT_NUMBER,
   CUSTOMER_UNIT_NAME,
   convert( varchar( 10 ), INSTALL_DATE, 01 ) as INSTALL_DATE
   from #TEMP_UNIT
   order by PROVIDER_SYSTEM_ID, CUSTOMER_ID, UNIT_TOP_PARENT_ID, UNIT_PARENT_ID, CUSTOMER_UNIT_ID

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetCustomerUnitsBySystemUserParent' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetCustomerUnitsBySystemUserParent

   go

create procedure spGetCustomerUnitsBySystemUserParent( @ProviderSystemId    integer,
                                                       @MemberUserId        integer,
                                                       @ParentId            integer,
                                                       @TopParentId         integer ) as

   declare @UnitId integer
   declare @UnitName varchar(50)
   declare @UnitNumber varchar(50)
   declare @UnitTypeId integer
   declare @CustomerId integer
   declare @InstallDate datetime
   declare @RowCount integer

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   set nocount on

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   declare child_cursor cursor local fast_forward for
   select distinct cu.CUSTOMER_UNIT_ID,
          ISNULL( cu.CUSTOMER_UNIT_NAME,   ISNULL( cun.CUSTOMER_UNIT_NAME,   tpcun.CUSTOMER_UNIT_NAME   ) ) as CUSTOMER_UNIT_NAME,
	  ISNULL( cu.CUSTOMER_UNIT_NUMBER, ISNULL( cun.CUSTOMER_UNIT_NUMBER, tpcun.CUSTOMER_UNIT_NUMBER ) ) as CUSTOMER_UNIT_NUMBER,
	  cut.CUSTOMER_UNIT_TYPE_ID,
	  cu.CUSTOMER_ID,
          cu.INSTALL_DATE
   from dbo.CUSTOMER_UNIT CU
   inner join dbo.JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT jcutcu on cu.CUSTOMER_UNIT_ID = jcutcu.CUSTOMER_UNIT_ID
   left join dbo.CUSTOMER_UNIT_NAME cun on jcutcu.CUSTOMER_UNIT_NAME_ID = cun.CUSTOMER_UNIT_NAME_ID
   left join dbo.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME tpcun on cun.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME_ID = tpcun.CUSTOMER_UNIT_NAME_ID
   inner join dbo.CUSTOMER_UNIT_TYPE cut on jcutcu.CUSTOMER_UNIT_TYPE_ID = cut.CUSTOMER_UNIT_TYPE_ID
   where cut.PROVIDER_SYSTEM_ID = @ProviderSystemId
   and cu.UNIT_PARENT_ID = @ParentId

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   open child_cursor

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   fetch next from child_cursor into
   @UnitId,
   @UnitName,
   @UnitNumber,
   @UnitTypeId,
   @CustomerId,
   @InstallDate

   while ( @@Fetch_Status = 0 ) begin

      insert into #TEMP_UNIT
      values(
      @UnitId,
      @CustomerId,
      @UnitTypeId,
      @ProviderSystemId,
      @ParentId,
      @TopParentId,
      @UnitNumber,
      @UnitName,
      @InstallDate)

      select @RowCount = count(*)
      from dbo.CUSTOMER_UNIT CU
      inner join dbo.JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT jcutcu on cu.CUSTOMER_UNIT_ID = jcutcu.CUSTOMER_UNIT_ID
      inner join dbo.CUSTOMER_UNIT_TYPE cut on jcutcu.CUSTOMER_UNIT_TYPE_ID = cut.CUSTOMER_UNIT_TYPE_ID
      where cut.PROVIDER_SYSTEM_ID = @ProviderSystemId
      and cu.UNIT_PARENT_ID = @UnitId

      /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
      select @ErrorCode = @@Error

      /* If there was an error... */
      if ( @ErrorCode <> 00 ) begin

         /* Rollback the transaction. */
         rollback transaction

         /* Return the failure. */
         return 01

     end


      if @RowCount > 0 begin

         execute spGetCustomerUnitsBySystemUserParent @ProviderSystemId, @MemberUserId, @UnitId, @TopParentId

      end

      /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
      select @ErrorCode = @@Error

      /* If there was an error... */
      if ( @ErrorCode <> 00 ) begin

         /* Rollback the transaction. */
         rollback transaction

         /* Return the failure. */
         return 01

      end

      fetch next from child_cursor into
      @UnitId,
      @UnitName,
      @UnitNumber,
      @UnitTypeId,
      @CustomerId,
      @InstallDate

   end

   close child_cursor
   deallocate child_cursor

      /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetCustomerUnitsByUnitType' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetCustomerUnitsByUnitType

   go

create procedure spGetCustomerUnitsByUnitType( @ParentId              integer,
                                               @TopParentId           integer,
                                               @CustomerUnitTypeId    integer,
                                               @UnitTypeIds           varchar(500),
                                               @UserUnitTypeId        integer ) as

   declare @CustomerUnitId integer
   declare @CustomerUnitName varchar(100)
   declare @CustomerUnitTypeName varchar(50)
   declare @ParentUnitName varchar(100)
   declare @ParentUnitTypeName varchar(50)
   declare @ChildUnitTypeId integer
   declare @ParentUnitTypeId integer
   declare @RowCount integer
   declare @FindUnitTypeId integer
   declare @Pos integer

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */
   declare @ReturnCode   integer /* Result code returned by the execution of the stored procedure */

    /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   declare child_cursor cursor local fast_forward for
      select cu.customer_unit_id,
      ISNULL( cu.CUSTOMER_UNIT_NAME,   ISNULL( cun.CUSTOMER_UNIT_NAME,   tpcun.CUSTOMER_UNIT_NAME   ) ) as CUSTOMER_UNIT_NAME,
      ISNULL( cut.CUSTOMER_UNIT_TYPE_NAME, tpcut.CUSTOMER_UNIT_TYPE_NAME ) as CUSTOMER_UNIT_TYPE_NAME,
      ISNULL( pu.CUSTOMER_UNIT_NAME,   ISNULL( pun.CUSTOMER_UNIT_NAME,   tppun.CUSTOMER_UNIT_NAME   ) ) as PARENT_UNIT_NAME,
      ISNULL( put.CUSTOMER_UNIT_TYPE_NAME, tpput.CUSTOMER_UNIT_TYPE_NAME ) as PARENT_UNIT_TYPE_NAME
      from
      customer_unit cu
      inner join dbo.JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT jcutcu on cu.CUSTOMER_UNIT_ID = jcutcu.CUSTOMER_UNIT_ID
      inner join dbo.CUSTOMER_UNIT_TYPE cut on cut.customer_unit_type_id = jcutcu.customer_unit_type_id
      left outer join dbo.TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE tpcut on cut.template_provider_customer_unit_type_id = tpcut.CUSTOMER_UNIT_TYPE_ID
      left outer join dbo.CUSTOMER_UNIT_NAME cun on jcutcu.CUSTOMER_UNIT_NAME_ID = cun.CUSTOMER_UNIT_NAME_ID
      left outer join dbo.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME tpcun on cun.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME_ID = tpcun.CUSTOMER_UNIT_NAME_ID

      inner join customer_unit pu on cu.unit_parent_id = pu.customer_unit_id
      inner join dbo.JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT jputpu on pu.CUSTOMER_UNIT_ID = jputpu.CUSTOMER_UNIT_ID
      inner join dbo.CUSTOMER_UNIT_TYPE put on put.customer_unit_type_id = jputpu.customer_unit_type_id and cut.provider_system_id = put.provider_system_id
      left outer join dbo.TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE tpput on put.template_provider_customer_unit_type_id = tpput.CUSTOMER_UNIT_TYPE_ID
      left outer join dbo.CUSTOMER_UNIT_NAME pun on jputpu.CUSTOMER_UNIT_NAME_ID = pun.CUSTOMER_UNIT_NAME_ID
      left outer join dbo.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME tppun on pun.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME_ID = tppun.CUSTOMER_UNIT_NAME_ID

      where ( cu.unit_parent_id            = @ParentId   )
        and ( jcutcu.CUSTOMER_UNIT_TYPE_ID = @CustomerUnitTypeId )

      /* Get the error code for the previous statement.
         Error checking MUST be done this way since any single statement executed
         will affect both of the global functions,  @@Error. */
      select @ErrorCode = @@Error

      /* If there was an error... */
      if ( @ErrorCode <> 00 ) begin

         /* Rollback the transaction. */
         rollback transaction

         /* Return the failure. */
         return 01

      end

   open child_cursor fetch next from child_cursor into @CustomerUnitId,
                                                       @CustomerUnitName,
                                                       @CustomerUnitTypeName,
                                                       @ParentUnitName,
                                                       @ParentUnitTypeName

   if @UnitTypeIds <> '' begin
      set @Pos = CHARINDEX(',',@UnitTypeIds)
      set @UnitTypeIds = SUBSTRING(@UnitTypeIds, @Pos+1, LEN(@UnitTypeIds) - @Pos )
   end

   while ( @@Fetch_Status = 0 ) begin
      if @CustomerUnitTypeId = @UserUnitTypeId begin
         insert into #TEMP_UNIT
         values(@CustomerUnitId,
                @TopParentId,
                @CustomerUnitName,
                @CustomerUnitTypeName,
                @ParentUnitName,
                @ParentUnitTypeName )
      end

      if @UnitTypeIds <> '' begin
         set @Pos = CHARINDEX(',',@UnitTypeIds)
         set @FindUnitTypeId = CAST( SUBSTRING(@UnitTypeIds, 1, @Pos-1 )  as integer )

      end
      else
         set @FindUnitTypeId = 0

      if @FindUnitTypeId > 0 begin

         /*get children of the next unit type in the hierarchy*/
         select @RowCount = count(*)
         from dbo.CUSTOMER_UNIT CU
         inner join dbo.JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT jcutcu on cu.CUSTOMER_UNIT_ID = jcutcu.CUSTOMER_UNIT_ID
         where cu.UNIT_PARENT_ID      = @CustomerUnitId
         and jcutcu.CUSTOMER_UNIT_TYPE_ID = @FindUnitTypeId

         /* Get the error code for the previous statement.
            Error checking MUST be done this way since any single statement executed
            will affect both of the global functions,  @@Error. */
         select @ErrorCode = @@Error

         /* If there was an error... */
         if ( @ErrorCode <> 00 ) begin

            /* Rollback the transaction. */
            rollback transaction

            /* Return the failure. */
            return 01

         end

         if @RowCount > 0 begin
            /* pass the top parent, the unit type looking for and the other unit types looking for */
           execute @ReturnCode = spGetCustomerUnitsByUnitType @CustomerUnitId, @TopParentId, @FindUnitTypeId, @UnitTypeIds, @UserUnitTypeId
           /* If there was an error... */
           if ( @ReturnCode <> 00 ) begin

              /* Return the failure. */
              return @ReturnCode
           end

         end

      end

      fetch next from child_cursor into @CustomerUnitId,
                                        @CustomerUnitName,
                                        @CustomerUnitTypeName,
                                        @ParentUnitName,
                                        @ParentUnitTypeName

   end

   close child_cursor
   deallocate child_cursor

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetCustomerUnitsByUnitTypeCustomer' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetCustomerUnitsByUnitTypeCustomer

   go

create procedure spGetCustomerUnitsByUnitTypeCustomer( @CustomerId         integer,
                                                       @CustomerUnitTypeId integer ) as

   set nocount on

   declare @SqlSelect varchar(4000)
   declare @SqlFrom varchar(4000)
   declare @SqlFrom2 varchar(4000)
   declare @SqlIn varchar(4000)
   declare @Comma char(1)
   declare @i integer
   declare @ParentUnitTypeId integer
   declare @PrevUnitTypeName varchar(100)
   declare @UnitTypeName varchar(100)
   declare @SystemName varchar(100)
   declare @SystemId integer
   declare @ChildUnitTypeId integer
   declare @RowCount integer
   declare @TempTable varchar(4000)
   declare @SelectUnitValues varchar(4000)
   declare @OrderBy varchar(4000)

   declare @UnitTypeTable table ( UnitTypeId integer )

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   set @SqlIn = ''
   set @Comma = ','

   set @ChildUnitTypeId = @CustomerUnitTypeId

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   select @SystemId = cut.provider_system_id,
          @SystemName = ISNULL(ps.PROVIDER_SYSTEM_NAME, tps.PROVIDER_SYSTEM_NAME )
   from customer_unit_type cut
   inner join provider_system ps on cut.provider_system_id = ps.provider_system_id
   left outer join dbo.TEMPLATE_PROVIDER_SYSTEM tps on ps.TEMPLATE_PROVIDER_SYSTEM_ID = tps.PROVIDER_SYSTEM_ID
   where cut.customer_unit_type_id = @ChildUnitTypeId

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   while (@ChildUnitTypeId > 0 ) begin
      insert into @UnitTypeTable values ( @ChildUnitTypeId )
      select @ParentUnitTypeId = customer_unit_type_parent_id
      from customer_unit_type
      where customer_unit_type_id = @ChildUnitTypeId

       /* If there was an error... */
      if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end
      set @ChildUnitTypeId = @ParentUnitTypeId

   end

   set @SqlSelect = ' select m.member_name as MEMBER_NAME '
   set @SqlSelect = @SqlSelect + ', ''' + @SystemName + ''' as PROVIDER_SYSTEM_NAME '

   set @SqlFrom   = ' from member m '

   set @SqlFrom2 = ' '

   set @i = 1

   select @RowCount = count(*) from @UnitTypeTable

   set @TempTable = 'declare @TempUnit table ( MEMBER_NAME varchar(100), PROVIDER_SYSTEM_NAME varchar(100), '
   set @OrderBy = 'order by MEMBER_NAME, '

   declare unit_type_cursor cursor for
      select cut.customer_unit_type_id,
         isnull(cut.customer_unit_type_name, tpcut.customer_unit_type_name) as customer_unit_type_name
      from customer_unit_type cut
      left outer join template_provider_customer_unit_type tpcut on cut.template_provider_customer_unit_type_id = tpcut.customer_unit_type_id
      inner join @UnitTypeTable utt on cut.customer_unit_type_id = utt.UnitTypeId
      where cut.provider_system_id =  @SystemId
      order by cut.customer_unit_type_parent_id, cut.customer_unit_type_id

   open unit_type_cursor

    /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   fetch next from unit_type_cursor into
   @ParentUnitTypeId, @UnitTypeName

   while (@@fetch_status = 00) begin

      if ( @i = 1 ) begin
         set @TempTable = @TempTable + 'TOP_PARENT_UNIT_TYPE_NAME varchar(50), TOP_PARENT_UNIT_NAME varchar(100), TOP_PARENT_UNIT_ID integer '
         set @SqlSelect = @SqlSelect + ', ''' + @UnitTypeName + ''' as [TOP_PARENT_UNIT_TYPE_NAME], '
         select @UnitTypeName = Replace(@UnitTypeName, ' ', '_')
         set @SqlSelect = @SqlSelect + 'isnull([' + @UnitTypeName + '_cu].customer_unit_name, isnull([' + @UnitTypeName + '_cun].customer_unit_name, [' + @UnitTypeName + '_tpcun].customer_unit_name)) as [TOP_PARENT_UNIT_NAME], '
         set @SqlSelect = @SqlSelect + '[' + @UnitTypeName + '_cu].customer_unit_id as [TOP_PARENT_UNIT_ID] '
         set @OrderBy = @OrderBy + ' TOP_PARENT_UNIT_NAME '
      end

      if ( @i = @RowCount ) begin
         set @TempTable = @TempTable + ', CUSTOMER_UNIT_TYPE_NAME varchar(50), CUSTOMER_UNIT_NAME varchar(100), CUSTOMER_UNIT_ID integer '
         set @SqlSelect = @SqlSelect + ', ''' + @UnitTypeName + ''' as [CUSTOMER_UNIT_TYPE_NAME], '
         select @UnitTypeName = Replace(@UnitTypeName, ' ', '_')
         set @SqlSelect = @SqlSelect + 'isnull([' + @UnitTypeName + '_cu].customer_unit_name, isnull([' + @UnitTypeName + '_cun].customer_unit_name, [' + @UnitTypeName + '_tpcun].customer_unit_name)) as [CUSTOMER_UNIT_NAME], '
         set @SqlSelect = @SqlSelect + '[' + @UnitTypeName + '_cu].customer_unit_id as [CUSTOMER_UNIT_ID] '
         set @OrderBy = @OrderBy + ', CUSTOMER_UNIT_NAME '
      end
      else if ( @i = (@RowCount-1) ) begin
         set @TempTable = @TempTable + ', PARENT_UNIT_TYPE_NAME 
varchar(50), PARENT_UNIT_NAME varchar(100), PARENT_UNIT_ID integer '
         set @SqlSelect = @SqlSelect + ', ''' + @UnitTypeName + ''' as [PARENT_UNIT_TYPE_NAME], '
         select @UnitTypeName = Replace(@UnitTypeName, ' ', '_')
         set @SqlSelect = @SqlSelect + 'isnull([' + @UnitTypeName + '_cu].customer_unit_name, isnull([' + @UnitTypeName + '_cun].customer_unit_name, [' + @UnitTypeName + '_tpcun].customer_unit_name)) as [PARENT_UNIT_NAME], '
         set @SqlSelect = @SqlSelect + '[' + @UnitTypeName + '_cu].customer_unit_id as [PARENT_UNIT_ID] '
         set @OrderBy = @OrderBy + ', PARENT_UNIT_NAME '
      end
      else if ( @i <> 1 ) begin
         set @TempTable = @TempTable + ', [PARENT' + cast((@i-1) as char(1)) + '_UNIT_TYPE_NAME] varchar(50), [PARENT' + cast((@i-1) as char(1)) + '_UNIT_NAME] varchar(100), [PARENT' + cast((@i-1) as char(1)) + '_UNIT_ID] integer '
         set @SqlSelect = @SqlSelect + ', ''' + @UnitTypeName + ''' as [PARENT' + cast((@i-1) as char(1)) + '_UNIT_TYPE_NAME], '
         select @UnitTypeName = Replace(@UnitTypeName, ' ', '_')
         set @SqlSelect = @SqlSelect + 'isnull([' + @UnitTypeName + '_cu].customer_unit_name, isnull([' + @UnitTypeName + '_cun].customer_unit_name, [' + @UnitTypeName + '_tpcun].customer_unit_name)) as [PARENT' + cast((@i-1) as char(1)) + '_UNIT_NAME], '
         set @SqlSelect = @SqlSelect + '[' + @UnitTypeName + '_cu].customer_unit_id as [PARENT' + cast((@i-1) as char(1)) + '_UNIT_ID] '
         set @OrderBy = @OrderBy + ', [PARENT' + cast((@i-1) as char(1)) + '_UNIT_NAME] '
      end

      set @SqlFrom = @SqlFrom + ' inner join customer_unit [' + @UnitTypeName + '_cu] on m.member_id = [' + @UnitTypeName + '_cu].customer_id '

      if @PrevunitTypeName is not null begin
         set @SqlFrom = @SqlFrom + ' and [' + @PrevUnitTypeName + '_cu].customer_unit_id = [' + @UnitTypeName + '_cu].unit_parent_id '
      end

      set @SqlFrom = @SqlFrom + ' inner join join_customer_unit_type_customer_unit [' + @UnitTypeName + '_jcutcu] on [' + @UnitTypeName + '_cu].customer_unit_id = [' + @UnitTypeName + '_jcutcu].customer_unit_id '

      set @SqlFrom = @SqlFrom  + ' inner join customer_unit_type [' + @UnitTypeName + '_cut] on [' + @UnitTypeName + '_jcutcu].customer_unit_type_id = [' + @UnitTypeName + '_cut].customer_unit_type_id and [' + @UnitTypeName + '_cut].customer_unit_type_id = '
                               + cast(@ParentUnitTypeId as varchar(10)) + ' and [' + @UnitTypeName + '_cut].provider_system_id = ' + cast( @SystemId as varchar(10) )
      set @SqlFrom2 = @SqlFrom2 + ' left outer join template_provider_customer_unit_type [' + @UnitTypeName + '_tpcut] on [' + @UnitTypeName + '_cut].template_provider_customer_unit_type_id = [' + @UnitTypeName + '_tpcut].customer_unit_type_id '
      set @SqlFrom2 = @SqlFrom2 + ' left outer join customer_unit_name [' + @UnitTypeName + '_cun] on [' + @UnitTypeName + '_jcutcu].customer_unit_name_id = [' + @UnitTypeName + '_cun].customer_unit_name_id '
      set @SqlFrom2 = @SqlFrom2 + ' left outer join template_provider_customer_unit_name [' + @UnitTypeName + '_tpcun] on [' + @UnitTypeName + '_cun].template_provider_customer_unit_name_id = [' + @UnitTypeName + '_tpcun].customer_unit_name_id '

      set @PrevUnitTypeName = @UnitTypeName
      set @i = @i + 1

      fetch next from unit_type_cursor into
      @ParentUnitTypeId, @UnitTypeName

   end

   close unit_type_cursor
   deallocate unit_type_cursor

   set @TempTable = @TempTable + ' ) '
   set @SqlFrom2 = @SqlFrom2 + ' where m.member_id =' + cast(@CustomerId as varchar(10))

   set @SelectUnitValues = ' select tu.*, '
   set @SelectUnitValues = @SelectUnitValues + 'cs.COM_SERVICE_DATE, '
   set @SelectUnitValues = @SelectUnitValues + 'ISNULL(psv.PROVIDER_SERVICE_VALUE, tpsv.PROVIDER_SERVICE_VALUE) as PROVIDER_SERVICE_VALUE, '
   set @SelectUnitValues = @SelectUnitValues + 'ISNULL(psv.PROVIDER_SERVICE_VALUE_TEXT, tpsv.PROVIDER_SERVICE_VALUE_TEXT) as PROVIDER_SERVICE_VALUE_TEXT '
   set @SelectUnitValues = @SelectUnitValues + 'from @TempUnit tu ' +
                                               'left outer join ( ' +
                                                       'select max(a.COM_SERVICE_UNIT_VALUE_ID) as COM_SERVICE_UNIT_VALUE_ID, a.CUSTOMER_UNIT_ID ' +
                                                       'from COM_SERVICE_UNIT_VALUE a, CUSTOMER_UNIT b ' +
                                                       'where a.CUSTOMER_UNIT_ID = b.CUSTOMER_UNIT_ID ' +
                                                         'and b.CUSTOMER_ID = ' + cast(@CustomerId  as varchar(10)) +
                                                       'group by a.CUSTOMER_UNIT_ID ) lastservice on tu.customer_unit_id = lastservice.customer_unit_id '
   set @SelectUnitValues = @SelectUnitValues + 'left outer join com_service_unit_value csuv on csuv.customer_unit_id = tu.customer_unit_id ' +
                                                                                           'and lastservice.com_service_unit_value_id = csuv.com_service_unit_value_id '
   set @SelectUnitValues = @SelectUnitValues + 'left outer join dbo.COM_SERVICE cs on csuv.com_service_id = cs.com_service_id ' +
                                                                                     'and cs.customer_unit_id = tu.TOP_PARENT_UNIT_ID '
   set @SelectUnitValues = @SelectUnitValues + 'left outer join dbo.PROVIDER_SERVICE_VALUE psv on csuv.PROVIDER_SERVICE_VALUE_ID = psv.PROVIDER_SERVICE_VALUE_ID '
   set @SelectUnitValues = @SelectUnitValues + 'left outer join dbo.TEMPLATE_PROVIDER_SERVICE_VALUE tpsv on psv.TEMPLATE_PROVIDER_SERVICE_VALUE_ID = tpsv.PROVIDER_SERVICE_VALUE_ID '

   set @SelectUnitValues = @SelectUnitValues + @OrderBy

   exec( @TempTable + ' insert into @TempUnit ' + @SqlSelect + @SqlFrom + @SqlFrom2 + @SelectUnitValues )

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

    /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetCustomerUnitsByUnitTypeCustomerExport' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetCustomerUnitsByUnitTypeCustomerExport

   go

create procedure spGetCustomerUnitsByUnitTypeCustomerExport( @CustomerId integer,
                                                             @CustomerUnitTypeId integer ) as

   set nocount on

   declare @Sql varchar(4000)
   declare @SqlSelect varchar(4000)
   declare @SqlFrom varchar(4000)
   declare @SqlFrom2 varchar(4000)
   declare @SqlIn varchar(4000)
   declare @Comma char(1)
   declare @i integer
   declare @ParentUnitTypeId integer
   declare @PrevUnitTypeName varchar(100)
   declare @UnitTypeName varchar(100)
   declare @SystemName varchar(100)
   declare @SystemId integer
   declare @ChildUnitTypeId integer

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   declare @UnitTypeTable table ( UnitTypeId integer )

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   set @SqlIn = ''
   set @Comma = ','

   set @ChildUnitTypeId = @CustomerUnitTypeId

   select @SystemId = cut.provider_system_id,
          @SystemName = ISNULL(ps.PROVIDER_SYSTEM_NAME, tps.PROVIDER_SYSTEM_NAME )
   from customer_unit_type cut
   inner join provider_system ps on cut.provider_system_id = ps.provider_system_id
   left outer join dbo.TEMPLATE_PROVIDER_SYSTEM tps on ps.TEMPLATE_PROVIDER_SYSTEM_ID = tps.PROVIDER_SYSTEM_ID
   where cut.customer_unit_type_id = @ChildUnitTypeId

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   while (@ChildUnitTypeId > 0 ) begin
      insert into @UnitTypeTable values ( @ChildUnitTypeId )
      select @ParentUnitTypeId = customer_unit_type_parent_id
      from customer_unit_type
      where customer_unit_type_id = @ChildUnitTypeId

      /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
      select @ErrorCode = @@Error

      /* If there was an error... */
      if ( @ErrorCode <> 00 ) begin

         /* Rollback the transaction. */
         rollback transaction

         /* Return the failure. */
         return 01

      end

      set @ChildUnitTypeId = @ParentUnitTypeId

   end

   set @SqlSelect = ' select m.member_name as CustomerName '
   set @SqlSelect = @SqlSelect + ', ''' + @SystemName + ''' as System '

   set @SqlFrom   = ' from member m '

   set @SqlFrom2 = ' '

   set @i = 1

   declare unit_type_cursor cursor for
      select cut.customer_unit_type_id,
         isnull(cut.customer_unit_type_name, tpcut.customer_unit_type_name) as customer_unit_type_name
      from customer_unit_type cut
      left outer join template_provider_customer_unit_type tpcut on cut.template_provider_customer_unit_type_id = tpcut.customer_unit_type_id
      inner join @UnitTypeTable utt on cut.customer_unit_type_id = utt.UnitTypeId
      where cut.provider_system_id =  @SystemId
      order by cut.customer_unit_type_parent_id, cut.customer_unit_type_id

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   open unit_type_cursor

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   fetch next from unit_type_cursor into
   @CustomerUnitTypeId, @UnitTypeName

   while (@@fetch_status = 00) begin

      set @SqlSelect = @SqlSelect + ', ''' + @UnitTypeName + ''' as [Field' + cast(@i as char(1)) + '] '

      select @UnitTypeName = Replace(@UnitTypeName, ' ', '_')

      set @SqlSelect = @SqlSelect + ', isnull([' + @UnitTypeName + '_cu].customer_unit_name, isnull([' + @UnitTypeName + '_cun].customer_unit_name, [' + @UnitTypeName + '_tpcun].customer_unit_name)) as [Field' + cast(@i as char(1)) + '_Name], '
      set @SqlSelect = @SqlSelect + ' isnull([' + @UnitTypeName + '_cu].customer_unit_number, isnull([' + @UnitTypeName + '_cun].customer_unit_number, [' + @UnitTypeName + '_tpcun].customer_unit_number)) as [Field' + cast(@i as char(1)) + '_Barcode], '
      set @SqlSelect = @SqlSelect + '[' + @UnitTypeName + '_cu].customer_unit_id as [Field' + cast(@i as char(1)) + '_id_id] '

      set @SqlFrom = @SqlFrom + ' inner join customer_unit [' + @UnitTypeName + '_cu] on m.member_id = [' + @UnitTypeName + '_cu].customer_id '

      if @PrevunitTypeName is not null begin
         set @SqlFrom = @SqlFrom + ' and [' + @PrevUnitTypeName + '_cu].customer_unit_id = [' + @UnitTypeName + '_cu].unit_parent_id '
      end

      set @SqlFrom = @SqlFrom + ' inner join join_customer_unit_type_customer_unit [' + @UnitTypeName + '_jcutcu] on [' + @UnitTypeName + '_cu].customer_unit_id = [' + @UnitTypeName + '_jcutcu].customer_unit_id '

      set @SqlFrom = @SqlFrom  + ' inner join customer_unit_type [' + @UnitTypeName + '_cut] on [' + @UnitTypeName + '_jcutcu].customer_unit_type_id = [' + @UnitTypeName + '_cut].customer_unit_type_id and [' + @UnitTypeName + '_cut].customer_unit_type_id = '
                               + cast(@CustomerUnitTypeId as varchar(10)) + ' and [' + @UnitTypeName + '_cut].provider_system_id = ' + cast( @SystemId as varchar(10) )
      set @SqlFrom2 = @SqlFrom2  + ' left outer join template_provider_customer_unit_type [' + @UnitTypeName + '_tpcut] on [' + @UnitTypeName + '_cut].template_provider_customer_unit_type_id = [' + @UnitTypeName + '_tpcut].customer_unit_type_id '
      set @SqlFrom2 = @SqlFrom2  + ' left outer join customer_unit_name [' + @UnitTypeName + '_cun] on [' + @UnitTypeName + '_jcutcu].customer_unit_name_id = [' + @UnitTypeName + '_cun].customer_unit_name_id '
      set @SqlFrom2 = @SqlFrom2 + ' left outer join template_provider_customer_unit_name [' + @UnitTypeName + '_tpcun] on [' + @UnitTypeName + '_cun].template_provider_customer_unit_name_id = [' + @UnitTypeName + '_tpcun].customer_unit_name_id '

      set @PrevUnitTypeName = @UnitTypeName
      set @i = @i + 1

      fetch next from unit_type_cursor into
      @CustomerUnitTypeId, @UnitTypeName

   end

   close unit_type_cursor
   deallocate unit_type_cursor

   set @SqlFrom2 = @SqlFrom2 + ' where m.member_id =' + cast(@CustomerId as varchar(10))

   exec ( @SqlSelect + @SqlFrom + @SqlFrom2  )

   /* Get the error code for the previous statement.
             Error checking MUST be done this way since any single statement executed
             will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
        executed... */
   if ( @Transactions = 00 ) begin

     /* Commit the transaction. */
     commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetCustomerUnitsByUnitTypeCustomerServiceValues' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetCustomerUnitsByUnitTypeCustomerServiceValues

   go

create procedure spGetCustomerUnitsByUnitTypeCustomerServiceValues( @CustomerId             integer,
                                                                    @CustomerUnitTypeId     integer,
                                                                    @IncludeServiceValueIds varchar(4000)= NULL,
                                                                    @ExcludeServiceValueIds varchar(4000)= NULL ) as
   set nocount on

   declare @SqlSelect varchar(4000)
   declare @SqlFrom varchar(4000)
   declare @SqlFrom2 varchar(4000)
   declare @SqlIn varchar(4000)
   declare @Comma char(1)
   declare @i integer
   declare @ParentUnitTypeId integer
   declare @PrevUnitTypeName varchar(100)
   declare @UnitTypeName varchar(100)
   declare @SystemName varchar(100)
   declare @SystemId integer
   declare @ChildUnitTypeId integer
   declare @RowCount integer
   declare @TempTable varchar(4000)
   declare @SelectUnitValues varchar(4000)
   declare @OrderBy varchar(4000)

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   declare @UnitTypeTable table ( UnitTypeId integer )

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   set @SqlIn = ''
   set @Comma = ','

   set @ChildUnitTypeId = @CustomerUnitTypeId

   select @SystemId = cut.provider_system_id,
          @SystemName = ISNULL(ps.PROVIDER_SYSTEM_NAME, tps.PROVIDER_SYSTEM_NAME )
   from customer_unit_type cut
   inner join provider_system ps on cut.provider_system_id = ps.provider_system_id
   left outer join dbo.TEMPLATE_PROVIDER_SYSTEM tps on ps.TEMPLATE_PROVIDER_SYSTEM_ID = tps.PROVIDER_SYSTEM_ID
   where cut.customer_unit_type_id = @ChildUnitTypeId

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   while (@ChildUnitTypeId > 0 ) begin
      insert into @UnitTypeTable values ( @ChildUnitTypeId )
      select @ParentUnitTypeId = customer_unit_type_parent_id
      from customer_unit_type
      where customer_unit_type_id = @ChildUnitTypeId

      /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
      select @ErrorCode = @@Error

      /* If there was an error... */
      if ( @ErrorCode <> 00 ) begin

         /* Rollback the transaction. */
         rollback transaction

         /* Return the failure. */
         return 01

      end

      set @ChildUnitTypeId = @ParentUnitTypeId

   end

   set @SqlSelect = ' select m.member_name as MEMBER_NAME '
   set @SqlSelect = @SqlSelect + ', ''' + @SystemName + ''' as PROVIDER_SYSTEM_NAME '

   set @SqlFrom   = ' from member m '

   set @SqlFrom2 = ' '

   set @i = 1

   select @RowCount = count(*) from @UnitTypeTable

   set @TempTable = 'declare @TempUnit table ( MEMBER_NAME varchar(100), PROVIDER_SYSTEM_NAME varchar(100), '
   set @OrderBy = 'order by MEMBER_NAME, '

   declare unit_type_cursor cursor for
      select cut.customer_unit_type_id,
         isnull(cut.customer_unit_type_name, tpcut.customer_unit_type_name) as customer_unit_type_name
      from customer_unit_type cut
      left outer join template_provider_customer_unit_type tpcut on cut.template_provider_customer_unit_type_id = tpcut.customer_unit_type_id
      inner join @UnitTypeTable utt on cut.customer_unit_type_id = utt.UnitTypeId
      where cut.provider_system_id =  @SystemId
      order by cut.customer_unit_type_parent_id, cut.customer_unit_type_id

    /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   open unit_type_cursor

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   fetch next from unit_type_cursor into
   @ParentUnitTypeId, @UnitTypeName

   while (@@fetch_status = 00) begin

      if ( @i = 1 ) begin
         set @TempTable = @TempTable + 'TOP_PARENT_UNIT_TYPE_NAME varchar(50), TOP_PARENT_UNIT_NAME varchar(100), TOP_PARENT_UNIT_ID integer '
         set @SqlSelect = @SqlSelect + ', ''' + @UnitTypeName + ''' as [TOP_PARENT_UNIT_TYPE_NAME], '
         select @UnitTypeName = Replace(@UnitTypeName, ' ', '_')
         set @SqlSelect = @SqlSelect + 'isnull([' + @UnitTypeName + '_cu].customer_unit_name, isnull([' + @UnitTypeName + '_cun].customer_unit_name, [' + @UnitTypeName + '_tpcun].customer_unit_name)) as [TOP_PARENT_UNIT_NAME], '
         set @SqlSelect = @SqlSelect + '[' + @UnitTypeName + '_cu].customer_unit_id as [TOP_PARENT_UNIT_ID] '
         set @OrderBy = @OrderBy + ' TOP_PARENT_UNIT_NAME '
      end

      if ( @i = @RowCount ) begin
         set @TempTable = @TempTable + ', CUSTOMER_UNIT_TYPE_NAME varchar(50), CUSTOMER_UNIT_NAME varchar(100), CUSTOMER_UNIT_ID integer '
         set @SqlSelect = @SqlSelect + ', ''' + @UnitTypeName + ''' as [CUSTOMER_UNIT_TYPE_NAME], '
         select @UnitTypeName = Replace(@UnitTypeName, ' ', '_')
         set @SqlSelect = @SqlSelect + 'isnull([' + @UnitTypeName + '_cu].customer_unit_name, isnull([' + @UnitTypeName + '_cun].customer_unit_name, [' + @UnitTypeName + '_tpcun].customer_unit_name)) as [CUSTOMER_UNIT_NAME], '
         set @SqlSelect = @SqlSelect + '[' + @UnitTypeName + '_cu].customer_unit_id as [CUSTOMER_UNIT_ID] '

         set @OrderBy = @OrderBy + ', CUSTOMER_UNIT_NAME '
      end
      else if ( @i = (@RowCount-1) ) begin
         set @TempTable = @TempTable + ', PARENT_UNIT_TYPE_NAME varchar(50), PARENT_UNIT_NAME varchar(100), PARENT_UNIT_ID integer '
         set @SqlSelect = @SqlSelect + ', ''' + @UnitTypeName + ''' as [PARENT_UNIT_TYPE_NAME], '
         select @UnitTypeName = Replace(@UnitTypeName, ' ', '_')
         set @SqlSelect = @SqlSelect + 'isnull([' + @UnitTypeName + '_cu].customer_unit_name, isnull([' + @UnitTypeName + '_cun].customer_unit_name, [' + @UnitTypeName + '_tpcun].customer_unit_name)) as [PARENT_UNIT_NAME], '
         set @SqlSelect = @SqlSelect + '[' + @UnitTypeName + '_cu].customer_unit_id as [PARENT_UNIT_ID] '
         set @OrderBy = @OrderBy + ', PARENT_UNIT_NAME '
      end
      else if ( @i <> 1 ) begin
         set @TempTable = @TempTable + ', [PARENT' + cast((@i-1) as char(1)) + '_UNIT_TYPE_NAME] varchar(50), [PARENT' + cast((@i-1) as char(1)) + '_UNIT_NAME] varchar(100), [PARENT' + cast((@i-1) as char(1)) + '_UNIT_ID] integer '
         set @SqlSelect = @SqlSelect + ', ''' + @UnitTypeName + ''' as [PARENT' + cast((@i-1) as char(1)) + '_UNIT_TYPE_NAME], '
         select @UnitTypeName = Replace(@UnitTypeName, ' ', '_')
         set @SqlSelect = @SqlSelect + 'isnull([' + @UnitTypeName + '_cu].customer_unit_name, isnull([' + @UnitTypeName + '_cun].customer_unit_name, [' + @UnitTypeName + '_tpcun].customer_unit_name)) as [PARENT' + cast((@i-1) as char(1)) + '_UNIT_NAME], '
         set @SqlSelect = @SqlSelect + '[' + @UnitTypeName + '_cu].customer_unit_id as [PARENT' + cast((@i-1) as char(1)) + '_UNIT_ID] '
         set @OrderBy = @OrderBy + ', [PARENT' + cast((@i-1) as char(1)) + '_UNIT_NAME] '
      end

      set @SqlFrom = @SqlFrom + ' inner join customer_unit [' + @UnitTypeName + '_cu] on m.member_id = [' + @UnitTypeName + '_cu].customer_id '

      if @PrevunitTypeName is not null begin
         set @SqlFrom = @SqlFrom + ' and [' + @PrevUnitTypeName + '_cu].customer_unit_id = [' + @UnitTypeName + '_cu].unit_parent_id '
      end

      set @SqlFrom = @SqlFrom + ' inner join join_customer_unit_type_customer_unit [' + @UnitTypeName + '_jcutcu] on [' + @UnitTypeName + '_cu].customer_unit_id = [' + @UnitTypeName + '_jcutcu].customer_unit_id '

      set @SqlFrom = @SqlFrom  + ' inner join customer_unit_type [' + @UnitTypeName + '_cut] on [' + @UnitTypeName + '_jcutcu].customer_unit_type_id = [' + @UnitTypeName + '_cut].customer_unit_type_id and [' + @UnitTypeName + '_cut].customer_unit_type_id = '
                               + cast(@ParentUnitTypeId as varchar(10)) + ' and [' + @UnitTypeName + '_cut].provider_system_id = ' + cast( @SystemId as varchar(10) )
      set @SqlFrom2 = @SqlFrom2 + ' left outer join template_provider_customer_unit_type [' + @UnitTypeName + '_tpcut] on [' + @UnitTypeName + '_cut].template_provider_customer_unit_type_id = [' + @UnitTypeName + '_tpcut].customer_unit_type_id '
      set @SqlFrom2 = @SqlFrom2 + ' left outer join customer_unit_name [' + @UnitTypeName + '_cun] on [' + @UnitTypeName + '_jcutcu].customer_unit_name_id = [' + @UnitTypeName + '_cun].customer_unit_name_id '
      set @SqlFrom2 = @SqlFrom2 + ' left outer join template_provider_customer_unit_name [' + @UnitTypeName + '_tpcun] on [' + @UnitTypeName + '_cun].template_provider_customer_unit_name_id = [' + @UnitTypeName + '_tpcun].customer_unit_name_id '

      set @PrevUnitTypeName = @UnitTypeName
      set @i = @i + 1

      fetch next from unit_type_cursor into
      @ParentUnitTypeId, @UnitTypeName

   end

   close unit_type_cursor
   deallocate unit_type_cursor

   set @TempTable = @TempTable + ' ) '
   set @SqlFrom2 = @SqlFrom2 + ' where m.member_id =' + cast(@CustomerId as varchar(10))

   set @SelectUnitValues = ' select tu.*, '
   set @SelectUnitValues = @SelectUnitValues + 'cs.COM_SERVICE_DATE, '
   set @SelectUnitValues = @SelectUnitValues + 'ISNULL(psv.PROVIDER_SERVICE_VALUE, tpsv.PROVIDER_SERVICE_VALUE) as PROVIDER_SERVICE_VALUE, '
   set @SelectUnitValues = @SelectUnitValues + 'ISNULL(psv.PROVIDER_SERVICE_VALUE_TEXT, tpsv.PROVIDER_SERVICE_VALUE_TEXT) as PROVIDER_SERVICE_VALUE_TEXT '
   set @SelectUnitValues = @SelectUnitValues + 'from @TempUnit tu ' +
                                               'left outer join ( ' +
                                                       'select max(a.COM_SERVICE_UNIT_VALUE_ID) as COM_SERVICE_UNIT_VALUE_ID, a.CUSTOMER_UNIT_ID ' +
                                                       'from COM_SERVICE_UNIT_VALUE a, CUSTOMER_UNIT b ' +
                                                       'where a.CUSTOMER_UNIT_ID = b.CUSTOMER_UNIT_ID ' +
                                                         'and b.CUSTOMER_ID = ' + cast(@CustomerId  as varchar(10)) +
                                                       'group by a.CUSTOMER_UNIT_ID ) lastservice on tu.customer_unit_id = lastservice.customer_unit_id '
   set @SelectUnitValues = @SelectUnitValues + 'inner join com_service_unit_value csuv on csuv.customer_unit_id = tu.customer_unit_id ' +
                                                                                           'and lastservice.com_service_unit_value_id = csuv.com_service_unit_value_id '
   set @SelectUnitValues = @SelectUnitValues + 'inner join dbo.COM_SERVICE cs on csuv.com_service_id = cs.com_service_id ' +
                                                                                     'and cs.customer_unit_id = tu.TOP_PARENT_UNIT_ID '
   set @SelectUnitValues = @SelectUnitValues + 'left outer join dbo.PROVIDER_SERVICE_VALUE psv on csuv.PROVIDER_SERVICE_VALUE_ID = psv.PROVIDER_SERVICE_VALUE_ID '
   set @SelectUnitValues = @SelectUnitValues + 'left outer join dbo.TEMPLATE_PROVIDER_SERVICE_VALUE tpsv on psv.TEMPLATE_PROVIDER_SERVICE_VALUE_ID = tpsv.PROVIDER_SERVICE_VALUE_ID '

   if @IncludeServiceValueIds <> '' begin
      set @SelectUnitValues = @SelectUnitValues + 'WHERE exists ' +
                                                        '( select csuv.customer_unit_id ' +
                                                          'from com_service_unit_value csuv ' +
                                                          'where csuv.customer_unit_id = tu.customer_unit_id and ' +
                                                          'csuv.provider_service_value_id in (' + @IncludeServiceValueIds + ' ) ) '
   end

   if @ExcludeServiceValueIds <> '' begin
      if @IncludeServiceValueIds <> '' begin
         set @SelectUnitValues = @SelectUnitValues + 'and '
      end
      else begin
         set @SelectUnitValues = @SelectUnitValues + 'WHERE '
      end

      set @SelectUnitValues = @SelectUnitValues + 'not exists ' +
                                                        '( select csuv.customer_unit_id ' +
                                                        'from com_service_unit_value csuv ' +
                                                        'where csuv.customer_unit_id = tu.customer_unit_id and ' +
                                                        'csuv.provider_service_value_id in (' + @ExcludeServiceValueIds + ') ) '
   end

   set @SelectUnitValues = @SelectUnitValues + @OrderBy

   exec ( @TempTable + ' insert into @TempUnit ' + @SqlSelect + @SqlFrom + @SqlFrom2 + @SelectUnitValues )

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

     /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetCustomerUnitsByUnitTypeGroup' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetCustomerUnitsByUnitTypeGroup

   go

create procedure spGetCustomerUnitsByUnitTypeGroup( @GroupId            integer,
                                                    @CustomerUnitTypeId integer ) as

   set nocount on

      declare @SqlSelect varchar(4000)
      declare @SqlFrom varchar(4000)
      declare @SqlFrom2 varchar(4000)
      declare @SqlIn varchar(4000)
      declare @Comma char(1)
      declare @i integer
      declare @ParentUnitTypeId integer
      declare @TopParentTypeId integer
      declare @PrevUnitTypeName varchar(100)
      declare @UnitTypeName varchar(100)
      declare @SystemName varchar(100)
      declare @SystemId integer
      declare @CustomerId integer
      declare @ParentUnitTypeName varchar(100)
      declare @GroupType varchar(50)
      declare @GroupName varchar(50)
      declare @ChildUnitTypeId integer
      declare @RowCount integer
      declare @TempTable varchar(4000)
      declare @SelectUnitValues varchar(4000)
      declare @OrderBy varchar(4000)

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   declare @UnitTypeTable table ( UnitTypeId integer )

   set @SqlIn = ''
   set @Comma = ','

   set @ChildUnitTypeId = @CustomerUnitTypeId

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   select @SystemId = cut.provider_system_id,
          @SystemName = ISNULL(ps.PROVIDER_SYSTEM_NAME, tps.PROVIDER_SYSTEM_NAME )
   from customer_unit_type cut
   inner join provider_system ps on cut.provider_system_id = ps.provider_system_id
   left outer join dbo.TEMPLATE_PROVIDER_SYSTEM tps on ps.TEMPLATE_PROVIDER_SYSTEM_ID = tps.PROVIDER_SYSTEM_ID
   where cut.customer_unit_type_id = @ChildUnitTypeId

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   while (@ChildUnitTypeId > 0 ) begin
      set @TopParentTypeId = @ChildUnitTypeId
      insert into @UnitTypeTable values ( @ChildUnitTypeId )
      select @ParentUnitTypeId = customer_unit_type_parent_id
      from customer_unit_type
      where customer_unit_type_id = @ChildUnitTypeId

      /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
      select @ErrorCode = @@Error

      /* If there was an error... */
      if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

      set @ChildUnitTypeId = @ParentUnitTypeId

   end

   select @ParentUnitTypeName = isnull(cut.customer_unit_type_name, tpcut.customer_unit_type_name)
   from customer_unit_type cut
   left outer join template_provider_customer_unit_type tpcut on cut.template_provider_customer_unit_type_id = tpcut.customer_unit_type_id
   where cut.customer_unit_type_id = @TopParentTypeId

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   select @GroupType = mgt.member_group_type_name,
          @GroupName = mg.member_group_name from
          dbo.member_group mg
   inner join dbo.member_group_type mgt on mg.member_group_type_id = mgt.member_group_type_id
   where mg.member_group_id = @GroupId

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   set @SqlSelect = ' select m.member_name as MEMBER_NAME '
   set @SqlSelect = @SqlSelect + ', ''' + @SystemName + ''' as PROVIDER_SYSTEM_NAME '

   set @SqlFrom   = ' from member m '

   set @SqlFrom2 = ' '

   set @i = 1

   select @RowCount = count(*) from @UnitTypeTable

   set @TempTable = 'declare @TempUnit table ( MEMBER_NAME varchar(100), PROVIDER_SYSTEM_NAME varchar(100), '
   set @OrderBy = 'order by tu.MEMBER_NAME, '

   declare unit_type_cursor cursor for
      select cut.customer_unit_type_id,
         isnull(cut.customer_unit_type_name, tpcut.customer_unit_type_name) as customer_unit_type_name
      from customer_unit_type cut
      left outer join template_provider_customer_unit_type tpcut on cut.template_provider_customer_unit_type_id = tpcut.customer_unit_type_id
      inner join @UnitTypeTable utt on cut.customer_unit_type_id = utt.UnitTypeId
      where cut.provider_system_id =  @SystemId
      order by cut.customer_unit_type_parent_id, cut.customer_unit_type_id

   open unit_type_cursor

    /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   fetch next from unit_type_cursor into
   @ParentUnitTypeId, @UnitTypeName

   while (@@fetch_status = 00) begin

      if ( @i = 1 ) begin
         set @TempTable = @TempTable + 'TOP_PARENT_UNIT_TYPE_NAME varchar(50), TOP_PARENT_UNIT_NAME varchar(100), TOP_PARENT_UNIT_ID integer '
         set @SqlSelect = @SqlSelect + ', ''' + @UnitTypeName + ''' as [TOP_PARENT_UNIT_TYPE_NAME], '
         select @UnitTypeName = Replace(@UnitTypeName, ' ', '_')
         set @SqlSelect = @SqlSelect + 'isnull([' + @UnitTypeName + '_cu].customer_unit_name, isnull([' + @UnitTypeName + '_cun].customer_unit_name, [' + @UnitTypeName + '_tpcun].customer_unit_name)) as [TOP_PARENT_UNIT_NAME], '
         set @SqlSelect = @SqlSelect + '[' + @UnitTypeName + '_cu].customer_unit_id as [TOP_PARENT_UNIT_ID] '
         set @OrderBy = @OrderBy + ' TOP_PARENT_UNIT_NAME '
      end

      if ( @i = @RowCount ) begin
         set @TempTable = @TempTable + ', CUSTOMER_UNIT_TYPE_NAME varchar(50), CUSTOMER_UNIT_NAME varchar(100), CUSTOMER_UNIT_ID integer '
         set @SqlSelect = @SqlSelect + ', ''' + @UnitTypeName + ''' as [CUSTOMER_UNIT_TYPE_NAME], '
         select @UnitTypeName = Replace(@UnitTypeName, ' ', '_')
         set @SqlSelect = @SqlSelect + 'isnull([' + @UnitTypeName + '_cu].customer_unit_name, isnull([' + @UnitTypeName + '_cun].customer_unit_name, [' + @UnitTypeName + '_tpcun].customer_unit_name)) as [CUSTOMER_UNIT_NAME], '
         set @SqlSelect = @SqlSelect + '[' + @UnitTypeName + '_cu].customer_unit_id as [CUSTOMER_UNIT_ID] '
         set @OrderBy = @OrderBy + ', tu.CUSTOMER_UNIT_NAME '
      end
      else if ( @i = (@RowCount-1) ) begin
         set @TempTable = @TempTable + ', PARENT_UNIT_TYPE_NAME varchar(50), PARENT_UNIT_NAME varchar(100), PARENT_UNIT_ID integer '
         set @SqlSelect = @SqlSelect + ', ''' + @UnitTypeName + ''' as [PARENT_UNIT_TYPE_NAME], '
         select @UnitTypeName = Replace(@UnitTypeName, ' ', '_')
         set @SqlSelect = @SqlSelect + 'isnull([' + @UnitTypeName + '_cu].customer_unit_name, isnull([' + @UnitTypeName + '_cun].customer_unit_name, [' + @UnitTypeName + '_tpcun].customer_unit_name)) as [PARENT_UNIT_NAME], '
         set @SqlSelect = @SqlSelect + '[' + @UnitTypeName + '_cu].customer_unit_id as [PARENT_UNIT_ID] '
         set @OrderBy = @OrderBy + ', PARENT_UNIT_NAME '
      end
      else if ( @i <> 1 ) begin
         set @TempTable = @TempTable + ', [PARENT' + cast((@i-1) as char(1)) + '_UNIT_TYPE_NAME] varchar(50), [PARENT' + cast((@i-1) as char(1)) + '_UNIT_NAME] varchar(100), [PARENT' + cast((@i-1) as char(1)) + '_UNIT_ID] integer '
         set @SqlSelect = @SqlSelect + ', ''' + @UnitTypeName + ''' as [PARENT' + cast((@i-1) as char(1)) + '_UNIT_TYPE_NAME], '
         select @UnitTypeName = Replace(@UnitTypeName, ' ', '_')
         set @SqlSelect = @SqlSelect + 'isnull([' + @UnitTypeName + '_cu].customer_unit_name, isnull([' + @UnitTypeName + '_cun].customer_unit_name, [' + @UnitTypeName + '_tpcun].customer_unit_name)) as [PARENT' + cast((@i-1) as char(1)) + '_UNIT_NAME], '
         set @SqlSelect = @SqlSelect + '[' + @UnitTypeName + '_cu].customer_unit_id as [PARENT' + cast((@i-1) as char(1)) + '_UNIT_ID] '
         set @OrderBy = @OrderBy + ', [PARENT' + cast((@i-1) as char(1)) + '_UNIT_NAME] '
      end

      set @SqlFrom = @SqlFrom + ' inner join customer_unit [' + @UnitTypeName + '_cu] on m.member_id = [' + @UnitTypeName + '_cu].customer_id '

      if @PrevunitTypeName is not null begin
         set @SqlFrom = @SqlFrom + ' and [' + @PrevUnitTypeName + '_cu].customer_unit_id = [' + @UnitTypeName + '_cu].unit_parent_id '
      end

      set @SqlFrom = @SqlFrom + ' inner join join_customer_unit_type_customer_unit [' + @UnitTypeName + '_jcutcu] on [' + @UnitTypeName + '_cu].customer_unit_id = [' + @UnitTypeName + '_jcutcu].customer_unit_id '

      set @SqlFrom = @SqlFrom  + ' inner join customer_unit_type [' + @UnitTypeName + '_cut] on [' + @UnitTypeName + '_jcutcu].customer_unit_type_id = [' + @UnitTypeName + '_cut].customer_unit_type_id and [' + @UnitTypeName + '_cut].customer_unit_type_id = '
                               + cast(@ParentUnitTypeId as varchar(10)) + ' and [' + @UnitTypeName + '_cut].provider_system_id = ' + cast( @SystemId as varchar(10) )
      set @SqlFrom2 = @SqlFrom2 + ' left outer join template_provider_customer_unit_type [' + @UnitTypeName + '_tpcut] on [' + @UnitTypeName + '_cut].template_provider_customer_unit_type_id = [' + @UnitTypeName + '_tpcut].customer_unit_type_id '
      set @SqlFrom2 = @SqlFrom2 + ' left outer join customer_unit_name [' + @UnitTypeName + '_cun] on [' + @UnitTypeName + '_jcutcu].customer_unit_name_id = [' + @UnitTypeName + '_cun].customer_unit_name_id '
      set @SqlFrom2 = @SqlFrom2 + ' left outer join template_provider_customer_unit_name [' + @UnitTypeName + '_tpcun] on [' + @UnitTypeName + '_cun].template_provider_customer_unit_name_id = [' + @UnitTypeName + '_tpcun].customer_unit_name_id '

      set @PrevUnitTypeName = @UnitTypeName
      set @i = @i + 1

      fetch next from unit_type_cursor into
      @ParentUnitTypeId, @UnitTypeName

   end

   close unit_type_cursor
   deallocate unit_type_cursor

   set @TempTable = @TempTable + ' ) '
   set @SqlFrom2 = @SqlFrom2 + ' inner join dbo.JOIN_MEMBER_GROUP_CUSTOMER_UNIT jmgcu on [' + @ParentUnitTypeName + '_cu].customer_unit_id = jmgcu.CUSTOMER_UNIT_ID '
   set @SqlFrom2 = @SqlFrom2 + ' where jmgcu.MEMBER_GROUP_ID =' + cast(@GroupId as varchar(10))

   set @SelectUnitValues = ' select tu.*, '
   set @SelectUnitValues = @SelectUnitValues + 'cs.COM_SERVICE_DATE, '
   set @SelectUnitValues = @SelectUnitValues + 'ISNULL(psv.PROVIDER_SERVICE_VALUE, tpsv.PROVIDER_SERVICE_VALUE) as PROVIDER_SERVICE_VALUE, '
   set @SelectUnitValues = @SelectUnitValues + 'ISNULL(psv.PROVIDER_SERVICE_VALUE_TEXT, tpsv.PROVIDER_SERVICE_VALUE_TEXT) as PROVIDER_SERVICE_VALUE_TEXT, '
   set @SelectUnitValues = @SelectUnitValues + '''' + @GroupType  + ''' as MEMBER_GROUP_TYPE_NAME, '
   set @SelectUnitValues = @SelectUnitValues + '''' + @GroupName  + ''' as MEMBER_GROUP_NAME '
   set @SelectUnitValues = @SelectUnitValues + 'from @TempUnit tu '
   set @SelectUnitValues = @SelectUnitValues + 'inner join dbo.CUSTOMER_UNIT cu on cu.CUSTOMER_UNIT_ID = tu.CUSTOMER_UNIT_ID '
   set @SelectUnitValues = @SelectUnitValues + 'inner join dbo.MEMBER m on m.MEMBER_ID = cu.CUSTOMER_ID '
   set @SelectUnitValues = @SelectUnitValues + 'left outer join ( ' +
                                                       'select max(a.COM_SERVICE_UNIT_VALUE_ID) as COM_SERVICE_UNIT_VALUE_ID, a.CUSTOMER_UNIT_ID ' +
                                                       'from dbo.COM_SERVICE_UNIT_VALUE a ' +
                                                       'group by a.CUSTOMER_UNIT_ID ) lastservice on tu.customer_unit_id = lastservice.customer_unit_id '
   set @SelectUnitValues = @SelectUnitValues + 'left outer join com_service_unit_value csuv on csuv.customer_unit_id = tu.customer_unit_id ' +
                                                                                           'and lastservice.com_service_unit_value_id = csuv.com_service_unit_value_id '
   set @SelectUnitValues = @SelectUnitValues + 'left outer join dbo.COM_SERVICE cs on csuv.com_service_id = cs.com_service_id ' +
                                                                                     'and cs.customer_unit_id = tu.TOP_PARENT_UNIT_ID '
   set @SelectUnitValues = @SelectUnitValues + 'left outer join dbo.PROVIDER_SERVICE_VALUE psv on csuv.PROVIDER_SERVICE_VALUE_ID = psv.PROVIDER_SERVICE_VALUE_ID '
   set @SelectUnitValues = @SelectUnitValues + 'left outer join dbo.TEMPLATE_PROVIDER_SERVICE_VALUE tpsv on psv.TEMPLATE_PROVIDER_SERVICE_VALUE_ID = tpsv.PROVIDER_SERVICE_VALUE_ID '

   set @SelectUnitValues = @SelectUnitValues + @OrderBy

   exec ( @TempTable + ' insert into @TempUnit ' + @SqlSelect + @SqlFrom + @SqlFrom2 + @SelectUnitValues )

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

     /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetCustomerUnitsByUnitTypeGroupExport' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetCustomerUnitsByUnitTypeGroupExport

   go

create procedure spGetCustomerUnitsByUnitTypeGroupExport( @GroupId            integer,
                                                          @CustomerUnitTypeId integer ) as

   declare @Sql varchar(4000)
   declare @SqlSelect varchar(4000)
   declare @SqlFrom varchar(4000)
   declare @SqlFrom2 varchar(4000)
   declare @SqlIn varchar(4000)
   declare @Comma char(1)
   declare @i integer
   declare @ParentUnitTypeId integer
   declare @ParentUnitTypeName varchar(100)
   declare @PrevUnitTypeName varchar(100)
   declare @UnitTypeName varchar(100)
   declare @SystemName varchar(100)
   declare @SystemId integer
   declare @ChildUnitTypeId integer
   declare @TopParentTypeId integer

   declare @UnitTypeTable table ( UnitTypeId integer )

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   set nocount on

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   set @SqlIn = ''
   set @Comma = ','

   set @ChildUnitTypeId = @CustomerUnitTypeId

   select @SystemId = cut.provider_system_id,
          @SystemName = ISNULL(ps.PROVIDER_SYSTEM_NAME, tps.PROVIDER_SYSTEM_NAME )
   from customer_unit_type cut
   inner join provider_system ps on cut.provider_system_id = ps.provider_system_id
   left outer join dbo.TEMPLATE_PROVIDER_SYSTEM tps on ps.TEMPLATE_PROVIDER_SYSTEM_ID = tps.PROVIDER_SYSTEM_ID
   where cut.customer_unit_type_id = @ChildUnitTypeId

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   while (@ChildUnitTypeId > 0 ) begin
      /*last value set will be to top parent type id*/
      set @TopParentTypeId = @ChildUnitTypeId
      insert into @UnitTypeTable values ( @ChildUnitTypeId )
      select @ParentUnitTypeId = customer_unit_type_parent_id
      from customer_unit_type
      where customer_unit_type_id = @ChildUnitTypeId

      /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
      select @ErrorCode = @@Error

      /* If there was an error... */
      if ( @ErrorCode <> 00 ) begin

         /* Rollback the transaction. */
         rollback transaction

         /* Return the failure. */
         return 01

      end

      set @ChildUnitTypeId = @ParentUnitTypeId

   end

   select @ParentUnitTypeName = isnull(cut.customer_unit_type_name, tpcut.customer_unit_type_name)
   from customer_unit_type cut
   left outer join template_provider_customer_unit_type tpcut on cut.template_provider_customer_unit_type_id = tpcut.customer_unit_type_id
   where cut.customer_unit_type_id = @TopParentTypeId

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   set @SqlSelect = ' select m.member_name as CustomerName '
   set @SqlSelect = @SqlSelect + ', ''' + @SystemName + ''' as System '

   set @SqlFrom   = ' from member m '
   set @SqlFrom2 = ' '
   set @i = 1

   declare unit_type_cursor cursor for
      select cut.customer_unit_type_id,
         isnull(cut.customer_unit_type_name, tpcut.customer_unit_type_name) as customer_unit_type_name
      from customer_unit_type cut
      left outer join template_provider_customer_unit_type tpcut on cut.template_provider_customer_unit_type_id = tpcut.customer_unit_type_id
      inner join @UnitTypeTable utt on cut.customer_unit_type_id = utt.UnitTypeId
      where cut.provider_system_id =  @SystemId
      order by cut.customer_unit_type_parent_id, cut.customer_unit_type_id

   open unit_type_cursor

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   fetch next from unit_type_cursor into
   @CustomerUnitTypeId, @UnitTypeName

   while (@@fetch_status = 00) begin

      set @SqlSelect = @SqlSelect + ', ''' + @UnitTypeName + ''' as Field' + cast(@i as char(1))

      select @UnitTypeName = Replace(@UnitTypeName, ' ', '_')

      set @SqlSelect = @SqlSelect + ', isnull([' + @UnitTypeName + '_cu].customer_unit_name, isnull([' + @UnitTypeName + '_cun].customer_unit_name, [' + @UnitTypeName + '_tpcun].customer_unit_name)) as [Field' + cast(@i as char(1)) + '_Name], '
      set @SqlSelect = @SqlSelect + ' isnull([' + @UnitTypeName + '_cu].customer_unit_number, isnull([' + @UnitTypeName + '_cun].customer_unit_number, ' + @UnitTypeName + '_tpcun.[customer_unit_number])) as [Field' + cast(@i as char(1)) + '_Barcode], '
      set @SqlSelect = @SqlSelect + '[' + @UnitTypeName + '_cu].customer_unit_id as [Field' + cast(@i as char(1)) + '_id_id] '
      set @SqlFrom = @SqlFrom + ' inner join customer_unit [' + @UnitTypeName + '_cu] on m.member_id = [' + @UnitTypeName + '_cu].customer_id '

      if @PrevunitTypeName is not null begin
         set @SqlFrom = @SqlFrom + ' and [' + @PrevUnitTypeName + '_cu].customer_unit_id = [' + @UnitTypeName + '_cu].unit_parent_id '
      end
      set @SqlFrom = @SqlFrom + ' inner join join_customer_unit_type_customer_unit [' + @UnitTypeName + '_jcutcu] on [' + @UnitTypeName + '_cu].customer_unit_id = [' + @UnitTypeName + '_jcutcu].customer_unit_id '
      set @SqlFrom = @SqlFrom + ' inner join customer_unit_type [' + @UnitTypeName + '_cut] on [' + @UnitTypeName + '_jcutcu].customer_unit_type_id = [' + @UnitTypeName + '_cut].customer_unit_type_id and [' + @UnitTypeName + '_cut].customer_unit_type_id = '
                              + cast(@CustomerUnitTypeId as varchar(10)) + ' and [' + @UnitTypeName + '_cut].provider_system_id = ' + cast( @SystemId as varchar(10) )
      set @SqlFrom2 = @SqlFrom2 + ' left outer join template_provider_customer_unit_type [' + @UnitTypeName + '_tpcut] on [' + @UnitTypeName + '_cut].template_provider_customer_unit_type_id = [' + @UnitTypeName + '_tpcut].customer_unit_type_id '
      set @SqlFrom2 = @SqlFrom2 + ' left outer join customer_unit_name [' + @UnitTypeName + '_cun] on [' + @UnitTypeName + '_jcutcu].customer_unit_name_id = [' + @UnitTypeName + '_cun].customer_unit_name_id '
      set @SqlFrom2 = @SqlFrom2 + ' left outer join template_provider_customer_unit_name [' + @UnitTypeName + '_tpcun] on [' + @UnitTypeName + '_cun].template_provider_customer_unit_name_id = [' + @UnitTypeName + '_tpcun].customer_unit_name_id '

      set @PrevUnitTypeName = @UnitTypeName
      set @i = @i + 1

      fetch next from unit_type_cursor into
      @CustomerUnitTypeId, @UnitTypeName

   end

   close unit_type_cursor
   deallocate unit_type_cursor
   set @SqlFrom2 = @SqlFrom2 + ' inner join dbo.JOIN_MEMBER_GROUP_CUSTOMER_UNIT jmgcu on [' + @ParentUnitTypeName + '_cu].customer_unit_id = jmgcu.CUSTOMER_UNIT_ID '
   set @SqlFrom2 = @SqlFrom2+ ' where jmgcu.MEMBER_GROUP_ID =' + cast(@GroupId as varchar(10))

   exec ( @SqlSelect + @SqlFrom + @SqlFrom2 )

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

     /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetCustomerUnitsByUnitTypeGroupServiceValues' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetCustomerUnitsByUnitTypeGroupServiceValues

   go

create procedure spGetCustomerUnitsByUnitTypeGroupServiceValues( @GroupId                integer,
                                                                 @CustomerUnitTypeId     integer,
                                                                 @IncludeServiceValueIds varchar(4000)= NULL,
                                                                 @ExcludeServiceValueIds varchar(4000)= NULL ) as
   set nocount on

   declare @SqlSelect varchar(4000)
   declare @SqlFrom varchar(4000)
   declare @SqlFrom2 varchar(4000)
   declare @SqlIn varchar(4000)
   declare @Comma char(1)
   declare @i integer
   declare @ParentUnitTypeId integer
   declare @TopParentTypeId integer
   declare @PrevUnitTypeName varchar(100)
   declare @UnitTypeName varchar(100)
   declare @SystemName varchar(100)
   declare @SystemId integer
   declare @CustomerId integer
   declare @ParentUnitTypeName varchar(100)
   declare @GroupType varchar(50)
   declare @GroupName varchar(50)
   declare @ChildUnitTypeId integer
   declare @RowCount integer
   declare @TempTable varchar(4000)
   declare @SelectUnitValues varchar(4000)
   declare @OrderBy varchar(4000)

   declare @UnitTypeTable table ( UnitTypeId integer )

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   set @SqlIn = ''
   set @Comma = ','

   set @ChildUnitTypeId = @CustomerUnitTypeId

   select @SystemId = cut.provider_system_id,
          @SystemName = ISNULL(ps.PROVIDER_SYSTEM_NAME, tps.PROVIDER_SYSTEM_NAME )
   from customer_unit_type cut
   inner join provider_system ps on cut.provider_system_id = ps.provider_system_id
   left outer join dbo.TEMPLATE_PROVIDER_SYSTEM tps on ps.TEMPLATE_PROVIDER_SYSTEM_ID = tps.PROVIDER_SYSTEM_ID
   where cut.customer_unit_type_id = @ChildUnitTypeId

    /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   while (@ChildUnitTypeId > 0 ) begin
      set @TopParentTypeId = @ChildUnitTypeId
      insert into @UnitTypeTable values ( @ChildUnitTypeId )
      select @ParentUnitTypeId = customer_unit_type_parent_id
      from customer_unit_type
      where customer_unit_type_id = @ChildUnitTypeId

      /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
      select @ErrorCode = @@Error

      /* If there was an error... */
      if ( @ErrorCode <> 00 ) begin

         /* Rollback the transaction. */
         rollback transaction

         /* Return the failure. */
         return 01

      end

      set @ChildUnitTypeId = @ParentUnitTypeId

   end

   select @ParentUnitTypeName = isnull(cut.customer_unit_type_name, tpcut.customer_unit_type_name)
   from customer_unit_type cut
   left outer join template_provider_customer_unit_type tpcut on cut.template_provider_customer_unit_type_id = tpcut.customer_unit_type_id
   where cut.customer_unit_type_id = @TopParentTypeId

    /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   select @GroupType = mgt.member_group_type_name,
          @GroupName = mg.member_group_name from
          dbo.member_group mg
   inner join dbo.member_group_type mgt on mg.member_group_type_id = mgt.member_group_type_id
   where mg.member_group_id = @GroupId

    /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   set @SqlSelect = ' select m.member_name as MEMBER_NAME '
   set @SqlSelect = @SqlSelect + ', ''' + @SystemName + ''' as PROVIDER_SYSTEM_NAME '

   set @SqlFrom   = ' from member m '

   set @SqlFrom2 = ' '

   set @i = 1

   select @RowCount = count(*) from @UnitTypeTable

   set @TempTable = 'declare @TempUnit table ( MEMBER_NAME varchar(100), PROVIDER_SYSTEM_NAME varchar(100), '
   set @OrderBy = 'order by tu.MEMBER_NAME, '

   declare unit_type_cursor cursor for
      select cut.customer_unit_type_id,
         isnull(cut.customer_unit_type_name, tpcut.customer_unit_type_name) as customer_unit_type_name
      from customer_unit_type cut
      left outer join template_provider_customer_unit_type tpcut on cut.template_provider_customer_unit_type_id = tpcut.customer_unit_type_id
      inner join @UnitTypeTable utt on cut.customer_unit_type_id = utt.UnitTypeId
      where cut.provider_system_id =  @SystemId
      order by cut.customer_unit_type_parent_id, cut.customer_unit_type_id

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   open unit_type_cursor

    /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   fetch next from unit_type_cursor into
   @ParentUnitTypeId, @UnitTypeName

   while (@@fetch_status = 00) begin

      if ( @i = 1 ) begin
         set @TempTable = @TempTable + 'TOP_PARENT_UNIT_TYPE_NAME varchar(50), TOP_PARENT_UNIT_NAME varchar(100), TOP_PARENT_UNIT_ID integer '
         set @SqlSelect = @SqlSelect + ', ''' + @UnitTypeName + ''' as [TOP_PARENT_UNIT_TYPE_NAME], '
         select @UnitTypeName = Replace(@UnitTypeName, ' ', '_')
         set @SqlSelect = @SqlSelect + 'isnull([' + @UnitTypeName + '_cu].customer_unit_name, isnull([' + @UnitTypeName + '_cun].customer_unit_name, [' + @UnitTypeName + '_tpcun].customer_unit_name)) as [TOP_PARENT_UNIT_NAME], '
         set @SqlSelect = @SqlSelect + '[' + @UnitTypeName + '_cu].customer_unit_id as [TOP_PARENT_UNIT_ID] '
         set @OrderBy = @OrderBy + ' TOP_PARENT_UNIT_NAME '
      end

      if ( @i = @RowCount ) begin
         set @TempTable = @TempTable + ', CUSTOMER_UNIT_TYPE_NAME varchar(50), CUSTOMER_UNIT_NAME varchar(100), CUSTOMER_UNIT_ID integer '
         set @SqlSelect = @SqlSelect + ', ''' + @UnitTypeName + ''' as [CUSTOMER_UNIT_TYPE_NAME], '
         select @UnitTypeName = Replace(@UnitTypeName, ' ', '_')
         set @SqlSelect = @SqlSelect + 'isnull([' + @UnitTypeName + '_cu].customer_unit_name, isnull([' + @UnitTypeName + '_cun].customer_unit_name, [' + @UnitTypeName + '_tpcun].customer_unit_name)) as [CUSTOMER_UNIT_NAME], '
         set @SqlSelect = @SqlSelect + '[' + @UnitTypeName + '_cu].customer_unit_id as [CUSTOMER_UNIT_ID] '
         set @OrderBy = @OrderBy + ', tu.CUSTOMER_UNIT_NAME '
      end
      else if ( @i = (@RowCount-1) ) begin
         set @TempTable = @TempTable + ', PARENT_UNIT_TYPE_NAME varchar(50), PARENT_UNIT_NAME varchar(100), PARENT_UNIT_ID integer '
         set @SqlSelect = @SqlSelect + ', ''' + @UnitTypeName + ''' as [PARENT_UNIT_TYPE_NAME], '
         select @UnitTypeName = Replace(@UnitTypeName, ' ', '_')
         set @SqlSelect = @SqlSelect + 'isnull([' + @UnitTypeName + '_cu].customer_unit_name, isnull([' + @UnitTypeName + '_cun].customer_unit_name, [' + @UnitTypeName + '_tpcun].customer_unit_name)) as [PARENT_UNIT_NAME], '
         set @SqlSelect = @SqlSelect + '[' + @UnitTypeName + '_cu].customer_unit_id as [PARENT_UNIT_ID] '
         set @OrderBy = @OrderBy + ', PARENT_UNIT_NAME '
      end
      else if ( @i <> 1 ) begin
         set @TempTable = @TempTable + ', [PARENT' + cast((@i-1) as char(1)) + '_UNIT_TYPE_NAME] varchar(50), [PARENT' + cast((@i-1) as char(1)) + '_UNIT_NAME] varchar(100), [PARENT' + cast((@i-1) as char(1)) + '_UNIT_ID] integer '
         set @SqlSelect = @SqlSelect + ', ''' + @UnitTypeName + ''' as [PARENT' + cast((@i-1) as char(1)) + '_UNIT_TYPE_NAME], '
         select @UnitTypeName = Replace(@UnitTypeName, ' ', '_')
         set @SqlSelect = @SqlSelect + 'isnull([' + @UnitTypeName + '_cu].customer_unit_name, isnull([' + @UnitTypeName + '_cun].customer_unit_name, [' + @UnitTypeName + '_tpcun].customer_unit_name)) as [PARENT' + cast((@i-1) as char(1)) + '_UNIT_NAME], '
         set @SqlSelect = @SqlSelect + '[' + @UnitTypeName + '_cu].customer_unit_id as [PARENT' + cast((@i-1) as char(1)) + '_UNIT_ID] '
         set @OrderBy = @OrderBy + ', [PARENT' + cast((@i-1) as char(1)) + '_UNIT_NAME] '
      end

      set @SqlFrom = @SqlFrom + ' inner join customer_unit [' + @UnitTypeName + '_cu] on m.member_id = [' + @UnitTypeName + '_cu].customer_id '

      if @PrevunitTypeName is not null begin
         set @SqlFrom = @SqlFrom + ' and [' + @PrevUnitTypeName + '_cu].customer_unit_id = [' + @UnitTypeName + '_cu].unit_parent_id '
      end

      set @SqlFrom = @SqlFrom + ' inner join join_customer_unit_type_customer_unit [' + @UnitTypeName + '_jcutcu] on [' + @UnitTypeName + '_cu].customer_unit_id = [' + @UnitTypeName + '_jcutcu].customer_unit_id '

      set @SqlFrom = @SqlFrom  + ' inner join customer_unit_type [' + @UnitTypeName + '_cut] on [' + @UnitTypeName + '_jcutcu].customer_unit_type_id = [' + @UnitTypeName + '_cut].customer_unit_type_id and [' + @UnitTypeName + '_cut].customer_unit_type_id = '
                               + cast(@ParentUnitTypeId as varchar(10)) + ' and [' + @UnitTypeName + '_cut].provider_system_id = ' + cast( @SystemId as varchar(10) )
      set @SqlFrom2 = @SqlFrom2 + ' left outer join template_provider_customer_unit_type [' + @UnitTypeName + '_tpcut] on [' + @UnitTypeName + '_cut].template_provider_customer_unit_type_id = [' + @UnitTypeName + '_tpcut].customer_unit_type_id '
      set @SqlFrom2 = @SqlFrom2 + ' left outer join customer_unit_name [' + @UnitTypeName + '_cun] on [' + @UnitTypeName + '_jcutcu].customer_unit_name_id = [' + @UnitTypeName + '_cun].customer_unit_name_id '
      set @SqlFrom2 = @SqlFrom2 + ' left outer join template_provider_customer_unit_name [' + @UnitTypeName + '_tpcun] on [' + @UnitTypeName + '_cun].template_provider_customer_unit_name_id = [' + @UnitTypeName + '_tpcun].customer_unit_name_id '

      set @PrevUnitTypeName = @UnitTypeName
      set @i = @i + 1

      fetch next from unit_type_cursor into
      @ParentUnitTypeId, @UnitTypeName

   end

   close unit_type_cursor
   deallocate unit_type_cursor

   set @TempTable = @TempTable + ' ) '
   set @SqlFrom2 = @SqlFrom2 + ' inner join dbo.JOIN_MEMBER_GROUP_CUSTOMER_UNIT jmgcu on [' + @ParentUnitTypeName + '_cu].customer_unit_id = jmgcu.CUSTOMER_UNIT_ID '
   set @SqlFrom2 = @SqlFrom2 + ' where jmgcu.MEMBER_GROUP_ID =' + cast(@GroupId as varchar(10))

   set @SelectUnitValues = ' select tu.*, '
   set @SelectUnitValues = @SelectUnitValues + 'cs.COM_SERVICE_DATE, '
   set @SelectUnitValues = @SelectUnitValues + 'ISNULL(psv.PROVIDER_SERVICE_VALUE, tpsv.PROVIDER_SERVICE_VALUE) as PROVIDER_SERVICE_VALUE, '
   set @SelectUnitValues = @SelectUnitValues + 'ISNULL(psv.PROVIDER_SERVICE_VALUE_TEXT, tpsv.PROVIDER_SERVICE_VALUE_TEXT) as PROVIDER_SERVICE_VALUE_TEXT, '
   set @SelectUnitValues = @SelectUnitValues + '''' + @GroupType  + ''' as MEMBER_GROUP_TYPE_NAME, '
   set @SelectUnitValues = @SelectUnitValues + '''' + @GroupName  + ''' as MEMBER_GROUP_NAME '
   set @SelectUnitValues = @SelectUnitValues + 'from @TempUnit tu '
   set @SelectUnitValues = @SelectUnitValues + 'inner join dbo.CUSTOMER_UNIT cu on cu.CUSTOMER_UNIT_ID = tu.CUSTOMER_UNIT_ID '
   set @SelectUnitValues = @SelectUnitValues + 'inner join dbo.MEMBER m on m.MEMBER_ID = cu.CUSTOMER_ID '
   set @SelectUnitValues = @SelectUnitValues + 'left outer join ( ' +
                                                       'select max(a.COM_SERVICE_UNIT_VALUE_ID) as COM_SERVICE_UNIT_VALUE_ID, a.CUSTOMER_UNIT_ID ' +
                                                       'from dbo.COM_SERVICE_UNIT_VALUE a ' +
                                                       'group by a.CUSTOMER_UNIT_ID ) lastservice on tu.customer_unit_id = lastservice.customer_unit_id '
   set @SelectUnitValues = @SelectUnitValues + 'inner join com_service_unit_value csuv on csuv.customer_unit_id = tu.customer_unit_id ' +
                                                                                           'and lastservice.com_service_unit_value_id = csuv.com_service_unit_value_id '
   set @SelectUnitValues = @SelectUnitValues + 'inner join dbo.COM_SERVICE cs on csuv.com_service_id = cs.com_service_id ' +
                                                                                     'and cs.customer_unit_id = tu.TOP_PARENT_UNIT_ID '
   set @SelectUnitValues = @SelectUnitValues + 'left outer join dbo.PROVIDER_SERVICE_VALUE psv on csuv.PROVIDER_SERVICE_VALUE_ID = psv.PROVIDER_SERVICE_VALUE_ID '
   set @SelectUnitValues = @SelectUnitValues + 'left outer join dbo.TEMPLATE_PROVIDER_SERVICE_VALUE tpsv on psv.TEMPLATE_PROVIDER_SERVICE_VALUE_ID = tpsv.PROVIDER_SERVICE_VALUE_ID '

   if @IncludeServiceValueIds <> '' begin
      set @SelectUnitValues = @SelectUnitValues + 'WHERE exists ' +
                                                        '( select csuv.customer_unit_id ' +
                                                          'from com_service_unit_value csuv ' +
                                                          'where csuv.customer_unit_id = tu.customer_unit_id and ' +
                                                          'csuv.provider_service_value_id in (' + @IncludeServiceValueIds + ' ) ) '
   end

   if @ExcludeServiceValueIds <> '' begin
      if @IncludeServiceValueIds <> '' begin
         set @SelectUnitValues = @SelectUnitValues + 'and '
      end
      else begin
         set @SelectUnitValues = @SelectUnitValues + 'WHERE '
      end

      set @SelectUnitValues = @SelectUnitValues + 'not exists ' +
                                                        '( select csuv.customer_unit_id ' +
                                                        'from com_service_unit_value csuv ' +
                                                        'where csuv.customer_unit_id = tu.customer_unit_id and ' +
                                                        'csuv.provider_service_value_id in (' + @ExcludeServiceValueIds + ') ) '
   end

   set @SelectUnitValues = @SelectUnitValues + @OrderBy

   exec ( @TempTable + ' insert into @TempUnit ' + @SqlSelect + @SqlFrom + @SqlFrom2 + @SelectUnitValues )

    /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
   executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetCustomerUnitsByUnitTypeParent' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetCustomerUnitsByUnitTypeParent

   go

create procedure spGetCustomerUnitsByUnitTypeParent( @CustomerUnitId     integer,
                                                     @CustomerUnitTypeId integer ) as

   set nocount on

  declare @SqlSelect varchar(4000)
  declare @SqlFrom varchar(4000)
  declare @SqlFrom2 varchar(4000)
  declare @SqlIn varchar(4000)
  declare @Comma char(1)
  declare @i integer
  declare @ParentUnitTypeId integer
  declare @TopParentTypeId integer
  declare @PrevUnitTypeName varchar(100)
  declare @UnitTypeName varchar(100)
  declare @SystemName varchar(100)
  declare @SystemId integer
  declare @CustomerId integer
  declare @ParentUnitTypeName varchar(100)
  declare @ChildUnitTypeId integer
  declare @RowCount integer
  declare @TempTable varchar(4000)
  declare @SelectUnitValues varchar(4000)
  declare @OrderBy varchar(4000)

   declare @UnitTypeTable table ( UnitTypeId integer )
   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   set @SqlIn = ''
   set @Comma = ','

   set @ChildUnitTypeId = @CustomerUnitTypeId

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   select @SystemId = cut.provider_system_id,
          @SystemName = ISNULL(ps.PROVIDER_SYSTEM_NAME, tps.PROVIDER_SYSTEM_NAME )
   from customer_unit_type cut
   inner join provider_system ps on cut.provider_system_id = ps.provider_system_id
   left outer join dbo.TEMPLATE_PROVIDER_SYSTEM tps on ps.TEMPLATE_PROVIDER_SYSTEM_ID = tps.PROVIDER_SYSTEM_ID
   where cut.customer_unit_type_id = @ChildUnitTypeId

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   select @CustomerId = customer_id from customer_unit
   where customer_unit_id = @CustomerUnitId

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   while (@ChildUnitTypeId > 0 ) begin
      set @TopParentTypeId = @ChildUnitTypeId
      insert into @UnitTypeTable values ( @ChildUnitTypeId )
      select @ParentUnitTypeId = customer_unit_type_parent_id
      from customer_unit_type
      where customer_unit_type_id = @ChildUnitTypeId

      /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
      select @ErrorCode = @@Error

      /* If there was an error... */
      if ( @ErrorCode <> 00 ) begin

         /* Rollback the transaction. */
         rollback transaction

         /* Return the failure. */
         return 01

      end

      set @ChildUnitTypeId = @ParentUnitTypeId

   end

   select @ParentUnitTypeName = isnull(cut.customer_unit_type_name, tpcut.customer_unit_type_name)
   from customer_unit_type cut
   left outer join template_provider_customer_unit_type tpcut on cut.template_provider_customer_unit_type_id = tpcut.customer_unit_type_id
   where cut.customer_unit_type_id = @TopParentTypeId

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   set @SqlSelect = ' select m.member_name as MEMBER_NAME '
   set @SqlSelect = @SqlSelect + ', ''' + @SystemName + ''' as PROVIDER_SYSTEM_NAME '

   set @SqlFrom   = ' from member m '

   set @SqlFrom2 = ' '

   set @i = 1

   select @RowCount = count(*) from @UnitTypeTable

   set @TempTable = 'declare @TempUnit table ( MEMBER_NAME varchar(100), PROVIDER_SYSTEM_NAME varchar(100), '
   set @OrderBy = 'order by MEMBER_NAME, '

   declare unit_type_cursor cursor for
      select cut.customer_unit_type_id,
         isnull(cut.customer_unit_type_name, tpcut.customer_unit_type_name) as customer_unit_type_name
      from customer_unit_type cut
      left outer join template_provider_customer_unit_type tpcut on cut.template_provider_customer_unit_type_id = tpcut.customer_unit_type_id
      inner join @UnitTypeTable utt on cut.customer_unit_type_id = utt.UnitTypeId
      where cut.provider_system_id =  @SystemId
      order by cut.customer_unit_type_parent_id, cut.customer_unit_type_id

   open unit_type_cursor

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   fetch next from unit_type_cursor into
   @ParentUnitTypeId, @UnitTypeName

   while (@@fetch_status = 00) begin

      if ( @i = 1 ) begin
         set @TempTable = @TempTable + 'TOP_PARENT_UNIT_TYPE_NAME varchar(50), TOP_PARENT_UNIT_NAME varchar(100), TOP_PARENT_UNIT_ID integer '
         set @SqlSelect = @SqlSelect + ', ''' + @UnitTypeName + ''' as [TOP_PARENT_UNIT_TYPE_NAME], '
         select @UnitTypeName = Replace(@UnitTypeName, ' ', '_')
         set @SqlSelect = @SqlSelect + 'isnull([' + @UnitTypeName + '_cu].customer_unit_name, isnull([' + @UnitTypeName + '_cun].customer_unit_name, [' + @UnitTypeName + '_tpcun].customer_unit_name)) as [TOP_PARENT_UNIT_NAME], '
         set @SqlSelect = @SqlSelect + '[' + @UnitTypeName + '_cu].customer_unit_id as [TOP_PARENT_UNIT_ID] '
         set @OrderBy = @OrderBy + ' TOP_PARENT_UNIT_NAME '
      end

      if ( @i = @RowCount ) begin
         set @TempTable = @TempTable + ', CUSTOMER_UNIT_TYPE_NAME varchar(50), CUSTOMER_UNIT_NAME varchar(100), CUSTOMER_UNIT_ID integer '
         set @SqlSelect = @SqlSelect + ', ''' + @UnitTypeName + ''' as [CUSTOMER_UNIT_TYPE_NAME], '
         select @UnitTypeName = Replace(@UnitTypeName, ' ', '_')
         set @SqlSelect = @SqlSelect + 'isnull([' + @UnitTypeName + '_cu].customer_unit_name, isnull([' + @UnitTypeName + '_cun].customer_unit_name, [' + @UnitTypeName + '_tpcun].customer_unit_name)) as [CUSTOMER_UNIT_NAME], '
         set @SqlSelect = @SqlSelect + '[' + @UnitTypeName + '_cu].customer_unit_id as [CUSTOMER_UNIT_ID] '
         set @OrderBy = @OrderBy + ', CUSTOMER_UNIT_NAME '
      end
      else if ( @i = (@RowCount-1) ) begin
         set @TempTable = @TempTable + ', PARENT_UNIT_TYPE_NAME varchar(50), PARENT_UNIT_NAME varchar(100), PARENT_UNIT_ID integer '
         set @SqlSelect = @SqlSelect + ', ''' + @UnitTypeName + ''' as [PARENT_UNIT_TYPE_NAME], '
         select @UnitTypeName = Replace(@UnitTypeName, ' ', '_')
         set @SqlSelect = @SqlSelect + 'isnull([' + @UnitTypeName + '_cu].customer_unit_name, isnull([' + @UnitTypeName + '_cun].customer_unit_name, [' + @UnitTypeName + '_tpcun].customer_unit_name)) as [PARENT_UNIT_NAME], '
         set @SqlSelect = @SqlSelect + '[' + @UnitTypeName + '_cu].customer_unit_id as [PARENT_UNIT_ID] '
         set @OrderBy = @OrderBy + ', PARENT_UNIT_NAME '
      end
      else if ( @i <> 1 ) begin
         set @TempTable = @TempTable + ', [PARENT' + cast((@i-1) as char(1)) + '_UNIT_TYPE_NAME] varchar(50), [PARENT' + cast((@i-1) as char(1)) + '_UNIT_NAME] varchar(100), [PARENT' + cast((@i-1) as char(1)) + '_UNIT_ID] integer '
         set @SqlSelect = @SqlSelect + ', ''' + @UnitTypeName + ''' as [PARENT' + cast((@i-1) as char(1)) + '_UNIT_TYPE_NAME], '
         select @UnitTypeName = Replace(@UnitTypeName, ' ', '_')
         set @SqlSelect = @SqlSelect + 'isnull([' + @UnitTypeName + '_cu].customer_unit_name, isnull([' + @UnitTypeName + '_cun].customer_unit_name, [' + @UnitTypeName + '_tpcun].customer_unit_name)) as [PARENT' + cast((@i-1) as char(1)) + '_UNIT_NAME], '
         set @SqlSelect = @SqlSelect + '[' + @UnitTypeName + '_cu].customer_unit_id as [PARENT' + cast((@i-1) as char(1)) + '_UNIT_ID] '
         set @OrderBy = @OrderBy + ', [PARENT' + cast((@i-1) as char(1)) + '_UNIT_NAME] '
      end

      set @SqlFrom = @SqlFrom + ' inner join customer_unit [' + @UnitTypeName + '_cu] on m.member_id = [' + @UnitTypeName + '_cu].customer_id '

      if @PrevunitTypeName is not null begin
         set @SqlFrom = @SqlFrom + ' and [' + @PrevUnitTypeName + '_cu].customer_unit_id = [' + @UnitTypeName + '_cu].unit_parent_id '
      end

      set @SqlFrom = @SqlFrom + ' inner join join_customer_unit_type_customer_unit [' + @UnitTypeName + '_jcutcu] on [' + @UnitTypeName + '_cu].customer_unit_id = [' + @UnitTypeName + '_jcutcu].customer_unit_id '

      set @SqlFrom = @SqlFrom  + ' inner join customer_unit_type [' + @UnitTypeName + '_cut] on [' + @UnitTypeName + '_jcutcu].customer_unit_type_id = [' + @UnitTypeName + '_cut].customer_unit_type_id and [' + @UnitTypeName + '_cut].customer_unit_type_id = '
                               + cast(@ParentUnitTypeId as varchar(10)) + ' and [' + @UnitTypeName + '_cut].provider_system_id = ' + cast( @SystemId as varchar(10) )
      set @SqlFrom2 = @SqlFrom2 + ' left outer join template_provider_customer_unit_type [' + @UnitTypeName + '_tpcut] on [' + @UnitTypeName + '_cut].template_provider_customer_unit_type_id = [' + @UnitTypeName + '_tpcut].customer_unit_type_id '
      set @SqlFrom2 = @SqlFrom2 + ' left outer join customer_unit_name [' + @UnitTypeName + '_cun] on [' + @UnitTypeName + '_jcutcu].customer_unit_name_id = [' + @UnitTypeName + '_cun].customer_unit_name_id '
      set @SqlFrom2 = @SqlFrom2 + ' left outer join template_provider_customer_unit_name [' + @UnitTypeName + '_tpcun] on [' + @UnitTypeName + '_cun].template_provider_customer_unit_name_id = [' + @UnitTypeName + '_tpcun].customer_unit_name_id '

      set @PrevUnitTypeName = @UnitTypeName
      set @i = @i + 1

      fetch next from unit_type_cursor into
      @ParentUnitTypeId, @UnitTypeName

   end

   close unit_type_cursor
   deallocate unit_type_cursor

   set @TempTable = @TempTable + ' ) '
   set @SqlFrom2 = @SqlFrom2 + 'where [' + @ParentUnitTypeName + '_cu].customer_unit_id =' + cast(@CustomerUnitId as varchar(10))

   set @SelectUnitValues = ' select tu.*, '
   set @SelectUnitValues = @SelectUnitValues + 'cs.COM_SERVICE_DATE, '
   set @SelectUnitValues = @SelectUnitValues + 'ISNULL(psv.PROVIDER_SERVICE_VALUE, tpsv.PROVIDER_SERVICE_VALUE) as PROVIDER_SERVICE_VALUE, '
   set @SelectUnitValues = @SelectUnitValues + 'ISNULL(psv.PROVIDER_SERVICE_VALUE_TEXT, tpsv.PROVIDER_SERVICE_VALUE_TEXT) as PROVIDER_SERVICE_VALUE_TEXT '
   set @SelectUnitValues = @SelectUnitValues + 'from @TempUnit tu ' +
                                               'left outer join ( ' +
                                                       'select max(a.COM_SERVICE_UNIT_VALUE_ID) as COM_SERVICE_UNIT_VALUE_ID, a.CUSTOMER_UNIT_ID ' +
                                                       'from COM_SERVICE_UNIT_VALUE a, CUSTOMER_UNIT b ' +
                                                       'where a.CUSTOMER_UNIT_ID = b.CUSTOMER_UNIT_ID ' +
                                                         'and b.CUSTOMER_ID = ' + cast(@CustomerId  as varchar(10)) +
                                                       'group by a.CUSTOMER_UNIT_ID ) lastservice on tu.customer_unit_id = lastservice.customer_unit_id '
   set @SelectUnitValues = @SelectUnitValues + 'left outer join com_service_unit_value csuv on csuv.customer_unit_id = tu.customer_unit_id ' +
                                                                                           'and lastservice.com_service_unit_value_id = csuv.com_service_unit_value_id '
   set @SelectUnitValues = @SelectUnitValues + 'left outer join dbo.COM_SERVICE cs on csuv.com_service_id = cs.com_service_id ' +
                                                                                     'and cs.customer_unit_id = tu.TOP_PARENT_UNIT_ID '
   set @SelectUnitValues = @SelectUnitValues + 'left outer join dbo.PROVIDER_SERVICE_VALUE psv on csuv.PROVIDER_SERVICE_VALUE_ID = psv.PROVIDER_SERVICE_VALUE_ID '
   set @SelectUnitValues = @SelectUnitValues + 'left outer join dbo.TEMPLATE_PROVIDER_SERVICE_VALUE tpsv on psv.TEMPLATE_PROVIDER_SERVICE_VALUE_ID = tpsv.PROVIDER_SERVICE_VALUE_ID '

   set @SelectUnitValues = @SelectUnitValues + @OrderBy

   exec ( @TempTable + ' insert into @TempUnit ' + @SqlSelect + @SqlFrom + @SqlFrom2 + @SelectUnitValues )

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

     /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetCustomerUnitsByUnitTypeParentExport' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetCustomerUnitsByUnitTypeParentExport

   go

create procedure spGetCustomerUnitsByUnitTypeParentExport( @CustomerUnitId     integer,
                                                           @CustomerUnitTypeId integer )  as

  declare @Sql varchar(4000),
           @SqlSelect varchar(4000),
           @SqlFrom varchar(4000),
           @SqlFrom2 varchar(4000),
           @SqlIn varchar(4000),
           @Comma char(1),
           @i integer,
           @ParentUnitTypeId integer,
           @ParentUnitTypeName varchar(100),
           @PrevUnitTypeName varchar(100),
           @UnitTypeName varchar(100),
           @SystemName varchar(100),
           @SystemId integer,
           @ChildUnitTypeId integer,
           @TopParentTypeId integer

   declare @UnitTypeTable table ( UnitTypeId integer )

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   set nocount on

      /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   set @SqlIn = ''
   set @Comma = ','

   set @ChildUnitTypeId = @CustomerUnitTypeId

   select @SystemId = cut.provider_system_id,
          @SystemName = ISNULL(ps.PROVIDER_SYSTEM_NAME, tps.PROVIDER_SYSTEM_NAME )
   from customer_unit_type cut
   inner join provider_system ps on cut.provider_system_id = ps.provider_system_id
   left outer join dbo.TEMPLATE_PROVIDER_SYSTEM tps on ps.TEMPLATE_PROVIDER_SYSTEM_ID = tps.PROVIDER_SYSTEM_ID
   where cut.customer_unit_type_id = @ChildUnitTypeId

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   while (@ChildUnitTypeId > 0 ) begin
      set @TopParentTypeId = @ChildUnitTypeId
      insert into @UnitTypeTable values ( @ChildUnitTypeId )
      select @ParentUnitTypeId = customer_unit_type_parent_id
      from customer_unit_type
      where customer_unit_type_id = @ChildUnitTypeId

      /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
      select @ErrorCode = @@Error

      /* If there was an error... */
      if ( @ErrorCode <> 00 ) begin

         /* Rollback the transaction. */
         rollback transaction

         /* Return the failure. */
         return 01

      end

      set @ChildUnitTypeId = @ParentUnitTypeId

   end

   select @ParentUnitTypeName = isnull(cut.customer_unit_type_name, tpcut.customer_unit_type_name)
   from customer_unit_type cut
   left outer join template_provider_customer_unit_type tpcut on cut.template_provider_customer_unit_type_id = tpcut.customer_unit_type_id
   where cut.customer_unit_type_id = @TopParentTypeId

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   set @SqlSelect = ' select m.member_name as CustomerName '
   set @SqlSelect = @SqlSelect + ', ''' + @SystemName + ''' as System '

   set @SqlFrom   = ' from member m '
   set @SqlFrom2  = ' '

   set @i = 1

   declare unit_type_cursor cursor for
      select cut.customer_unit_type_id,
         isnull(cut.customer_unit_type_name, tpcut.customer_unit_type_name) as customer_unit_type_name
      from customer_unit_type cut
      left outer join template_provider_customer_unit_type tpcut on cut.template_provider_customer_unit_type_id = tpcut.customer_unit_type_id
      inner join @UnitTypeTable utt on cut.customer_unit_type_id = utt.UnitTypeId
      where cut.provider_system_id =  @SystemId
      order by cut.customer_unit_type_parent_id, cut.customer_unit_type_id

   open unit_type_cursor

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   fetch next from unit_type_cursor into
   @CustomerUnitTypeId, @UnitTypeName

   while (@@fetch_status = 00) begin

      set @SqlSelect = @SqlSelect + ', ''' + @UnitTypeName + ''' as Field' + cast(@i as char(1))

      select @UnitTypeName = Replace(@UnitTypeName, ' ', '_')

      set @SqlSelect = @SqlSelect + ', isnull([' + @UnitTypeName + '_cu].customer_unit_name, isnull([' + @UnitTypeName + '_cun].customer_unit_name, [' + @UnitTypeName + '_tpcun].customer_unit_name)) as [Field' + cast(@i as char(1)) + '_Name], '
      set @SqlSelect = @SqlSelect + ' isnull([' + @UnitTypeName + '_cu].customer_unit_number, isnull([' + @UnitTypeName + '_cun].customer_unit_number, [' + @UnitTypeName + '_tpcun].customer_unit_number)) as [Field' + cast(@i as char(1)) + '_Barcode], '
      set @SqlSelect = @SqlSelect + '[' + @UnitTypeName + '_cu].customer_unit_id as [Field' + cast(@i as char(1)) + '_id_id] '
      set @SqlFrom = @SqlFrom + ' inner join customer_unit [' + @UnitTypeName + '_cu] on m.member_id = [' + @UnitTypeName + '_cu].customer_id '

      if @PrevunitTypeName is not null begin
         set @SqlFrom = @SqlFrom + ' and [' + @PrevUnitTypeName + '_cu].customer_unit_id = [' + @UnitTypeName + '_cu].unit_parent_id '
      end
      set @SqlFrom = @SqlFrom + ' inner join join_customer_unit_type_customer_unit [' + @UnitTypeName + '_jcutcu] on [' + @UnitTypeName + '_cu].customer_unit_id = [' + @UnitTypeName + '_jcutcu].customer_unit_id '
      set @SqlFrom = @SqlFrom + ' inner join customer_unit_type [' + @UnitTypeName + '_cut] on [' + @UnitTypeName + '_jcutcu].customer_unit_type_id = [' + @UnitTypeName + '_cut].customer_unit_type_id and [' + @UnitTypeName + '_cut].customer_unit_type_id = '
                              + cast(@CustomerUnitTypeId as varchar(10)) + ' and [' + @UnitTypeName + '_cut].provider_system_id = ' + cast( @SystemId as varchar(10) )
      set @SqlFrom2 = @SqlFrom2 + ' left outer join template_provider_customer_unit_type [' + @UnitTypeName + '_tpcut] on [' + @UnitTypeName + '_cut].template_provider_customer_unit_type_id = [' + @UnitTypeName + '_tpcut].customer_unit_type_id '
      set @SqlFrom2 = @SqlFrom2 + ' left outer join customer_unit_name [' + @UnitTypeName + '_cun] on [' + @UnitTypeName + '_jcutcu].customer_unit_name_id = [' + @UnitTypeName + '_cun].customer_unit_name_id '
      set @SqlFrom2 = @SqlFrom2 + ' left outer join template_provider_customer_unit_name [' + @UnitTypeName + '_tpcun] on [' + @UnitTypeName + '_cun].template_provider_customer_unit_name_id = [' + @UnitTypeName + '_tpcun].customer_unit_name_id '

      set @PrevUnitTypeName = @UnitTypeName
      set @i = @i + 1

      fetch next from unit_type_cursor into
      @CustomerUnitTypeId, @UnitTypeName

   end

   close unit_type_cursor
   deallocate unit_type_cursor

   set @SqlFrom2 = @SqlFrom2 + 'where [' + @ParentUnitTypeName + '_cu].customer_unit_id =' + cast(@CustomerUnitId as varchar(10))

   exec ( @SqlSelect + @SqlFrom + @SqlFrom2 )

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

      /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetCustomerUnitsByUnitTypeParentServiceValues' and xtype = 'P' ) )


   /* Remove it. */
   drop procedure spGetCustomerUnitsByUnitTypeParentServiceValues

   go

create procedure spGetCustomerUnitsByUnitTypeParentServiceValues( @CustomerUnitId         integer,
                                                                  @CustomerUnitTypeId     integer,
                                                                  @IncludeServiceValueIds varchar(4000)= NULL,
                                                                  @ExcludeServiceValueIds varchar(4000)= NULL ) as
   set nocount on

   declare @SqlSelect varchar(4000)
   declare @SqlFrom varchar(4000)
   declare @SqlFrom2 varchar(4000)
   declare @SqlIn varchar(4000)
   declare @Comma char(1)
   declare @i integer
   declare @ParentUnitTypeId integer
   declare @TopParentTypeId integer
   declare @PrevUnitTypeName varchar(100)
   declare @UnitTypeName varchar(100)
   declare @SystemName varchar(100)
   declare @SystemId integer
   declare @CustomerId integer
   declare @ParentUnitTypeName varchar(100)
   declare @ChildUnitTypeId integer
   declare @RowCount integer
   declare @TempTable varchar(4000)
   declare @SelectUnitValues varchar(4000)
   declare @OrderBy varchar(4000)

   declare @UnitTypeTable table ( UnitTypeId integer )

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   set @SqlIn = ''
   set @Comma = ','

   set @ChildUnitTypeId = @CustomerUnitTypeId

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   select @SystemId = cut.provider_system_id,
          @SystemName = ISNULL(ps.PROVIDER_SYSTEM_NAME, tps.PROVIDER_SYSTEM_NAME )
   from customer_unit_type cut
   inner join provider_system ps on cut.provider_system_id = ps.provider_system_id
   left outer join dbo.TEMPLATE_PROVIDER_SYSTEM tps on ps.TEMPLATE_PROVIDER_SYSTEM_ID = tps.PROVIDER_SYSTEM_ID
   where cut.customer_unit_type_id = @ChildUnitTypeId

  /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   select @CustomerId = customer_id from customer_unit
   where customer_unit_id = @CustomerUnitId

  /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   while (@ChildUnitTypeId > 0 ) begin
      set @TopParentTypeId = @ChildUnitTypeId
      insert into @UnitTypeTable values ( @ChildUnitTypeId )
      select @ParentUnitTypeId = customer_unit_type_parent_id
      from customer_unit_type
      where customer_unit_type_id = @ChildUnitTypeId

      set @ChildUnitTypeId = @ParentUnitTypeId

   end

   select @ParentUnitTypeName = isnull(cut.customer_unit_type_name, tpcut.customer_unit_type_name)
   from customer_unit_type cut
   left outer join template_provider_customer_unit_type tpcut on cut.template_provider_customer_unit_type_id = tpcut.customer_unit_type_id
   where cut.customer_unit_type_id = @TopParentTypeId

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   set @SqlSelect = ' select m.member_name as MEMBER_NAME '
   set @SqlSelect = @SqlSelect + ', ''' + @SystemName + ''' as PROVIDER_SYSTEM_NAME '

   set @SqlFrom   = ' from member m '

   set @SqlFrom2 = ' '

   set @i = 1

   select @RowCount = count(*) from @UnitTypeTable

   set @TempTable = 'declare @TempUnit table ( MEMBER_NAME varchar(100), PROVIDER_SYSTEM_NAME varchar(100), '
   set @OrderBy = 'order by MEMBER_NAME, '

   declare unit_type_cursor cursor for
      select cut.customer_unit_type_id,
         isnull(cut.customer_unit_type_name, tpcut.customer_unit_type_name) as customer_unit_type_name
      from customer_unit_type cut
      left outer join template_provider_customer_unit_type tpcut on cut.template_provider_customer_unit_type_id = tpcut.customer_unit_type_id
      inner join @UnitTypeTable utt on cut.customer_unit_type_id = utt.UnitTypeId
      where cut.provider_system_id =  @SystemId
      order by cut.customer_unit_type_parent_id, cut.customer_unit_type_id

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   open unit_type_cursor

  /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   fetch next from unit_type_cursor into
   @ParentUnitTypeId, @UnitTypeName

   while (@@fetch_status = 00) begin

      if ( @i = 1 ) begin
         set @TempTable = @TempTable + 'TOP_PARENT_UNIT_TYPE_NAME varchar(50), TOP_PARENT_UNIT_NAME varchar(100), TOP_PARENT_UNIT_ID integer '
         set @SqlSelect = @SqlSelect + ', ''' + @UnitTypeName + ''' as [TOP_PARENT_UNIT_TYPE_NAME], '
         select @UnitTypeName = Replace(@UnitTypeName, ' ', '_')
         set @SqlSelect = @SqlSelect + 'isnull([' + @UnitTypeName + '_cu].customer_unit_name, isnull([' + @UnitTypeName + '_cun].customer_unit_name, [' + @UnitTypeName + '_tpcun].customer_unit_name)) as [TOP_PARENT_UNIT_NAME], '
         set @SqlSelect = @SqlSelect + '[' + @UnitTypeName + '_cu].customer_unit_id as [TOP_PARENT_UNIT_ID] '
         set @OrderBy = @OrderBy + ' TOP_PARENT_UNIT_NAME '
      end

      if ( @i = @RowCount ) begin
         set @TempTable = @TempTable + ', CUSTOMER_UNIT_TYPE_NAME varchar(50), CUSTOMER_UNIT_NAME varchar(100), CUSTOMER_UNIT_ID integer '
         set @SqlSelect = @SqlSelect + ', ''' + @UnitTypeName + ''' as [CUSTOMER_UNIT_TYPE_NAME], '
         select @UnitTypeName = Replace(@UnitTypeName, ' ', '_')
         set @SqlSelect = @SqlSelect + 'isnull([' + @UnitTypeName + '_cu].customer_unit_name, isnull([' + @UnitTypeName + '_cun].customer_unit_name, [' + @UnitTypeName + '_tpcun].customer_unit_name)) as [CUSTOMER_UNIT_NAME], '
         set @SqlSelect = @SqlSelect + '[' + @UnitTypeName + '_cu].customer_unit_id as [CUSTOMER_UNIT_ID] '
         set @OrderBy = @OrderBy + ', CUSTOMER_UNIT_NAME '
      end
      else if ( @i = (@RowCount-1) ) begin
         set @TempTable = @TempTable + ', PARENT_UNIT_TYPE_NAME varchar(50), PARENT_UNIT_NAME varchar(100), PARENT_UNIT_ID integer '
         set @SqlSelect = @SqlSelect + ', ''' + @UnitTypeName + ''' as [PARENT_UNIT_TYPE_NAME], '
         select @UnitTypeName = Replace(@UnitTypeName, ' ', '_')
         set @SqlSelect = @SqlSelect + 'isnull([' + @UnitTypeName + '_cu].customer_unit_name, isnull([' + @UnitTypeName + '_cun].customer_unit_name, [' + @UnitTypeName + '_tpcun].customer_unit_name)) as [PARENT_UNIT_NAME], '
         set @SqlSelect = @SqlSelect + '[' + @UnitTypeName + '_cu].customer_unit_id as [PARENT_UNIT_ID] '
         set @OrderBy = @OrderBy + ', PARENT_UNIT_NAME '
      end
      else if ( @i <> 1 ) begin
         set @TempTable = @TempTable + ', [PARENT' + cast((@i-1) as char(1)) + '_UNIT_TYPE_NAME] varchar(50), [PARENT' + cast((@i-1) as char(1)) + '_UNIT_NAME] varchar(100), [PARENT' + cast((@i-1) as char(1)) + '_UNIT_ID] integer '
         set @SqlSelect = @SqlSelect + ', ''' + @UnitTypeName + ''' as [PARENT' + cast((@i-1) as char(1)) + '_UNIT_TYPE_NAME], '
         select @UnitTypeName = Replace(@UnitTypeName, ' ', '_')
         set @SqlSelect = @SqlSelect + 'isnull([' + @UnitTypeName + '_cu].customer_unit_name, isnull([' + @UnitTypeName + '_cun].customer_unit_name, [' + @UnitTypeName + '_tpcun].customer_unit_name)) as [PARENT' + cast((@i-1) as char(1)) + '_UNIT_NAME], '
         set @SqlSelect = @SqlSelect + '[' + @UnitTypeName + '_cu].customer_unit_id as [PARENT' + cast((@i-1) as char(1)) + '_UNIT_ID] '
         set @OrderBy = @OrderBy + ', [PARENT' + cast((@i-1) as char(1)) + '_UNIT_NAME] '
      end

      set @SqlFrom = @SqlFrom + ' inner join customer_unit [' + @UnitTypeName + '_cu] on m.member_id = [' + @UnitTypeName + '_cu].customer_id '

      if @PrevunitTypeName is not null begin
         set @SqlFrom = @SqlFrom + ' and [' + @PrevUnitTypeName + '_cu].customer_unit_id = [' + @UnitTypeName + '_cu].unit_parent_id '
      end

      set @SqlFrom = @SqlFrom + ' inner join join_customer_unit_type_customer_unit [' + @UnitTypeName + '_jcutcu] on [' + @UnitTypeName + '_cu].customer_unit_id = [' + @UnitTypeName + '_jcutcu].customer_unit_id '

      set @SqlFrom = @SqlFrom  + ' inner join customer_unit_type [' + @UnitTypeName + '_cut] on [' + @UnitTypeName + '_jcutcu].customer_unit_type_id = [' + @UnitTypeName + '_cut].customer_unit_type_id and [' + @UnitTypeName + '_cut].customer_unit_type_id = '
                               + cast(@ParentUnitTypeId as varchar(10)) + ' and [' + @UnitTypeName + '_cut].provider_system_id = ' + cast( @SystemId as varchar(10) )
      set @SqlFrom2 = @SqlFrom2 + ' left outer join template_provider_customer_unit_type [' + @UnitTypeName + '_tpcut] on [' + @UnitTypeName + '_cut].template_provider_customer_unit_type_id = [' + @UnitTypeName + '_tpcut].customer_unit_type_id '
      set @SqlFrom2 = @SqlFrom2 + ' left outer join customer_unit_name [' + @UnitTypeName + '_cun] on [' + @UnitTypeName + '_jcutcu].customer_unit_name_id = [' + @UnitTypeName + '_cun].customer_unit_name_id '
      set @SqlFrom2 = @SqlFrom2 + ' left outer join template_provider_customer_unit_name [' + @UnitTypeName + '_tpcun] on [' + @UnitTypeName + '_cun].template_provider_customer_unit_name_id = [' + @UnitTypeName + '_tpcun].customer_unit_name_id '

      set @PrevUnitTypeName = @UnitTypeName
      set @i = @i + 1

      fetch next from unit_type_cursor into
      @ParentUnitTypeId, @UnitTypeName

   end

   close unit_type_cursor
   deallocate unit_type_cursor

   set @TempTable = @TempTable + ' ) '
   set @SqlFrom2 = @SqlFrom2 + 'where [' + @ParentUnitTypeName + '_cu].customer_unit_id =' + cast(@CustomerUnitId as varchar(10))

   set @SelectUnitValues = ' select tu.*, '
   set @SelectUnitValues = @SelectUnitValues + 'cs.COM_SERVICE_DATE, '
   set @SelectUnitValues = @SelectUnitValues + 'ISNULL(psv.PROVIDER_SERVICE_VALUE, tpsv.PROVIDER_SERVICE_VALUE) as PROVIDER_SERVICE_VALUE, '
   set @SelectUnitValues = @SelectUnitValues + 'ISNULL(psv.PROVIDER_SERVICE_VALUE_TEXT, tpsv.PROVIDER_SERVICE_VALUE_TEXT) as PROVIDER_SERVICE_VALUE_TEXT '
   set @SelectUnitValues = @SelectUnitValues + 'from @TempUnit tu ' +
                                               'left outer join ( ' +
                                                       'select max(a.COM_SERVICE_UNIT_VALUE_ID) as COM_SERVICE_UNIT_VALUE_ID, a.CUSTOMER_UNIT_ID ' +
                                                       'from COM_SERVICE_UNIT_VALUE a, CUSTOMER_UNIT b ' +
                                                       'where a.CUSTOMER_UNIT_ID = b.CUSTOMER_UNIT_ID ' +
                                                         'and b.CUSTOMER_ID = ' + cast(@CustomerId  as varchar(10)) +
                                                       'group by a.CUSTOMER_UNIT_ID ) lastservice on tu.customer_unit_id = lastservice.customer_unit_id '
   set @SelectUnitValues = @SelectUnitValues + 'inner join com_service_unit_value csuv on csuv.customer_unit_id = tu.customer_unit_id ' +
                                                                                           'and lastservice.com_service_unit_value_id = csuv.com_service_unit_value_id '
   set @SelectUnitValues = @SelectUnitValues + 'inner join dbo.COM_SERVICE cs on csuv.com_service_id = cs.com_service_id ' +
                                                                                     'and cs.customer_unit_id = tu.TOP_PARENT_UNIT_ID '
   set @SelectUnitValues = @SelectUnitValues + 'left outer join dbo.PROVIDER_SERVICE_VALUE psv on csuv.PROVIDER_SERVICE_VALUE_ID = psv.PROVIDER_SERVICE_VALUE_ID '
   set @SelectUnitValues = @SelectUnitValues + 'left outer join dbo.TEMPLATE_PROVIDER_SERVICE_VALUE tpsv on psv.TEMPLATE_PROVIDER_SERVICE_VALUE_ID = tpsv.PROVIDER_SERVICE_VALUE_ID '

   if @IncludeServiceValueIds <> '' begin
      set @SelectUnitValues = @SelectUnitValues + 'WHERE exists ' +
                                                        '( select csuv.customer_unit_id ' +
                                                          'from com_service_unit_value csuv ' +
                                                          'where csuv.customer_unit_id = tu.customer_unit_id and ' +
                                                          'csuv.provider_service_value_id in (' + @IncludeServiceValueIds + ' ) ) '
   end

   if @ExcludeServiceValueIds <> '' begin
      if @IncludeServiceValueIds <> '' begin
         set @SelectUnitValues = @SelectUnitValues + 'and '
      end
      else begin
         set @SelectUnitValues = @SelectUnitValues + 'WHERE '
      end

      set @SelectUnitValues = @SelectUnitValues + 'not exists ' +
                                                        '( select csuv.customer_unit_id ' +
                                                        'from com_service_unit_value csuv ' +
                                                        'where csuv.customer_unit_id = tu.customer_unit_id and ' +
                                                        'csuv.provider_service_value_id in (' + @ExcludeServiceValueIds + ') ) '
   end

   set @SelectUnitValues = @SelectUnitValues + @OrderBy

   exec ( @TempTable + ' insert into @TempUnit ' + @SqlSelect + @SqlFrom + @SqlFrom2 + @SelectUnitValues )

  /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

     /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetCustomerUnitsByUnitTypeSystemUser' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetCustomerUnitsByUnitTypeSystemUser

   go

create procedure spGetCustomerUnitsByUnitTypeSystemUser( @ProviderSystemId integer,
                                                         @unittypeid       integer,
                                                         @MemberUserId     integer ) as

   declare @securitygroupid integer
   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   select @securitygroupid = SECURITY_GROUP_ID FROM JOIN_MEMBER_USER_SECURITY_GROUP WHERE MEMBER_USER_ID = @MemberUserId

    /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   if @securitygroupid < 6 begin
      select customer_unit_id,
             customer_unit_name,
             customer_unit_number,
             unit_parent_id
      from vw_customer_units_by_system_user
      where member_user_id = @MemberUserId
      and provider_system_id = @ProviderSystemId
      and customer_unit_type_id = @unittypeid
      order by customer_unit_name

   end
   else begin
      declare @customerid integer
      select @customerid = MEMBER_ID FROM MEMBER_USER WHERE MEMBER_USER_ID = @MemberUserId
      select customer_unit_id,
             customer_unit_name,
             customer_unit_number,
             unit_parent_id
      from vw_customer_units_by_system_customer
      where customer_id = @customerid
      and provider_system_id = @ProviderSystemId
      and customer_unit_type_id = @unittypeid
      order by customer_unit_name
   end

    /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

    /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetCustomerUnitsByUnitTypeUser' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetCustomerUnitsByUnitTypeUser

   go

create procedure spGetCustomerUnitsByUnitTypeUser( @ProviderSystemId   integer,
                                                   @CustomerUnitTypeId integer,
                                                   @MemberUserId       integer ) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */
   -- new stored procedure
   execute @ReturnCode = spGetCustomerUnitsByUnitTypeSystemUser @ProviderSystemId,
                                                                @CustomerUnitTypeId,
                                                                @MemberUserId

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetCustomerUnitsforUserByType' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetCustomerUnitsforUserByType

   go

create procedure spGetCustomerUnitsforUserByType( @ProviderSystemId   integer,
                                                  @CustomerUnitTypeId integer,
												  @MemberUserId       integer ) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   -- new procedure
   execute @ReturnCode = spGetCustomerUnitsByUnitTypeSystemUser @ProviderSystemId, @CustomerUnitTypeId, @MemberUserId

    /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetCustomerUnitsWithLayoutsBySystemUser' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetCustomerUnitsWithLayoutsBySystemUser

   go

create procedure spGetCustomerUnitsWithLayoutsBySystemUser( @MemberUserId     integer,
                                                            @ProviderSystemId integer ) as

    declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   -- new procedure ( maybe rename misspelling in datainterface? )
   execute @ReturnCode = spGetCustomerUnitWithLayoutsBySystemUser @MemberUserId, @ProviderSystemId

    /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetCustomerUnitTypesByCustomer' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetCustomerUnitTypesByCustomer

   go

create procedure spGetCustomerUnitTypesByCustomer( @customerid integer ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   SELECT DISTINCT c.CUSTOMER_UNIT_TYPE_ID,
	           isnull( c.CUSTOMER_UNIT_TYPE_NAME, d.CUSTOMER_UNIT_TYPE_NAME ) as CUSTOMER_UNIT_TYPE_NAME,
	           c.CUSTOMER_UNIT_TYPE_PARENT_ID,
	           c.PROVIDER_SYSTEM_ID
   FROM CUSTOMER_UNIT a
   LEFT OUTER JOIN JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT b on a.customer_unit_id = b.customer_unit_id
   LEFT OUTER JOIN CUSTOMER_UNIT_TYPE c on b.customer_unit_type_id = c.customer_unit_type_id
   LEFT OUTER JOIN TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE d ON c.TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE_ID = d.CUSTOMER_UNIT_TYPE_ID
   WHERE a.CUSTOMER_ID = @customerid

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 )  begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetCustomerUnitTypesByProviderSystem' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetCustomerUnitTypesByProviderSystem

   go

create procedure spGetCustomerUnitTypesByProviderSystem( @ProviderSystemId integer ) as

   set nocount on

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   select cut.CUSTOMER_UNIT_TYPE_ID,
   ISNULL( cut.CUSTOMER_UNIT_TYPE_NAME, tpcut.CUSTOMER_UNIT_TYPE_NAME ) as CUSTOMER_UNIT_TYPE_NAME
   from dbo.CUSTOMER_UNIT_TYPE cut
   left join dbo.TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE tpcut on cut.TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE_ID = tpcut.CUSTOMER_UNIT_TYPE_ID
   where PROVIDER_SYSTEM_ID = @ProviderSystemId
   order by CUSTOMER_UNIT_TYPE_NAME

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetCustomerUnitTypesByProviderSystemId' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetCustomerUnitTypesByProviderSystemId

   go

create procedure spGetCustomerUnitTypesByProviderSystemId( @providersystemid integer,
                                                           @unittypeparentid integer = -1 ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

  SELECT a.CUSTOMER_UNIT_TYPE_ID,
	isnull( a.CUSTOMER_UNIT_TYPE_NAME, c.CUSTOMER_UNIT_TYPE_NAME ) as CUSTOMER_UNIT_TYPE_NAME,
	a.CUSTOMER_UNIT_TYPE_PARENT_ID,
	ISNULL(c.CUSTOMER_UNIT_TYPE_MOD,1) AS CUSTOMER_UNIT_TYPE_MOD,
	a.TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE_ID
   FROM CUSTOMER_UNIT_TYPE a
   LEFT OUTER JOIN TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE c ON a.TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE_ID = c.CUSTOMER_UNIT_TYPE_ID
   WHERE a.PROVIDER_SYSTEM_ID = @providersystemid
   AND a.CUSTOMER_UNIT_TYPE_PARENT_ID = @unittypeparentid

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetCustomerUnitTypesBySystem' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetCustomerUnitTypesBySystem

   go

create procedure spGetCustomerUnitTypesBySystem( @ProviderSystemId integer,
                                                 @UnitTypeParentId integer = -1 ) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   -- new procedure
   execute @ReturnCode = spGetCustomerUnitTypesByProviderSystemId @ProviderSystemId,
                                                                  @UnitTypeParentId

    /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetCustomerUnitTypesBySystemUser' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetCustomerUnitTypesBySystemUser

   go

create procedure spGetCustomerUnitTypesBySystemUser( @ProviderSystemId integer,
                                                     @MemberUserId     integer ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   select a.customer_unit_type_id,
	isnull( a.customer_unit_type_name, b.customer_unit_type_name ) as customer_unit_type_name,
	a.customer_unit_type_parent_id
   from customer_unit_type a
   left outer join template_provider_customer_unit_type b on a.template_provider_customer_unit_type_id = b.customer_unit_type_id
   where a.provider_system_id = @ProviderSystemId
   order by a.customer_unit_type_id

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if  ( @ErrorCode <> 00 )  begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetCustomerUnitTypesByUser' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetCustomerUnitTypesByUser

   go

create procedure spGetCustomerUnitTypesByUser( @ProviderSystemId integer,
                                               @MemberUserId     integer ) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   -- new procedure
   execute @ReturnCode = spGetCustomerUnitTypesBySystemUser @ProviderSystemId, @MemberUserId

    /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetCustomerUnitWithLayoutsBySystemUser' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetCustomerUnitWithLayoutsBySystemUser

   go

create procedure spGetCustomerUnitWithLayoutsBySystemUser( @memberuserid     integer,
                                                           @providersystemid integer ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   declare @securitygroupid integer

   select @securitygroupid = SECURITY_GROUP_ID FROM JOIN_MEMBER_USER_SECURITY_GROUP WHERE MEMBER_USER_ID = @memberuserid

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   if @securitygroupid < 6 begin
      select b.customer_unit_id,
	     customer_unit_type_name,
	     customer_unit_name,
	     customer_unit_number
      from vw_customer_units_by_system_user a,
         customer_unit_layout_image b
      where a.customer_unit_id = b.customer_unit_id
      and member_user_id = @memberuserid
      and provider_system_id = @providersystemid
   end
   else begin
      declare @customerid integer
      select @customerid = MEMBER_ID FROM MEMBER_USER WHERE MEMBER_USER_ID = @memberuserid
      select b.customer_unit_id,
             customer_unit_type_name,
	     customer_unit_name,
	     customer_unit_number
      from vw_customer_units_by_system_customer a,
         customer_unit_layout_image b
      where a.customer_unit_id = b.customer_unit_id
      and customer_id = @customerid
      and provider_system_id = @providersystemid
   end

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 )  begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetCustomerUserContact' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetCustomerUserContact

   go

create procedure spGetCustomerUserContact( @CustomerUserId integer ) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   -- new stored procedure
   execute @ReturnCode = spGetContactInfoForEntity @CustomerUserId,
                                                 2

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetCustomerUserNameByCustomerUserId' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetCustomerUserNameByCustomerUserId

   go

create procedure spGetCustomerUserNameByCustomerUserId( @CustomerUserId        integer,
                                                        @CustomerUserFirstName varchar(25) output,
                                                        @CustomerUserLastName  varchar(25) output ) as

   /* Get the name of the customer user. */
   execute spGetMemberUserNameByMemberUserId @CustomerUserId,
                                             @CustomerUserFirstName output,
                                             @CustomerUserLastName  output

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetCustomerUserSuperUserCountByCustomer' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetCustomerUserSuperUserCountByCustomer

   go

create procedure spGetCustomerUserSuperUserCountByCustomer( @CustomerId     integer,
                                                            @CustomerUserId integer,
                                                            @SuperUserCount integer output ) as

   /* Execute the general member user security group counting procedure to
      return the number of super users for the passed customer.  Note the
      scalar value for the super user security group identifier.  This value
      is found in the security group table. */
   execute spGetMemberUserSecurityGroupCountByMember @CustomerId,
                                                     06,
                                                     @CustomerUserId,
                                                     @SuperUserCount output

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetDistinctCustomerSubstringsByProvider' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetDistinctCustomerSubstringsByProvider

   go

create procedure spGetDistinctCustomerSubstringsByProvider( @providerid integer ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   select distinct substring(member_name, 1, 1) as LETTER
   from member a
   left outer join provider_customer b on a.member_id = b.customer_id
   where b.provider_id = @providerid
   order by LETTER

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetDistinctCustomerSubstringsByProviderUser' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetDistinctCustomerSubstringsByProviderUser

   go

create procedure spGetDistinctCustomerSubstringsByProviderUser ( @ProviderId   integer,
                                                                 @MemberUserId integer ) as

   select distinct substring(member_name, 1, 1) as LETTER
   from member m
   inner join provider_customer pc on m.member_id = pc.customer_id
   inner join customer_unit cu on pc.customer_id = cu.customer_id and cu.unit_parent_id = -1
   inner join join_member_group_customer_unit jmgcu on cu.customer_unit_id = jmgcu.customer_unit_id
   inner join join_member_group_user jmgu on jmgcu.member_group_id = jmgu.member_group_id
   where pc.provider_id      = @ProviderId
     and jmgu.member_user_id = @MemberUserId

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetDistinctCustomerSubstringsBySystem' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetDistinctCustomerSubstringsBySystem

   go

create procedure spGetDistinctCustomerSubstringsBySystem( @ProviderSystemId integer ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   select distinct substring(member_name, 1, 1) as LETTER
   from member a
   left outer join provider_customer b on a.member_id = b.customer_id
   left outer join provider_customer_service c on b.provider_customer_id = c.provider_customer_id
   where c.provider_system_id = @ProviderSystemId

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetDistinctCustomerSubstringsBySystemUser' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetDistinctCustomerSubstringsBySystemUser

   go

create procedure spGetDistinctCustomerSubstringsBySystemUser ( @ProviderSystemId integer,
                                                               @MemberUserId     integer ) as

   select distinct substring(member_name, 1, 1) as LETTER
   from member m
   inner join provider_customer pc on m.member_id = pc.customer_id
   inner join provider_customer_service pcs on pc.provider_customer_id = pcs.provider_customer_id
   inner join customer_unit cu on pc.customer_id = cu.customer_id and cu.unit_parent_id = -1
   inner join join_member_group_customer_unit jmgcu on cu.customer_unit_id = jmgcu.customer_unit_id
   inner join join_member_group_user jmgu on jmgcu.member_group_id = jmgu.member_group_id
   where pcs.provider_system_id = @ProviderSystemId
     and jmgu.member_user_id    = @MemberUserId

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetEntityTypes' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetEntityTypes

   go

create procedure spGetEntityTypes as

   select et.ENTITY_TYPE_ID,
          et.ENTITY_TYPE
   from dbo.ENTITY_TYPE et
   order by et.ENTITY_TYPE

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetForeignTypesByEntityTypeId' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetForeignTypesByEntityTypeId

   go

create procedure spGetForeignTypesByEntityTypeId( @InterfaceId  integer,
                                                  @EntityTypeId integer ) as

  select distinct( me.FOREIGN_TYPE ) from
                MAPPING_ENTITY me where
                me.INTERFACE_ID   = @InterfaceId and
                me.ENTITY_TYPE_ID = @EntityTypeId
                order by me.FOREIGN_TYPE

go

/******************************************************************************/
/******************* Provider Service Data Type Procedures ********************/
/******************************************************************************/

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetGroupsByCustomerGroupType' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetGroupsByCustomerGroupType

   go

create procedure spGetGroupsByCustomerGroupType( @CustomerGroupTypeId integer ) as

    declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   -- new procedure
   execute @ReturnCode = spGetMemberGroupsByType @CustomerGroupTypeId

    /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetGroupsByProviderGroupType' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetGroupsByProviderGroupType

   go

create procedure spGetGroupsByProviderGroupType( @ProviderGroupTypeId integer ) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   -- new procedure
   execute @ReturnCode = spGetMemberGroupsByType @ProviderGroupTypeId

    /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetGroupsForTypeByCustomerCategoryDateRange' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetGroupsForTypeByCustomerCategoryDateRange

   go

create procedure spGetGroupsForTypeByCustomerCategoryDateRange( @CustomerId integer,
                                                                @CategoryId integer,
                                                                @StartDate  datetime,
                                                                @EndDate    datetime,
                                                                @GroupType  integer = 00 ) as

   declare @outerSelect varchar( 4000 )
   declare @innerSelect varchar( 4000 )
   declare @innerWhere  varchar( 4000 )
   declare @groupSelect varchar( 4000 )

   set nocount on

   set @innerSelect = char(13) + '
      select jmgcu.member_group_id
      from join_member_group_customer_unit jmgcu
         inner join com_service cs on jmgcu.customer_unit_id = cs.customer_unit_id
         inner join com_service_unit_value csuv on cs.com_service_id = csuv.com_service_id
         inner join com_service_data csd on csuv.com_service_unit_value_id = csd.com_service_unit_value_id
         inner join provider_service_data_type psdt on csd.provider_service_data_type_id = psdt.provider_service_data_type_id
         inner join provider_service_category psc on psdt.provider_service_category_id = psc.provider_service_category_id
         inner join provider_system ps on psc.provider_system_id = ps.provider_system_id
         inner join customer_unit_type parent_type on ps.provider_system_id = parent_type.provider_system_id
         inner join customer_unit parent_unit on cs.customer_unit_id = parent_unit.customer_unit_id
         inner join join_customer_unit_type_customer_unit parent_join on parent_type.customer_unit_type_id = parent_join.customer_unit_type_id
                                                                      and parent_join.customer_unit_id = parent_unit.customer_unit_id
         inner join member_group mg on jmgcu.member_group_id = mg.member_group_id
         inner join member_group_type mgt on mg.member_group_type_id = mgt.member_group_type_id'

   set @innerWhere = char(13) + '
      where parent_unit.customer_id = ' + cast(@CustomerId as varchar(10)) + '
        and psc.provider_service_category_id = ' + cast(@CategoryId as varchar(10)) + '
        and cs.com_service_date >= ''' + convert(varchar(10), @StartDate, 01) + '''
        and cs.com_service_date <= ''' + convert(varchar(10), @EndDate, 01) + ''''

   if @GroupType = 0 begin
        set @groupSelect = char(13) + ' and ( ( mgt.member_id = ps.provider_id ) or ( mgt.member_id = parent_unit.customer_id ) )'
   end

   else if @GroupType = 1 begin
        set @groupSelect = char(13) + ' and ( mgt.member_id = ps.provider_id ) '
   end

   else if @GroupType = 2 begin
        set @groupSelect = char(13) + ' and ( mgt.member_id = parent_unit.customer_id ) '
   end

   set @outerSelect = char(13) + '
   select member_group_id, member_group_type_name, member_group_name
   from member_group_type mgt
      inner join member_group mg on mgt.member_group_type_id = mg.member_group_type_id
   where mg.member_group_id in ( ' + @innerSelect + @innerWhere + @groupSelect + ' )'

   exec(@outerSelect)

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetGroupsForTypeByTechnicianCategoryDateRange' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetGroupsForTypeByTechnicianCategoryDateRange

   go

create procedure spGetGroupsForTypeByTechnicianCategoryDateRange( @TechnicianId integer,
                                                                  @CategoryId  integer,
                                                                  @StartDate   datetime,
                                                                  @EndDate     datetime,
                                                                  @GroupType   integer = 00 ) as

   declare @outerSelect varchar( 4000 )
   declare @innerSelect varchar( 4000 )
   declare @innerWhere  varchar( 4000 )
   declare @groupSelect varchar( 4000 )

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   set nocount on

   set @innerSelect = char(13) + '
      select jmgcu.member_group_id
      from join_member_group_customer_unit jmgcu
         inner join com_service cs on jmgcu.customer_unit_id = cs.customer_unit_id
         inner join com_service_unit_value csuv on cs.com_service_id = csuv.com_service_id
         inner join com_service_data csd on csuv.com_service_unit_value_id = csd.com_service_unit_value_id
         inner join provider_service_data_type psdt on csd.provider_service_data_type_id = psdt.provider_service_data_type_id
         inner join provider_service_category psc on psdt.provider_service_category_id = psc.provider_service_category_id
         inner join provider_system ps on psc.provider_system_id = ps.provider_system_id
         inner join customer_unit_type parent_type on ps.provider_system_id = parent_type.provider_system_id
         inner join customer_unit parent_unit on cs.customer_unit_id = parent_unit.customer_unit_id
         inner join join_customer_unit_type_customer_unit parent_join on parent_type.customer_unit_type_id = parent_join.customer_unit_type_id
                                                                      and parent_join.customer_unit_id = parent_unit.customer_unit_id
         inner join member_group mg on jmgcu.member_group_id = mg.member_group_id
         inner join member_group_type mgt on mg.member_group_type_id = mgt.member_group_type_id'

   set @innerWhere = char(13) + '
      where cs.technician_id = ' + cast(@TechnicianId as varchar(10)) + '
        and psc.provider_service_category_id = ' + cast(@CategoryId as varchar(10)) + '
        and cs.com_service_date >= ''' + convert(varchar(10), @StartDate, 01) + '''
        and cs.com_service_date <= ''' + convert(varchar(10), @EndDate, 01) + ''''

   if @GroupType = 0 begin
        set @groupSelect = char(13) + ' and ( ( mgt.member_id = ps.provider_id ) or ( mgt.member_id = parent_unit.customer_id ) )'
   end

   else if @GroupType = 1 begin
        set @groupSelect = char(13) + ' and ( mgt.member_id = ps.provider_id ) '
   end

   else if @GroupType = 2 begin
        set @groupSelect = char(13) + ' and ( mgt.member_id = parent_unit.customer_id ) '
   end

   set @outerSelect = char(13) + '
   select member_group_id, member_group_type_name, member_group_name
   from member_group_type mgt
      inner join member_group mg on mgt.member_group_type_id = mg.member_group_type_id
   where mg.member_group_id in ( ' + @innerSelect + @innerWhere + @groupSelect + ' )'

   exec(@outerSelect)

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetGroupTransactionsByInterfaceId' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetGroupTransactionsByInterfaceId

   go

create procedure spGetGroupTransactionsByInterfaceId ( @InterfaceId  integer,
                                                       @GroupTypeId  integer ) as

   select
   mg.MEMBER_GROUP_ID   as GroupId,
   mg.MEMBER_GROUP_NAME as GroupName,
   me.FOREIGN_ID        as ForeignId,
   me.FOREIGN_TYPE      as ForeignType
   from MEMBER_GROUP mg
   inner join MAPPING_INTERFACE mi   on mi.INTERFACE_ID         = @InterfaceId
   inner join TRANSACTION_LOG tl     on mi.INTERFACE_ID         = tl.INTERFACE_ID and
                                        mg.MEMBER_GROUP_ID      = tl.ENTITY_ID and
                                        tl.ENTITY_TYPE_ID       = 17
   left outer join MAPPING_ENTITY me on tl.INTERFACE_ID         = me.INTERFACE_ID and
                                        tl.ENTITY_ID            = me.ENTITY_ID and
                                        tl.ENTITY_TYPE_ID       = me.ENTITY_TYPE_ID
   where mg.MEMBER_GROUP_TYPE_ID = @GroupTypeId
     and tl.TRANSMITTED             = 0
   order by mg.MEMBER_GROUP_ID, me.FOREIGN_ID

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetGroupTypesByCustomer' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetGroupTypesByCustomer

   go

create procedure spGetGroupTypesByCustomer( @CustomerId integer ) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

    -- new procedure
   execute @ReturnCode = spGetMemberGroupTypesByMember @CustomerId

    /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetGroupTypesByProvider' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetGroupTypesByProvider

   go

create procedure spGetGroupTypesByProvider( @ProviderId integer ) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   -- new procedure
   execute @ReturnCode = spGetmemberGroupTypesByMember @ProviderId

    /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetGroupUnits' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetGroupUnits

   go

create procedure spGetGroupUnits( @CustomerId integer,
                                  @GroupId    integer ) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   -- new procedure
   execute @ReturnCode = spGetParentUnitsWithGroupByCustomer @CustomerId, @GroupId

    /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetLicenseAgreementByAgreementId' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetLicenseAgreementByAgreementId

   go

create procedure spGetLicenseAgreementByAgreementId( @AgreementId integer ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @RowsAffected integer /* Number of rows affected by the previously executed statement */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Return the identifier and the text for the specified license agreement. */
   select AGREEMENT_ID, AGREEMENT_TEXT, AGREEMENT_HTML
   from AGREEMENT
   where AGREEMENT_ID = @AgreementId

   /* Get the the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,@@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects

             where name = 'spGetMappingEntityByInterfaceIdEntityTypeId' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetMappingEntityByInterfaceIdEntityTypeId

   go

create procedure spGetMappingEntityByInterfaceIdEntityTypeId( @InterfaceId  integer,
                                                              @EntityTypeId integer ) as

   select MAPPING_ENTITY_ID as MappingEntityId,
          ENTITY_TYPE       as EntityType,
          ENTITY_ID         as EntityId,
          FOREIGN_ID        as ForeignId,
          FOREIGN_TYPE      as ForeignType
   from MAPPING_ENTITY me
   left join ENTITY_TYPE et on me.ENTITY_TYPE_ID = et.ENTITY_TYPE_ID
   where et.ENTITY_TYPE_ID = @EntityTypeId and
         me.INTERFACE_ID   = @InterfaceId

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetMappingInterfaceByProviderId' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetMappingInterfaceByProviderId

   go

create procedure spGetMappingInterfaceByProviderId( @ProviderId integer) as

   select mi.INTERFACE_ID,
          mi.INTERFACE_NAME
   from dbo.MAPPING_INTERFACE mi
   where mi.PROVIDER_ID = @ProviderId
   order by mi.INTERFACE_NAME

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetMaxCustomerUnitBarCodeIdByCustomer' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetMaxCustomerUnitBarCodeIdByCustomer

   go

create procedure spGetMaxCustomerUnitBarCodeIdByCustomer( @CustomerId   integer,
                                                          @MaxBarCodeId varchar(50) output ) as

   declare @ErrorCode            integer         /* Error code returned by the execution of the last statement   */
   declare @RowsAffected         integer         /* Number of rows affected by the previously executed statement */
   declare @Transactions         integer         /* Number of active transactions at the start of this procedure */

    /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Get the largest barcode identifier currently used for the customer */
   select @MaxBarCodeId = max( cu.CUSTOMER_UNIT_NUMBER )
   from CUSTOMER_UNIT cu
   where cu.CUSTOMER_ID = @CustomerId

   /* Get the rows affected and the error code for the previous
       statement.  Error checking MUST be done this way since any single
       statement executed will affect both of the global functions,
       @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetMaxCustomerUnitNameBarCodeIdBySystem' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetMaxCustomerUnitNameBarCodeIdBySystem

   go

create procedure spGetMaxCustomerUnitNameBarCodeIdBySystem( @ProviderSystemId integer,
                                                            @MaxBarCodeId     varchar(10) output ) as

   declare @ErrorCode            integer         /* Error code returned by the execution of the last statement   */
   declare @RowsAffected         integer         /* Number of rows affected by the previously executed statement */
   declare @MaxProviderBarCodeId varchar(10) /* Largest barcode identifier for the provider system          */
   declare @MaxTemplateBarCodeId varchar(10) /* Largest barcode identifier for the provider system template */

   /* Get the largest barcode identifiers currently used for the provider
      system.  Since the system may inherit its barcodes from its template, we
      must check the associated template barcode identifiers as well. */
   select @MaxProviderBarCodeId = max( un.CUSTOMER_UNIT_NUMBER ),
          @MaxTemplateBarCodeId = max( tn.CUSTOMER_UNIT_NUMBER )
   from CUSTOMER_UNIT_NAME un
        left outer join TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME tn on un.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME_ID = tn.CUSTOMER_UNIT_NAME_ID
        inner join      CUSTOMER_UNIT_TYPE                   ut on un.CUSTOMER_UNIT_TYPE_ID                   = ut.CUSTOMER_UNIT_TYPE_ID
   where ut.PROVIDER_SYSTEM_ID = @ProviderSystemId

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was NOT an error... */
   if ( ( @ErrorCode = 00 ) and ( @RowsAffected <> 00 ) ) begin

      /* Set the maximum barcode identifier from the template if it is null to
         the default starting barcode identifier.  This handles the special
         case where the template has no barcodes and the maximum barcode
         identifier is null.  This currently occurs if the user designs a
         service program using the custom template which contains no barcodes.
         We do not have to default the maximum barcode identifier from the
         service program since comparing the null service program barcode
         identifier to the non-null template barcode identifier defaulted here
         will always return the maximum barcode identifier from the template. */
      set @MaxTemplateBarCodeId = IsNull( @MaxTemplateBarCodeId, 10000 )

      /* If the largest provider system barcode is not in the template... */
      if ( @MaxProviderBarCodeId > @MaxTemplateBarCodeId ) begin

         /* Return that value as the maximum. */
         set @MaxBarCodeId = @MaxProviderBarCodeId

      end


      else begin /* Template is greater or equal or provider is null... */

         /* Return the template value as the maximum. */
         set @MaxBarCodeId = @MaxTemplateBarCodeId

      end

   end

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetMaxCustomerUnitNameBarCodeIdByUnitType' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetMaxCustomerUnitNameBarCodeIdByUnitType

   go

create procedure spGetMaxCustomerUnitNameBarCodeIdByUnitType( @CustomerUnitTypeId integer,
                                                              @MaxBarCodeId       varchar(10) output ) as

   declare @ErrorCode            integer         /* Error code returned by the execution of the last statement   */
   declare @RowsAffected         integer         /* Number of rows affected by the previously executed statement */
   declare @MaxProviderBarCodeId varchar(10) /* Largest barcode identifier for the provider system          */
   declare @MaxTemplateBarCodeId varchar(10) /* Largest barcode identifier for the provider system template */

   /* Get the largest barcode identifiers currently used for the provider
      system.  Since the system may inherit its barcodes from its template, we
      must check the associated template barcode identifiers as well. */
   select @MaxProviderBarCodeId = max( un.CUSTOMER_UNIT_NUMBER ),
          @MaxTemplateBarCodeId = max( tn.CUSTOMER_UNIT_NUMBER )
   from CUSTOMER_UNIT_NAME un
        left outer join TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME tn on un.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME_ID = tn.CUSTOMER_UNIT_NAME_ID
        inner join      CUSTOMER_UNIT_TYPE                   ut on un.CUSTOMER_UNIT_TYPE_ID                   = ut.CUSTOMER_UNIT_TYPE_ID
   where ut.PROVIDER_SYSTEM_ID = ( select distinct xt.PROVIDER_SYSTEM_ID
                                   from CUSTOMER_UNIT_TYPE xt
                                   where xt.CUSTOMER_UNIT_TYPE_ID = @CustomerUnitTypeId )

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was NOT an error... */
   if ( ( @ErrorCode = 00 ) and ( @RowsAffected <> 00 ) ) begin

      /* Set the maximum barcode identifier from the template if it is null to
         the default starting barcode identifier.  This handles the special
         case where the template has no barcodes and the maximum barcode
         identifier is null.  This currently occurs if the user designs a
         service program using the custom template which contains no barcodes.
         We do not have to default the maximum barcode identifier from the
         service program since comparing the null service program barcode
         identifier to the non-null template barcode identifier defaulted here
         will always return the maximum barcode identifier from the template. */
      set @MaxTemplateBarCodeId = IsNull( @MaxTemplateBarCodeId, 10000 )

      /* If the largest provider system barcode is not in the template... */
      if ( @MaxProviderBarCodeId > @MaxTemplateBarCodeId ) begin

         /* Return that value as the maximum. */
         set @MaxBarCodeId = @MaxProviderBarCodeId

      end

      else begin /* Template is greater or equal or provider is null... */

         /* Return the template value as the maximum. */
         set @MaxBarCodeId = @MaxTemplateBarCodeId

      end

   end

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetMaxProviderServiceDataBarCodeIdByDataType' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetMaxProviderServiceDataBarCodeIdByDataType

   go

create procedure spGetMaxProviderServiceDataBarCodeIdByDataType( @ServiceDataTypeId integer,
                                                                 @MaxBarCodeId      varchar(10) output ) as

   declare @ErrorCode            integer         /* Error code returned by the execution of the last statement   */
   declare @RowsAffected         integer         /* Number of rows affected by the previously executed statement */
   declare @MaxProviderBarCodeId varchar(10) /* Largest barcode identifier for the provider system           */
   declare @MaxTemplateBarCodeId varchar(10) /* Largest barcode identifier for the provider system template  */

   /* Get the largest barcode identifiers currently used for the provider
      system using the passed service data type identifier.  Since the system
      may inherit its barcodes from its template, we must check the associated
      template barcode identifiers as well. */
   select @MaxProviderBarCodeId = max( fv.BARCODE_ID ),
          @MaxTemplateBarCodeId = max( tv.BARCODE_ID )
   from PROVIDER_SERVICE_DATA fv
        left outer join TEMPLATE_PROVIDER_SERVICE_DATA tv on fv.TEMPLATE_PROVIDER_SERVICE_DATA_ID = tv.PROVIDER_SERVICE_DATA_ID
        inner join      PROVIDER_SERVICE_DATA_TYPE     cf on fv.PROVIDER_SERVICE_DATA_TYPE_ID     = cf.PROVIDER_SERVICE_DATA_TYPE_ID
        inner join      PROVIDER_SERVICE_CATEGORY      sc on cf.PROVIDER_SERVICE_CATEGORY_ID      = sc.PROVIDER_SERVICE_CATEGORY_ID
   where sc.PROVIDER_SYSTEM_ID = ( select distinct xc.PROVIDER_SYSTEM_ID
                                   from PROVIDER_SERVICE_CATEGORY xc
                                        inner join PROVIDER_SERVICE_DATA_TYPE xf on xc.PROVIDER_SERVICE_CATEGORY_ID = xf.PROVIDER_SERVICE_CATEGORY_ID
                                   where xf.PROVIDER_SERVICE_DATA_TYPE_ID = @ServiceDataTypeId )

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was NOT an error... */
   if ( ( @ErrorCode = 00 ) and ( @RowsAffected <> 00 ) ) begin

      /* Set the maximum barcode identifier from the template if it is null to
         the default starting barcode identifier.  This handles the special
         case where the template has no barcodes and the maximum barcode
         identifier is null.  This currently occurs if the user designs a
         service program using the custom template which contains no barcodes.
         We do not have to default the maximum barcode identifier from the
         service program since comparing the null service program barcode
         identifier to the non-null template barcode identifier defaulted here
         will always return the maximum barcode identifier from the template. */
      set @MaxTemplateBarCodeId = IsNull( @MaxTemplateBarCodeId, 1000000000 )

      /* If the largest provider system barcode is not in the template... */
      if ( @MaxProviderBarCodeId > @MaxTemplateBarCodeId ) begin

         /* Return that value as the maximum. */
         set @MaxBarCodeId = @MaxProviderBarCodeId

      end

      else begin /* Template is greater or equal or provider is null... */

         /* Return the template value as the maximum. */
         set @MaxBarCodeId = @MaxTemplateBarCodeId

      end

   end

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetMaxProviderServiceDataBarCodeIdBySystem' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetMaxProviderServiceDataBarCodeIdBySystem

   go

create procedure spGetMaxProviderServiceDataBarCodeIdBySystem( @ProviderSystemId integer,
                                                               @MaxBarCodeId     varchar(10) output ) as

   declare @ErrorCode            integer         /* Error code returned by the execution of the last statement   */
   declare @RowsAffected         integer         /* Number of rows affected by the previously executed statement */
   declare @MaxProviderBarCodeId varchar(10) /* Largest barcode identifier for the provider system           */
   declare @MaxTemplateBarCodeId varchar(10) /* Largest barcode identifier for the provider system template  */

   /* Get the largest barcode identifiers currently used for the provider
      system.  Since the system may inherit its barcodes from its template, we
      must check the associated template barcode identifiers as well. */
   select @MaxProviderBarCodeId = max( fv.BARCODE_ID ),
          @MaxTemplateBarCodeId = max( tv.BARCODE_ID )
   from PROVIDER_SERVICE_DATA fv
        left outer join TEMPLATE_PROVIDER_SERVICE_DATA tv on fv.TEMPLATE_PROVIDER_SERVICE_DATA_ID = tv.PROVIDER_SERVICE_DATA_ID
        inner join      PROVIDER_SERVICE_DATA_TYPE     cf on fv.PROVIDER_SERVICE_DATA_TYPE_ID     = cf.PROVIDER_SERVICE_DATA_TYPE_ID
        inner join      PROVIDER_SERVICE_CATEGORY      sc on cf.PROVIDER_SERVICE_CATEGORY_ID      = sc.PROVIDER_SERVICE_CATEGORY_ID
   where sc.PROVIDER_SYSTEM_ID = @ProviderSystemId

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was NOT an error... */
   if ( ( @ErrorCode = 00 ) and ( @RowsAffected <> 00 ) ) begin

      /* Set the maximum barcode identifier from the template if it is null to
         the default starting barcode identifier.  This handles the special
         case where the template has no barcodes and the maximum barcode
         identifier is null.  This currently occurs if the user designs a
         service program using the custom template which contains no barcodes.
         We do not have to default the maximum barcode identifier from the
         service program since comparing the null service program barcode
         identifier to the non-null template barcode identifier defaulted here
         will always return the maximum barcode identifier from the template. */
      set @MaxTemplateBarCodeId = IsNull( @MaxTemplateBarCodeId, 1000000000 )

      /* If the largest provider system barcode is not in the template... */
      if ( @MaxProviderBarCodeId > @MaxTemplateBarCodeId ) begin

         /* Return that value as the maximum. */
         set @MaxBarCodeId = @MaxProviderBarCodeId

      end

      else begin /* Template is greater or equal or provider is null... */

         /* Return the template value as the maximum. */
         set @MaxBarCodeId = @MaxTemplateBarCodeId

      end

   end

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetMaxProviderServiceDataTypeSortOrderByCategory' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetMaxProviderServiceDataTypeSortOrderByCategory

   go

create procedure spGetMaxProviderServiceDataTypeSortOrderByCategory( @ServiceCategoryId integer,
                                                                     @MaxSortOrder      integer output ) as

   declare @ErrorCode            integer /* Error code returned by the execution of the last statement    */
   declare @RowsAffected         integer /* Number of rows affected by the previously executed statement  */
   declare @MaxProviderSortOrder integer /* Largest sort order for the provider data type in the category */
   declare @MaxTemplateSortOrder integer /* Largest sort order for the provider data type in the template */

   /* Get the largest sort order currently used for the provider system.  Since
      the system may inherit its sort order from its template, we must check
      the associated template sort orders as well. */
   select @MaxProviderSortOrder = max( psdt.SORT_ORDER  ),
          @MaxTemplateSortOrder = max( tpsdt.SORT_ORDER )
   from PROVIDER_SERVICE_DATA_TYPE psdt
        left outer join TEMPLATE_PROVIDER_SERVICE_DATA_TYPE tpsdt on psdt.TEMPLATE_PROVIDER_SERVICE_DATA_TYPE_ID = tpsdt.PROVIDER_SERVICE_DATA_TYPE_ID
   where psdt.PROVIDER_SERVICE_CATEGORY_ID = @ServiceCategoryId

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was NOT an error... */
   if ( ( @ErrorCode = 00 ) and ( @RowsAffected <> 00 ) ) begin

      /* Set the maximum sort order from the template if it is null to the
         default starting sort order.  This handles the special case where the
         template has no sort orders and the maximum sort order is null.  This
         currently occurs if the user designs a service program using the
         custom template which contains no sort orders.  We do not have to
         default the maximum sort order from the service program since
         comparing the null service program sort order to the non-null template
         sort order defaulted here will always return the maximum sort order
         from the template. */
      set @MaxTemplateSortOrder = IsNull( @MaxTemplateSortOrder, 01 )

      /* If the largest provider data type sort order is not in the
         template... */
      if ( @MaxProviderSortOrder > @MaxTemplateSortOrder ) begin

         /* Return that value as the maximum. */
         set @MaxSortOrder = @MaxProviderSortOrder

      end

      else begin /* Template is greater or equal or provider is null... */

         /* Return the template value as the maximum. */
         set @MaxSortOrder = @MaxTemplateSortOrder

      end

   end

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetMemberGroupsByGroupTypeUser' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetMemberGroupsByGroupTypeUser

   go

create procedure spGetMemberGroupsByGroupTypeUser( @membergrouptypeid integer,
                                                   @memberuserid      integer ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   SELECT dbo.MEMBER_GROUP.MEMBER_GROUP_ID, dbo.MEMBER_GROUP.MEMBER_GROUP_NAME
   FROM  dbo.JOIN_MEMBER_GROUP_USER LEFT OUTER JOIN
         dbo.MEMBER_GROUP_TYPE INNER JOIN
         dbo.MEMBER_GROUP ON dbo.MEMBER_GROUP_TYPE.MEMBER_GROUP_TYPE_ID = dbo.MEMBER_GROUP.MEMBER_GROUP_TYPE_ID ON
         dbo.JOIN_MEMBER_GROUP_USER.MEMBER_GROUP_ID = dbo.MEMBER_GROUP.MEMBER_GROUP_ID AND
         dbo.JOIN_MEMBER_GROUP_USER.MEMBER_USER_ID = @memberuserid
   WHERE     (dbo.MEMBER_GROUP_TYPE.MEMBER_GROUP_TYPE_ID = @membergrouptypeid)
   ORDER BY MEMBER_GROUP_NAME

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetMemberGroupsByType' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetMemberGroupsByType

   go

create procedure spGetMemberGroupsByType( @membergrouptypeid integer ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   SELECT MEMBER_GROUP_ID, MEMBER_GROUP_NAME
   FROM MEMBER_GROUP
   WHERE MEMBER_GROUP_TYPE_ID = @membergrouptypeid

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetMemberGroupsWithUserByType' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetMemberGroupsWithUserByType

   go

create procedure spGetMemberGroupsWithUserByType( @memberuserid      integer,
                                                  @membergrouptypeid integer ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   SELECT dbo.MEMBER_GROUP.MEMBER_GROUP_ID,
	  dbo.MEMBER_GROUP.MEMBER_GROUP_NAME,
	  dbo.JOIN_MEMBER_GROUP_USER.MEMBER_USER_ID
   FROM member_group
   LEFT OUTER JOIN dbo.JOIN_MEMBER_GROUP_USER
   ON dbo.JOIN_MEMBER_GROUP_USER.MEMBER_GROUP_ID = dbo.MEMBER_GROUP.MEMBER_GROUP_ID AND
      dbo.JOIN_MEMBER_GROUP_USER.MEMBER_USER_ID = @memberuserid
   WHERE (dbo.MEMBER_GROUP.MEMBER_GROUP_TYPE_ID = @membergrouptypeid)
   ORDER BY MEMBER_GROUP_NAME

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetMemberGroupTypesByMember' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetMemberGroupTypesByMember

   go

create procedure spGetMemberGroupTypesByMember( @memberid integer ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   SELECT MEMBER_GROUP_TYPE_ID, MEMBER_GROUP_TYPE_NAME
   FROM MEMBER_GROUP_TYPE
   WHERE MEMBER_ID = @memberid

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetMemberGroupTypesByMemberUser' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetMemberGroupTypesByMemberUser

   go

create procedure spGetMemberGroupTypesByMemberUser( @ProviderSystemId integer,
                                                    @MemberUserId     integer ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   select distinct i.member_group_type_id, i.member_group_type_name
   from join_member_group_user g
   left outer join member_group h on g.member_group_id = h.member_group_id
   right outer join member_group_type i on h.member_group_type_id = i.member_group_type_id
   where g.member_user_id = @MemberUserId
   order by i.member_group_type_name

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetMemberIdByMemberUserId' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetMemberIdByMemberUserId

   go

create procedure spGetMemberIdByMemberUserId( @MemberUserId integer,
                                              @MemberId     integer output ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @RowsAffected integer /* Number of rows affected by the previously executed statement */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Return the name of the specified user. */
   select @MemberId = MEMBER_ID
   from MEMBER_USER
   where MEMBER_USER_ID = @MemberUserId

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetMemberNameByMemberId' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetMemberNameByMemberId

   go

create procedure spGetMemberNameByMemberId( @MemberId   integer,
                                            @MemberName varchar(100) output ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @RowsAffected integer /* Number of rows affected by the previously executed statement */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Return the name of the specified member. */
   select @MemberName = MEMBER_NAME
   from MEMBER
   where MEMBER_ID = @MemberId

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetMembers' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetMembers

   go

create procedure spGetMembers( @MemberId     integer,
                               @letter       char(1),
							   @MemberTypeId integer ) as

   declare @Transactions       integer /* Number of active transactions at the start of this procedure */
   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   if @MemberId <> null begin
      if @letter = ''
         -- new stored proc
         execute @ReturnCode = spGetCustomersByProviderNoSubString @Memberid
      else
         execute @ReturnCode = spGetCustomersByProviderSubString @MemberId, @letter

   end
   else begin
   -- new procedure
      execute @ReturnCode = spGetMembersByType @MemberTypeId

   end

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetMembersByType' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetMembersByType

   go

create procedure spGetMembersByType( @membertypeid integer ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   SELECT MEMBER_ID, MEMBER_NAME FROM MEMBER WHERE MEMBER_TYPE_ID = @membertypeid
   ORDER BY MEMBER_ID

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetMemberUserByDeviceId' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetMemberUserByDeviceId

   go

create procedure spGetMemberUserByDeviceId( @DeviceId     varchar(50),
                                            @MemberUserId integer output ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @RowsAffected integer /* Number of rows affected by the previously executed statement */

   /* Stop the message indicating the number of rows affected by a Transact-SQL
      statement from being returned as part of the results. */
   set nocount on

   /* Get the identifier for the user using their data collection device
      identifier. */
   select @MemberUserId = MEMBER_USER_ID
   from MEMBER_USER
   where MEMBER_USER_NAME = @DeviceId

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* If there was an active transaction when this stored procedure was
         executed... */
      if (  @@TranCount > 00 ) begin

         /* Rollback the transaction. */
         rollback transaction

      end

      /* Return the failure. */
      return 01

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetMemberUserEmailSettingsByMemberUserId' and xtype = 'P' ) )

   /* Remove it. */

   drop procedure spGetMemberUserEmailSettingsByMemberUserId

   go

create procedure spGetMemberUserEmailSettingsByMemberUserId( @MemberUserId integer ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

    /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   select mues.member_user_email_id,
       mues.provider_system_id,
       ISNULL(ps.provider_system_name, tps.provider_system_name ) as provider_system_name,
       mues.provider_service_value_id,
       ISNULL(psv.provider_service_value, tpsv.provider_service_value ) as provider_service_value,
       provider_service_value_text = case
        when mues.provider_service_value_id is null then null
           else cast( ISNULL(psv.provider_service_value, tpsv.provider_service_value ) as varchar(10) ) + ': ' +
                ISNULL(psv.provider_service_value_text, tpsv.provider_service_value_text )
         end,
       mues.email_frequency_days,
       mues.email_last_update,
       mues.email_disabled

   from MEMBER_USER_EMAIL_SETTINGS mues

   inner join      PROVIDER_SYSTEM ps                   on ( mues.provider_system_id                = ps.provider_system_id          )
   left outer join TEMPLATE_PROVIDER_SYSTEM tps         on ( ps.template_provider_system_id         = tps.provider_system_id         )
   left outer join PROVIDER_SERVICE_VALUE psv           on ( mues.provider_service_value_id         = psv.provider_service_value_id  )
   left outer join TEMPLATE_PROVIDER_SERVICE_VALUE tpsv on ( psv.template_provider_service_value_id = tpsv.provider_service_value_id )
   where mues.member_user_id = @MemberUserId
   order by provider_system_name

    /* Get the the error code for the previous statement.
       Error checking MUST be done this way since any single statement executed
       will affect both of the global functions,@@Error. */

   select @ErrorCode = @@Error

   /* If there was an error... */
   if  ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetMemberUserEmailSettingsByMemberUserIdAndProviderSystemId' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetMemberUserEmailSettingsByMemberUserIdAndProviderSystemId

   go

create procedure spGetMemberUserEmailSettingsByMemberUserIdAndProviderSystemId( @MemberUserId     integer,
                                                                                @ProviderSystemId integer ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

    /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   select mues.member_user_email_id,
          mues.provider_system_id,
          mues.provider_service_value_id,
          mues.email_frequency_days,
          mues.email_last_update,
          mues.email_disabled

   from MEMBER_USER_EMAIL_SETTINGS mues
   where mues.member_user_id     = @MemberUserId and
         mues.provider_system_id = @ProviderSystemId

    /* Get the the error code for the previous statement.
       Error checking MUST be done this way since any single statement executed
       will affect both of the global functions,@@Error. */

   select @ErrorCode = @@Error

   /* If there was an error... */
   if  ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetMemberUserNameByMemberUserId' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetMemberUserNameByMemberUserId

   go

create procedure spGetMemberUserNameByMemberUserId( @MemberUserId        integer,
                                                    @MemberUserFirstName varchar(25) output,
                                                    @MemberUserLastName  varchar(25) output ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @RowsAffected integer /* Number of rows affected by the previously executed statement */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Return the name of the specified user. */
   select @MemberUserFirstName = MEMBER_USER_FNAME,
          @MemberUserLastName  = MEMBER_USER_LNAME
   from MEMBER_USER
   where MEMBER_USER_ID = @MemberUserId

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetMemberUsersByMemberId' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetMemberUsersByMemberId

   go

create procedure spGetMemberUsersByMemberId( @memberid integer ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */

      begin transaction

   end

   SELECT MEMBER_USER.MEMBER_USER_ID,
	  MEMBER_ID,
	  MEMBER_USER_NAME,
 	  MEMBER_USER_PWD,
	  MEMBER_USER_FNAME,
	  MEMBER_USER_LNAME,
	  MEMBER_USER_LAST_LOGIN,
	  MEMBER_USER_EMAIL,
	  SECURITY_GROUP.SECURITY_GROUP_ID,
          SECURITY_GROUP.SECURITY_GROUP_NAME
   FROM	MEMBER_USER
   LEFT OUTER JOIN JOIN_MEMBER_USER_SECURITY_GROUP ON MEMBER_USER.MEMBER_USER_ID = JOIN_MEMBER_USER_SECURITY_GROUP.MEMBER_USER_ID
   LEFT OUTER JOIN SECURITY_GROUP ON JOIN_MEMBER_USER_SECURITY_GROUP.SECURITY_GROUP_ID = SECURITY_GROUP.SECURITY_GROUP_ID
   WHERE  MEMBER_USER.MEMBER_ID = @memberid
   ORDER BY MEMBER_USER_LNAME, MEMBER_USER_FNAME

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetMemberUsersByMemberUserId' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetMemberUsersByMemberUserId

   go

create procedure spGetMemberUsersByMemberUserId( @MemberUserId integer ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Return the names of the users tat are in the same group as the specified
      user. */
   select distinct mu.MEMBER_USER_ID,
                   mu.MEMBER_USER_FNAME,
                   mu.MEMBER_USER_LNAME
   from MEMBER_USER mu
   inner join JOIN_MEMBER_GROUP_USER jmgu on mu.MEMBER_USER_ID = jmgu.MEMBER_USER_ID
   where MEMBER_GROUP_ID in ( select MEMBER_GROUP_ID
                              from JOIN_MEMBER_GROUP_USER
                              where MEMBER_USER_ID = @MemberUserId )

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 )  begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetMemberUserSecurityGroupCountByMember' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetMemberUserSecurityGroupCountByMember

   go

create procedure spGetMemberUserSecurityGroupCountByMember( @MemberId           integer,
                                                            @SecurityGroupId    integer,
                                                            @MemberUserId       integer,
                                                            @SecurityGroupCount integer output ) as

   /* If the user is inserting a new member user... */
   if ( @MemberUserId is null ) begin

      /* Get the number of member users that match the passed security group
         identifier value.  This should be zero, however, if it is nonzero,
         then the user has created a duplicate. */
      select @SecurityGroupCount = count(*)
      from MEMBER m
         inner join MEMBER_USER u                     on m.MEMBER_ID      = u.MEMBER_ID
         inner join JOIN_MEMBER_USER_SECURITY_GROUP j on u.MEMBER_USER_ID = j.MEMBER_USER_ID
      where m.MEMBER_ID         = @MemberId        and
            j.SECURITY_GROUP_ID = @SecurityGroupId

   end

   else begin /* Updating an existing member user...  */

      /* Get the number of member users that match the passed security group
         identifier value and are not contained by the passed member user.
         This should be zero, however, if it is nonzero, then the user has
         created a duplicate by updating the member user's security group to a
         value that matches another member user.  This test handles the
         special case of an updated row finding itself as a duplicate. */
      select @SecurityGroupCount = count(*)
      from MEMBER m
         inner join MEMBER_USER u                     on m.MEMBER_ID      = u.MEMBER_ID
         inner join JOIN_MEMBER_USER_SECURITY_GROUP j on u.MEMBER_USER_ID = j.MEMBER_USER_ID
      where m.MEMBER_ID         = @MemberId        and
            j.SECURITY_GROUP_ID = @SecurityGroupId and
            u.MEMBER_USER_ID   <> @MemberUserId

   end

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetNewCustomerUnitBarCodeIdByCustomer' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetNewCustomerUnitBarCodeIdByCustomer

   go

create procedure spGetNewCustomerUnitBarCodeIdByCustomer( @CustomerId   integer,
                                                          @NewBarCodeId varchar(50) output ) as

   declare @MaxBarCodeId  varchar(10) /* Maximum barcode identifier for the current provider system */
   declare @NextBarCodeId integer         /* Next barcode identifier for the current provider system    */

   /* Use the stored procedure that returns the maximum barcode identifier
      currently assigned to a customer unit for the customer. */
   execute spGetMaxCustomerUnitBarCodeIdByCustomer @CustomerId,
                                                   @MaxBarCodeId output

   /* If there is a maximum barcode identifier in the table for the
      customer... */
   if ( @MaxBarCodeId is not null ) begin

      /* Assign the initial value for the new barcode identifiers. */
      set @NextBarCodeId = Cast( @MaxBarCodeId as integer )

   end

   else begin /* No inherited template barcode identifiers... */

      /* Assign the default starting barcode identifier. */
      set @NextBarCodeId = 10000

   end

   /* Increment the barcode identifier to get the next one to assign. */
   set @NextBarCodeId = @NextBarCodeId + 01

   /* Convert the next barcode identifier to assign to the table. */
   set @NewBarCodeId = Cast( @NextBarCodeId as varchar(50) )

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetNewCustomerUnitNameBarCodeIdBySystem' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetNewCustomerUnitNameBarCodeIdBySystem

   go

create procedure spGetNewCustomerUnitNameBarCodeIdBySystem( @ProviderSystemId integer,
                                                            @NewBarCodeId     varchar(10) output ) as

   declare @MaxBarCodeId  varchar(10) /* Maximum barcode identifier for the current provider system */
   declare @NextBarCodeId integer         /* Next barcode identifier for the current provider system    */

   /* Use the stored procedure that returns the maximum barcode identifier
      currently assigned to a customer unit name for the system. */
   execute spGetMaxCustomerUnitNameBarCodeIdBySystem @ProviderSystemId,
                                                     @MaxBarCodeId output

   /* If there is a maximum barcode identifier in the table for the system
      (i.e. the system inherits some barcode identifiers from a template) */
   if ( @MaxBarCodeId is not null ) begin

      /* Assign the initial value for the new barcode identifiers. */
      set @NextBarCodeId = Cast( @MaxBarCodeId as integer )

   end

   else begin /* No inherited template barcode identifiers... */

      /* Assign the default starting barcode identifier. */
      set @NextBarCodeId = 10000

   end

   /* Increment the barcode identifier to get the next one to assign. */
   set @NextBarCodeId = @NextBarCodeId + 01

   /* Convert the next barcode identifier to assign to the table. */
   set @NewBarCodeId = Cast( @NextBarCodeId as varchar(10) )

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetNewCustomerUnitNameBarCodeIdByUnitType' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetNewCustomerUnitNameBarCodeIdByUnitType

   go

create procedure spGetNewCustomerUnitNameBarCodeIdByUnitType( @CustomerUnitTypeId integer,
                                                              @NewBarCodeId       varchar(10) output ) as

   declare @MaxBarCodeId  varchar(10) /* Maximum barcode identifier for the current provider system */
   declare @NextBarCodeId integer         /* Next barcode identifier for the current provider system    */

   /* Use the stored procedure that returns the maximum barcode identifier
      currently assigned to a customer unit name for the system. */
   execute spGetMaxCustomerUnitNameBarCodeIdByUnitType @CustomerUnitTypeId,
                                                       @MaxBarCodeId output

   /* If there is a maximum barcode identifier in the table for the system
      (i.e. the system inherits some barcode identifiers from a template) */
   if ( @MaxBarCodeId is not null ) begin

      /* Assign the initial value for the new barcode identifiers. */
      set @NextBarCodeId = Cast( @MaxBarCodeId as integer )

   end

   else begin /* No inherited template barcode identifiers... */

      /* Assign the default starting barcode identifier. */
      set @NextBarCodeId = 10000

   end

   /* Increment the barcode identifier to get the next one to assign. */
   set @NextBarCodeId = @NextBarCodeId + 01

   /* Convert the next barcode identifier to assign to the table. */
   set @NewBarCodeId = Cast( @NextBarCodeId as varchar(10) )

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetNewProviderServiceDataBarCodeIdByDataType' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetNewProviderServiceDataBarCodeIdByDataType

   go

create procedure spGetNewProviderServiceDataBarCodeIdByDataType( @ServiceDataTypeId integer,
                                                                 @NewBarCodeId      varchar(10) output ) as

   declare @MaxBarCodeId  varchar(10) /* Maximum barcode identifier for the current provider system */
   declare @NextBarCodeId integer         /* Next barcode identifier for the current provider system    */

   /* Use the stored procedure that returns the maximum barcode identifier
      currently assigned to a service data item for the system. */
   execute spGetMaxProviderServiceDataBarCodeIdByDataType @ServiceDataTypeId,
                                                          @MaxBarCodeId output

   /* If there is a maximum barcode identifier in the table for the system
      (i.e. the system inherits some barcode identifiers from a template) */
   if ( @MaxBarCodeId is not null ) begin

      /* Assign the initial value for the new barcode identifiers. */
      set @NextBarCodeId = Cast( @MaxBarCodeId as integer )

   end

   else begin /* No inherited template barcode identifiers... */

      /* Assign the default starting barcode identifier. */
      set @NextBarCodeId = 1000000000

   end

   /* Increment the barcode identifier to get the next one to assign. */
   set @NextBarCodeId = @NextBarCodeId + 01

   /* Convert the next barcode identifier to assign to the table. */
   set @NewBarCodeId = Cast( @NextBarCodeId as varchar(10) )

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetNewProviderServiceDataBarCodeIdBySystem' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetNewProviderServiceDataBarCodeIdBySystem

   go

create procedure spGetNewProviderServiceDataBarCodeIdBySystem( @ProviderSystemId integer,
                                                               @NewBarCodeId     varchar(10) output ) as

   declare @MaxBarCodeId  varchar(10) /* Maximum barcode identifier for the current provider system */
   declare @NextBarCodeId integer         /* Next barcode identifier for the current provider system    */

   /* Use the stored procedure that returns the maximum barcode identifier
      currently assigned to a service data item for the system. */
   execute spGetMaxProviderServiceDataBarCodeIdBySystem @ProviderSystemId,
                                                        @MaxBarCodeId output

   /* If there is a maximum barcode identifier in the table for the system
      (i.e. the system inherits some barcode identifiers from a template) */
   if ( @MaxBarCodeId is not null ) begin

      /* Assign the initial value for the new barcode identifiers. */
      set @NextBarCodeId = Cast( @MaxBarCodeId as integer )

   end

   else begin /* No inherited template barcode identifiers... */

      /* Assign the default starting barcode identifier. */
      set @NextBarCodeId = 1000000000

   end

   /* Increment the barcode identifier to get the next one to assign. */
   set @NextBarCodeId = @NextBarCodeId + 01

   /* Convert the next barcode identifier to assign to the table. */
   set @NewBarCodeId = Cast( @NextBarCodeId as varchar(10) )

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetNewProviderServiceDataTypeSortOrderByCategory' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetNewProviderServiceDataTypeSortOrderByCategory

   go

create procedure spGetNewProviderServiceDataTypeSortOrderByCategory( @ServiceCategoryId integer,
                                                                     @NewSortOrder      integer output ) as

   declare @MaxSortOrder  integer /* Maximum sort order for the current provider system */
   declare @NextSortOrder integer /* Next sort order for the current provider system    */

   /* Use the stored procedure that returns the maximum sort order currently
      assigned to a service data type for the service category. */
   execute spGetMaxProviderServiceDataTypeSortOrderByCategory @ServiceCategoryId,
                                                              @MaxSortOrder output

   /* If there is a maximum sort order in the table for the service data type
      (i.e. the system inherits some sort orders from a template)... */
   if ( @MaxSortOrder is not null ) begin

      /* Assign the initial value for the new sort orders. */
      set @NextSortOrder = @MaxSortOrder

   end

   else begin /* No inherited template sort orders... */

      /* Assign the default starting sort order. */
      set @NextSortOrder = 01

   end

   /* Increment the sort order to get the next one to assign. */
   set @NewSortOrder = @NextSortOrder + 01

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetParentUnitsBySystemCustomer' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetParentUnitsBySystemCustomer

   go

create procedure spGetParentUnitsBySystemCustomer( @ProviderSystemId  integer,
                                                   @CustomerId        integer,
                                                   @UnitParentId      integer=-1,
                                                   @Assigned          integer=1 ) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   if @Assigned = 1
      execute @ReturnCode = spGetParentUnitsBySystemAssignedByCustomer @ProviderSystemId, @CustomerId

   else
      execute @ReturnCode = spGetParentUnitsNotBySystemCustomer @ProviderSystemId, @CustomerId, @UnitParentId

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetParentUnitsBySystemAssignedByCustomer' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetParentUnitsBySystemAssignedByCustomer

   go

create procedure spGetParentUnitsBySystemAssignedByCustomer( @ProviderSystemId integer,
                                                           @CustomerId         integer,
                                                           @UnitParentId       integer=-1 ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   select a.customer_unit_id,
          c.customer_unit_type_id,
          isnull( c.customer_unit_type_name, d.customer_unit_type_name ) as customer_unit_type_name,
          isnull( a.customer_unit_name, isnull( e.customer_unit_name, f.customer_unit_name ) as customer_unit_name,
          isnull( a.customer_unit_number, isnull( e.customer_unit_number, f.customer_unit_number ) as customer_unit_number,
          customer_unit_layout_image_id
   from customer_unit a
   left outer join join_customer_unit_type_customer_unit b on a.customer_unit_id = b.customer_unit_id
   left outer join customer_unit_type c on b.customer_unit_type_id = c.customer_unit_type_id
   left outer join template_provider_customer_unit_type d on c.template_provider_customer_unit_type_id = d.customer_unit_type_id
   left outer join customer_unit_name e on b.customer_unit_name_id = e.customer_unit_name_id
   left outer join template_provider_customer_unit_name f on e.template_provider_customer_unit_name_id = f.customer_unit_name_id
   left outer join customer_unit_layout_image g on a.customer_unit_id = g.customer_unit_id
   where c.provider_system_id = @ProviderSystemId
   and a.customer_id = @CustomerId
   and a.unit_parent_id = @UnitParentId

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetParentUnitsBySystemCustomerUser' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetParentUnitsBySystemCustomerUser

   go

create procedure spGetParentUnitsBySystemCustomerUser( @ProviderSystemId integer,
                                                       @CustomerId       integer,
                                                       @MemberUserId     integer,
                                                       @UnitParentId     integer = -1 ) as

   select cu.customer_unit_id,
          cut.customer_unit_type_id,
          isnull(cut.customer_unit_type_name, d.customer_unit_type_name) as customer_unit_type_name,
          isnull(cu.customer_unit_name, isnull(e.customer_unit_name, f.customer_unit_name)) as customer_unit_name,
          isnull(cu.customer_unit_number, isnull(e.customer_unit_number, f.customer_unit_number)) as customer_unit_number,
          customer_unit_layout_image_id
   from CUSTOMER_UNIT cu
   inner join JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT b on cu.customer_unit_id = b.customer_unit_id
   inner join CUSTOMER_UNIT_TYPE cut on b.customer_unit_type_id = cut.customer_unit_type_id
   left outer join TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE d on cut.template_provider_customer_unit_type_id = d.customer_unit_type_id
   left outer join CUSTOMER_UNIT_NAME e on b.customer_unit_name_id = e.customer_unit_name_id
   left outer join TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME f on e.template_provider_customer_unit_name_id = f.customer_unit_name_id
   left outer join CUSTOMER_UNIT_LAYOUT_IMAGE g on cu.customer_unit_id = g.customer_unit_id
   inner join JOIN_MEMBER_GROUP_CUSTOMER_UNIT jmgcu on ( cu.UNIT_PARENT_ID = jmgcu.CUSTOMER_UNIT_ID ) or ( cu.CUSTOMER_UNIT_ID = jmgcu.CUSTOMER_UNIT_ID )
   inner join JOIN_MEMBER_GROUP_USER jmgu on jmgcu.MEMBER_GROUP_ID = jmgu.MEMBER_GROUP_ID
   where jmgu.MEMBER_USER_ID    = @MemberUserId     and
         cut.PROVIDER_SYSTEM_ID = @ProviderSystemId and
         cu.UNIT_PARENT_ID      = @UnitParentId     and
         cu.CUSTOMER_ID         = @CustomerId

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetParentUnitsNotBySystemCustomer' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetParentUnitsNotBySystemCustomer

   go

create procedure spGetParentUnitsNotBySystemCustomer( @ProviderSystemId integer,
                                                      @customerid       integer,
                                                      @parentid         integer=-1 ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   select distinct a.customer_unit_id,
                   c.customer_unit_type_id,
                   isnull( c.customer_unit_type_name, d.customer_unit_type_name ) as customer_unit_type_name,
                   isnull( a.customer_unit_name, isnull( e.customer_unit_name, f.customer_unit_name ) as customer_unit_name,
                   customer_unit_layout_image_id
   from customer_unit a
   left outer join join_customer_unit_type_customer_unit b on a.customer_unit_id = b.customer_unit_id
   left outer join customer_unit_type c on b.customer_unit_type_id = c.customer_unit_type_id and c.provider_system_id = @ProviderSystemId
   left outer join template_provider_customer_unit_type d on c.template_provider_customer_unit_type_id = d.customer_unit_type_id
   left outer join customer_unit_name e on b.customer_unit_name_id = e.customer_unit_name_id
   left outer join template_provider_customer_unit_name f on e.template_provider_customer_unit_name_id = f.customer_unit_name_id
   left outer join customer_unit_layout_image g on a.customer_unit_id = g.customer_unit_id
   where a.customer_id = @customerid
   and a.unit_parent_id = @parentid
   and a.customer_unit_id not in
   (select a.customer_unit_id
   from customer_unit a, join_customer_unit_type_customer_unit b, customer_unit_type c
   where a.customer_unit_id = b.customer_unit_id
   and b.customer_unit_type_id = c.customer_unit_type_id
   and c.provider_system_id = @ProviderSystemId
   and a.customer_id = @customerid)

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetParentUnitsWithGroupByCustomer' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetParentUnitsWithGroupByCustomer

   go

create procedure spGetParentUnitsWithGroupByCustomer( @customerid integer,
                                                      @groupid    integer ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   SELECT a.CUSTOMER_UNIT_ID,
	  a.CUSTOMER_UNIT_NAME,
          a.CUSTOMER_UNIT_NUMBER,
	  b.MEMBER_GROUP_ID
   from customer_unit a
   left outer join join_member_group_customer_unit b on a.CUSTOMER_UNIT_ID = b.CUSTOMER_UNIT_ID
	AND b.MEMBER_GROUP_ID = @groupid
   WHERE a.CUSTOMER_ID = @customerid
   AND a.UNIT_PARENT_ID = -1
   order by a.CUSTOMER_UNIT_NAME

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetProviderAgreement' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetProviderAgreement

   go

create procedure spGetProviderAgreement as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   -- new procedure
   execute spGetAgreementById 1

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetProviderContactInfo' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetProviderContactInfo

   go

create procedure spGetProviderContactInfo( @ProviderId integer ) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   -- new procedure
   execute @ReturnCode = spGetContactInfoForEntity @ProviderId,
                                                   3

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetProviderCustomerInvoicesBySystemUser' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetProviderCustomerInvoicesBySystemUser

   go

create procedure spGetProviderCustomerInvoicesBySystemUser( @ProviderSystemId integer,
                                                            @MemberUserId     integer ) as

   /* Return the result set containing the financial data for customer, unit,
      and service type in the specified service program for the passed member
      user identifier. */
   select pc.CUSTOMER_ID,
          pcsf.CUSTOMER_UNIT_ID,
          pcsf.PROVIDER_SERVICE_TYPE_ID,
          pcsf.PROVIDER_CUSTOMER_SERVICE_AMOUNT
   from PROVIDER_CUSTOMER pc
   left outer join  PROVIDER_CUSTOMER_SERVICE pcs                on pc.PROVIDER_CUSTOMER_ID          = pcs.PROVIDER_CUSTOMER_ID
   right outer join PROVIDER_CUSTOMER_SERVICE_FINANCIAL pcsf     on pcs.PROVIDER_CUSTOMER_SERVICE_ID = pcsf.PROVIDER_CUSTOMER_SERVICE_ID
   inner join       CUSTOMER_UNIT cu                             on pcsf.CUSTOMER_UNIT_ID            = cu.CUSTOMER_UNIT_ID
   inner join       JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT jcutcu on cu.CUSTOMER_UNIT_ID              = jcutcu.CUSTOMER_UNIT_ID
   inner join       CUSTOMER_UNIT_TYPE cut                       on ( jcutcu.CUSTOMER_UNIT_TYPE_ID   = cut.CUSTOMER_UNIT_TYPE_ID ) and
                                                                    ( pcs.PROVIDER_SYSTEM_ID         = cut.PROVIDER_SYSTEM_ID )
   inner join       JOIN_MEMBER_GROUP_CUSTOMER_UNIT jmgcu        on ( cu.UNIT_PARENT_ID              = jmgcu.CUSTOMER_UNIT_ID ) or
                                                                    ( cu.CUSTOMER_UNIT_ID            = jmgcu.CUSTOMER_UNIT_ID )
   inner join       JOIN_MEMBER_GROUP_USER jmgu                  on jmgcu.MEMBER_GROUP_ID            = jmgu.MEMBER_GROUP_ID
   where jmgu.MEMBER_USER_ID    = @MemberUserId and
         cut.PROVIDER_SYSTEM_ID = @ProviderSystemId

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetProviderCustomersBySystem' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetProviderCustomersBySystem

   go

create procedure spGetProviderCustomersBySystem( @ProviderSystemId integer,
                                                 @SubString        char(1) = null ) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   if ( ( @SubString = '' ) or ( @SubString is null ) )
      -- new stored proc
      execute @ReturnCode = spGetProviderCustomersBySystemNoSubString @ProviderSystemId
    else
      execute @ReturnCode = spGetProviderCustomersBySystemSubString @ProviderSystemId, @SubString

    /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetProviderCustomersBySystemNoSubString' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetProviderCustomersBySystemNoSubString

   go

create procedure spGetProviderCustomersBySystemNoSubString( @ProviderSystemId integer ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   select member_id, member_name, b.provider_customer_id
   from member a
   left outer join provider_customer b on a.member_id = b.customer_id
   left outer join provider_customer_service c on b.provider_customer_id = c.provider_customer_id
   where c.provider_system_id = @ProviderSystemId
   order by member_name

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetProviderCustomersBySystemSubstring' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetProviderCustomersBySystemSubstring

   go

create procedure spGetProviderCustomersBySystemSubstring( @ProviderSystemId integer,
                                                          @letter           char(1) ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   select member_id, member_name, b.provider_customer_id
   from member a
   left outer join provider_customer b on a.member_id = b.customer_id
   left outer join provider_customer_service c on b.provider_customer_id = c.provider_customer_id
   where c.provider_system_id = @ProviderSystemId
   and substring(a.member_name, 1, 1) = @letter
   order by member_name

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@Error. */
   select @ErrorCode = @@Error


   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetProviderCustomersByUser' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetProviderCustomersByUser

   go

create procedure spGetProviderCustomersByUser( @ProviderId   integer,
                                               @MemberUserId integer,
                                               @SubString    char(1) = null ) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   if ( ( @SubString = '' ) or ( @SubString is null ) )
      execute @ReturnCode = spGetProviderCustomersByUserNoSubString @ProviderId, @MemberUserId
   else
      execute @ReturnCode = spGetProviderCustomersByUserSubString @ProviderId,
                                                                  @MemberUserId,
                                                                  @SubString

    /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetProviderCustomersByUserNoSubString' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetProviderCustomersByUserNoSubString

   go

create procedure spGetProviderCustomersByUserNoSubString( @providerid   integer,
                                                          @memberuserid integer ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   select distinct a.member_id,
   	a.member_name,
	b.provider_customer_id
   from vw_customer_units_by_provider_user e
   left join provider_customer b on b.customer_id = e.customer_id and b.provider_id = e.provider_id
   left join member a on a.member_id = b.customer_id
   where e.member_user_id = @memberuserid
   and e.provider_id = @providerid
   order by member_id

    /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetProviderCustomersByUserSubString' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetProviderCustomersByUserSubString

   go

create procedure spGetProviderCustomersByUserSubString( @providerid   integer,
                                                        @memberuserid integer,
                                                        @letter       char(1) ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   select distinct a.member_id,
	a.member_name,
	b.provider_customer_id
   from vw_customer_units_by_provider_user e
   left join provider_customer b on b.customer_id = e.customer_id and b.provider_id = e.provider_id
   left join member a on a.member_id = b.customer_id
   where e.member_user_id = @memberuserid
   and e.provider_id = @providerid
   and substring(a.member_name, 1, 1) = @letter
   order by member_id

    /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetProviderCustomerServiceFinancialBySystemUnit' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetProviderCustomerServiceFinancialBySystemUnit

   go

create procedure spGetProviderCustomerServiceFinancialBySystemUnit( @ProviderSystemId integer,
                                                                    @CustomerUnitId   integer ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Get the financial data for the current service program and unit. */
   select pcsf.PROVIDER_CUSTOMER_SERVICE_FINANCIAL_ID,
          pcsf.PROVIDER_CUSTOMER_SERVICE_ID,
          pcsf.PROVIDER_SERVICE_TYPE_ID,
          IsNull( pst.PROVIDER_SERVICE_TYPE_TEXT, tpst.PROVIDER_SERVICE_TYPE_TEXT ) as PROVIDER_SERVICE_TYPE_TEXT,
          pcsf.CUSTOMER_UNIT_ID,
          pcsf.PROVIDER_CUSTOMER_SERVICE_AMOUNT
   from PROVIDER_CUSTOMER_SERVICE_FINANCIAL pcsf
   inner join      PROVIDER_SERVICE_TYPE pst           on pcsf.PROVIDER_SERVICE_TYPE_ID         = pst.PROVIDER_SERVICE_TYPE_ID
   left outer join TEMPLATE_PROVIDER_SERVICE_TYPE tpst on pst.TEMPLATE_PROVIDER_SERVICE_TYPE_ID = tpst.PROVIDER_SERVICE_TYPE_ID
   where ( pst.PROVIDER_SYSTEM_ID = @ProviderSystemId ) and
         ( pcsf.CUSTOMER_UNIT_ID  = @CustomerUnitId   )

   /* If there was an error... */
   if ( @@Error <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetProviderCustomerServiceScheduleByProviderCustomerService' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetProviderCustomerServiceScheduleByProviderCustomerService

   go

create procedure spGetProviderCustomerServiceScheduleByProviderCustomerService( @ProviderCustomerServiceId integer ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Get the work orders for the current provider, customer, and service
      program. */
   select pcss.PROVIDER_CUSTOMER_SERVICE_SCHEDULE_ID,
          pcss.PROVIDER_CUSTOMER_SERVICE_ID,
          pcss.PROVIDER_SERVICE_TYPE_ID,
          IsNull( pst.PROVIDER_SERVICE_TYPE_TEXT, tpst.PROVIDER_SERVICE_TYPE_TEXT ) as PROVIDER_SERVICE_TYPE_TEXT,
          pcss.CUSTOMER_UNIT_ID,
          cu.CUSTOMER_UNIT_NAME,
          pcss.PROVIDER_CUSTOMER_SERVICE_SCHEDULE_DATE,
          pcss.COM_SERVICE_ID,
          cs.COM_SERVICE_DATE,
          pcss.WORK_ORDER_NUMBER
   from PROVIDER_CUSTOMER_SERVICE_SCHEDULE pcss
   inner join      PROVIDER_SERVICE_TYPE pst           on pcss.PROVIDER_SERVICE_TYPE_ID         = pst.PROVIDER_SERVICE_TYPE_ID
   left outer join TEMPLATE_PROVIDER_SERVICE_TYPE tpst on pst.TEMPLATE_PROVIDER_SERVICE_TYPE_ID = tpst.PROVIDER_SERVICE_TYPE_ID
   inner join      CUSTOMER_UNIT cu                    on pcss.CUSTOMER_UNIT_ID                 = cu.CUSTOMER_UNIT_ID
   left outer join COM_SERVICE cs                      on pcss.COM_SERVICE_ID                   = cs.COM_SERVICE_ID
   where ( pcss.PROVIDER_CUSTOMER_SERVICE_ID = @ProviderCustomerServiceId ) and
         ( cu.UNIT_PARENT_ID                 = -1                         )

   /* If there was an error... */
   if ( @@Error <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetProviderCustomerServiceScheduleBySystemCustomer' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetProviderCustomerServiceScheduleBySystemCustomer

   go

create procedure spGetProviderCustomerServiceScheduleBySystemCustomer( @ProviderId       integer,
                                                                       @CustomerId       integer,
                                                                       @ProviderSystemId integer ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Get the work orders for the current provider, customer, and service
      program. */
   select pcss.PROVIDER_CUSTOMER_SERVICE_SCHEDULE_ID,
          pcss.PROVIDER_CUSTOMER_SERVICE_ID,
          pcss.PROVIDER_SERVICE_TYPE_ID,
          IsNull( pst.PROVIDER_SERVICE_TYPE_TEXT, tpst.PROVIDER_SERVICE_TYPE_TEXT ) as PROVIDER_SERVICE_TYPE_TEXT,
          pcss.CUSTOMER_UNIT_ID,
          cu.CUSTOMER_UNIT_NAME,
          pcss.PROVIDER_CUSTOMER_SERVICE_SCHEDULE_DATE,
          pcss.COM_SERVICE_ID,
          cs.COM_SERVICE_DATE,
          pcss.WORK_ORDER_NUMBER
   from PROVIDER_CUSTOMER_SERVICE_SCHEDULE pcss
   inner join      PROVIDER_CUSTOMER_SERVICE pcs       on pcss.PROVIDER_CUSTOMER_SERVICE_ID     = pcs.PROVIDER_CUSTOMER_SERVICE_ID
   inner join      PROVIDER_CUSTOMER pc                on pc.PROVIDER_CUSTOMER_ID               = pcs.PROVIDER_CUSTOMER_ID
   inner join      PROVIDER_SERVICE_TYPE pst           on pcss.PROVIDER_SERVICE_TYPE_ID         = pst.PROVIDER_SERVICE_TYPE_ID
   left outer join TEMPLATE_PROVIDER_SERVICE_TYPE tpst on pst.TEMPLATE_PROVIDER_SERVICE_TYPE_ID = tpst.PROVIDER_SERVICE_TYPE_ID
   inner join      CUSTOMER_UNIT cu                    on pcss.CUSTOMER_UNIT_ID                 = cu.CUSTOMER_UNIT_ID
   left outer join COM_SERVICE cs                      on pcss.COM_SERVICE_ID                   = cs.COM_SERVICE_ID
   where ( pc.PROVIDER_ID         = @ProviderId ) and
         ( pc.CUSTOMER_ID         = @CustomerId ) and
         ( pcs.PROVIDER_SYSTEM_ID = @ProviderSystemId   ) and
         ( cu.UNIT_PARENT_ID      = -1          )

   /* If there was an error... */
   if ( @@Error <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetProviderCustomerServiceScheduleBySystemUnit' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetProviderCustomerServiceScheduleBySystemUnit

   go

create procedure spGetProviderCustomerServiceScheduleBySystemUnit( @ProviderSystemId integer,
                                                                   @CustomerUnitId   integer,
                                                                   @Pending          integer = 01 ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* If the caller wants only the completed work orders... */
   if ( @Pending = 00 ) begin

      /* Get the completed work orders for the current service program and
         customer unit. */
      select pcss.PROVIDER_CUSTOMER_SERVICE_SCHEDULE_ID,
             pcss.PROVIDER_CUSTOMER_SERVICE_ID,
             pcss.PROVIDER_SERVICE_TYPE_ID,
             pcss.CUSTOMER_UNIT_ID,
             pcss.PROVIDER_CUSTOMER_SERVICE_SCHEDULE_DATE,
             pcss.COM_SERVICE_ID,
             pcss.WORK_ORDER_NUMBER
      from PROVIDER_CUSTOMER_SERVICE_SCHEDULE pcss
      inner join PROVIDER_CUSTOMER_SERVICE pcs on pcss.PROVIDER_CUSTOMER_SERVICE_ID = pcs.PROVIDER_CUSTOMER_SERVICE_ID
      where ( pcs.PROVIDER_SYSTEM_ID = @ProviderSystemId ) and
            ( pcss.CUSTOMER_UNIT_ID  = @CustomerUnitId   ) and
            ( pcss.COM_SERVICE_ID is not null    )

   end

   /* If the caller wants only the pending work orders... */
   else if ( @Pending = 01 ) begin

      /* Get the pending work orders for the current service program and
         customer unit. */
      select pcss.PROVIDER_CUSTOMER_SERVICE_SCHEDULE_ID,
             pcss.PROVIDER_CUSTOMER_SERVICE_ID,
             pcss.PROVIDER_SERVICE_TYPE_ID,
             pcss.CUSTOMER_UNIT_ID,
             pcss.PROVIDER_CUSTOMER_SERVICE_SCHEDULE_DATE,
             pcss.COM_SERVICE_ID,
             pcss.WORK_ORDER_NUMBER
      from PROVIDER_CUSTOMER_SERVICE_SCHEDULE pcss
      inner join PROVIDER_CUSTOMER_SERVICE pcs on pcss.PROVIDER_CUSTOMER_SERVICE_ID = pcs.PROVIDER_CUSTOMER_SERVICE_ID
      where ( pcs.PROVIDER_SYSTEM_ID = @ProviderSystemId ) and
            ( pcss.CUSTOMER_UNIT_ID  = @CustomerUnitId   ) and
            ( pcss.COM_SERVICE_ID is null        )

   end

   /* If the caller wants all of the work orders... */
   else begin

      /* Get all of the work orders for the current service program and
         customer unit. */
      select pcss.PROVIDER_CUSTOMER_SERVICE_SCHEDULE_ID,
             pcss.PROVIDER_CUSTOMER_SERVICE_ID,
             pcss.PROVIDER_SERVICE_TYPE_ID,
             pcss.CUSTOMER_UNIT_ID,
             pcss.PROVIDER_CUSTOMER_SERVICE_SCHEDULE_DATE,
             pcss.COM_SERVICE_ID,
             pcss.WORK_ORDER_NUMBER
      from PROVIDER_CUSTOMER_SERVICE_SCHEDULE pcss
      inner join PROVIDER_CUSTOMER_SERVICE pcs on pcss.PROVIDER_CUSTOMER_SERVICE_ID = pcs.PROVIDER_CUSTOMER_SERVICE_ID
      where ( pcs.PROVIDER_SYSTEM_ID = @ProviderSystemId ) and
            ( pcss.CUSTOMER_UNIT_ID  = @CustomerUnitId   )

   end

   /* If there was an error... */
   if ( @@Error <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetProviderCustomerUnitSubTypesByProviderSystemId' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetProviderCustomerUnitSubTypesByProviderSystemId

   go

create procedure spGetProviderCustomerUnitSubTypesByProviderSystemId( @ProviderSystemId integer ) as

   /* Return the result set containing the customer unit sub-types for the
      passed provider system identifier. */
   select a.CUSTOMER_UNIT_TYPE_ID,
          IsNull( a.CUSTOMER_UNIT_TYPE_NAME, c.CUSTOMER_UNIT_TYPE_NAME ) as CUSTOMER_UNIT_TYPE_NAME,
          a.CUSTOMER_UNIT_TYPE_PARENT_ID,
          IsNull( c.CUSTOMER_UNIT_TYPE_MOD, 01 )                        as CUSTOMER_UNIT_TYPE_MOD,
          a.TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE_ID
   from CUSTOMER_UNIT_TYPE a
   left outer join TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE c on a.TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE_ID = c.CUSTOMER_UNIT_TYPE_ID
   where a.PROVIDER_SYSTEM_ID = @ProviderSystemId and
         a.CUSTOMER_UNIT_TYPE_PARENT_ID <> -1

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetProviderCustomerUnitTypesByProviderSystemId' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetProviderCustomerUnitTypesByProviderSystemId

   go

create procedure spGetProviderCustomerUnitTypesByProviderSystemId( @ProviderSystemId integer ) as

   /* Return the result set containing the customer unit types for the passed
      provider system identifier. */
   select a.CUSTOMER_UNIT_TYPE_ID,
          IsNull( a.CUSTOMER_UNIT_TYPE_NAME, c.CUSTOMER_UNIT_TYPE_NAME ) as CUSTOMER_UNIT_TYPE_NAME,
          a.CUSTOMER_UNIT_TYPE_PARENT_ID,
          IsNull( c.CUSTOMER_UNIT_TYPE_MOD, 01 )                        as CUSTOMER_UNIT_TYPE_MOD,
          a.TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE_ID
   from CUSTOMER_UNIT_TYPE a
   left outer join TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE c on a.TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE_ID = c.CUSTOMER_UNIT_TYPE_ID
   where a.PROVIDER_SYSTEM_ID = @ProviderSystemId

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetProviderIdByProviderUserId' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetProviderIdByProviderUserId

   go

create procedure spGetProviderIdByProviderUserId( @ProviderUserId integer,
                                                  @ProviderId     integer output ) as

   /* Get the identifier of the provider. */
   execute spGetMemberIdByMemberUserId @ProviderUserId,
                                       @ProviderId output

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetProviderMessage' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetProviderMessage

   go

create procedure spGetProviderMessage( @ProviderId integer ) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   -- new procedure
   execute @ReturnCode = spGetContactInfoForEntityByType @ProviderId,
                                                          3,
                                                          14

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetProviderNameByProviderId' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetProviderNameByProviderId

   go

create procedure spGetProviderNameByProviderId( @ProviderId   integer,
                                                @ProviderName varchar(100) output ) as

   /* Get the name of the provider. */
   execute spGetMemberNameByMemberId @ProviderId,
                                     @ProviderName output

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetProviderPortalReports' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetProviderPortalReports

   go

create procedure spGetProviderPortalReports as

   /* Use the stored procedure that returns the reports for an application to
      retrieve the reports for the provider portal system. */
   execute spGetApplicationReports 01

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetProviders' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetProviders

   go

create procedure spGetProviders( @ProviderId integer,
                                 @letter     char(1) ) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   execute @ReturnCode = spGetMembers 1,
                                      @ProviderId,
                                      @letter

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetProvidersByMemberUserId' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetProvidersByMemberUserId

   go

create procedure spGetProvidersByMemberUserId( @memberuserid integer ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   declare @securitygroupid integer
   select @securitygroupid=security_group_id from join_member_user_security_group where member_user_id = @memberuserid

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   if @securitygroupid<6 begin
      select distinct ps.provider_id, m.member_name, d.contact_info
      from customer_unit cu
      inner join join_customer_unit_type_customer_unit jcutcu on cu.customer_unit_id = jcutcu.customer_unit_id and cu.unit_parent_id = -1
      inner join customer_unit_type cut on jcutcu.customer_unit_type_id = cut.customer_unit_type_id
      inner join join_member_group_customer_unit jmgcu on cu.customer_unit_id = jmgcu.customer_unit_id
      inner join join_member_group_user jmgu on jmgcu.member_group_id = jmgu.member_group_id
      left outer join provider_system ps on ps.provider_system_id = cut.provider_system_id
      left outer join member m on ps.provider_id = m.member_id
      left outer join contact_join f
      left outer join contact d on f.contact_id = d.contact_id
      on m.member_id = f.entity_id
      and d.contact_type_id = 14
      and f.entity_type_id = 3
      where jmgu.member_user_id = @memberuserid
   end
   else begin
      select provider_id, member_name, contact_info
      from provider_customer a
      left outer join member b on a.provider_id = b.member_id
      left outer join member_user c on a.customer_id = c.member_id
      left outer join contact_join f
      left outer join contact d on f.contact_id = d.contact_id
      on b.member_id = f.entity_id
      and d.contact_type_id = 14
      and f.entity_type_id = 3
      where c.member_user_id = @memberuserid

   end

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetProvidersByUser' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetProvidersByUser

   go

create procedure spGetProvidersByUser( @MemberUserId integer ) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   -- new procedure
   execute @ReturnCode = spGetProvidersByMemberUserId @MemberUserId

    /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetProviderSecurityGroups' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetProviderSecurityGroups

   go

create procedure spGetProviderSecurityGroups as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   -- new procedure
   execute @ReturnCode = spGetSecurityGroupsByType 4

    /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetProviderServiceCategoriesByProviderSystemId' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetProviderServiceCategoriesByProviderSystemId

   go

create procedure spGetProviderServiceCategoriesByProviderSystemId( @providersystemid integer ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

  select a.provider_service_category_id,
         isnull( a.provider_service_category, b.provider_service_category ) as provider_service_category,
	 isnull(b.provider_service_category_mod,1) as provider_service_category_mod,
	 template_provider_service_category_id
   from provider_service_category a
   left outer join template_provider_service_category b on a.template_provider_service_category_id = b.provider_service_category_id
   where a.provider_system_id = @providersystemid
   order by a.provider_service_category_id

   /* Get the the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 )  begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetProviderServiceCategoriesBySystem' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetProviderServiceCategoriesBySystem

   go

create procedure spGetProviderServiceCategoriesBySystem( @ProviderSystemId integer ) as

  declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   -- new procedure
   execute @ReturnCode = spGetProviderServiceCategoriesByProviderSystemId @ProviderSystemId

    /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetProviderServiceCommentsBySystem' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetProviderServiceCommentsBySystem

   go

create procedure spGetProviderServiceCommentsBySystem( @ProviderSystemId integer ) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   -- new procedure
   execute @ReturnCode = spGetProviderServiceCommentsByProviderSystemId @ProviderSystemId

    /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetProviderServiceCommentsByProviderSystemId' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetProviderServiceCommentsByProviderSystemId

   go

create procedure spGetProviderServiceCommentsByProviderSystemId( @ProviderSystemId integer ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   select a.provider_service_comment_id,
          isnull( a.provider_service_comment, b.provider_service_comment_text ) as provider_service_comment,
	  isnull(b.provider_service_comment_mod,1) as provider_service_comment_mod,
	  template_provider_service_comment_id
   from provider_service_comment a
   left outer join template_provider_service_comment b on a.template_provider_service_comment_id = b.provider_service_comment_id
   where a.provider_system_id = @ProviderSystemId

    /* Get the the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 )  begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetProviderServiceDataBarCodeIdIsUniqueBySystem' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetProviderServiceDataBarCodeIdIsUniqueBySystem

   go

create procedure spGetProviderServiceDataBarCodeIdIsUniqueBySystem( @ProviderSystemId integer,
                                                                    @BarCodeId        varchar(10),
                                                                    @ServiceDataId    integer,
                                                                    @BarCodeCount     integer output ) as

   declare @ErrorCode            integer         /* Error code returned by the execution of the last statement   */
   declare @RowsAffected         integer         /* Number of rows affected by the previously executed statement */
   declare @Transactions         integer         /* Number of active transactions at the start of this procedure */

    /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* If the user is inserting a new service data item... */
   if ( @ServiceDataId is null ) begin

      /* Get the number of barcode identifiers that match the passed barcode
         identifier value.  This should be zero, however, if it is nonzero,
         then the user has created a duplicate. */
      select @BarCodeCount = count(*)
      from PROVIDER_SERVICE_DATA fv
           left outer join TEMPLATE_PROVIDER_SERVICE_DATA tv on fv.TEMPLATE_PROVIDER_SERVICE_DATA_ID = tv.PROVIDER_SERVICE_DATA_ID
           inner join      PROVIDER_SERVICE_DATA_TYPE     cf on fv.PROVIDER_SERVICE_DATA_TYPE_ID     = cf.PROVIDER_SERVICE_DATA_TYPE_ID
           inner join      PROVIDER_SERVICE_CATEGORY      sc on cf.PROVIDER_SERVICE_CATEGORY_ID      = sc.PROVIDER_SERVICE_CATEGORY_ID
      where sc.PROVIDER_SYSTEM_ID = @ProviderSystemId and
            ( ( fv.BARCODE_ID = @BarCodeId ) or
              ( tv.BARCODE_ID = @BarCodeId ) )

   end

   else begin /* Updating an existing service data item...  */

      /* Get the number of barcode identifiers that match the passed barcode
         identifier value and are not contained by the passed service data
         item.  This should be zero, however, if it is nonzero, then the user
         has created a duplicate by updating the barcode identifier to a value
         that matches another barcode identifier.  This test handles the
         special case of an updated row finding itself as a duplicate. */
      select @BarCodeCount = count(*)
      from PROVIDER_SERVICE_DATA fv
           left outer join TEMPLATE_PROVIDER_SERVICE_DATA tv on fv.TEMPLATE_PROVIDER_SERVICE_DATA_ID = tv.PROVIDER_SERVICE_DATA_ID
           inner join      PROVIDER_SERVICE_DATA_TYPE     cf on fv.PROVIDER_SERVICE_DATA_TYPE_ID     = cf.PROVIDER_SERVICE_DATA_TYPE_ID
           inner join      PROVIDER_SERVICE_CATEGORY      sc on cf.PROVIDER_SERVICE_CATEGORY_ID      = sc.PROVIDER_SERVICE_CATEGORY_ID
      where sc.PROVIDER_SYSTEM_ID = @ProviderSystemId and
            ( ( fv.BARCODE_ID = @BarCodeId ) or
              ( tv.BARCODE_ID = @BarCodeId ) ) and
            fv.PROVIDER_SERVICE_DATA_ID <> @ServiceDataId

   end

    /* Get the rows affected and the error code for the previous
       statement.  Error checking MUST be done this way since any single
       statement executed will affect both of the global functions,
       @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetProviderServiceDataByDataType' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetProviderServiceDataByDataType

   go

create procedure spGetProviderServiceDataByDataType( @ProviderServiceDataTypeId integer ) as

  declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   -- new procedure
   execute @ReturnCode = spGetProviderServiceDataByProviderServiceDataTypeId @ProviderServiceDataTypeId

     /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetProviderServiceDataByProviderServiceDataTypeId' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetProviderServiceDataByProviderServiceDataTypeId

   go

create procedure spGetProviderServiceDataByProviderServiceDataTypeId( @providerservicedatatypeid integer ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

  select a.provider_service_data_id,
         isnull( a.provider_service_data, b.provider_service_data ) as provider_service_data,
         isnull( a.barcode_id, b.barcode_id ) as barcode_id,
   	 isnull(b.provider_service_data_mod,1) as provider_service_data_mod,
	 template_provider_service_data_id
   from provider_service_data a
   left outer join template_provider_service_data b on a.template_provider_service_data_id = b.provider_service_data_id
   where a.provider_service_data_type_id = @providerservicedatatypeid
   order by provider_service_data_type_id, a.provider_service_data_id

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetProviderServiceDataTypesByCategory' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetProviderServiceDataTypesByCategory

   go

create procedure spGetProviderServiceDataTypesByCategory( @ProviderServiceCategoryId integer ) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   -- new procedure
   execute @ReturnCode = spGetProviderServiceDataTypesByProviderServiceCategoryId @ProviderServiceCategoryId

     /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetProviderServiceDataTypesByProviderSystemID' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetProviderServiceDataTypesByProviderSystemID

   go

create procedure spGetProviderServiceDataTypesByProviderSystemID( @ProviderSystemId integer ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   select psc.provider_service_category_id,
          isnull( psc.provider_service_category, tpsc.provider_service_category ) as provider_service_category,
          psdt.provider_service_data_type_id,
          isnull( psdt.provider_service_data_type_text, tpsdt.provider_service_data_type_text ) as provider_service_data_type,
          isnull( psdt.web_query, tpsdt.web_query ) as web_query,
          isnull( psdt.sort_order, tpsdt.sort_order ) as sort_order
   from provider_service_category psc
   left outer join template_provider_service_category tpsc on psc.template_provider_service_category_id = tpsc.provider_service_category_id
   inner join provider_service_data_type psdt on psc.provider_service_category_id = psdt.provider_service_category_id
   left outer join template_provider_service_data_type tpsdt on psdt.template_provider_service_data_type_id = tpsdt.provider_service_data_type_id
   where psc.provider_system_id = @ProviderSystemId
     and ( isnull( psdt.web_query, tpsdt.web_query) > 0 )
   order by psc.provider_service_category_id, sort_order

    /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 )  begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetProviderServiceDataTypesByProviderServiceCategoryId' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetProviderServiceDataTypesByProviderServiceCategoryId

   go

create procedure spGetProviderServiceDataTypesByProviderServiceCategoryId( @providerservicecategoryid integer ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   SELECT  a.PROVIDER_SERVICE_DATA_TYPE_ID,
          isnull( psdt.provider_service_data_type_text, tpsdt.provider_service_data_type_text ) as provider_service_data_type,
          isnull( psdt.web_query, tpsdt.web_query ) as web_query,
          isnull( psdt.sort_order, tpsdt.sort_order ) as sort_order,
	ISNULL(b.PROVIDER_SERVICE_DATA_TYPE_MOD,1) AS PROVIDER_SERVICE_DATA_TYPE_MOD,
	TEMPLATE_PROVIDER_SERVICE_DATA_TYPE_ID
   FROM PROVIDER_SERVICE_DATA_TYPE a
   LEFT OUTER JOIN TEMPLATE_PROVIDER_SERVICE_DATA_TYPE b ON a.TEMPLATE_PROVIDER_SERVICE_DATA_TYPE_ID = b.PROVIDER_SERVICE_DATA_TYPE_ID
   WHERE a.PROVIDER_SERVICE_CATEGORY_ID = @providerservicecategoryid
   ORDER BY SORT_ORDER

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 )  begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetProviderServiceTypesByProviderSystemId' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetProviderServiceTypesByProviderSystemId

   go

create procedure spGetProviderServiceTypesByProviderSystemId( @ProviderSystemId integer ) as

   /* Return the result set containing the service types for the passed
      provider system identifier. */
   select a.PROVIDER_SERVICE_TYPE_ID,
          IsNull( a.PROVIDER_SERVICE_TYPE_TEXT, b.PROVIDER_SERVICE_TYPE_TEXT ) as PROVIDER_SERVICE_TYPE_TEXT,
          IsNull( b.PROVIDER_SERVICE_TYPE_MOD, 01 )                           as PROVIDER_SERVICE_TYPE_MOD,
          a.TEMPLATE_PROVIDER_SERVICE_TYPE_ID
   from PROVIDER_SERVICE_TYPE a
   left outer join TEMPLATE_PROVIDER_SERVICE_TYPE b on a.TEMPLATE_PROVIDER_SERVICE_TYPE_ID = b.PROVIDER_SERVICE_TYPE_ID
   where a.PROVIDER_SYSTEM_ID = @ProviderSystemId
   order by a.PROVIDER_SYSTEM_ID,
            a.PROVIDER_SERVICE_TYPE_ID

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetProviderServiceTypesBySystem' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetProviderServiceTypesBySystem

   go

create procedure spGetProviderServiceTypesBySystem( @ProviderSystemId integer ) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   -- new procedure
   execute @ReturnCode = spGetProviderServiceTypesByProviderSystemId @ProviderSystemId

    /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetProviderServiceValuesByProviderSystemId' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetProviderServiceValuesByProviderSystemId

   go

create procedure spGetProviderServiceValuesByProviderSystemId( @providersystemid integer ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   SELECT a.PROVIDER_SERVICE_VALUE_ID,
	  isnull( a.PROVIDER_SERVICE_VALUE, b.PROVIDER_SERVICE_VALUE ) as PROVIDER_SERVICE_VALUE,
	  isnull( a.PROVIDER_SERVICE_VALUE_TEXT, b.PROVIDER_SERVICE_VALUE_TEXT ) as PROVIDER_SERVICE_VALUE_TEXT,
	ISNULL(b.PROVIDER_SERVICE_VALUE_MOD,1) AS PROVIDER_SERVICE_VALUE_MOD,
	TEMPLATE_PROVIDER_SERVICE_VALUE_ID
   FROM PROVIDER_SERVICE_VALUE a
   LEFT OUTER JOIN TEMPLATE_PROVIDER_SERVICE_VALUE b ON a.TEMPLATE_PROVIDER_SERVICE_VALUE_ID = b.PROVIDER_SERVICE_VALUE_ID
   WHERE a.PROVIDER_SYSTEM_ID = @providersystemid
   ORDER BY a.PROVIDER_SYSTEM_ID, a.PROVIDER_SERVICE_VALUE, a.PROVIDER_SERVICE_VALUE_ID

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetProviderServiceValuesBySystem' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetProviderServiceValuesBySystem

   go

create procedure spGetProviderServiceValuesBySystem( @ProviderSystemId integer ) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   -- new procedure
   execute @ReturnCode = spGetProviderServiceValuesByProviderSystemId @ProviderSystemId

     /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetProviderSystemCustomersBySystemUser' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetProviderSystemCustomersBySystemUser

   go

create procedure spGetProviderSystemCustomersBySystemUser( @ProviderSystemId integer,
                                                           @MemberUserId     integer,
                                                           @SubString        char(1) = null ) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   if ( ( @SubString = '' ) or ( @SubString is null ) )
      execute @ReturnCode = spGetProviderSystemCustomersByUser @ProviderSystemId,
                                                               @MemberUserId
   else
      execute @ReturnCode = spGetProviderSystemCustomersByUserSubString @ProviderSystemId,
                                                                        @MemberUserId,
                                                                        @SubString

    /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetProviderSystemCustomersByUser' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetProviderSystemCustomersByUser

   go

create procedure spGetProviderSystemCustomersByUser( @ProviderSystemId integer,
                                                     @memberuserid     integer ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   select distinct e.member_id, e.member_name, g.provider_customer_id
   from join_member_group_customer_unit a
   left outer join customer_unit b on a.customer_unit_id = b.customer_unit_id
   left outer join provider_customer g on b.customer_id = g.customer_id
   left outer join join_customer_unit_type_customer_unit d on b.customer_unit_id = d.customer_unit_id
   left outer join customer_unit_type c on d.customer_unit_type_id = c.customer_unit_type_id
   inner join provider_system ps on c.provider_system_id = ps.provider_system_id and g.provider_id = ps.provider_id
   left outer join member e on b.customer_id = e.member_id
   left outer join join_member_group_user f on a.member_group_id = f.member_group_id
   where f.member_user_id = @memberuserid
   and c.provider_system_id = @ProviderSystemId
   order by e.member_id

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetProviderSystemCustomersByUserSubstring' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetProviderSystemCustomersByUserSubstring

   go

create procedure spGetProviderSystemCustomersByUserSubstring( @ProviderSystemId     integer,
                                                              @memberuserid integer,
                                                              @letter       char(1) ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   select distinct e.member_id, e.member_name, g.provider_customer_id
   from join_member_group_customer_unit a
   left outer join customer_unit b on a.customer_unit_id = b.customer_unit_id
   left outer join provider_customer g on b.customer_id = g.customer_id
   left outer join join_customer_unit_type_customer_unit d on b.customer_unit_id = d.customer_unit_id
   left outer join customer_unit_type c on d.customer_unit_type_id = c.customer_unit_type_id
   left outer join member e on b.customer_id = e.member_id
   left outer join join_member_group_user f on a.member_group_id = f.member_group_id
   where f.member_user_id = @memberuserid
   and c.provider_system_id = @ProviderSystemId
   and substring(e.member_name, 1, 1) = @letter
   order by e.member_id

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetProviderSystemNameByProviderSystemId' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetProviderSystemNameByProviderSystemId

   go

create procedure spGetProviderSystemNameByProviderSystemId( @ProviderSystemId   integer,
                                                            @ProviderSystemName varchar(100) output ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

    /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Return the result set containing the service types for the passed
      provider system identifier. */
   select @ProviderSystemName = IsNull( ps.PROVIDER_SYSTEM_NAME,
                                        tps.PROVIDER_SYSTEM_NAME )
   from PROVIDER_SYSTEM ps
   left outer join TEMPLATE_PROVIDER_SYSTEM tps on ps.TEMPLATE_PROVIDER_SYSTEM_ID = tps.PROVIDER_SYSTEM_ID
   where ps.PROVIDER_SYSTEM_ID = @ProviderSystemId

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetProviderSystemsAssignedByCustomer' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetProviderSystemsAssignedByCustomer

   go

create procedure spGetProviderSystemsAssignedByCustomer( @providerid integer,
                                                         @customerid integer ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   SELECT a.PROVIDER_SYSTEM_ID,
          isnull( a.PROVIDER_SYSTEM_NAME, d.PROVIDER_SYSTEM_NAME ) as PROVIDER_SYSTEM_NAME,
       a.PROVIDER_ID,
       b.PROVIDER_CUSTOMER_SERVICE_ID,
       e.contact_info
   FROM PROVIDER_SYSTEM a
   INNER JOIN      PROVIDER_CUSTOMER_SERVICE b ON a.provider_system_id          = b.provider_system_id
   INNER JOIN      PROVIDER_CUSTOMER c         ON b.provider_customer_id        = c.provider_customer_id
   LEFT OUTER JOIN TEMPLATE_PROVIDER_SYSTEM d  ON a.TEMPLATE_PROVIDER_SYSTEM_ID = d.PROVIDER_SYSTEM_ID
   left outer join contact_join f
   left outer join contact e on f.contact_id = e.contact_id
   on a.provider_system_id = f.entity_id
   and e.contact_type_id = 14
   and f.entity_type_id = 6
   WHERE c.customer_id = @customerid AND
         c.provider_id = @providerid

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetProviderSystemsByCustomer' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetProviderSystemsByCustomer

   go

create procedure spGetProviderSystemsByCustomer( @ProviderId integer,
                                                 @CustomerId integer,
												 @Assigned   integer ) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   if @Assigned = 1
      execute @ReturnCode = spGetProviderSystemsAssignedByCustomer @ProviderId, @CustomerId

   else
      execute @ReturnCode = spGetProviderSystemsNotByCustomer @ProviderId, @CustomerId

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetProviderSystemsByMemberUserId' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetProviderSystemsByMemberUserId

   go

create procedure spGetProviderSystemsByMemberUserId( @MemberUserId integer ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

  /* Return the result set containing the service programs for the passed
      member user identifier. */
   select distinct ps.PROVIDER_SYSTEM_ID,
                   ps.PROVIDER_ID,
                   IsNull( ps.PROVIDER_SYSTEM_NAME,
                           tps.PROVIDER_SYSTEM_NAME ) as PROVIDER_SYSTEM_NAME,
  		   REVIEW,
		   [PROVIDER_SYSTEM_SERVICE_COMMENT_ADD],
		   [PROVIDER_SYSTEM_SERVICE_COMMENT_MOD],
		   [PROVIDER_SYSTEM_SERVICE_TYPE_ADD],
		   [PROVIDER_SYSTEM_SERVICE_TYPE_MOD],
		   [PROVIDER_SYSTEM_SERVICE_CATEGORY_ADD],
		   [PROVIDER_SYSTEM_SERVICE_CATEGORY_MOD],
		   [PROVIDER_SYSTEM_SERVICE_DATA_TYPE_ADD],
		   [PROVIDER_SYSTEM_SERVICE_DATA_TYPE_MOD],
		   [PROVIDER_SYSTEM_SERVICE_DATA_ADD],
		   [PROVIDER_SYSTEM_SERVICE_DATA_MOD],
		   [PROVIDER_SYSTEM_SERVICE_VALUE_ADD],
		   [PROVIDER_SYSTEM_SERVICE_VALUE_MOD],
		   [PROVIDER_SYSTEM_CUSTOMER_UNIT_TYPE_ADD],
		   [PROVIDER_SYSTEM_CUSTOMER_UNIT_TYPE_MOD],
		   [PROVIDER_SYSTEM_CUSTOMER_UNIT_NAME_ADD],
		   [PROVIDER_SYSTEM_CUSTOMER_UNIT_NAME_MOD],
		   ps.TEMPLATE_PROVIDER_SYSTEM_ID
      from PROVIDER_SYSTEM ps
      inner join TEMPLATE_PROVIDER_SYSTEM tps               on ps.TEMPLATE_PROVIDER_SYSTEM_ID = tps.PROVIDER_SYSTEM_ID
      inner join CUSTOMER_UNIT_TYPE cut                     on ps.PROVIDER_SYSTEM_ID          = cut.PROVIDER_SYSTEM_ID
      inner join JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT jcut on cut.CUSTOMER_UNIT_TYPE_ID      = jcut.CUSTOMER_UNIT_TYPE_ID
      inner join JOIN_MEMBER_GROUP_CUSTOMER_UNIT jmg        on jcut.CUSTOMER_UNIT_ID          = jmg.CUSTOMER_UNIT_ID
      inner join JOIN_MEMBER_GROUP_USER jmgu                on jmg.MEMBER_GROUP_ID            = jmgu.MEMBER_GROUP_ID
      inner join MEMBER_USER mu                             on jmgu.MEMBER_USER_ID            = mu.MEMBER_USER_ID
      where mu.MEMBER_USER_ID = @MemberUserId
      order by PROVIDER_SYSTEM_NAME

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetProviderSystemsByProvider' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetProviderSystemsByProvider

   go

create procedure spGetProviderSystemsByProvider( @ProviderId integer ) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   execute @ReturnCode = spGetProviderSystemsByProviderId @ProviderId

    /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetProviderSystemsByProviderId' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetProviderSystemsByProviderId

   go

create procedure spGetProviderSystemsByProviderId( @providerid integer ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   SELECT a.PROVIDER_SYSTEM_ID,
	  a.PROVIDER_ID,
	  isnull( a.PROVIDER_SYSTEM_NAME, b.PROVIDER_SYSTEM_NAME ) as PROVIDER_SYSTEM_NAME,
	  REVIEW,
  	  [PROVIDER_SYSTEM_SERVICE_COMMENT_ADD],
  	  [PROVIDER_SYSTEM_SERVICE_COMMENT_MOD],
	  [PROVIDER_SYSTEM_SERVICE_TYPE_ADD],
	  [PROVIDER_SYSTEM_SERVICE_TYPE_MOD],
	  [PROVIDER_SYSTEM_SERVICE_CATEGORY_ADD],
	  [PROVIDER_SYSTEM_SERVICE_CATEGORY_MOD],
	  [PROVIDER_SYSTEM_SERVICE_DATA_TYPE_ADD],
	  [PROVIDER_SYSTEM_SERVICE_DATA_TYPE_MOD],
	  [PROVIDER_SYSTEM_SERVICE_DATA_ADD],
	  [PROVIDER_SYSTEM_SERVICE_DATA_MOD],
	  [PROVIDER_SYSTEM_SERVICE_VALUE_ADD],
	  [PROVIDER_SYSTEM_SERVICE_VALUE_MOD],
	  [PROVIDER_SYSTEM_CUSTOMER_UNIT_TYPE_ADD],
	  [PROVIDER_SYSTEM_CUSTOMER_UNIT_TYPE_MOD],
	  [PROVIDER_SYSTEM_CUSTOMER_UNIT_NAME_ADD],
	  [PROVIDER_SYSTEM_CUSTOMER_UNIT_NAME_MOD],
	  isnull( a.PROVIDER_SERVICET_TYPE_DEFAULT_ID, b.PROVIDER_SERVICET_TYPE_DEFAULT_ID ) as PROVIDER_SERVICET_TYPE_DEFAULT_ID,
	  isnull( a.PROVIDER_SERVICET_VALUE_DEFAULT_ID, b.PROVIDER_SERVICET_VALUE_DEFAULT_ID ) as PROVIDER_SERVICET_VALUE_DEFAULT_ID,
	  a.TEMPLATE_PROVIDER_SYSTEM_ID
   FROM PROVIDER_SYSTEM a
   LEFT OUTER JOIN TEMPLATE_PROVIDER_SYSTEM b ON a.TEMPLATE_PROVIDER_SYSTEM_ID = b.PROVIDER_SYSTEM_ID
   WHERE PROVIDER_ID = @providerid

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 )  begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetProviderSystemsByUser' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetProviderSystemsByUser

   go

create procedure spGetProviderSystemsByUser( @MemberUserId integer ) as

   declare @membertypeid integer

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   SELECT @membertypeid = a.MEMBER_TYPE_ID
   FROM MEMBER a
   left join MEMBER_USER b on a.member_id = b.member_id
   WHERE b.member_user_id = @memberuserid

    /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 )  begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   if @membertypeid = 2 begin

      select distinct ps.PROVIDER_SYSTEM_ID,
                   IsNull( ps.PROVIDER_SYSTEM_NAME,
                           tps.PROVIDER_SYSTEM_NAME ) as PROVIDER_SYSTEM_NAME,
                   ps.PROVIDER_ID,
                   e.contact_info
      from PROVIDER_SYSTEM ps
      inner join TEMPLATE_PROVIDER_SYSTEM tps               on ps.TEMPLATE_PROVIDER_SYSTEM_ID = tps.PROVIDER_SYSTEM_ID
      inner join CUSTOMER_UNIT_TYPE cut                     on ps.PROVIDER_SYSTEM_ID          = cut.PROVIDER_SYSTEM_ID
      inner join JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT jcut on cut.CUSTOMER_UNIT_TYPE_ID      = jcut.CUSTOMER_UNIT_TYPE_ID
      inner join JOIN_MEMBER_GROUP_CUSTOMER_UNIT jmg        on jcut.CUSTOMER_UNIT_ID          = jmg.CUSTOMER_UNIT_ID
      inner join JOIN_MEMBER_GROUP_USER jmgu                on jmg.MEMBER_GROUP_ID            = jmgu.MEMBER_GROUP_ID
      left outer join contact_join f
      left outer join contact e                             on f.contact_id          = e.contact_id
                                                            on ps.provider_system_id = f.entity_id and
                                                               e.contact_type_id     = 14          and
                                                               f.entity_type_id      = 6
      where jmgu.MEMBER_USER_ID = @MemberUserId
      order by PROVIDER_SYSTEM_NAME

      end
      else begin

      select distinct ps.PROVIDER_SYSTEM_ID,
                      IsNull( ps.PROVIDER_SYSTEM_NAME,
                           tps.PROVIDER_SYSTEM_NAME ) as PROVIDER_SYSTEM_NAME,
                   ps.PROVIDER_ID,
                   e.contact_info
      from PROVIDER_SYSTEM ps
      inner join TEMPLATE_PROVIDER_SYSTEM tps               on ps.TEMPLATE_PROVIDER_SYSTEM_ID = tps.PROVIDER_SYSTEM_ID
      inner join CUSTOMER_UNIT_TYPE cut                     on ps.PROVIDER_SYSTEM_ID          = cut.PROVIDER_SYSTEM_ID
      inner join JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT jcut on cut.CUSTOMER_UNIT_TYPE_ID      = jcut.CUSTOMER_UNIT_TYPE_ID
      inner join JOIN_MEMBER_GROUP_CUSTOMER_UNIT jmg        on jcut.CUSTOMER_UNIT_ID          = jmg.CUSTOMER_UNIT_ID
      inner join JOIN_MEMBER_GROUP_USER jmgu                on jmg.MEMBER_GROUP_ID            = jmgu.MEMBER_GROUP_ID
      inner join MEMBER_USER mu                             on jmgu.MEMBER_USER_ID            = mu.MEMBER_USER_ID
      inner join MEMBER_GROUP mg			    on jmgu.MEMBER_GROUP_ID           = mg.MEMBER_GROUP_ID
      inner join MEMBER_GROUP_TYPE mgt                      on mg.MEMBER_GROUP_TYPE_ID        = mgt.MEMBER_GROUP_TYPE_ID
							       and ps.provider_id             = mgt.member_id
      left outer join contact_join f
      left outer join contact e                             on f.contact_id          = e.contact_id
                                                            on ps.provider_system_id = f.entity_id and
                                                               e.contact_type_id     = 14          and
                                                               f.entity_type_id      = 6
      where mu.MEMBER_USER_ID = @MemberUserId
      order by PROVIDER_SYSTEM_NAME

   end

    /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 )  begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetProviderSystemsNotByCustomer' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetProviderSystemsNotByCustomer

   go

create procedure spGetProviderSystemsNotByCustomer( @providerid integer,
                                                    @customerid integer ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   SELECT a.PROVIDER_SYSTEM_ID,
          isnull( a.PROVIDER_SYSTEM_NAME, b.PROVIDER_SYSTEM_NAME ) as PROVIDER_SYSTEM_NAME
   FROM PROVIDER_SYSTEM a
   LEFT OUTER JOIN TEMPLATE_PROVIDER_SYSTEM b ON a.template_provider_system_id = b.provider_system_id
   WHERE provider_id = @providerid
   AND a.PROVIDER_SYSTEM_ID not in
   (select provider_system_id
   from PROVIDER_CUSTOMER_SERVICE a, PROVIDER_CUSTOMER b
   where a.provider_customer_id = b.provider_customer_id
   and customer_id = @customerid )

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if  ( @ErrorCode <> 00 )  begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetProviderTemplateProviderSystemsByProvider' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetProviderTemplateProviderSystemsByProvider

   go

create procedure spGetProviderTemplateProviderSystemsByProvider( @providerid integer ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   SELECT a.PROVIDER_ID,
	  a.TEMPLATE_PROVIDER_SYSTEM_ID,
          b.PROVIDER_SYSTEM_NAME
   FROM JOIN_PROVIDER_TEMPLATE_PROVIDER_SYSTEM a
   LEFT OUTER JOIN TEMPLATE_PROVIDER_SYSTEM b on a.TEMPLATE_PROVIDER_SYSTEM_ID = b.PROVIDER_SYSTEM_ID
   WHERE PROVIDER_ID = @providerid

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 )  begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetProviderUserAdministratorCountByProvider' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetProviderUserAdministratorCountByProvider

   go

create procedure spGetProviderUserAdministratorCountByProvider( @ProviderId         integer,
                                                                @ProviderUserId     integer,
                                                                @AdministratorCount integer output ) as

   /* Execute the general member user security group counting procedure to
      return the number of administrators for the passed provider.  Note the
      scalar value for the administrator security group identifier.  This value
      is found in the security group table. */
   execute spGetMemberUserSecurityGroupCountByMember @ProviderId,
                                                     13,
                                                     @ProviderUserId,
                                                     @AdministratorCount output

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetProviderUserBackupAdministratorCountByProvider' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetProviderUserBackupAdministratorCountByProvider

   go

create procedure spGetProviderUserBackupAdministratorCountByProvider( @ProviderId               integer,
                                                                      @ProviderUserId           integer,
                                                                      @BackupAdministratorCount integer output ) as

   /* Execute the general member user security group counting procedure to
      return the number of backup administrators for the passed provider.  Note
      the scalar value for the backup administrator security group identifier.
      This value is found in the security group table. */
   execute spGetMemberUserSecurityGroupCountByMember @ProviderId,
                                                     12,
                                                     @ProviderUserId,
                                                     @BackupAdministratorCount output

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetProviderUserContactInfo' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetProviderUserContactInfo

   go

create procedure spGetProviderUserContactInfo( @ProviderUserId integer ) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   -- new procedure
   execute @ReturnCode = spGetContactInfoForEntity @ProviderUserId,
                                                   1

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetProviderUserNameByProviderUserId' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetProviderUserNameByProviderUserId

   go

create procedure spGetProviderUserNameByProviderUserId( @ProviderUserId        integer,
                                                        @ProviderUserFirstName varchar(25) output,
                                                        @ProviderUserLastName  varchar(25) output ) as

   /* Get the name of the provider user. */
   execute spGetMemberUserNameByMemberUserId @ProviderUserId,
                                             @ProviderUserFirstName output,
                                             @ProviderUserLastName  output

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetProviderUserTransactionsByInterfaceId' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetProviderUserTransactionsByInterfaceId

   go

create procedure spGetProviderUserTransactionsByInterfaceId ( @InterfaceId integer ) as

   select
   mu.member_user_id     as ProviderUserId,
   mu.member_user_fname  as FirstName,
   mu.member_user_lname  as LastName,
   address1.contact_info as Address1,
   address2.contact_info as Address2,
   address3.contact_info as Address3,
   city.contact_info     as City,
   state.contact_info    as State,
   zip.contact_info      as Zip,
   country.contact_info  as Country,
   phone.contact_info    as Phone,
   fax.contact_info      as Fax,
   mobile.contact_info   as Mobile,
   pager.contact_info    as Pager,
   email.contact_info    as Email,
   me.foreign_id         as ForeignId,
   me.foreign_type       as ForeignType
   from member_user mu
   left outer join vwContactCrosstab vw on mu.member_user_id = vw.entity_id and
                                           vw.entity_type_id = 1
   left outer join contact address1     on vw.Address1       = address1.contact_id
   left outer join contact address2     on vw.Address2       = address2.contact_id
   left outer join contact address3     on vw.Address3       = address3.contact_id
   left outer join contact city         on vw.City           = city.contact_id
   left outer join contact state        on vw.State          = state.contact_id
   left outer join contact zip          on vw.Zip            = zip.contact_id
   left outer join contact country      on vw.Country        = country.contact_id
   left outer join contact phone        on vw.Phone          = phone.contact_id
   left outer join contact fax          on vw.Fax            = fax.contact_id
   left outer join contact mobile       on vw.Mobile         = mobile.contact_id
   left outer join contact pager        on vw.Pager          = pager.contact_id
   left outer join contact email        on vw.Email          = email.contact_id

   inner join mapping_interface mi      on mi.interface_id   = @InterfaceId
   inner join TRANSACTION_LOG tl        on mi.INTERFACE_ID   = tl.INTERFACE_ID and
                                           mu.MEMBER_USER_ID = tl.ENTITY_ID and
                                           tl.ENTITY_TYPE_ID = 1
   left outer join MAPPING_ENTITY me    on tl.INTERFACE_ID   = me.INTERFACE_ID and
                                           tl.ENTITY_ID      = me.ENTITY_ID and
                                           tl.ENTITY_TYPE_ID = me.ENTITY_TYPE_ID

   where tl.TRANSMITTED = 0
   order by MEMBER_USER_ID, FOREIGN_ID

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetRouteTransactionsByInterfaceId' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetRouteTransactionsByInterfaceId

   go

create procedure spGetRouteTransactionsByInterfaceId ( @InterfaceId integer ) as
   select
   mg.MEMBER_GROUP_ID   as RouteId,
   mg.MEMBER_GROUP_NAME as RouteName,
   me.FOREIGN_ID        as ForeignId,
   me.FOREIGN_TYPE      as ForeignType
   from MEMBER_GROUP mg
   inner join MEMBER_GROUP_TYPE mgt  on mg.MEMBER_GROUP_TYPE_ID = mgt.MEMBER_GROUP_TYPE_ID

   inner join MAPPING_INTERFACE mi   on mi.INTERFACE_ID         = @InterfaceId
   inner join TRANSACTION_LOG tl     on mi.INTERFACE_ID         = tl.INTERFACE_ID and
                                        mg.MEMBER_GROUP_ID      = tl.ENTITY_ID and
                                        tl.ENTITY_TYPE_ID       = 16
   left outer join MAPPING_ENTITY me on tl.INTERFACE_ID         = me.INTERFACE_ID and
                                        tl.ENTITY_ID            = me.ENTITY_ID and
                                        tl.ENTITY_TYPE_ID       = me.ENTITY_TYPE_ID

   where mgt.MEMBER_GROUP_TYPE_NAME = 'Routes'
     and tl.TRANSMITTED             = 0
   order by mg.MEMBER_GROUP_ID, me.FOREIGN_ID

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetSecurityGroupsByType' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetSecurityGroupsByType

   go

create procedure spGetSecurityGroupsByType( @securitygrouptypeid integer ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   SELECT SECURITY_GROUP_ID,
          SECURITY_GROUP_NAME,
	  SECURITY_GROUP_DESC
   FROM SECURITY_GROUP
   WHERE SECURITY_GROUP_TYPE_ID = @securitygrouptypeid
   order by security_group_id desc

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 )  begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetServiceAmountTransactionsByInterfaceId' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetServiceAmountTransactionsByInterfaceId

   go

create procedure spGetServiceAmountTransactionsByInterfaceId ( @InterfaceId integer ) as

   select
   pcsf.provider_customer_service_financial_id     as ServiceAmountId,
   service_type.foreign_id                         as ServiceType,
   service_location.foreign_id                     as ServiceLocation,
   pcsf.provider_customer_service_amount           as ServiceAmount,
   me.foreign_id                                   as ForeignId,
   me.foreign_type                                 as ForeignType
   from provider_customer_service_financial pcsf
   inner join mapping_interface mi            on mi.interface_id                             = @InterfaceId
   inner join TRANSACTION_LOG tl              on mi.INTERFACE_ID                             = tl.INTERFACE_ID and
                                                 pcsf.PROVIDER_CUSTOMER_SERVICE_FINANCIAL_ID = tl.ENTITY_ID and
                                                 tl.ENTITY_TYPE_ID                           = 14
   left outer join MAPPING_ENTITY me          on tl.INTERFACE_ID                             = me.INTERFACE_ID and
                                                 tl.ENTITY_ID                                = me.ENTITY_ID and
                                                 tl.ENTITY_TYPE_ID                           = me.ENTITY_TYPE_ID
   inner join mapping_entity service_type     on mi.interface_id                             = service_type.interface_id and
                                                 pcsf.provider_service_type_id               = service_type.entity_id and
                                                 service_type.entity_type_id                 = 7
   inner join mapping_entity service_location on mi.interface_id                             = service_location.interface_id and
                                                 pcsf.customer_unit_id                       = service_location.entity_id and
                                                 service_location.entity_type_id             = 5
   where tl.TRANSMITTED = 0
   order by ServiceAmountId

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetServiceCountsByProvider' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetServiceCountsByProvider

   go

create procedure spGetServiceCountsByProvider( @ProviderID varchar(8000),
                                               @StartDate  varchar(10),
                                               @EndDate    varchar(10) ) as

   -- revision of spGetSingleWeekTotalServicesNo
   -- added ability to filter on single provider
   -- pass a -1 as ProviderID to get all providers
   -- jf 2/21/2005
   -- jf 3/04/2005 Make providerID a list, no -1 for all

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   select  MEMBER_NAME as COMPANY,
           mtype.MEMBER_TYPE_NAME,
           mu.MEMBER_USER_FNAME + ' ' + mu.MEMBER_USER_LNAME as EPM_USER,
           convert(varchar, LAST_LOGIN, 100) as LAST_LOGIN,
           SECURITY_GROUP_NAME,
           isNull(WEEKLY_TOTAL, 0) as WEEKLY_TOTAL,
           isNull(MONTH_TOTAL, 0) as MONTH_TOTAL,
           isNull(TECHNICIAN_TOTAL, 0) as TECHNICIAN_TOTAL,
           cast(@StartDate as DateTime) as START_DATE,
           cast(@EndDate as DateTime) as END_DATE,
           cast(MONTH(dateadd(m, -1, @StartDate)) as varchar) + '/' +
           cast(DAY(dateadd(m, -1, @StartDate)) as varchar) + ' - ' +
           cast(MONTH(dateadd(d, -1, @StartDate)) as varchar) + '/' +
           cast(DAY(dateadd(d, -1, @StartDate)) as varchar) as MONTH_RANGE,
           MEMBER_USER_DATE

   from    MEMBER_USER mu
           inner join fnStringListToIntegerTable( @ProviderID ) Providers on mu.Member_ID = Providers.IntegerID
           inner join MEMBER m on m.MEMBER_ID = mu.MEMBER_ID
           inner join MEMBER_TYPE mtype on m.MEMBER_TYPE_ID = mtype.MEMBER_TYPE_ID
           inner join JOIN_MEMBER_USER_SECURITY_GROUP jmusg on jmusg.MEMBER_USER_ID = mu.MEMBER_USER_ID
           inner join SECURITY_GROUP sg on sg.SECURITY_GROUP_ID = jmusg.SECURITY_GROUP_ID

           left outer join ( select TECHNICIAN_ID, count(*) as WEEKLY_TOTAL
                             from COM_SERVICE cs
                             where PROVIDER_INPUT_DATE between @StartDate and @EndDate
                             group by TECHNICIAN_ID) w on w.TECHNICIAN_ID = mu.MEMBER_USER_ID

           left outer join ( select TECHNICIAN_ID, count(*) as MONTH_TOTAL
                             from COM_SERVICE cs
                             where PROVIDER_INPUT_DATE < @StartDate
                                   and PROVIDER_INPUT_DATE >= dateadd(m, -1, @StartDate)
                             group by TECHNICIAN_ID) mt on mt.TECHNICIAN_ID = mu.MEMBER_USER_ID

           left outer join ( select TECHNICIAN_ID, count(*) as TECHNICIAN_TOTAL
                             from COM_SERVICE cs
                             group by TECHNICIAN_ID) tt on tt.TECHNICIAN_ID = mu.MEMBER_USER_ID

           left outer join ( select MEMBER_USER_ID, max(convert(datetime, MEMBER_USER_LAST_LOGIN, 100)) as LAST_LOGIN
                             from MEMBER_USER
                             group by MEMBER_USER_ID) mdt on mdt.MEMBER_USER_ID = mu.MEMBER_USER_ID

           left outer join ( select MEMBER_ID, convert(varchar, MEMBER_USER_AGREEMENT_DATETIME, 101) as MEMBER_USER_DATE
                             from MEMBER_USER_AGREEMENT, MEMBER_USER
                             where MEMBER_USER_AGREEMENT.MEMBER_USER_ID = MEMBER_USER.MEMBER_USER_ID ) mua on mua.MEMBER_ID = m.MEMBER_ID

   order by COMPANY, EPM_USER

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetServiceDataBarcodesForTechFieldGuideReport' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetServiceDataBarcodesForTechFieldGuideReport

   go

create procedure spGetServiceDataBarcodesForTechFieldGuideReport( @BarCodeId varchar(1000) ) as

   declare @SQLString nvarchar(2500) /* Dynamic query string to execute to retrieve the barcodes */
   declare @Condition nvarchar(1000) /* Filter condition for the dynamic query string            */

   declare @ReturnCode   integer /* Result code returned by the execution of the stored procedure */

   /* Trim any leading and trailing spaces from the barcode identifier set. */
   set @BarCodeId = LTrim( RTrim( @BarCodeId ) );
   set @Condition = @BarCodeId;

   /* Assemble the dynamic query string to execute to retrieve the barcodes. */
   set @SQLString =
      N'select fv.PROVIDER_SERVICE_DATA_ID,
               PROVIDER_SERVICE_DATA = IsNull( fv.PROVIDER_SERVICE_DATA, tfv.PROVIDER_SERVICE_DATA ),
               BARCODE_ID            = IsNull( fv.BARCODE_ID,            tfv.BARCODE_ID            ),
               cf.PROVIDER_SERVICE_DATA_TYPE_ID,
               PROVIDER_SERVICE_DATA_TYPE_TEXT = IsNull( cf.PROVIDER_SERVICE_DATA_TYPE_TEXT, tcf.PROVIDER_SERVICE_DATA_TYPE_TEXT ),
               sc.PROVIDER_SERVICE_CATEGORY_ID,
               PROVIDER_SERVICE_CATEGORY = IsNull( sc.PROVIDER_SERVICE_CATEGORY, tsc.PROVIDER_SERVICE_CATEGORY )
        from PROVIDER_SERVICE_DATA fv
             left outer join TEMPLATE_PROVIDER_SERVICE_DATA      tfv on fv.TEMPLATE_PROVIDER_SERVICE_DATA_ID      = tfv.PROVIDER_SERVICE_DATA_ID
             inner join      PROVIDER_SERVICE_DATA_TYPE          cf  on fv.PROVIDER_SERVICE_DATA_TYPE_ID          = cf.PROVIDER_SERVICE_DATA_TYPE_ID
             left outer join TEMPLATE_PROVIDER_SERVICE_DATA_TYPE tcf on cf.TEMPLATE_PROVIDER_SERVICE_DATA_TYPE_ID = tcf.PROVIDER_SERVICE_DATA_TYPE_ID
             inner join      PROVIDER_SERVICE_CATEGORY           sc  on cf.PROVIDER_SERVICE_CATEGORY_ID           = sc.PROVIDER_SERVICE_CATEGORY_ID
             left outer join TEMPLATE_PROVIDER_SERVICE_CATEGORY  tsc on sc.TEMPLATE_PROVIDER_SERVICE_CATEGORY_ID  = tsc.PROVIDER_SERVICE_CATEGORY_ID
        where fv.PROVIDER_SERVICE_DATA_ID in (' + @Condition + N')'

   /* Execute the query to return the result set for the report. */
   execute @ReturnCode = sp_ExecuteSql @SQLString

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetServiceDetailsByCustomerCategoryDateRange' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetServiceDetailsByCustomerCategoryDateRange

   go

create procedure spGetServiceDetailsByCustomerCategoryDateRange( @CustomerId integer,
                                                                 @CategoryId integer,
                                                                 @StartDate  datetime,
                                                                 @EndDate    datetime ) as

   declare @sqlselect nvarchar( 4000 )
   declare @sqlfrom   nvarchar( 4000 )
   declare @tabtable  nvarchar( 4000 )
   declare @tabinsert nvarchar( 4000 )
   declare @tabselect nvarchar( 4000 )
   declare @tabfrom   nvarchar( 4000 )
   declare @tabwhere  nvarchar( 4000 )
   declare @tabgroup  nvarchar( 4000 )
   declare @tmpsql    nvarchar( 4000 )

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   set nocount on

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   set @tabtable = char(13) + 'declare @tab table ( SERVICE_DETAIL_ID integer, SERVICE_ID integer, CATEGORY_ID integer, CUSTOMER_UNIT_ID integer, PROVIDER_SERVICE_VALUE_ID integer, ROW_ID integer '

   set @tabinsert = char(13) + 'insert into @tab  ( SERVICE_DETAIL_ID, SERVICE_ID, CATEGORY_ID, CUSTOMER_UNIT_ID, PROVIDER_SERVICE_VALUE_ID, ROW_ID '

   set @tabselect = char(13) + 'select csuv.com_service_unit_value_id, cs.com_service_id, psdt.provider_service_category_id, csuv.customer_unit_id, csuv.provider_service_value_id, csd.row_id '

   set @tabfrom =  char(13)+ 'from com_service_unit_value csuv '
   set @tabfrom = @tabfrom + char(13) + 'inner join com_service cs                        on csuv.com_service_id                = cs.com_service_id '
   set @tabfrom = @tabfrom + char(13) + 'left outer join com_service_data csd                   on csuv.com_service_unit_value_id     = csd.com_service_unit_value_id '
   set @tabfrom = @tabfrom + char(13) + 'inner join provider_service_data_type psdt         on csd.provider_service_data_type_id = psdt.provider_service_data_type_id '
   set @tabfrom = @tabfrom + char(13) + 'inner join customer_unit cu on cs.customer_unit_id  = cu.customer_unit_id '

   set @tabwhere = char(13) + 'where psdt.provider_service_category_id  = ' + cast(@CategoryId  as varchar(10)) + ''
   set @tabwhere = @tabwhere + char(13) + '  and cs.com_service_date >= ''' + convert(varchar(10), @StartDate, 01) + ''''
   set @tabwhere = @tabwhere + char(13) + '  and cs.com_service_date <= ''' + convert(varchar(10), @EndDate, 01) + ''''
   set @tabwhere = @tabwhere + char(13) + '  and cu.customer_id = ' + cast(@CustomerId  as varchar(10)) + ''

   set @tabgroup = char(13) + 'group by csuv.com_service_unit_value_id, cs.com_service_id, psdt.provider_service_category_id, csd.row_id, csuv.customer_unit_id, csuv.provider_service_value_id'
   set @tabgroup = @tabgroup + char(13) + 'order by csuv.com_service_unit_value_id, cs.com_service_id, psdt.provider_service_category_id, csd.row_id, csuv.customer_unit_id, csuv.provider_service_value_id'

   set @sqlselect = char(13) + 'select a.service_detail_id, a.service_id, ISNULL(psc.provider_service_category, tpsc.provider_service_category) as CATEGORY_NAME, a.customer_unit_id, a.provider_service_value_id, a.ROW_ID  '

   set @sqlfrom = char(13) + 'from @tab a'
   set @sqlfrom = @sqlfrom + char(13) + 'inner join provider_service_category psc on a.category_id  = psc.provider_service_category_id '
   set @sqlfrom = @sqlfrom + char(13) + 'left outer join template_provider_service_category tpsc on psc.template_provider_service_category_id  = tpsc.provider_service_category_id '

   declare @datatypeid   integer
   declare @datatype     varchar(50)

   declare data_type_cursor cursor for
   select psdt.provider_service_data_type_id, isnull(psdt.provider_service_data_type_text, tpsdt.provider_service_data_type_text) as provider_service_data_type_text
   from provider_service_data_type psdt
   left outer join template_provider_service_data_type tpsdt on psdt.template_provider_service_data_type_id = tpsdt.provider_service_data_type_id
   where provider_service_category_id = @CategoryId
   order by psdt.sort_order, tpsdt.sort_order

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   open data_type_cursor

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   fetch next from data_type_cursor into
   @datatypeid,
   @datatype

   while ( @@fetch_status = 0 ) begin

      select @DataType = replace(@DataType, ',', '' )
      select @DataType = replace(@DataType, ' ', '_')

      if exists ( select name from tempdb..sysobjects where name like '#tmp2%' ) begin
         set @tmpsql = 'ALTER TABLE #tmp2 ADD ' + @datatype + ' varchar(255) NULL'
         exec(@tmpsql)

         /* Get the error code for the previous statement.
         Error checking MUST be done this way since any single statement executed
         will affect both of the global functions,  @@Error. */
         select @ErrorCode = @@Error

         /* If there was an error... */
         if ( @ErrorCode <> 00 ) begin

            /* Rollback the transaction. */
            rollback transaction

            /* Return the failure. */
            return 01

         end

      end

      set @tabtable = @tabtable + ',' + char(13) + @datatype + ' varchar(255) NULL' + char(13)
      set @tabinsert = @tabinsert + ',' + char(13) + @datatype
      set @tabselect = @tabselect + ',' + char(13) + 'sum(case psdt.provider_service_data_type_id when ' + cast(@datatypeid as varchar(10)) + ' then csd.com_service_data_id else NULL end) as ' + @datatype

      set @sqlselect = @sqlselect + ',' + char(13) + 'dt' + cast(@datatypeid as varchar(10)) + '.com_service_data_alt_text as ' + @datatype
      set @sqlfrom = @sqlfrom + char(13) + 'left outer join com_service_data dt' + cast(@datatypeid as varchar(10)) + ' on a.' + @datatype + '= dt' + cast(@datatypeid as varchar(10)) + '.com_service_data_id'

   fetch next from data_type_cursor into
   @datatypeid,
   @datatype

   end

   close data_type_cursor
   deallocate data_type_cursor

   set @tabtable = @tabtable   + ') ' + char(13)
   set @tabinsert = @tabinsert + ') ' + char(13)

   if exists ( select name from tempdb..sysobjects where name like '#tmp2%' ) begin
     insert into #tmp2 exec( @tabTable + @tabInsert + @tabSelect + @tabFrom + @tabwhere + @tabgroup + @sqlSelect + @sqlFrom )
   end
   else begin
     exec( @tabTable + @tabInsert + @tabSelect + @tabFrom + @tabwhere + @tabgroup + @sqlSelect + @sqlFrom )
   end

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

    /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetServiceDetailsByGroupCategoryDateRange' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetServiceDetailsByGroupCategoryDateRange

   go

create procedure spGetServiceDetailsByGroupCategoryDateRange( @GroupId    integer,
                                                              @CategoryId integer,
                                                              @StartDate  datetime,
                                                              @EndDate    datetime ) as

   set nocount on

   declare @sqlselect nvarchar( 4000 )
   declare @sqlfrom   nvarchar( 4000 )
   declare @tabtable  nvarchar( 4000 )
   declare @tabinsert nvarchar( 4000 )
   declare @tabselect nvarchar( 4000 )
   declare @tabfrom   nvarchar( 4000 )
   declare @tabwhere  nvarchar( 4000 )
   declare @tabgroup  nvarchar( 4000 )
   declare @tmpsql    nvarchar( 4000 )

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

    /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   set @tabtable = char(13) + 'declare @tab table ( SERVICE_DETAIL_ID integer, SERVICE_ID integer, CATEGORY_ID integer, CUSTOMER_UNIT_ID integer, PROVIDER_SERVICE_VALUE_ID integer, ROW_ID integer '

   set @tabinsert = char(13) + 'insert into @tab  ( SERVICE_DETAIL_ID, SERVICE_ID, CATEGORY_ID, CUSTOMER_UNIT_ID, PROVIDER_SERVICE_VALUE_ID, ROW_ID '

   set @tabselect = char(13) + 'select csuv.com_service_unit_value_id, cs.com_service_id, psdt.provider_service_category_id, csuv.customer_unit_id, csuv.provider_service_value_id, csd.row_id '

   set @tabfrom =  char(13)+ 'from com_service_unit_value csuv '
   set @tabfrom = @tabfrom + char(13) + 'inner join com_service cs                        on csuv.com_service_id                = cs.com_service_id '
   set @tabfrom = @tabfrom + char(13) + 'left outer join com_service_data csd                   on csuv.com_service_unit_value_id     = csd.com_service_unit_value_id '
   set @tabfrom = @tabfrom + char(13) + 'inner join provider_service_data_type psdt         on csd.provider_service_data_type_id = psdt.provider_service_data_type_id '
   set @tabfrom = @tabfrom + char(13) + 'inner join customer_unit cu on cs.customer_unit_id  = cu.customer_unit_id '
   set @tabfrom = @tabfrom + char(13) + 'inner join join_member_group_customer_unit jmgcu on cs.customer_unit_id = jmgcu.customer_unit_id '

   set @tabwhere = char(13) + 'where psdt.provider_service_category_id  = ' + cast(@CategoryId  as varchar(10)) + ''
   set @tabwhere = @tabwhere + char(13) + '  and cs.com_service_date >= ''' + convert(varchar(10), @StartDate, 01) + ''''
   set @tabwhere = @tabwhere + char(13) + '  and cs.com_service_date <= ''' + convert(varchar(10), @EndDate, 01) + ''''
   set @tabwhere = @tabwhere + char(13) + '  and jmgcu.member_group_id = ' + cast(@GroupId  as varchar(10)) + ''

   set @tabgroup = char(13) + 'group by csuv.com_service_unit_value_id, cs.com_service_id, psdt.provider_service_category_id, csd.row_id, csuv.customer_unit_id, csuv.provider_service_value_id'
   set @tabgroup = @tabgroup + char(13) + 'order by csuv.com_service_unit_value_id, cs.com_service_id, psdt.provider_service_category_id, csd.row_id, csuv.customer_unit_id, csuv.provider_service_value_id'

   set @sqlselect = char(13) + 'select a.service_detail_id, a.service_id, ISNULL(psc.provider_service_category, tpsc.provider_service_category) as CATEGORY_NAME, a.customer_unit_id, a.provider_service_value_id, a.ROW_ID  '

   set @sqlfrom = char(13) + 'from @tab a'
   set @sqlfrom = @sqlfrom + char(13) + 'inner join provider_service_category psc on a.category_id  = psc.provider_service_category_id '
   set @sqlfrom = @sqlfrom + char(13) + 'left outer join template_provider_service_category tpsc on psc.template_provider_service_category_id  = tpsc.provider_service_category_id '

   declare @datatypeid   integer
   declare @datatype     varchar(50)

   declare data_type_cursor cursor for
   select psdt.provider_service_data_type_id, isnull(psdt.provider_service_data_type_text, tpsdt.provider_service_data_type_text) as provider_service_data_type_text
   from provider_service_data_type psdt
   left outer join template_provider_service_data_type tpsdt on psdt.template_provider_service_data_type_id = tpsdt.provider_service_data_type_id
   where provider_service_category_id = @CategoryId
   order by psdt.sort_order, tpsdt.sort_order

    /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   open data_type_cursor

    /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   fetch next from data_type_cursor into
   @datatypeid,
   @datatype

   while ( @@fetch_status = 0 ) begin

      select @DataType = replace(@DataType, ',', '' )
      select @DataType = replace(@DataType, ' ', '_')

      if exists ( select name from tempdb..sysobjects where name like '#tmp2%' ) begin
         set @tmpsql = 'ALTER TABLE #tmp2 ADD ' + @datatype + ' varchar(255) NULL'
         exec(@tmpsql)

          /* Get the error code for the previous statement.
          Error checking MUST be done this way since any single statement executed
          will affect both of the global functions,  @@Error. */
          select @ErrorCode = @@Error

          /* If there was an error... */
          if ( @ErrorCode <> 00 ) begin

             /* Rollback the transaction. */
             rollback transaction

             /* Return the failure. */
            return 01

          end
      end

      set @tabtable = @tabtable + ',' + char(13) + @datatype + ' varchar(255) NULL' + char(13)
      set @tabinsert = @tabinsert + ',' + char(13) + @datatype
      set @tabselect = @tabselect + ',' + char(13) + 'sum(case psdt.provider_service_data_type_id when ' + cast(@datatypeid as varchar(10)) + ' then csd.com_service_data_id else NULL end) as ' + @datatype

      set @sqlselect = @sqlselect + ',' + char(13) + 'dt' + cast(@datatypeid as varchar(10)) + '.com_service_data_alt_text as ' + @datatype
      set @sqlfrom = @sqlfrom + char(13) + 'left outer join com_service_data dt' + cast(@datatypeid as varchar(10)) + ' on a.' + @datatype + '= dt' + cast(@datatypeid as varchar(10)) + '.com_service_data_id'

   fetch next from data_type_cursor into
   @datatypeid,
   @datatype

   end

   close data_type_cursor
   deallocate data_type_cursor

   set @tabtable = @tabtable   + ') ' + char(13)
   set @tabinsert = @tabinsert + ') ' + char(13)

   if exists ( select name from tempdb..sysobjects where name like '#tmp2%' ) begin
     insert into #tmp2 exec( @tabTable + @tabInsert + @tabSelect + @tabFrom + @tabwhere + @tabgroup + @sqlSelect + @sqlFrom )
   end
   else begin
     exec( @tabTable + @tabInsert + @tabSelect + @tabFrom + @tabwhere + @tabgroup + @sqlSelect + @sqlFrom )
   end

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetServiceDetailsByTechnicianCategoryDateRange' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetServiceDetailsByTechnicianCategoryDateRange

   go

create procedure spGetServiceDetailsByTechnicianCategoryDateRange( @TechnicianId integer,
                                                                    @CategoryId  integer,
                                                                    @StartDate   datetime,
                                                                    @EndDate     datetime ) as

   set nocount on

   declare @sqlselect nvarchar( 4000 )
   declare @sqlfrom   nvarchar( 4000 )
   declare @tabtable  nvarchar( 4000 )
   declare @tabinsert nvarchar( 4000 )
   declare @tabselect nvarchar( 4000 )
   declare @tabfrom   nvarchar( 4000 )
   declare @tabwhere  nvarchar( 4000 )
   declare @tabgroup  nvarchar( 4000 )
   declare @tmpsql    nvarchar( 4000 )

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   set @tabtable = char(13) + 'declare @tab table ( SERVICE_DETAIL_ID integer, SERVICE_ID integer, CATEGORY_ID integer, CUSTOMER_UNIT_ID integer, PROVIDER_SERVICE_VALUE_ID integer, ROW_ID integer '

   set @tabinsert = char(13) + 'insert into @tab  ( SERVICE_DETAIL_ID, SERVICE_ID, CATEGORY_ID, CUSTOMER_UNIT_ID, PROVIDER_SERVICE_VALUE_ID, ROW_ID '

   set @tabselect = char(13) + 'select csuv.com_service_unit_value_id, cs.com_service_id, psdt.provider_service_category_id, csuv.customer_unit_id, csuv.provider_service_value_id, csd.row_id '

   set @tabfrom =  char(13)+ 'from com_service_unit_value csuv '
   set @tabfrom = @tabfrom + char(13) + 'inner join com_service cs                        on csuv.com_service_id                = cs.com_service_id '
   set @tabfrom = @tabfrom + char(13) + 'left outer join com_service_data csd                   on csuv.com_service_unit_value_id     = csd.com_service_unit_value_id '
   set @tabfrom = @tabfrom + char(13) + 'inner join provider_service_data_type psdt         on csd.provider_service_data_type_id = psdt.provider_service_data_type_id '
   set @tabfrom = @tabfrom + char(13) + 'inner join customer_unit cu on cs.customer_unit_id  = cu.customer_unit_id '

   set @tabwhere = char(13) + 'where psdt.provider_service_category_id  = ' + cast(@CategoryId  as varchar(10)) + ''
   set @tabwhere = @tabwhere + char(13) + '  and cs.com_service_date >= ''' + convert(varchar(10), @StartDate, 01) + ''''
   set @tabwhere = @tabwhere + char(13) + '  and cs.com_service_date <= ''' + convert(varchar(10), @EndDate, 01) + ''''
   set @tabwhere = @tabwhere + char(13) + '  and cs.technician_id = ' + cast(@TechnicianId  as varchar(10)) + ''

   set @tabgroup = char(13) + 'group by csuv.com_service_unit_value_id, cs.com_service_id, psdt.provider_service_category_id, csd.row_id, csuv.customer_unit_id, csuv.provider_service_value_id'
   set @tabgroup = @tabgroup + char(13) + 'order by csuv.com_service_unit_value_id, cs.com_service_id, psdt.provider_service_category_id, csd.row_id, csuv.customer_unit_id, csuv.provider_service_value_id'

   set @sqlselect = char(13) + 'select a.service_detail_id, a.service_id, ISNULL(psc.provider_service_category, tpsc.provider_service_category) as CATEGORY_NAME, a.customer_unit_id, a.provider_service_value_id, a.ROW_ID  '

   set @sqlfrom = char(13) + 'from @tab a'
   set @sqlfrom = @sqlfrom + char(13) + 'inner join provider_service_category psc on a.category_id  = psc.provider_service_category_id '
   set @sqlfrom = @sqlfrom + char(13) + 'left outer join template_provider_service_category tpsc on psc.template_provider_service_category_id  = tpsc.provider_service_category_id '

   declare @datatypeid   integer
   declare @datatype     varchar(50)

   declare data_type_cursor cursor for
   select psdt.provider_service_data_type_id, isnull(psdt.provider_service_data_type_text, tpsdt.provider_service_data_type_text) as provider_service_data_type_text
   from provider_service_data_type psdt
   left outer join template_provider_service_data_type tpsdt on psdt.template_provider_service_data_type_id = tpsdt.provider_service_data_type_id
   where provider_service_category_id = @CategoryId
   order by psdt.sort_order, tpsdt.sort_order

    /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   open data_type_cursor

    /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   fetch next from data_type_cursor into
   @datatypeid,
   @datatype

   while ( @@fetch_status = 0 ) begin

      select @DataType = replace(@DataType, ',', '' )
      select @DataType = replace(@DataType, ' ', '_')

      if exists ( select name from tempdb..sysobjects where name like '#tmp2%' ) begin
         set @tmpsql = 'ALTER TABLE #tmp2 ADD ' + @datatype + ' varchar(255) NULL'
         exec(@tmpsql)

          /* Get the error code for the previous statement.
          Error checking MUST be done this way since any single statement executed
          will affect both of the global functions,  @@Error. */
          select @ErrorCode = @@Error

          /* If there was an error... */
          if ( @ErrorCode <> 00 ) begin

             /* Rollback the transaction. */
             rollback transaction

             /* Return the failure. */
             return 01

          end

      end

      set @tabtable = @tabtable + ',' + char(13) + @datatype + ' varchar(255) NULL' + char(13)
      set @tabinsert = @tabinsert + ',' + char(13) + @datatype
      set @tabselect = @tabselect + ',' + char(13) + 'sum(case psdt.provider_service_data_type_id when ' + cast(@datatypeid as varchar(10)) + ' then csd.com_service_data_id else NULL end) as ' + @datatype

      set @sqlselect = @sqlselect + ',' + char(13) + 'dt' + cast(@datatypeid as varchar(10)) + '.com_service_data_alt_text as ' + @datatype
      set @sqlfrom = @sqlfrom + char(13) + 'left outer join com_service_data dt' + cast(@datatypeid as varchar(10)) + ' on a.' + @datatype + '= dt' + cast(@datatypeid as varchar(10)) + '.com_service_data_id'

   fetch next from data_type_cursor into
   @datatypeid,
   @datatype

   end

   close data_type_cursor
   deallocate data_type_cursor

   set @tabtable = @tabtable   + ') ' + char(13)
   set @tabinsert = @tabinsert + ') ' + char(13)

   if exists ( select name from tempdb..sysobjects where name like '#tmp2%' ) begin
     insert into #tmp2 exec( @tabTable + @tabInsert + @tabSelect + @tabFrom + @tabwhere + @tabgroup + @sqlSelect + @sqlFrom )
   end
   else begin
     exec( @tabTable + @tabInsert + @tabSelect + @tabFrom + @tabwhere + @tabgroup + @sqlSelect + @sqlFrom )
   end

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetServiceDetailTransactionsByInterfaceId' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetServiceDetailTransactionsByInterfaceId

   go

create procedure spGetServiceDetailTransactionsByInterfaceId ( @InterfaceId integer ,
                                                               @CategoryId  integer ) as

   declare @tablesql  nvarchar ( 4000 )
   declare @sqlselect nvarchar ( 4000 )
   declare @sqlselectfields nvarchar ( 4000 )
   declare @sqlfrom   nvarchar ( 4000 )
   declare @sqlwhere  nvarchar ( 4000 )
   declare @tab       nvarchar ( 4000 )
   declare @foreigncategory varchar(50)

   select @foreigncategory = foreign_id
   from mapping_entity
   where interface_id = @InterfaceId
   and entity_id = @CategoryId
   and entity_type_id = 8

   /* Generate temp table to store data as it selected into crosstab */
   set @tablesql = 'declare @tmp table ( '
   set @tablesql = @tablesql + 'SERVICE_DETAIL_ID integer, '
   set @tablesql = @tablesql + 'SERVICE_ID varchar(50), '
   set @tablesql = @tablesql + 'ROW_ID integer'

   /* Start of crosstab query to get ServiceDetailData */
   set @tab = 'insert into @tmp '
   set @tab = @tab + 'select b.com_service_unit_value_id as SERVICE_DETAIL_ID, '
   set @tab = @tab + 'd.work_order_number as SERVICE_ID, '
   set @tab = @tab + 'b.row_id as ROW_ID'

   /* Start of select from #TMP table */
   set @sqlselect = 'select a.SERVICE_DETAIL_ID as ServiceDetailId, '
   set @sqlselect = @sqlselect + 'a.SERVICE_ID as ServiceId, '
   set @sqlselect = @sqlselect + 'a.ROW_ID as RowId, '

   /* Start of FROM clause of select from #tmp table */
   set @sqlfrom = char(13) + 'from @tmp a '
   set @sqlfrom = @sqlfrom + char(13) + 'inner join com_service_unit_value csuv on a.SERVICE_DETAIL_ID = csuv.com_service_unit_value_id'
   set @sqlfrom = @sqlfrom + char(13) + 'inner join com_service cs on csuv.com_service_id = cs.com_service_id'
   set @sqlfrom = @sqlfrom + char(13) + 'inner join provider_service_type pst on cs.provider_service_type_id = pst.provider_service_type_id'
   set @sqlfrom = @sqlfrom + char(13) + 'inner join mapping_entity service_type on pst.provider_service_type_id = service_type.entity_id and service_type.entity_type_id = 7'
   set @sqlfrom = @sqlfrom + char(13) + 'inner join mapping_entity service on a.service_id = service.entity_id and service.entity_type_id = 12'
   set @sqlfrom = @sqlfrom + char(13) + 'left outer join mapping_entity service_detail on a.SERVICE_DETAIL_ID = service_detail.entity_id and service_detail.entity_type_id = 13'

   declare @datatypeid   integer
   declare @foreignid    varchar ( 50 )
   declare @foreigntype  varchar ( 50 )

   /* Cursor to iterate over mapped data types */
   declare data_type_cursor cursor for
   select provider_service_data_type_id, foreign_id
   from provider_service_data_type a
   left join mapping_entity b on a.provider_service_data_type_id = b.entity_id
   where entity_type_id = 9 and b.interface_id = @interfaceid and a.provider_service_category_id = @CategoryId
   order by sort_order

   open data_type_cursor

   fetch next from data_type_cursor into
   @datatypeid,
   @foreignid

   while ( @@fetch_status = 0 ) begin

      set @tablesql = @tablesql + ', ' + @foreignid + ' varchar(255) NULL'

      set @tab = @tab + ', ' + 'sum(case c.provider_service_data_type_id when ' + cast(@datatypeid as varchar(10)) + ' then b.com_service_data_id else NULL end) as ' + @foreignid

      set @sqlfrom = @sqlfrom + char(13) + 'left outer join com_service_data dt' + cast(@datatypeid as varchar(10)) + ' on a.' + @foreignid + '= dt' + cast(@datatypeid as varchar(10)) + '.com_service_data_id'

      if exists ( select *
                  from mapping_entity a, provider_service_data b
                  where a.entity_id = b.provider_service_data_id and
		        a.entity_type_id = 10 and
                        b.provider_service_data_type_id = @datatypeid )
      begin

         select @foreigntype = a.foreign_type
         from mapping_entity a, provider_service_data b
         where a.entity_id = b.provider_service_data_id and
	       a.entity_type_id = 10 and
               b.provider_service_data_type_id = @datatypeid

         if @sqlselectfields is not null set @sqlselectfields = @sqlselectfields + '+'';' + @foreigntype + '=''+isnull(map' + cast(@datatypeid as varchar(10)) + '.foreign_id,'''')'
         else set @sqlselectfields = '''' + @foreigntype + '=''+isnull(map' + cast(@datatypeid as varchar(10)) + '.foreign_id,'''')'

         set @sqlfrom = @sqlfrom + char(13) + 'left outer join mapping_entity map'  + cast(@datatypeid as varchar(10)) + ' on dt' + cast(@datatypeid as varchar(10)) + '.provider_service_data_id = map' + cast(@datatypeid as varchar(10)) + '.entity_id and map' + cast(@datatypeid as varchar(10)) + '.entity_type_id = 10'

         if @sqlwhere is not null begin
            set @sqlwhere = @sqlwhere + char(13) + 'and '
         end
         else begin
            set @sqlwhere = char(13) + 'where '
         end

         set @sqlwhere = @sqlwhere + ' map' + cast(@datatypeid as varchar(10)) + '.foreign_id is not null '

      end

      if @foreigntype <> @foreignid
         set @sqlselectfields = @sqlselectfields + '+'';' + @foreignid + '=''+isnull(dt' + cast(@datatypeid as varchar(10)) + '.com_service_data_alt_text,'''')'

      fetch next from data_type_cursor into
      @datatypeid,
      @foreignid

   end

   close data_type_cursor
   deallocate data_type_cursor

   set @tablesql = @tablesql + ' ) '

   set @tab = @tab  + char(13) + 'from com_service_unit_value a '
   set @tab = @tab  + 'left outer join com_service_data b on a.com_service_unit_value_id = b.com_service_unit_value_id '
   set @tab = @tab  + 'left outer join provider_service_data_type c on b.provider_service_data_type_id = c.provider_service_data_type_id '
   set @tab = @tab  + 'left outer join provider_customer_service_schedule d on a.com_service_id = d.com_service_id '
   set @tab = @tab  + 'inner join mapping_interface h on h.interface_id = ' + cast(@InterfaceId as varchar(10)) + ' '
   set @tab = @tab  + 'inner join transaction_log i on h.interface_id = i.interface_id '
   set @tab = @tab  + 'and a.COM_SERVICE_UNIT_VALUE_ID = i.entity_id '
   set @tab = @tab  + 'and i.entity_type_id = 13 '
   set @tab = @tab  + 'where c.provider_service_category_id  = ' + cast(@CategoryId  as varchar(10)) + ' '
   set @tab = @tab  + 'and i.TRANSMITTED = 0 '
   set @tab = @tab  + 'group by d.work_order_number, b.com_service_unit_value_id, b.row_id '
   set @tab = @tab  + 'order by d.work_order_number, b.com_service_unit_value_id, b.row_id '

   set @sqlselect = @sqlselect + CASE WHEN @sqlSelectfields is null then '' else @sqlSelectfields + 'as DetailData, ' end
   set @sqlselect = @sqlselect + 'service_detail.foreign_id as ForeignId, service_type.foreign_type + ''' + @foreigncategory + ''' as ForeignType'

   exec( @tablesql + @tab + @sqlselect + @sqlfrom + @sqlwhere + ' order by ServiceDetailId, RowId, DetailData' )

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetServiceLocationTransactionsByInterfaceId' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetServiceLocationTransactionsByInterfaceId

   go

create procedure spGetServiceLocationTransactionsByInterfaceId ( @InterfaceId integer ) as

   select
   cu.customer_unit_id   as ServiceLocationId,
   cu.customer_unit_name as ServiceLocationName,
   address1.contact_info as Address1,
   address2.contact_info as Address2,
   address3.contact_info as Address3,
   city.contact_info     as City,
   state.contact_info    as State,
   zip.contact_info      as Zip,
   country.contact_info  as Country,
   phone.contact_info    as Phone,
   fax.contact_info      as Fax,
   mobile.contact_info   as Mobile,
   pager.contact_info    as Pager,
   email.contact_info    as Email,
   me.foreign_id         as ForeignId,
   me.foreign_type       as ForeignType
   from customer_unit cu
   left outer join vwContactCrosstab vw on cu.customer_unit_id = vw.entity_id and
                                           vw.entity_type_id   = 5
   left outer join contact address1     on vw.Address1         = address1.contact_id
   left outer join contact address2     on vw.Address2         = address2.contact_id
   left outer join contact address3     on vw.Address3         = address3.contact_id
   left outer join contact city         on vw.City             = city.contact_id
   left outer join contact state        on vw.State            = state.contact_id
   left outer join contact zip          on vw.Zip              = zip.contact_id
   left outer join contact country      on vw.Country          = country.contact_id
   left outer join contact phone        on vw.Phone            = phone.contact_id
   left outer join contact fax          on vw.Fax              = fax.contact_id
   left outer join contact mobile       on vw.Mobile           = mobile.contact_id
   left outer join contact pager        on vw.Pager            = pager.contact_id
   left outer join contact email        on vw.Email            = email.contact_id

   inner join mapping_interface mi      on mi.interface_id     = @InterfaceId
   inner join TRANSACTION_LOG tl        on mi.INTERFACE_ID     = tl.INTERFACE_ID and
                                           cu.customer_unit_id = tl.ENTITY_ID and
                                           tl.ENTITY_TYPE_ID   = 5
   left outer join MAPPING_ENTITY me    on tl.INTERFACE_ID     = me.INTERFACE_ID and
                                           tl.ENTITY_ID        = me.ENTITY_ID and
                                           tl.ENTITY_TYPE_ID   = me.ENTITY_TYPE_ID

   where tl.TRANSMITTED = 0
   order by CU.CUSTOMER_UNIT_ID, ME.FOREIGN_ID

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetServicesByCustomerCategoryDateRange' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetServicesByCustomerCategoryDateRange

   go

create procedure spGetServicesByCustomerCategoryDateRange( @CustomerId integer,
                                                           @CategoryId integer,
                                                           @StartDate  datetime,
                                                           @EndDate    datetime ) as

   set nocount on

   declare @sqlselect nvarchar( 4000 )
   declare @sqlfrom   nvarchar( 4000 )
   declare @tab       nvarchar( 4000 )
   declare @tmpsql    nvarchar( 4000 )

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   create table #tmp ( SERVICE_DETAIL_ID integer,
                       CATEGORY_NAME     varchar(50),
                       ROW_ID            integer )

   create table #tmp2 ( SERVICE_DETAIL_ID integer,
                        CATEGORY_NAME     varchar(50),
                        ROW_ID            integer )

   set @tab = 'select        csuv.com_service_unit_value_id as service_detail_id,
              isnull( psc.provider_service_category, tpsc.provider_service_category) as category_name,
              csd.row_id'

   set @sqlselect = 'select csuv.com_service_unit_value_id, CATEGORY_NAME, a.ROW_ID'

   set @sqlfrom = char(13) + 'from #tmp a'
   set @sqlfrom = @sqlfrom + char(13) + 'inner join com_service_unit_value csuv on a.SERVICE_DETAIL_ID = csuv.com_service_unit_value_id'
   set @sqlfrom = @sqlfrom + char(13) + 'left outer join com_service cs on csuv.com_service_id = cs.com_service_id'
   set @sqlfrom = @sqlfrom + char(13) + 'left outer join provider_service_type pst on cs.provider_service_type_id = pst.provider_service_type_id'

   declare @datatypeid integer
   declare @datatype   varchar(50)

   declare data_type_cursor cursor for
      select provider_service_data_type_id, provider_service_data_type_text
      from provider_service_data_type
      where provider_service_category_id = @CategoryId
      order by sort_order

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   open data_type_cursor

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   fetch next from data_type_cursor into @datatypeid,
                                         @datatype

   while ( @@fetch_status = 00 ) begin

      select @DataType = replace(@DataType, ' ', '_')

      set @tmpsql = 'ALTER TABLE #tmp ADD ' + @datatype + ' varchar(255) NULL'
      exec(@tmpsql)

      set @tmpsql = 'ALTER TABLE #tmp2 ADD ' + @datatype + ' varchar(255) NULL'
      exec(@tmpsql)

      set @tab = @tab + ',' + char(13) + 'sum(case psdt.provider_service_data_type_id when ' + cast(@datatypeid as varchar(10)) + ' then csd.com_service_data_id else NULL end) as ' + @datatype

      set @sqlfrom = @sqlfrom + char(13) + 'left outer join com_service_data dt' + cast(@datatypeid as varchar(10)) + ' on a.' + @datatype + '= dt' + cast(@datatypeid as varchar(10)) + '.com_service_data_id'

      set @sqlselect = @sqlselect + ',' + char(13) + 'dt' + cast(@datatypeid as varchar(10)) + '.com_service_data_alt_text as ' + @datatype

      fetch next from data_type_cursor into @datatypeid,
                                            @datatype

   end

   close data_type_cursor

   deallocate data_type_cursor

   set @tab = @tab  + char(13)
   set @tab = @tab  + 'from com_service_unit_value csuv ' + char(13)
   set @tab = @tab  + 'inner join com_service cs                        on csuv.com_service_id                = cs.com_service_id ' + char(13)
   set @tab = @tab  + 'left outer join com_service_data csd                   on csuv.com_service_unit_value_id     = csd.com_service_unit_value_id ' + char(13)
   set @tab = @tab  + 'inner join provider_service_data_type psdt         on csd.provider_service_data_type_id = psdt.provider_service_data_type_id ' + char(13)
   set @tab = @tab  + 'inner join provider_service_category psc          on psdt.provider_service_category_id  = psc.provider_service_category_id ' + char(13)
   set @tab = @tab  + 'left outer join template_provider_service_category tpsc on psc.template_provider_service_category_id  = tpsc.provider_service_category_id ' + char(13)
   set @tab = @tab  + 'where psdt.provider_service_category_id  = ' + cast(@CategoryId  as varchar(10)) + '' + char(13)
   set @tab = @tab  + '  and cs.com_service_date >= ''' + convert(varchar(10), @StartDate, 01) + '''' + char(13)
   set @tab = @tab  + '  and cs.com_service_date <= ''' + convert(varchar(10), @EndDate, 01) + '''' + char(13)
   set @tab = @tab  + 'group by csuv.com_service_unit_value_id, cs.com_service_id, psc.provider_service_category, tpsc.provider_service_category, csd.row_id' + char(13)
   set @tab = @tab  + 'order by csuv.com_service_unit_value_id, cs.com_service_id, psc.provider_service_category, csd.row_id'

   insert into #tmp
   exec(@tab)

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   insert into #tmp2
   exec( @sqlselect + @sqlfrom )

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   select
   provider.member_id as provider_id,
   provider.member_name as provider_name,
   isnull(ps.provider_system_name, tps.provider_system_name) as provider_system_name,
   cs.com_service_id,
   convert(varchar(10), cs.com_service_date, 01) as COM_SERVICE_DATE,
   convert(varchar(10), cs.time_in, 08) as TIME_IN,
   convert(varchar(10), cs.time_out, 08) as TIME_OUT,
   parent_unit.customer_id,
   customer.member_name as customer_name,
   parent_unit.customer_unit_id as parent_unit_id,
   isnull(parent_type.customer_unit_type_name, parent_template_type.customer_unit_type_name) as parent_unit_type_name,
   isnull(parent_unit.customer_unit_name, isnull(parent_name.customer_unit_name, parent_template_name.customer_unit_name)) as parent_unit_name,
   isnull(pst.provider_service_type_text, tpst.provider_service_type_text) as provider_service_type_text,
   mu.member_user_fname+' '+member_user_lname as technician_name,
   cs.customer_contact,
   cs.com_service_comment,
   csuv.com_service_unit_value_id,
   service_unit.customer_unit_id as service_unit_id,
   isnull(service_type.customer_unit_type_name, service_template_type.customer_unit_type_name) as service_unit_type_name,
   isnull(service_unit.customer_unit_name, isnull(service_name.customer_unit_name, service_template_name.customer_unit_name)) as service_unit_name,
   isnull(psv.provider_service_value, tpsv.provider_service_value) as provider_service_value,
   isnull(psv.provider_service_value_text, tpsv.provider_service_value_text) as provider_service_value_text,
   mg.member_group_id,
   mgt.member_group_type_name,
   mg.member_group_name,
   csd.*

   from com_service cs
   left outer join com_service_unit_value csuv on cs.com_service_id = csuv.com_service_id
   inner join #tmp2 csd on csuv.com_service_unit_value_id = csd.SERVICE_DETAIL_ID
   inner join provider_service_type pst on cs.provider_service_type_id = pst.provider_service_type_id
   left outer join template_provider_service_type tpst on pst.template_provider_service_type_id = tpst.provider_service_type_id

   left outer join provider_service_value psv on csuv.provider_service_value_id = psv.provider_service_value_id
   left outer join template_provider_service_value tpsv on psv.template_provider_service_value_id = tpsv.provider_service_value_id

   inner join provider_system ps on pst.provider_system_id = ps.provider_system_id
   left outer join template_provider_system tps on ps.template_provider_system_id = tps.provider_system_id
   inner join member provider on ps.provider_id = provider.member_id

   inner join member_user mu on cs.technician_id = mu.member_user_id

   inner join customer_unit parent_unit on cs.customer_unit_id = parent_unit.customer_unit_id
   inner join join_customer_unit_type_customer_unit parent_join on parent_unit.customer_unit_id = parent_join.customer_unit_id
   inner join customer_unit_type parent_type on parent_join.customer_unit_type_id = parent_type.customer_unit_type_id
                                             and parent_type.provider_system_id = pst.provider_system_id
   left outer join template_provider_customer_unit_type parent_template_type on parent_type.template_provider_customer_unit_type_id = parent_template_type.customer_unit_type_id
   left outer join customer_unit_name parent_name on parent_join.customer_unit_name_id = parent_name.customer_unit_name_id
   left outer join template_provider_customer_unit_name parent_template_name on parent_name.template_provider_customer_unit_name_id = parent_template_name.customer_unit_name_id

   inner join member customer on parent_unit.customer_id = customer.member_id

   left outer join join_member_group_customer_unit jmgcu on parent_unit.customer_unit_id = jmgcu.customer_unit_id
   inner join member_group mg on jmgcu.member_group_id = mg.member_group_id
   inner join member_group_type mgt on mg.member_group_type_id = mgt.member_group_type_id

   inner join customer_unit service_unit on csuv.customer_unit_id = service_unit.customer_unit_id
   inner join join_customer_unit_type_customer_unit service_join on service_unit.customer_unit_id = service_join.customer_unit_id
   inner join customer_unit_type service_type on service_join.customer_unit_type_id = service_type.customer_unit_type_id
                                             and service_type.provider_system_id = pst.provider_system_id
   left outer join template_provider_customer_unit_type service_template_type on service_type.template_provider_customer_unit_type_id = service_template_type.customer_unit_type_id
   left outer join customer_unit_name service_name on service_join.customer_unit_name_id = service_name.customer_unit_name_id
   left outer join template_provider_customer_unit_name service_template_name on service_name.template_provider_customer_unit_name_id = service_template_name.customer_unit_name_id

   where parent_unit.customer_id = @CustomerId
   and com_service_date >= @StartDate
   and com_service_date <= @EndDate

   order by cs.com_service_id, csd.service_detail_id, csd.row_id

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetServicesForGroupsByCustomerCategoryDateRange' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetServicesForGroupsByCustomerCategoryDateRange

   go

create procedure spGetServicesForGroupsByCustomerCategoryDateRange( @CustomerId integer,
                                                                    @CategoryId integer,
                                                                    @StartDate  datetime,
                                                                    @EndDate    datetime,
                                                                    @grouplist  varchar( 4000 ),
                                                                    @typelist   varchar( 4000 ) = null,
                                                                    @valuelist  varchar( 4000 ) = null ) as

   declare @temptable varchar( 4000 )
   declare @execsp    varchar( 4000 )
   declare @select    varchar( 4000 )
   declare @from      varchar( 4000 )
   declare @where     varchar( 4000 )
   declare @order     varchar( 4000 )

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   set nocount on

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   set @temptable = char(13) + 'CREATE TABLE #tmp2 ('
   set @temptable = @temptable + char(13) + 'SERVICE_DETAIL_ID         integer,'
   set @temptable = @temptable + char(13) + 'SERVICE_ID                integer,'
   set @temptable = @temptable + char(13) + 'CATEGORY_NAME             varchar(50),'
   set @temptable = @temptable + char(13) + 'CUSTOMER_UNIT_ID          integer,'
   set @temptable = @temptable + char(13) + 'PROVIDER_SERVICE_VALUE_ID integer,'
   set @temptable = @temptable + char(13) + 'ROW_ID                    integer )'

   set @execsp = char(13) + 'exec spGetServiceDetailsByCustomerCategoryDateRange ' + cast( @CustomerId as varchar(10) ) + ', ' + cast( @CategoryId as varchar(10) ) + ', ' + '''' + convert( varchar(10), @StartDate, 01 ) + '''' + ',' + '''' + convert( varchar(10), @EndDate, 01 ) + ''''

   set @select = char(13) + '   select'
   set @select = @select + char(13) + '      provider.member_id as provider_id,'
   set @select = @select + char(13) + '      provider.member_name as provider_name,'
   set @select = @select + char(13) + '      isnull(ps.provider_system_name, tps.provider_system_name) as provider_system_name,'
   set @select = @select + char(13) + '      cs.com_service_id,'
   set @select = @select + char(13) + '      convert(varchar(10), cs.com_service_date, 01) as COM_SERVICE_DATE,'
   set @select = @select + char(13) + '      convert(varchar(10), cs.time_in, 08) as TIME_IN,'
   set @select = @select + char(13) + '      convert(varchar(10), cs.time_out, 08) as TIME_OUT,'
   set @select = @select + char(13) + '      parent_unit.customer_id,'
   set @select = @select + char(13) + '      customer.member_name as customer_name,'
   set @select = @select + char(13) + '      parent_unit.customer_unit_id as parent_unit_id,'
   set @select = @select + char(13) + '      isnull(parent_type.customer_unit_type_name, parent_template_type.customer_unit_type_name) as parent_unit_type_name,'
   set @select = @select + char(13) + '      isnull(parent_unit.customer_unit_name, isnull(parent_name.customer_unit_name, parent_template_name.customer_unit_name)) as parent_unit_name,'
   set @select = @select + char(13) + '      pst.provider_service_type_id,'
   set @select = @select + char(13) + '      isnull(pst.provider_service_type_text, tpst.provider_service_type_text) as provider_service_type_text,'
   set @select = @select + char(13) + '      mu.member_user_fname+member_user_lname as technician_name,'
   set @select = @select + char(13) + '      cs.customer_contact,'
   set @select = @select + char(13) + '      cs.com_service_comment,'
   set @select = @select + char(13) + '      csd.SERVICE_DETAIL_ID,'
   set @select = @select + char(13) + '      service_unit.customer_unit_id as service_unit_id,'
   set @select = @select + char(13) + '      isnull(service_type.customer_unit_type_name, service_template_type.customer_unit_type_name) as service_unit_type_name,'
   set @select = @select + char(13) + '      isnull(service_unit.customer_unit_name, isnull(service_name.customer_unit_name, service_template_name.customer_unit_name)) as service_unit_name,'
   set @select = @select + char(13) + '      csd.provider_service_value_id,'
   set @select = @select + char(13) + '      isnull(psv.provider_service_value, tpsv.provider_service_value) as provider_service_value,'
   set @select = @select + char(13) + '      isnull(psv.provider_service_value_text, tpsv.provider_service_value_text) as provider_service_value_text,'
   set @select = @select + char(13) + '      mg.member_group_id,'
   set @select = @select + char(13) + '      mgt.member_group_type_name,'
   set @select = @select + char(13) + '      mg.member_group_name,'
   set @select = @select + char(13) + '      csd.*'

   set @from = char(13) + '   from com_service cs'
   set @from = @from + char(13) + '      inner join #tmp2 csd on cs.com_service_id = csd.SERVICE_ID'
   set @from = @from + char(13) + '      inner join provider_service_type pst on cs.provider_service_type_id = pst.provider_service_type_id'
   set @from = @from + char(13) + '      left outer join template_provider_service_type tpst on pst.template_provider_service_type_id = tpst.provider_service_type_id'
   set @from = @from + char(13) + '      left outer join provider_service_value psv on csd.provider_service_value_id = psv.provider_service_value_id'
   set @from = @from + char(13) + '      left outer join template_provider_service_value tpsv on psv.template_provider_service_value_id = tpsv.provider_service_value_id'
   set @from = @from + char(13) + '      inner join provider_system ps on pst.provider_system_id = ps.provider_system_id'
   set @from = @from + char(13) + '      left outer join template_provider_system tps on ps.template_provider_system_id = tps.provider_system_id'
   set @from = @from + char(13) + '      inner join member provider on ps.provider_id = provider.member_id'
   set @from = @from + char(13) + '      inner join member_user mu on cs.technician_id = mu.member_user_id'
   set @from = @from + char(13) + '      inner join customer_unit parent_unit on cs.customer_unit_id = parent_unit.customer_unit_id'
   set @from = @from + char(13) + '      inner join join_customer_unit_type_customer_unit parent_join on parent_unit.customer_unit_id = parent_join.customer_unit_id'
   set @from = @from + char(13) + '      inner join customer_unit_type parent_type on parent_join.customer_unit_type_id = parent_type.customer_unit_type_id'
   set @from = @from + char(13) + '                                               and parent_type.provider_system_id = pst.provider_system_id'
   set @from = @from + char(13) + '      left outer join template_provider_customer_unit_type parent_template_type on parent_type.template_provider_customer_unit_type_id = parent_template_type.customer_unit_type_id'
   set @from = @from + char(13) + '      left outer join customer_unit_name parent_name on parent_join.customer_unit_name_id = parent_name.customer_unit_name_id'
   set @from = @from + char(13) + '      left outer join template_provider_customer_unit_name parent_template_name on parent_name.template_provider_customer_unit_name_id = parent_template_name.customer_unit_name_id'
   set @from = @from + char(13) + '      inner join member customer on parent_unit.customer_id = customer.member_id'
   set @from = @from + char(13) + '      inner join join_member_group_customer_unit jmgcu on parent_unit.customer_unit_id = jmgcu.customer_unit_id'
   set @from = @from + char(13) + '      inner join member_group mg on jmgcu.member_group_id = mg.member_group_id'
   set @from = @from + char(13) + '      inner join member_group_type mgt on mg.member_group_type_id = mgt.member_group_type_id'
   set @from = @from + char(13) + '      inner join customer_unit service_unit on csd.customer_unit_id = service_unit.customer_unit_id'
   set @from = @from + char(13) + '      inner join join_customer_unit_type_customer_unit service_join on service_unit.customer_unit_id = service_join.customer_unit_id'
   set @from = @from + char(13) + '      inner join customer_unit_type service_type on service_join.customer_unit_type_id = service_type.customer_unit_type_id'
   set @from = @from + char(13) + '                                                and service_type.provider_system_id = pst.provider_system_id'
   set @from = @from + char(13) + '      left outer join template_provider_customer_unit_type service_template_type on service_type.template_provider_customer_unit_type_id = service_template_type.customer_unit_type_id'
   set @from = @from + char(13) + '      left outer join customer_unit_name service_name on service_join.customer_unit_name_id = service_name.customer_unit_name_id'
   set @from = @from + char(13) + '      left outer join template_provider_customer_unit_name service_template_name on service_name.template_provider_customer_unit_name_id = service_template_name.customer_unit_name_id'

   set @where = char(13) + '   where ( parent_unit.customer_id = ' + cast( @CustomerId as varchar(10) ) + ')'
   set @where = @where + char(13) + '     and ( com_service_date >= ''' + convert( varchar(10), @StartDate, 01 ) + ''')'
   set @where = @where + char(13) + '     and ( com_service_date <= ''' + convert( varchar(10), @EndDate, 01 )   + ''')'
   set @where = @where + char(13) + '      and ( ( provider.member_id = mgt.member_id )'
   set @where = @where + char(13) + '         or ( customer.member_id = mgt.member_id ) )'

   /* Add filter for MEMBER_GROUP_ID */
   set @where = @where + char(13) + '      and ( mg.member_group_id in ( ' + @grouplist + ' ) )'

   /* If @TypeList is not NULL then add filter for PROVIDER_SERVICE_TYPE_ID */
   /* If @TypeList is NULL then the query will select all services that meet the parameters for all types */
   if @typelist is not null begin
      set @where = @where + char(13) + '      and ( pst.provider_service_type_id in ( ' + @typelist + ' ) )'
   end

   /* If @ValueList is not NULL then add filter for PROVIDER_SERVICE_VALUE_ID */
   /* If @ValueList is NULL then the query will select all services that meet the parameters for all values, inlcuding NULLs */
   if @valuelist is not null begin
      set @where = @where + char(13) + '      and ( psv.provider_service_value_id in ( ' + @valuelist + ' ) )'
   end

   set @order = char(13) + '   order by cs.com_service_id, csd.service_detail_id, csd.row_id'

   exec ( @temptable + @execsp + @select + @from + @where + @order )

    /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetServicesForGroupsByGroupCategoryDateRange' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetServicesForGroupsByGroupCategoryDateRange

   go

create procedure spGetServicesForGroupsByGroupCategoryDateRange( @GroupId    integer,
                                                                 @CategoryId integer,
                                                                 @StartDate  datetime,
                                                                 @EndDate    datetime,
                                                                 @typelist   varchar( 4000 ) = null,
                                                                 @valuelist  varchar( 4000 ) = null ) as

   declare @temptable varchar( 4000 )
   declare @execsp    varchar( 4000 )
   declare @select    varchar( 4000 )
   declare @from      varchar( 4000 )
   declare @where     varchar( 4000 )
   declare @order     varchar( 4000 )

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   set nocount on

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   set @temptable = char(13) + 'CREATE TABLE #tmp2 ('
   set @temptable = @temptable + char(13) + 'SERVICE_DETAIL_ID         integer,'
   set @temptable = @temptable + char(13) + 'SERVICE_ID                integer,'
   set @temptable = @temptable + char(13) + 'CATEGORY_NAME             varchar(50),'
   set @temptable = @temptable + char(13) + 'CUSTOMER_UNIT_ID          integer,'
   set @temptable = @temptable + char(13) + 'PROVIDER_SERVICE_VALUE_ID integer,'
   set @temptable = @temptable + char(13) + 'ROW_ID                    integer )'

   set @execsp = char(13) + 'exec spGetServiceDetailsByGroupCategoryDateRange ' +
   cast( @GroupId as varchar(10) ) + ', ' +
   cast( @CategoryId as varchar(10) ) + ', ' + '''' +
   convert( varchar(10), @StartDate, 01 ) + '''' + ',' + '''' +
   convert( varchar(10), @EndDate, 01 ) + ''''


   set @select = char(13) + '   select'
   set @select = @select + char(13) + '      provider.member_id as provider_id,'
   set @select = @select + char(13) + '      provider.member_name as provider_name,'
   set @select = @select + char(13) + '      isnull(ps.provider_system_name, tps.provider_system_name) as provider_system_name,'
   set @select = @select + char(13) + '      cs.com_service_id,'
   set @select = @select + char(13) + '      convert(varchar(10), cs.com_service_date, 01) as COM_SERVICE_DATE,'
   set @select = @select + char(13) + '      convert(varchar(10), cs.time_in, 08) as TIME_IN,'
   set @select = @select + char(13) + '      convert(varchar(10), cs.time_out, 08) as TIME_OUT,'
   set @select = @select + char(13) + '      parent_unit.customer_id,'
   set @select = @select + char(13) + '      customer.member_name as customer_name,'
   set @select = @select + char(13) + '      parent_unit.customer_unit_id as parent_unit_id,'
   set @select = @select + char(13) + '      isnull(parent_type.customer_unit_type_name, parent_template_type.customer_unit_type_name) as parent_unit_type_name,'
   set @select = @select + char(13) + '      isnull(parent_unit.customer_unit_name, isnull(parent_name.customer_unit_name, parent_template_name.customer_unit_name)) as parent_unit_name,'
   set @select = @select + char(13) + '      pst.provider_service_type_id,'
   set @select = @select + char(13) + '      isnull(pst.provider_service_type_text, tpst.provider_service_type_text) as provider_service_type_text,'
   set @select = @select + char(13) + '      mu.member_user_fname+member_user_lname as technician_name,'
   set @select = @select + char(13) + '      cs.customer_contact,'
   set @select = @select + char(13) + '      cs.com_service_comment,'
   set @select = @select + char(13) + '      csd.SERVICE_DETAIL_ID,'
   set @select = @select + char(13) + '      service_unit.customer_unit_id as service_unit_id,'
   set @select = @select + char(13) + '      isnull(service_type.customer_unit_type_name, service_template_type.customer_unit_type_name) as service_unit_type_name,'
   set @select = @select + char(13) + '      isnull(service_unit.customer_unit_name, isnull(service_name.customer_unit_name, service_template_name.customer_unit_name)) as service_unit_name,'
   set @select = @select + char(13) + '      csd.provider_service_value_id,'
   set @select = @select + char(13) + '      isnull(psv.provider_service_value, tpsv.provider_service_value) as provider_service_value,'
   set @select = @select + char(13) + '      isnull(psv.provider_service_value_text, tpsv.provider_service_value_text) as provider_service_value_text,'
   set @select = @select + char(13) + '      mg.member_group_id,'
   set @select = @select + char(13) + '      mgt.member_group_type_name,'
   set @select = @select + char(13) + '      mg.member_group_name,'
   set @select = @select + char(13) + '      csd.*'

   set @from = char(13) + '   from com_service cs'
   set @from = @from + char(13) + '      inner join #tmp2 csd on cs.com_service_id = csd.SERVICE_ID'
   set @from = @from + char(13) + '      inner join provider_service_type pst on cs.provider_service_type_id = pst.provider_service_type_id'
   set @from = @from + char(13) + '      left outer join template_provider_service_type tpst on pst.template_provider_service_type_id = tpst.provider_service_type_id'
   set @from = @from + char(13) + '      left outer join provider_service_value psv on csd.provider_service_value_id = psv.provider_service_value_id'
   set @from = @from + char(13) + '      left outer join template_provider_service_value tpsv on psv.template_provider_service_value_id = tpsv.provider_service_value_id'
   set @from = @from + char(13) + '      inner join provider_system ps on pst.provider_system_id = ps.provider_system_id'
   set @from = @from + char(13) + '      left outer join template_provider_system tps on ps.template_provider_system_id = tps.provider_system_id'
   set @from = @from + char(13) + '      inner join member provider on ps.provider_id = provider.member_id'
   set @from = @from + char(13) + '      inner join member_user mu on cs.technician_id = mu.member_user_id'
   set @from = @from + char(13) + '      inner join customer_unit parent_unit on cs.customer_unit_id = parent_unit.customer_unit_id'
   set @from = @from + char(13) + '      inner join join_customer_unit_type_customer_unit parent_join on parent_unit.customer_unit_id = parent_join.customer_unit_id'
   set @from = @from + char(13) + '      inner join customer_unit_type parent_type on parent_join.customer_unit_type_id = parent_type.customer_unit_type_id'
   set @from = @from + char(13) + '                                               and parent_type.provider_system_id = pst.provider_system_id'
   set @from = @from + char(13) + '      left outer join template_provider_customer_unit_type parent_template_type on parent_type.template_provider_customer_unit_type_id = parent_template_type.customer_unit_type_id'
   set @from = @from + char(13) + '      left outer join customer_unit_name parent_name on parent_join.customer_unit_name_id = parent_name.customer_unit_name_id'
   set @from = @from + char(13) + '      left outer join template_provider_customer_unit_name parent_template_name on parent_name.template_provider_customer_unit_name_id = parent_template_name.customer_unit_name_id'
   set @from = @from + char(13) + '      inner join member customer on parent_unit.customer_id = customer.member_id'
   set @from = @from + char(13) + '      inner join join_member_group_customer_unit jmgcu on parent_unit.customer_unit_id = jmgcu.customer_unit_id'
   set @from = @from + char(13) + '      inner join member_group mg on jmgcu.member_group_id = mg.member_group_id'
   set @from = @from + char(13) + '      inner join member_group_type mgt on mg.member_group_type_id = mgt.member_group_type_id'
   set @from = @from + char(13) + '      inner join customer_unit service_unit on csd.customer_unit_id = service_unit.customer_unit_id'
   set @from = @from + char(13) + '      inner join join_customer_unit_type_customer_unit service_join on service_unit.customer_unit_id = service_join.customer_unit_id'
   set @from = @from + char(13) + '      inner join customer_unit_type service_type on service_join.customer_unit_type_id = service_type.customer_unit_type_id'
   set @from = @from + char(13) + '                                                and service_type.provider_system_id = pst.provider_system_id'
   set @from = @from + char(13) + '      left outer join template_provider_customer_unit_type service_template_type on service_type.template_provider_customer_unit_type_id = service_template_type.customer_unit_type_id'
   set @from = @from + char(13) + '      left outer join customer_unit_name service_name on service_join.customer_unit_name_id = service_name.customer_unit_name_id'
   set @from = @from + char(13) + '      left outer join template_provider_customer_unit_name service_template_name on service_name.template_provider_customer_unit_name_id = service_template_name.customer_unit_name_id'

   set @where = char(13) + 'where ( com_service_date >= ''' + convert( varchar(10), @StartDate, 01 ) + ''')'
   set @where = @where + char(13) + '     and ( com_service_date <= ''' + convert( varchar(10), @EndDate, 01 )   + ''')'
   set @where = @where + char(13) + '      and ( ( provider.member_id = mgt.member_id )'
   set @where = @where + char(13) + '         or ( customer.member_id = mgt.member_id ) )'

   /* Add filter for MEMBER_GROUP_ID */
   set @where = @where + char(13) + '      and ( mg.member_group_id = ' + cast( @GroupId as varchar(10) ) + ')'

   /* If @TypeList is not NULL then add filter for PROVIDER_SERVICE_TYPE_ID */
   /* If @TypeList is NULL then the query will select all services that meet the parameters for all types */
   if @typelist is not null begin
      set @where = @where + char(13) + '      and ( pst.provider_service_type_id in ( ' + @typelist + ' ) )'
   end

   /* If @ValueList is not NULL then add filter for PROVIDER_SERVICE_VALUE_ID */
   /* If @ValueList is NULL then the query will select all services that meet the parameters for all values, inlcuding NULLs */
   if @valuelist is not null begin
      set @where = @where + char(13) + '      and ( psv.provider_service_value_id in ( ' + @valuelist + ' ) )'
   end

   set @order = char(13) + '   order by cs.com_service_id, csd.service_detail_id, csd.row_id'

   exec ( @temptable + @execsp + @select + @from + @where + @order )

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetServicesForGroupsByTechnicianCategoryDateRange' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetServicesForGroupsByTechnicianCategoryDateRange

   go

create procedure spGetServicesForGroupsByTechnicianCategoryDateRange( @TechnicianId integer,
                                                                      @CategoryId   integer,
                                                                      @StartDate    datetime,
                                                                      @EndDate      datetime,
                                                                      @grouplist    varchar( 4000 ),
                                                                      @typelist     varchar( 4000 ) = null,
                                                                      @valuelist    varchar( 4000 ) = null ) as

   declare @temptable varchar( 4000 )
   declare @execsp    varchar( 4000 )
   declare @select    varchar( 4000 )
   declare @from      varchar( 4000 )
   declare @where     varchar( 4000 )
   declare @order     varchar( 4000 )

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   set nocount on

    /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   set @temptable = char(13) + 'CREATE TABLE #tmp2 ('
   set @temptable = @temptable + char(13) + 'SERVICE_DETAIL_ID         integer,'
   set @temptable = @temptable + char(13) + 'SERVICE_ID                integer,'
   set @temptable = @temptable + char(13) + 'CATEGORY_NAME             varchar(50),'
   set @temptable = @temptable + char(13) + 'CUSTOMER_UNIT_ID          integer,'
   set @temptable = @temptable + char(13) + 'PROVIDER_SERVICE_VALUE_ID integer,'
   set @temptable = @temptable + char(13) + 'ROW_ID                    integer )'

   set @execsp = char(13) + 'exec spGetServiceDetailsByTechnicianCategoryDateRange ' +
   cast( @TechnicianId as varchar(10) ) + ', ' +
   cast( @CategoryId as varchar(10) ) + ', ' + '''' +
   convert( varchar(10), @StartDate, 01 ) + '''' + ',' + '''' +
   convert( varchar(10), @EndDate, 01 ) + ''''

   set @select = char(13) + '   select'
   set @select = @select + char(13) + '      provider.member_id as provider_id,'
   set @select = @select + char(13) + '      provider.member_name as provider_name,'
   set @select = @select + char(13) + '      isnull(ps.provider_system_name, tps.provider_system_name) as provider_system_name,'
   set @select = @select + char(13) + '      cs.com_service_id,'
   set @select = @select + char(13) + '      convert(varchar(10), cs.com_service_date, 01) as COM_SERVICE_DATE,'
   set @select = @select + char(13) + '      convert(varchar(10), cs.time_in, 08) as TIME_IN,'
   set @select = @select + char(13) + '      convert(varchar(10), cs.time_out, 08) as TIME_OUT,'
   set @select = @select + char(13) + '      parent_unit.customer_id,'
   set @select = @select + char(13) + '      customer.member_name as customer_name,'
   set @select = @select + char(13) + '      parent_unit.customer_unit_id as parent_unit_id,'
   set @select = @select + char(13) + '      isnull(parent_type.customer_unit_type_name, parent_template_type.customer_unit_type_name) as parent_unit_type_name,'
   set @select = @select + char(13) + '      isnull(parent_unit.customer_unit_name, isnull(parent_name.customer_unit_name, parent_template_name.customer_unit_name)) as parent_unit_name,'
   set @select = @select + char(13) + '      pst.provider_service_type_id,'
   set @select = @select + char(13) + '      isnull(pst.provider_service_type_text, tpst.provider_service_type_text) as provider_service_type_text,'
   set @select = @select + char(13) + '      mu.member_user_fname+member_user_lname as technician_name,'
   set @select = @select + char(13) + '      cs.customer_contact,'
   set @select = @select + char(13) + '      cs.com_service_comment,'
   set @select = @select + char(13) + '      csd.SERVICE_DETAIL_ID,'
   set @select = @select + char(13) + '      service_unit.customer_unit_id as service_unit_id,'
   set @select = @select + char(13) + '      isnull(service_type.customer_unit_type_name, service_template_type.customer_unit_type_name) as service_unit_type_name,'
   set @select = @select + char(13) + '      isnull(service_unit.customer_unit_name, isnull(service_name.customer_unit_name, service_template_name.customer_unit_name)) as service_unit_name,'
   set @select = @select + char(13) + '      csd.provider_service_value_id,'
   set @select = @select + char(13) + '      isnull(psv.provider_service_value, tpsv.provider_service_value) as provider_service_value,'
   set @select = @select + char(13) + '      isnull(psv.provider_service_value_text, tpsv.provider_service_value_text) as provider_service_value_text,'
   set @select = @select + char(13) + '      mg.member_group_id,'
   set @select = @select + char(13) + '      mgt.member_group_type_name,'
   set @select = @select + char(13) + '      mg.member_group_name,'
   set @select = @select + char(13) + '      csd.*'

   set @from = char(13) + '   from com_service cs'
   set @from = @from + char(13) + '      inner join #tmp2 csd on cs.com_service_id = csd.SERVICE_ID'
   set @from = @from + char(13) + '      inner join provider_service_type pst on cs.provider_service_type_id = pst.provider_service_type_id'
   set @from = @from + char(13) + '      left outer join template_provider_service_type tpst on pst.template_provider_service_type_id = tpst.provider_service_type_id'
   set @from = @from + char(13) + '      left outer join provider_service_value psv on csd.provider_service_value_id = psv.provider_service_value_id'
   set @from = @from + char(13) + '      left outer join template_provider_service_value tpsv on psv.template_provider_service_value_id = tpsv.provider_service_value_id'
   set @from = @from + char(13) + '      inner join provider_system ps on pst.provider_system_id = ps.provider_system_id'
   set @from = @from + char(13) + '      left outer join template_provider_system tps on ps.template_provider_system_id = tps.provider_system_id'
   set @from = @from + char(13) + '      inner join member provider on ps.provider_id = provider.member_id'
   set @from = @from + char(13) + '      inner join member_user mu on cs.technician_id = mu.member_user_id'
   set @from = @from + char(13) + '      inner join customer_unit parent_unit on cs.customer_unit_id = parent_unit.customer_unit_id'
   set @from = @from + char(13) + '      inner join join_customer_unit_type_customer_unit parent_join on parent_unit.customer_unit_id = parent_join.customer_unit_id'
   set @from = @from + char(13) + '      inner join customer_unit_type parent_type on parent_join.customer_unit_type_id = parent_type.customer_unit_type_id'
   set @from = @from + char(13) + '                                               and parent_type.provider_system_id = pst.provider_system_id'
   set @from = @from + char(13) + '      left outer join template_provider_customer_unit_type parent_template_type on parent_type.template_provider_customer_unit_type_id = parent_template_type.customer_unit_type_id'
   set @from = @from + char(13) + '      left outer join customer_unit_name parent_name on parent_join.customer_unit_name_id = parent_name.customer_unit_name_id'
   set @from = @from + char(13) + '      left outer join template_provider_customer_unit_name parent_template_name on parent_name.template_provider_customer_unit_name_id = parent_template_name.customer_unit_name_id'
   set @from = @from + char(13) + '      inner join member customer on parent_unit.customer_id = customer.member_id'
   set @from = @from + char(13) + '      inner join join_member_group_customer_unit jmgcu on parent_unit.customer_unit_id = jmgcu.customer_unit_id'
   set @from = @from + char(13) + '      inner join member_group mg on jmgcu.member_group_id = mg.member_group_id'
   set @from = @from + char(13) + '      inner join member_group_type mgt on mg.member_group_type_id = mgt.member_group_type_id'
   set @from = @from + char(13) + '      inner join customer_unit service_unit on csd.customer_unit_id = service_unit.customer_unit_id'
   set @from = @from + char(13) + '      inner join join_customer_unit_type_customer_unit service_join on service_unit.customer_unit_id = service_join.customer_unit_id'
   set @from = @from + char(13) + '      inner join customer_unit_type service_type on service_join.customer_unit_type_id = service_type.customer_unit_type_id'
   set @from = @from + char(13) + '                                                and service_type.provider_system_id = pst.provider_system_id'
   set @from = @from + char(13) + '      left outer join template_provider_customer_unit_type service_template_type on service_type.template_provider_customer_unit_type_id = service_template_type.customer_unit_type_id'
   set @from = @from + char(13) + '      left outer join customer_unit_name service_name on service_join.customer_unit_name_id = service_name.customer_unit_name_id'
   set @from = @from + char(13) + '      left outer join template_provider_customer_unit_name service_template_name on service_name.template_provider_customer_unit_name_id = service_template_name.customer_unit_name_id'

   set @where = char(13) + '   where ( cs.technician_id = ' + cast( @TechnicianId as varchar(10) ) + ')'
   set @where = @where + char(13) + '     and ( com_service_date >= ''' + convert( varchar(10), @StartDate, 01 ) + ''')'
   set @where = @where + char(13) + '     and ( com_service_date <= ''' + convert( varchar(10), @EndDate, 01 )   + ''')'
   set @where = @where + char(13) + '      and ( ( provider.member_id = mgt.member_id )'
   set @where = @where + char(13) + '         or ( customer.member_id = mgt.member_id ) )'

   /* Add filter for MEMBER_GROUP_ID */
   set @where = @where + char(13) + '      and ( mg.member_group_id in ( ' + @grouplist + ' ) )'

   /* If @TypeList is not NULL then add filter for PROVIDER_SERVICE_TYPE_ID */
   /* If @TypeList is NULL then the query will select all services that meet the parameters for all types */
   if @typelist is not null begin
      set @where = @where + char(13) + '      and ( pst.provider_service_type_id in ( ' + @typelist + ' ) )'
   end

   /* If @ValueList is not NULL then add filter for PROVIDER_SERVICE_VALUE_ID */
   /* If @ValueList is NULL then the query will select all services that meet the parameters for all values, inlcuding NULLs */
   if @valuelist is not null begin
      set @where = @where + char(13) + '      and ( psv.provider_service_value_id in ( ' + @valuelist + ' ) )'
   end

   set @order = char(13) + '   order by cs.com_service_id, csd.service_detail_id, csd.row_id'

   exec ( @temptable + @execsp + @select + @from + @where + @order )

    /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetServiceTransactionsByInterfaceId' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetServiceTransactionsByInterfaceId

   go

create procedure spGetServiceTransactionsByInterfaceId ( @InterfaceId integer ) as

   select
   pcss.provider_customer_service_schedule_id      as ServiceId,
   pcss.work_order_number                          as WorkOrderNumber,
   service_type.foreign_id                         as ServiceType,
   service_location.foreign_id                     as ServiceLocation,
   pcss.provider_customer_service_schedule_date    as ScheduleDate,
   convert(varchar(10), cs.com_service_date, 1)    as ServiceDate,
   convert(varchar(8),  cs.time_in,          8)    as TimeIn,
   convert(varchar(8),  cs.time_out,         8)    as TimeOut,
   technician.foreign_id                           as Technician,
   cs.customer_contact                             as Contact,
   cs.com_service_comment                          as Comment,
   me.foreign_id                                   as ForeignId,
   service_type.foreign_type                       as ForeignType
   from provider_customer_service_schedule pcss
   left outer join com_service cs             on pcss.com_service_id                        = cs.com_service_id
   inner join mapping_interface mi            on mi.interface_id                            = @InterfaceId
   inner join mapping_entity service_type     on mi.interface_id                            = service_type.interface_id and
                                                 pcss.provider_service_type_id              = service_type.entity_id and
                                                 service_type.entity_type_id                = 7
   inner join mapping_entity service_location on mi.interface_id                            = service_location.interface_id and
                                                 pcss.customer_unit_id                      = service_location.entity_id and
                                                 service_location.entity_type_id            = 5
   left outer join mapping_entity technician  on mi.interface_id                            = technician.interface_id and
                                                 cs.technician_id                           = technician.entity_id and
                                                 technician.entity_type_id                  = 1
   inner join transaction_log tl              on mi.interface_id                            = tl.interface_id and
                                                 pcss.PROVIDER_CUSTOMER_SERVICE_SCHEDULE_ID = tl.entity_id and
                                                 tl.entity_type_id                          = 12
   left outer join mapping_entity me          on tl.interface_id                            = me.interface_id and
                                                 tl.entity_id                               = me.entity_id and
                                                 tl.entity_type_id                          = me.entity_type_id
   where tl.TRANSMITTED = 0
   order by ServiceId

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetServiceTypesByCustomerCategoryDateRange' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetServiceTypesByCustomerCategoryDateRange

   go

create procedure spGetServiceTypesByCustomerCategoryDateRange( @CustomerId integer,
                                                               @CategoryId integer,
                                                               @StartDate  datetime,
                                                               @EndDate    datetime,
                                                               @GroupType  integer = 00 ) as

   declare @outerSelect varchar( 4000 )
   declare @innerSelect varchar( 4000 )
   declare @innerWhere  varchar( 4000 )
   declare @groupSelect varchar( 4000 )

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   set nocount on

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   set @innerSelect = char(13) + '
      select cs.provider_service_type_id
      from join_member_group_customer_unit jmgcu
         inner join com_service cs on jmgcu.customer_unit_id = cs.customer_unit_id
         inner join com_service_unit_value csuv on cs.com_service_id = csuv.com_service_id
         inner join com_service_data csd on csuv.com_service_unit_value_id = csd.com_service_unit_value_id
         inner join provider_service_data_type psdt on csd.provider_service_data_type_id = psdt.provider_service_data_type_id
         inner join provider_service_category psc on psdt.provider_service_category_id = psc.provider_service_category_id
         inner join provider_system ps on psc.provider_system_id = ps.provider_system_id
         inner join customer_unit_type parent_type on ps.provider_system_id = parent_type.provider_system_id
         inner join customer_unit parent_unit on cs.customer_unit_id = parent_unit.customer_unit_id
         inner join join_customer_unit_type_customer_unit parent_join on parent_type.customer_unit_type_id = parent_join.customer_unit_type_id
                                                                      and parent_join.customer_unit_id = parent_unit.customer_unit_id
         inner join member_group mg on jmgcu.member_group_id = mg.member_group_id
         inner join member_group_type mgt on mg.member_group_type_id = mgt.member_group_type_id'

   set @innerWhere = char(13) + '
      where parent_unit.customer_id = ' + cast(@CustomerId as varchar(10)) + '
        and psc.provider_service_category_id = ' + cast(@CategoryId as varchar(10)) + '
        and cs.com_service_date >= ''' + convert(varchar(10), @StartDate, 01) + '''
        and cs.com_service_date <= ''' + convert(varchar(10), @EndDate, 01) + ''''

   if @GroupType = 0 begin
        set @groupSelect = char(13) + ' and ( ( mgt.member_id = ps.provider_id ) or ( mgt.member_id = parent_unit.customer_id ) )'
   end

   else if @GroupType = 1 begin
        set @groupSelect = char(13) + ' and ( mgt.member_id = ps.provider_id ) '
   end

   else if @GroupType = 2 begin
        set @groupSelect = char(13) + ' and ( mgt.member_id = parent_unit.customer_id ) '
   end

   set @outerSelect = char(13) + '
   select pst.provider_service_type_id, isnull(pst.provider_service_type_text, tpst.provider_service_type_text) as provider_service_type_text
   from provider_service_type pst
   left outer join template_provider_service_type tpst on pst.template_provider_service_type_id = tpst.provider_service_type_id
   where pst.provider_service_type_id in ( ' + @innerSelect + @innerWhere + @groupSelect + ' )'

   exec(@outerSelect)

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetServiceTypesByGroupCategoryDateRange' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetServiceTypesByGroupCategoryDateRange

   go

create procedure spGetServiceTypesByGroupCategoryDateRange( @GroupId    integer,
                                                            @CategoryId integer,

                                                            @StartDate  datetime,
                                                            @EndDate    datetime,
                                                            @GroupType  integer = 00 ) as

   declare @outerSelect varchar( 4000 )
   declare @innerSelect varchar( 4000 )
   declare @innerWhere  varchar( 4000 )
   declare @groupSelect varchar( 4000 )

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   set nocount on

    /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   set @innerSelect = char(13) + '
      select cs.provider_service_type_id
      from join_member_group_customer_unit jmgcu
         inner join com_service cs on jmgcu.customer_unit_id = cs.customer_unit_id
         inner join com_service_unit_value csuv on cs.com_service_id = csuv.com_service_id
         inner join com_service_data csd on csuv.com_service_unit_value_id = csd.com_service_unit_value_id
         inner join provider_service_data_type psdt on csd.provider_service_data_type_id = psdt.provider_service_data_type_id
         inner join provider_service_category psc on psdt.provider_service_category_id = psc.provider_service_category_id
         inner join provider_system ps on psc.provider_system_id = ps.provider_system_id
         inner join customer_unit_type parent_type on ps.provider_system_id = parent_type.provider_system_id
         inner join customer_unit parent_unit on cs.customer_unit_id = parent_unit.customer_unit_id
         inner join join_customer_unit_type_customer_unit parent_join on parent_type.customer_unit_type_id = parent_join.customer_unit_type_id
                                                                      and parent_join.customer_unit_id = parent_unit.customer_unit_id
         inner join member_group mg on jmgcu.member_group_id = mg.member_group_id
         inner join member_group_type mgt on mg.member_group_type_id = mgt.member_group_type_id'

   set @innerWhere = char(13) + '
       where mg.member_group_id = ' + cast(@GroupId as varchar(10)) + '
        and psc.provider_service_category_id = ' + cast(@CategoryId as varchar(10)) + '
        and cs.com_service_date >= ''' + convert(varchar(10), @StartDate, 01) + '''
        and cs.com_service_date <= ''' + convert(varchar(10), @EndDate, 01) + ''''

   if @GroupType = 0 begin
        set @groupSelect = char(13) + ' and ( ( mgt.member_id = ps.provider_id ) or ( mgt.member_id = parent_unit.customer_id ) )'
   end

   else if @GroupType = 1 begin
        set @groupSelect = char(13) + ' and ( mgt.member_id = ps.provider_id ) '
   end

   else if @GroupType = 2 begin
        set @groupSelect = char(13) + ' and ( mgt.member_id = parent_unit.customer_id ) '
   end

   set @outerSelect = char(13) + '
   select pst.provider_service_type_id, isnull(pst.provider_service_type_text, tpst.provider_service_type_text) as provider_service_type_text
   from provider_service_type pst
   left outer join template_provider_service_type tpst on pst.template_provider_service_type_id = tpst.provider_service_type_id
   where pst.provider_service_type_id in ( ' + @innerSelect + @innerWhere + @groupSelect + ' )'

   exec(@outerSelect)

    /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetServiceTypesByTechnicianCategoryDateRange' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetServiceTypesByTechnicianCategoryDateRange

   go

create procedure spGetServiceTypesByTechnicianCategoryDateRange( @TechnicianId integer,
                                                                 @CategoryId   integer,
                                                                 @StartDate    datetime,
                                                                 @EndDate      datetime,
                                                                 @GroupType    integer = 00 ) as


   declare @outerSelect varchar( 4000 )
   declare @innerSelect varchar( 4000 )
   declare @innerWhere  varchar( 4000 )
   declare @groupSelect varchar( 4000 )

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   set nocount on

    /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   set @innerSelect = char(13) + '
      select cs.provider_service_type_id
      from join_member_group_customer_unit jmgcu
         inner join com_service cs on jmgcu.customer_unit_id = cs.customer_unit_id
         inner join com_service_unit_value csuv on cs.com_service_id = csuv.com_service_id
         inner join com_service_data csd on csuv.com_service_unit_value_id = csd.com_service_unit_value_id
         inner join provider_service_data_type psdt on csd.provider_service_data_type_id = psdt.provider_service_data_type_id
         inner join provider_service_category psc on psdt.provider_service_category_id = psc.provider_service_category_id
         inner join provider_system ps on psc.provider_system_id = ps.provider_system_id
         inner join customer_unit_type parent_type on ps.provider_system_id = parent_type.provider_system_id
         inner join customer_unit parent_unit on cs.customer_unit_id = parent_unit.customer_unit_id
         inner join join_customer_unit_type_customer_unit parent_join on parent_type.customer_unit_type_id = parent_join.customer_unit_type_id
                                                                      and parent_join.customer_unit_id = parent_unit.customer_unit_id
         inner join member_group mg on jmgcu.member_group_id = mg.member_group_id
         inner join member_group_type mgt on mg.member_group_type_id = mgt.member_group_type_id'

   set @innerWhere = char(13) + '
      where cs.technician_id = ' + cast(@TechnicianId as varchar(10)) + '
        and psc.provider_service_category_id = ' + cast(@CategoryId as varchar(10)) + '
        and cs.com_service_date >= ''' + convert(varchar(10), @StartDate, 01) + '''
        and cs.com_service_date <= ''' + convert(varchar(10), @EndDate, 01) + ''''

   if @GroupType = 0 begin
        set @groupSelect = char(13) + ' and ( ( mgt.member_id = ps.provider_id ) or ( mgt.member_id = parent_unit.customer_id ) )'
   end

   else if @GroupType = 1 begin
        set @groupSelect = char(13) + ' and ( mgt.member_id = ps.provider_id ) '
   end

   else if @GroupType = 2 begin
        set @groupSelect = char(13) + ' and ( mgt.member_id = parent_unit.customer_id ) '
   end

   set @outerSelect = char(13) + '
   select pst.provider_service_type_id, isnull(pst.provider_service_type_text, tpst.provider_service_type_text) as provider_service_type_text
   from provider_service_type pst
   left outer join template_provider_service_type tpst on pst.template_provider_service_type_id = tpst.provider_service_type_id
   where pst.provider_service_type_id in ( ' + @innerSelect + @innerWhere + @groupSelect + ' )'

   exec(@outerSelect)

    /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetServiceValuesByCustomerCategoryDateRange' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetServiceValuesByCustomerCategoryDateRange

   go

create procedure spGetServiceValuesByCustomerCategoryDateRange( @CustomerId integer,
                                                                @CategoryId integer,
                                                                @StartDate  datetime,
                                                                @EndDate    datetime,
                                                                @GroupType  integer = 00 ) as

   declare @outerSelect varchar( 4000 )
   declare @innerSelect varchar( 4000 )
   declare @innerWhere  varchar( 4000 )
   declare @groupSelect varchar( 4000 )

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   set nocount on

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   set @innerSelect = char(13) + '
      select csuv.provider_service_value_id
      from join_member_group_customer_unit jmgcu
         inner join com_service cs on jmgcu.customer_unit_id = cs.customer_unit_id
         inner join com_service_unit_value csuv on cs.com_service_id = csuv.com_service_id
         inner join com_service_data csd on csuv.com_service_unit_value_id = csd.com_service_unit_value_id
         inner join provider_service_data_type psdt on csd.provider_service_data_type_id = psdt.provider_service_data_type_id
         inner join provider_service_category psc on psdt.provider_service_category_id = psc.provider_service_category_id
         inner join provider_system ps on psc.provider_system_id = ps.provider_system_id
         inner join customer_unit_type parent_type on ps.provider_system_id = parent_type.provider_system_id
         inner join customer_unit parent_unit on cs.customer_unit_id = parent_unit.customer_unit_id
         inner join join_customer_unit_type_customer_unit parent_join on parent_type.customer_unit_type_id = parent_join.customer_unit_type_id
                                                                      and parent_join.customer_unit_id = parent_unit.customer_unit_id
         inner join member_group mg on jmgcu.member_group_id = mg.member_group_id
         inner join member_group_type mgt on mg.member_group_type_id = mgt.member_group_type_id'

   set @innerWhere = char(13) + '
      where parent_unit.customer_id = ' + cast(@CustomerId as varchar(10)) + '
        and psc.provider_service_category_id = ' + cast(@CategoryId as varchar(10)) + '
        and cs.com_service_date >= ''' + convert(varchar(10), @StartDate, 01) + '''
        and cs.com_service_date <= ''' + convert(varchar(10), @EndDate, 01) + ''''

   if @GroupType = 0 begin
        set @groupSelect = char(13) + ' and ( ( mgt.member_id = ps.provider_id ) or ( mgt.member_id = parent_unit.customer_id ) )'
   end

   else if @GroupType = 1 begin
        set @groupSelect = char(13) + ' and ( mgt.member_id = ps.provider_id ) '
   end

   else if @GroupType = 2 begin
        set @groupSelect = char(13) + ' and ( mgt.member_id = parent_unit.customer_id ) '
   end

   set @outerSelect = char(13) + '
   select psv.provider_service_value_id, isnull(psv.provider_service_value, tpsv.provider_service_value) as provider_service_value, isnull(psv.provider_service_value_text, tpsv.provider_service_value_text) as provider_service_value_text
   from provider_service_value psv
   left outer join template_provider_service_value tpsv on psv.template_provider_service_value_id = tpsv.provider_service_value_id
   where psv.provider_service_value_id in ( ' + @innerSelect + @innerWhere + @groupSelect + ' )'

   exec(@outerSelect)

    /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetServiceValuesByGroupCategoryDateRange' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetServiceValuesByGroupCategoryDateRange

   go

create procedure spGetServiceValuesByGroupCategoryDateRange( @GroupId    integer,
                                                             @CategoryId integer,
                                                             @StartDate  datetime,
                                                             @EndDate    datetime,
                                                             @GroupType  integer = 00 ) as

   declare @outerSelect varchar( 4000 )
   declare @innerSelect varchar( 4000 )
   declare @innerWhere  varchar( 4000 )
   declare @groupSelect varchar( 4000 )
   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   set nocount on

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   set @innerSelect = char(13) + '
      select csuv.provider_service_value_id
      from join_member_group_customer_unit jmgcu
         inner join com_service cs on jmgcu.customer_unit_id = cs.customer_unit_id
         inner join com_service_unit_value csuv on cs.com_service_id = csuv.com_service_id
         inner join com_service_data csd on csuv.com_service_unit_value_id = csd.com_service_unit_value_id
         inner join provider_service_data_type psdt on csd.provider_service_data_type_id = psdt.provider_service_data_type_id
         inner join provider_service_category psc on psdt.provider_service_category_id = psc.provider_service_category_id
         inner join provider_system ps on psc.provider_system_id = ps.provider_system_id
         inner join customer_unit_type parent_type on ps.provider_system_id = parent_type.provider_system_id
         inner join customer_unit parent_unit on cs.customer_unit_id = parent_unit.customer_unit_id
         inner join join_customer_unit_type_customer_unit parent_join on parent_type.customer_unit_type_id = parent_join.customer_unit_type_id
                                                                      and parent_join.customer_unit_id = parent_unit.customer_unit_id
         inner join member_group mg on jmgcu.member_group_id = mg.member_group_id
         inner join member_group_type mgt on mg.member_group_type_id = mgt.member_group_type_id'

   set @innerWhere = char(13) + '
      where mg.member_group_id = ' + cast(@GroupId as varchar(10)) + '
        and psc.provider_service_category_id = ' + cast(@CategoryId as varchar(10)) + '
        and cs.com_service_date >= ''' + convert(varchar(10), @StartDate, 01) + '''
        and cs.com_service_date <= ''' + convert(varchar(10), @EndDate, 01) + ''''

   if @GroupType = 0 begin
        set @groupSelect = char(13) + ' and ( ( mgt.member_id = ps.provider_id ) or ( mgt.member_id = parent_unit.customer_id ) )'
   end

   else if @GroupType = 1 begin
        set @groupSelect = char(13) + ' and ( mgt.member_id = ps.provider_id ) '
   end

   else if @GroupType = 2 begin
        set @groupSelect = char(13) + ' and ( mgt.member_id = parent_unit.customer_id ) '
   end

   set @outerSelect = char(13) + '
   select psv.provider_service_value_id, isnull(psv.provider_service_value, tpsv.provider_service_value) as provider_service_value, isnull(psv.provider_service_value_text, tpsv.provider_service_value_text) as provider_service_value_text
   from provider_service_value psv
   left outer join template_provider_service_value tpsv on psv.template_provider_service_value_id = tpsv.provider_service_value_id
   where psv.provider_service_value_id in ( ' + @innerSelect + @innerWhere + @groupSelect + ' )'

   exec(@outerSelect)

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetServiceValuesByProviderSystemId' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetServiceValuesByProviderSystemId

   go

create procedure spGetServiceValuesByProviderSystemId( @ProviderSystemId integer ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   set nocount on

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   select psv.provider_service_value_id,
          IsNull( psv.provider_service_value,      tpsv.provider_service_value      ) as provider_service_value,
          IsNull( psv.provider_service_value_text, tpsv.provider_service_value_text ) as provider_service_value_text
   from dbo.provider_service_value psv
   left outer join dbo.template_provider_service_value tpsv on psv.template_provider_service_value_id = tpsv.provider_service_value_id
   where psv.provider_system_id = @ProviderSystemId

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetServiceValuesByTechnicianCategoryDateRange' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetServiceValuesByTechnicianCategoryDateRange

   go

create procedure spGetServiceValuesByTechnicianCategoryDateRange( @TechnicianId integer,
                                                                  @CategoryId   integer,
                                                                  @StartDate    datetime,
                                                                  @EndDate      datetime,
                                                                  @GroupType    integer = 00 ) as

   declare @outerSelect varchar( 4000 )
   declare @innerSelect varchar( 4000 )
   declare @innerWhere  varchar( 4000 )
   declare @groupSelect varchar( 4000 )

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   set nocount on

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   set @innerSelect = char(13) + '
      select csuv.provider_service_value_id
      from join_member_group_customer_unit jmgcu
         inner join com_service cs on jmgcu.customer_unit_id = cs.customer_unit_id
         inner join com_service_unit_value csuv on cs.com_service_id = csuv.com_service_id
         inner join com_service_data csd on csuv.com_service_unit_value_id = csd.com_service_unit_value_id
         inner join provider_service_data_type psdt on csd.provider_service_data_type_id = psdt.provider_service_data_type_id
         inner join provider_service_category psc on psdt.provider_service_category_id = psc.provider_service_category_id
         inner join provider_system ps on psc.provider_system_id = ps.provider_system_id
         inner join customer_unit_type parent_type on ps.provider_system_id = parent_type.provider_system_id
         inner join customer_unit parent_unit on cs.customer_unit_id = parent_unit.customer_unit_id
         inner join join_customer_unit_type_customer_unit parent_join on parent_type.customer_unit_type_id = parent_join.customer_unit_type_id
                                                                      and parent_join.customer_unit_id = parent_unit.customer_unit_id
         inner join member_group mg on jmgcu.member_group_id = mg.member_group_id
         inner join member_group_type mgt on mg.member_group_type_id = mgt.member_group_type_id'

   set @innerWhere = char(13) + '
      where ' + /* cs.technician_id = ' + cast(@TechnicianId as varchar(10)) + '
        and */ ' psc.provider_service_category_id = ' + cast(@CategoryId as varchar(10)) + '
        and cs.com_service_date >= ''' + convert(varchar(10), @StartDate, 01) + '''
        and cs.com_service_date <= ''' + convert(varchar(10), @EndDate, 01) + ''''

   if @GroupType = 0 begin
        set @groupSelect = char(13) + ' and ( ( mgt.member_id = ps.provider_id ) or ( mgt.member_id = parent_unit.customer_id ) )'
   end

   else if @GroupType = 1 begin
        set @groupSelect = char(13) + ' and ( mgt.member_id = ps.provider_id ) '
   end

   else if @GroupType = 2 begin
        set @groupSelect = char(13) + ' and ( mgt.member_id = parent_unit.customer_id ) '
   end

   set @outerSelect = char(13) + '
   select psv.provider_service_value_id, isnull(psv.provider_service_value, tpsv.provider_service_value) as provider_service_value, isnull(psv.provider_service_value_text, tpsv.provider_service_value_text) as provider_service_value_text
   from provider_service_value psv
   left outer join template_provider_service_value tpsv on psv.template_provider_service_value_id = tpsv.provider_service_value_id
   where psv.provider_service_value_id in ( ' + @innerSelect + @innerWhere + @groupSelect + ' )'

   exec(@outerSelect)

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetServiceValuesByUnitTypeCustomer' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetServiceValuesByUnitTypeCustomer

   go

create procedure spGetServiceValuesByUnitTypeCustomer( @CustomerId         integer,
                                                       @CustomerUnitTypeId integer,
                                                       @StartDate          datetime,
                                                       @EndDate            datetime ) as

   set nocount on

   create table #TEMP_UNIT( CUSTOMER_UNIT_ID integer,
                            TOP_PARENT_UNIT_ID integer,
                            UNIT_NAME varchar(100),
                            UNIT_TYPE_NAME varchar(50),
                            PARENT_UNIT_NAME varchar(100),
                            PARENT_UNIT_TYPE_NAME varchar(50) )

   declare @CustomerUnitId integer
   declare @CustomerUnitName varchar(100)
   declare @CustomerUnitTypeName varchar(50)

   declare @ProviderSystemName varchar(100)
   declare @ProviderSystemId integer
   declare @MemberName varchar(100)

   declare @ChildUnitTypeId integer
   declare @ParentUnitTypeId integer
   declare @RowCount integer

   declare @UnitTypeIds varchar(500)
   declare @FindUnitTypeId integer
   declare @Pos integer
   declare @UnitTypeName varchar(50)
   declare @UnitCount integer

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   set @ChildUnitTypeId = @CustomerUnitTypeId
   set @UnitTypeIds     = ''

     /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   while (@ChildUnitTypeId > 0) begin

      select @ParentUnitTypeId = customer_unit_type_parent_id
      from customer_unit_type
      where customer_unit_type_id = @ChildUnitTypeId

      /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
      select @ErrorCode = @@Error

      /* If there was an error... */
      if ( @ErrorCode <> 00 ) begin

         /* Rollback the transaction. */
         rollback transaction

         /* Return the failure. */
         return 01

      end

      if @UnitTypeIds <> ''
         set @UnitTypeIds = CAST( @ChildUnitTypeId as varchar(10) ) + ',' + @UnitTypeIds
      else
         set @UnitTypeIds = CAST( @ChildUnitTypeId as varchar(10) ) + ','

      set @ChildUnitTypeId = @ParentUnitTypeId

   end

   if @UnitTypeIds <> '' begin
      set @Pos = CHARINDEX(',',@UnitTypeIds)
      set @FindUnitTypeId = CAST( SUBSTRING(@UnitTypeIds, 1, @Pos-1 )  as integer )
      set @UnitTypeIds = SUBSTRING(@UnitTypeIds, @Pos+1, LEN(@UnitTypeIds) - @Pos )
   end

   select @ProviderSystemId = ps.PROVIDER_SYSTEM_ID,
          @ProviderSystemName = ISNULL(ps.PROVIDER_SYSTEM_NAME, tps.PROVIDER_SYSTEM_NAME ),
          @UnitTypeName = ISNULL( cut.CUSTOMER_UNIT_TYPE_NAME, tpcut.CUSTOMER_UNIT_TYPE_NAME )
   from dbo.customer_unit_type cut
   inner join dbo.PROVIDER_SYSTEM ps on cut.provider_system_id = ps.PROVIDER_SYSTEM_ID
   left outer join dbo.TEMPLATE_PROVIDER_SYSTEM tps on ps.TEMPLATE_PROVIDER_SYSTEM_ID = tps.PROVIDER_SYSTEM_ID
   left outer join dbo.TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE tpcut on cut.template_provider_customer_unit_type_id = tpcut.CUSTOMER_UNIT_TYPE_ID
   where cut.customer_unit_type_id = @CustomerUnitTypeId

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   select @MemberName = member_name from member where member_id = @CustomerId

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   declare @TopParentUnitTable table (TopParentUnitId integer, TopParentUnitName varchar(100), TopParentUnitTypeName varchar(50))

   declare main_cursor cursor local fast_forward for

   select cu.customer_unit_id,
          ISNULL( cu.CUSTOMER_UNIT_NAME,   ISNULL( cun.CUSTOMER_UNIT_NAME,   tpcun.CUSTOMER_UNIT_NAME   ) ) as CUSTOMER_UNIT_NAME,
          ISNULL( cut.CUSTOMER_UNIT_TYPE_NAME, tpcut.CUSTOMER_UNIT_TYPE_NAME ) as CUSTOMER_UNIT_TYPE_NAME
   from customer_unit cu
   inner join dbo.JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT jcutcu on ( cu.CUSTOMER_UNIT_ID = jcutcu.CUSTOMER_UNIT_ID )
                                                               and ( jcutcu.CUSTOMER_UNIT_TYPE_ID = @FindUnitTypeId )
   inner join dbo.CUSTOMER_UNIT_TYPE cut on cut.customer_unit_type_id = jcutcu.customer_unit_type_id
   left outer join dbo.CUSTOMER_UNIT_NAME cun on jcutcu.CUSTOMER_UNIT_NAME_ID = cun.CUSTOMER_UNIT_NAME_ID
   left outer join dbo.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME tpcun on cun.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME_ID = tpcun.CUSTOMER_UNIT_NAME_ID
   left outer join dbo.TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE tpcut on cut.template_provider_customer_unit_type_id = tpcut.CUSTOMER_UNIT_TYPE_ID
   where cu.customer_id = @CustomerId and unit_parent_id = -1

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   open main_cursor fetch next from main_cursor into @CustomerUnitId,
                                                     @CustomerUnitName,
                                                     
@CustomerUnitTypeName

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   while ( @@Fetch_Status = 0 ) begin

      /*insert the top parent row to get its name and type */
      insert into @TopParentUnitTable
      values(@CustomerUnitId,
             @CustomerUnitName,
             @CustomerUnitTypeName)

      if @UnitTypeIds <> '' begin
         set @Pos = CHARINDEX(',',@UnitTypeIds)
         set @FindUnitTypeId = CAST( SUBSTRING(@UnitTypeIds, 1, @Pos-1 )  as integer )

         /*get children of the next unit type in the hierarchy */
         select @RowCount = count(*)
         from dbo.CUSTOMER_UNIT CU
         inner join dbo.JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT jcutcu on cu.CUSTOMER_UNIT_ID = jcutcu.CUSTOMER_UNIT_ID
         where cu.UNIT_PARENT_ID          = @CustomerUnitId
         and jcutcu.CUSTOMER_UNIT_TYPE_ID = @FindUnitTypeId

         if @RowCount > 0 begin
            /* pass the top parent, the unit type looking for and the other unit types looking for, the unit type the the user picked */
            execute spGetCustomerUnitsByUnitType @CustomerUnitId, @CustomerUnitId, @FindUnitTypeId, @UnitTypeIds, @CustomerUnitTypeId
         end

      end

      else begin

         insert into #TEMP_UNIT
         values(@CustomerUnitId,
                @CustomerUnitId,
                @CustomerUnitName,
                @CustomerUnitTypeName,
                @CustomerUnitName,
                @CustomerUnitTypeName )

      end

      fetch next from main_cursor into @CustomerUnitId,
                                       @CustomerUnitName,
                                       @CustomerUnitTypeName

   end

   close main_cursor
   deallocate main_cursor

   select @UnitCount = count(*) FROM dbo.#TEMP_UNIT

   select @ProviderSystemName as PROVIDER_SYSTEM_NAME,
          @MemberName as MEMBER_NAME,
          @UnitTypeName as UNIT_TYPE,
          isnull(psv.provider_service_value, tpsv.provider_service_value) as SERVICE_VALUE,
          isnull(psv.provider_service_value_text,
          tpsv.provider_service_value_text) as SERVICE_VALUE_TEXT,
          count(csuv.provider_service_value_id) as SERVICE_VALUE_COUNT,
          @UnitCount as TOTAL_UNITS_SERVICED
   from com_service_unit_value csuv
   inner join dbo.#TEMP_UNIT tu on csuv.customer_unit_id = tu.customer_unit_id
   inner join com_service cs on csuv.com_service_id = cs.com_service_id and
   ( (cs.com_service_date >= @StartDate) and (cs.com_service_date <= @EndDate + 1) )

   right outer join provider_service_value psv on psv.provider_system_id = @ProviderSystemId and
                                  csuv.provider_service_value_id = psv.provider_service_value_id

   left outer join template_provider_service_value tpsv on psv.template_provider_service_value_id = tpsv.provider_service_value_id

   where psv.provider_system_id = @ProviderSystemId

   group by

            tu.unit_type_name,
            isnull(psv.provider_service_value, tpsv.provider_service_value),
            isnull(psv.provider_service_value_text,
            tpsv.provider_service_value_text)

   order by isnull(psv.provider_service_value, tpsv.provider_service_value)

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetServiceValuesByUnitTypeGroup' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetServiceValuesByUnitTypeGroup

   go

create procedure spGetServiceValuesByUnitTypeGroup( @GroupId            integer,
                                                    @CustomerUnitTypeId integer,
                                                    @StartDate          datetime,
                                                    @EndDate            datetime ) as

   set nocount on

   create table #TEMP_UNIT( CUSTOMER_UNIT_ID integer,
                            TOP_PARENT_UNIT_ID integer,
                            UNIT_NAME varchar(100),
                            UNIT_TYPE_NAME varchar(50),
                            PARENT_UNIT_NAME varchar(100),
                            PARENT_UNIT_TYPE_NAME varchar(50) )

   declare @CustomerUnitId integer
   declare @CustomerUnitName varchar(100)
   declare @CustomerUnitTypeName varchar(50)

   declare @ProviderSystemName varchar(100)
   declare @ProviderSystemId integer

   declare @ChildUnitTypeId integer
   declare @ParentUnitTypeId integer
   declare @RowCount integer

   declare @UnitTypeIds varchar(500)
   declare @FindUnitTypeId integer
   declare @Pos integer

   declare @GroupType varchar(50)
   declare @GroupName varchar(50)
   declare @UnitTypeName varchar(50)
   declare @UnitCount integer

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */
   declare @ReturnCode   integer /* Result code returned by the execution of the stored procedure */

   set @ChildUnitTypeId = @CustomerUnitTypeId
   set @UnitTypeIds     = ''

    /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   while (@ChildUnitTypeId > 0) begin

      select @ParentUnitTypeId = customer_unit_type_parent_id
      from customer_unit_type
      where customer_unit_type_id = @ChildUnitTypeId

       /* Get the error code for the previous statement.
         Error checking MUST be done this way since any single statement executed
         will affect both of the global functions,  @@Error. */
      select @ErrorCode = @@Error

      /* If there was an error... */
      if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

      if @UnitTypeIds <> ''
         set @UnitTypeIds = CAST( @ChildUnitTypeId as varchar(10) ) + ',' + @UnitTypeIds
      else
         set @UnitTypeIds = CAST( @ChildUnitTypeId as varchar(10) ) + ','

      set @ChildUnitTypeId = @ParentUnitTypeId

   end

   if @UnitTypeIds <> '' begin
      set @Pos = CHARINDEX(',',@UnitTypeIds)
      set @FindUnitTypeId = CAST( SUBSTRING(@UnitTypeIds, 1, @Pos-1 )  as integer )
      set @UnitTypeIds = SUBSTRING(@UnitTypeIds, @Pos+1, LEN(@UnitTypeIds) - @Pos )
   end

   select @ProviderSystemId = ps.PROVIDER_SYSTEM_ID,
          @ProviderSystemName = ISNULL(ps.PROVIDER_SYSTEM_NAME, tps.PROVIDER_SYSTEM_NAME ),
          @UnitTypeName = ISNULL( cut.CUSTOMER_UNIT_TYPE_NAME, tpcut.CUSTOMER_UNIT_TYPE_NAME )
   from dbo.customer_unit_type cut
   inner join dbo.PROVIDER_SYSTEM ps on cut.provider_system_id = ps.PROVIDER_SYSTEM_ID
   left outer join dbo.TEMPLATE_PROVIDER_SYSTEM tps on ps.TEMPLATE_PROVIDER_SYSTEM_ID = tps.PROVIDER_SYSTEM_ID
   left outer join dbo.TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE tpcut on cut.template_provider_customer_unit_type_id = tpcut.CUSTOMER_UNIT_TYPE_ID
   where cut.customer_unit_type_id = @CustomerUnitTypeId

    /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   select @GroupType = mgt.member_group_type_name,
          @GroupName = mg.member_group_name from
          dbo.member_group mg
   inner join dbo.member_group_type mgt
   on mg.member_group_type_id = mgt.member_group_type_id
   where mg.member_group_id = @GroupId

    /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   declare @TopParentUnitTable table (TopParentUnitId integer, TopParentUnitName varchar(100), TopParentUnitTypeName varchar(50))

   declare main_cursor cursor local fast_forward for

   select cu.customer_unit_id,
          ISNULL( cu.CUSTOMER_UNIT_NAME,   ISNULL( cun.CUSTOMER_UNIT_NAME,   tpcun.CUSTOMER_UNIT_NAME   ) ) as CUSTOMER_UNIT_NAME,
          ISNULL( cut.CUSTOMER_UNIT_TYPE_NAME, tpcut.CUSTOMER_UNIT_TYPE_NAME ) as CUSTOMER_UNIT_TYPE_NAME
   from customer_unit cu
   inner join dbo.JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT jcutcu on ( cu.CUSTOMER_UNIT_ID = jcutcu.CUSTOMER_UNIT_ID )
                                                               and ( jcutcu.CUSTOMER_UNIT_TYPE_ID = @FindUnitTypeId )
   inner join dbo.CUSTOMER_UNIT_TYPE cut on cut.customer_unit_type_id = jcutcu.customer_unit_type_id
   left outer join dbo.CUSTOMER_UNIT_NAME cun on jcutcu.CUSTOMER_UNIT_NAME_ID = cun.CUSTOMER_UNIT_NAME_ID
   left outer join dbo.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME tpcun on cun.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME_ID = tpcun.CUSTOMER_UNIT_NAME_ID
   left outer join dbo.TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE tpcut on cut.template_provider_customer_unit_type_id = tpcut.CUSTOMER_UNIT_TYPE_ID
   inner join dbo.JOIN_MEMBER_GROUP_CUSTOMER_UNIT jmgcu on cu.CUSTOMER_UNIT_ID = jmgcu.CUSTOMER_UNIT_ID

   where unit_parent_id = -1
   and jmgcu.MEMBER_GROUP_ID = @GroupId

    /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   open main_cursor fetch next from main_cursor into @CustomerUnitId,
                                                     @CustomerUnitName,
                                                     @CustomerUnitTypeName

    /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   while ( @@Fetch_Status = 0 ) begin

      /*insert the top parent row to get its name and type */
      insert into @TopParentUnitTable
      values(@CustomerUnitId,
             @CustomerUnitName,
             @CustomerUnitTypeName)

      if @UnitTypeIds <> '' begin
         set @Pos = CHARINDEX(',',@UnitTypeIds)
         set @FindUnitTypeId = CAST( SUBSTRING(@UnitTypeIds, 1, @Pos-1 )  as integer )

         /*get children of the next unit type in the hierarchy */
         select @RowCount = count(*)
         from dbo.CUSTOMER_UNIT CU
         inner join dbo.JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT jcutcu on cu.CUSTOMER_UNIT_ID = jcutcu.CUSTOMER_UNIT_ID
         where cu.UNIT_PARENT_ID          = @CustomerUnitId
         and jcutcu.CUSTOMER_UNIT_TYPE_ID = @FindUnitTypeId

         /* Get the error code for the previous statement.
          Error checking MUST be done this way since any single statement executed
          will affect both of the global functions,  @@Error. */
         select @ErrorCode = @@Error

         /* If there was an error... */
         if ( @ErrorCode <> 00 ) begin

            /* Rollback the transaction. */
            rollback transaction

           /* Return the failure. */
            return 01

         end

         if @RowCount > 0 begin
            /* pass the top parent, the unit type looking for and the other unit types looking for, the unit type the the user picked */
            execute @ReturnCode = spGetCustomerUnitsByUnitType @CustomerUnitId, @CustomerUnitId, @FindUnitTypeId, @UnitTypeIds, @CustomerUnitTypeId

            /* If there was an error... */
            if ( @ReturnCode <> 00 ) begin

               /* Return the failure. */
               return @ReturnCode

            end

         end

      end

      else begin

        insert into #TEMP_UNIT
        values(@CustomerUnitId,
               @CustomerUnitId,
               @CustomerUnitName,
               @CustomerUnitTypeName,
               @CustomerUnitName,
               @CustomerUnitTypeName )

      end

      fetch next from main_cursor into @CustomerUnitId,
                                       @CustomerUnitName,
                                       @CustomerUnitTypeName

   end

   close main_cursor
   deallocate main_cursor

   select @UnitCount = count(*) FROM dbo.#TEMP_UNIT

   select @ProviderSystemName as PROVIDER_SYSTEM_NAME,
          @UnitTypeName as UNIT_TYPE,
          isnull(psv.provider_service_value, tpsv.provider_service_value) as SERVICE_VALUE,
          isnull(psv.provider_service_value_text,
          tpsv.provider_service_value_text) as SERVICE_VALUE_TEXT,
          count(csuv.provider_service_value_id) as SERVICE_VALUE_COUNT,
          @UnitCount as TOTAL_UNITS_SERVICED,
          @GroupType as MEMBER_GROUP_TYPE_NAME,
          @GroupName as MEMBER_GROUP_NAME

   from com_service_unit_value csuv
   inner join com_service cs on csuv.com_service_id = cs.com_service_id and
   ( (cs.com_service_date >= @StartDate) and (cs.com_service_date <= @EndDate + 1) )
   inner join dbo.#TEMP_UNIT tu on csuv.customer_unit_id = tu.customer_unit_id
   right outer join provider_service_value psv on psv.provider_system_id = @ProviderSystemId and csuv.provider_service_value_id = psv.provider_service_value_id
   left outer join template_provider_service_value tpsv on psv.template_provider_service_value_id = tpsv.provider_service_value_id

   where psv.provider_system_id = @ProviderSystemId

   group by

             tu.unit_type_name,
             isnull(psv.provider_service_value, tpsv.provider_service_value),
             isnull(psv.provider_service_value_text,
             tpsv.provider_service_value_text)

   order by isnull(psv.provider_service_value, tpsv.provider_service_value)

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetServiceValuesByUnitTypeParent' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetServiceValuesByUnitTypeParent

   go

create procedure spGetServiceValuesByUnitTypeParent( @CustomerUnitId     integer,
                                                     @CustomerUnitTypeId integer,
                                                     @StartDate          datetime,
                                                     @EndDate            datetime ) as

   set nocount on

   create table #TEMP_UNIT( CUSTOMER_UNIT_ID integer,
                            TOP_PARENT_UNIT_ID integer,
                            UNIT_NAME varchar(100),

                            UNIT_TYPE_NAME varchar(50),
                            PARENT_UNIT_NAME varchar(100),
                            PARENT_UNIT_TYPE_NAME varchar(50) )

   declare @UnitId integer
   declare @CustomerUnitName varchar(100)
   declare @CustomerUnitTypeName varchar(50)

   declare @ProviderSystemName varchar(100)
   declare @ProviderSystemId integer
   declare @MemberName varchar(100)

   declare @CustomerId integer

   declare @ChildUnitTypeId integer
   declare @ParentUnitTypeId integer
   declare @RowCount integer

   declare @UnitTypeIds varchar(500)
   declare @FindUnitTypeId integer
   declare @Pos integer
   declare @UnitTypeName varchar(50)
   declare @UnitCount integer

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */
   declare @ReturnCode   integer /* Result code returned by the execution of the stored procedure */

   set @ChildUnitTypeId = @CustomerUnitTypeId
   set @UnitTypeIds     = ''

    /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   while (@ChildUnitTypeId > 0) begin

      select @ParentUnitTypeId = customer_unit_type_parent_id
      from customer_unit_type
      where customer_unit_type_id = @ChildUnitTypeId

      /* Get the error code for the previous statement.
         Error checking MUST be done this way since any single statement executed
         will affect both of the global functions,  @@Error. */
      select @ErrorCode = @@Error

      /* If there was an error... */
      if ( @ErrorCode <> 00 ) begin

         /* Rollback the transaction. */
         rollback transaction

         /* Return the failure. */
         return 01

      end

      if @UnitTypeIds <> ''
         set @UnitTypeIds = CAST( @ChildUnitTypeId as varchar(10) ) + ',' + @UnitTypeIds
      else
         set @UnitTypeIds = CAST( @ChildUnitTypeId as varchar(10) ) + ','

      set @ChildUnitTypeId = @ParentUnitTypeId

   end

   if @UnitTypeIds <> '' begin
      set @Pos = CHARINDEX(',',@UnitTypeIds)
      set @FindUnitTypeId = CAST( SUBSTRING(@UnitTypeIds, 1, @Pos-1 )  as integer )
      set @UnitTypeIds = SUBSTRING(@UnitTypeIds, @Pos+1, LEN(@UnitTypeIds) - @Pos )
   end

   select @ProviderSystemId = ps.PROVIDER_SYSTEM_ID,
          @ProviderSystemName = ISNULL(ps.PROVIDER_SYSTEM_NAME, tps.PROVIDER_SYSTEM_NAME ),
          @UnitTypeName = ISNULL( cut.CUSTOMER_UNIT_TYPE_NAME, tpcut.CUSTOMER_UNIT_TYPE_NAME )
   from dbo.customer_unit_type cut
   inner join dbo.PROVIDER_SYSTEM ps on cut.provider_system_id = ps.PROVIDER_SYSTEM_ID
   left outer join dbo.TEMPLATE_PROVIDER_SYSTEM tps on ps.TEMPLATE_PROVIDER_SYSTEM_ID = tps.PROVIDER_SYSTEM_ID
   left outer join dbo.TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE tpcut on cut.template_provider_customer_unit_type_id = tpcut.CUSTOMER_UNIT_TYPE_ID
   where cut.customer_unit_type_id = @CustomerUnitTypeId

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* get the customer name from the parent unit passed in */
   select @MemberName = m.member_name,
          @CustomerId = m.member_id from member m
   inner join customer_unit cu on cu.customer_id = m.member_id
   where cu.customer_unit_id = @CustomerUnitId

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   declare @TopParentUnitTable table (TopParentUnitId integer, TopParentUnitName varchar(100), TopParentUnitTypeName varchar(50))

   declare main_cursor cursor local fast_forward for

   select cu.customer_unit_id,
          ISNULL( cu.CUSTOMER_UNIT_NAME,   ISNULL( cun.CUSTOMER_UNIT_NAME,   tpcun.CUSTOMER_UNIT_NAME   ) ) as CUSTOMER_UNIT_NAME,
          ISNULL( cut.CUSTOMER_UNIT_TYPE_NAME, tpcut.CUSTOMER_UNIT_TYPE_NAME ) as CUSTOMER_UNIT_TYPE_NAME
   from customer_unit cu
   inner join dbo.JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT jcutcu on ( cu.CUSTOMER_UNIT_ID = jcutcu.CUSTOMER_UNIT_ID )
                                                               and ( jcutcu.CUSTOMER_UNIT_TYPE_ID = @FindUnitTypeId )
   inner join dbo.CUSTOMER_UNIT_TYPE cut on cut.customer_unit_type_id = jcutcu.customer_unit_type_id
   left outer join dbo.CUSTOMER_UNIT_NAME cun on jcutcu.CUSTOMER_UNIT_NAME_ID = cun.CUSTOMER_UNIT_NAME_ID
   left outer join dbo.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME tpcun on cun.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME_ID = tpcun.CUSTOMER_UNIT_NAME_ID
   left outer join dbo.TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE tpcut on cut.template_provider_customer_unit_type_id = tpcut.CUSTOMER_UNIT_TYPE_ID
   where cu.customer_unit_id = @CustomerUnitId and cu.unit_parent_id = -1

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   open main_cursor fetch next from main_cursor into @UnitId,
                                                     @CustomerUnitName,
                                                     @CustomerUnitTypeName

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   while ( @@Fetch_Status = 0 ) begin

      /*insert the top parent row to get its name and type */
         insert into @TopParentUnitTable
         values(@UnitId,
                @CustomerUnitName,
                @CustomerUnitTypeName)

      if @UnitTypeIds <> '' begin
         set @Pos = CHARINDEX(',',@UnitTypeIds)
         set @FindUnitTypeId = CAST( SUBSTRING(@UnitTypeIds, 1, @Pos-1 )  as integer )

         /*get children of the next unit type in the hierarchy */
         select @RowCount = count(*)
         from dbo.CUSTOMER_UNIT CU
         inner join dbo.JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT jcutcu on cu.CUSTOMER_UNIT_ID = jcutcu.CUSTOMER_UNIT_ID
         where cu.UNIT_PARENT_ID          = @UnitId
         and jcutcu.CUSTOMER_UNIT_TYPE_ID = @FindUnitTypeId

         /* Get the error code for the previous statement.
         Error checking MUST be done this way since any single statement executed
         will affect both of the global functions,  @@Error. */
         select @ErrorCode = @@Error

         /* If there was an error... */
         if ( @ErrorCode <> 00 ) begin

            /* Rollback the transaction. */
            rollback transaction

            /* Return the failure. */
            return 01

         end

         if @RowCount > 0 begin
            /* pass the top parent, the unit type looking for and the other unit types looking for, the unit type the the user picked */
            execute @ReturnCode = spGetCustomerUnitsByUnitType @UnitId, @UnitId, @FindUnitTypeId, @UnitTypeIds, @CustomerUnitTypeId
            /* If there was an error... */
            if ( @ReturnCode <> 00 ) begin

               /* Return the failure. */
               return @ReturnCode

            end

         end

      end

      else begin

           insert into #TEMP_UNIT
           values(@UnitId,
                  @UnitId,
                  @CustomerUnitName,
                  @CustomerUnitTypeName,
                  @CustomerUnitName,
                  @CustomerUnitTypeName )

      end

      fetch next from main_cursor into @UnitId,
                                       @CustomerUnitName,
                                       @CustomerUnitTypeName

   end

   close main_cursor
   deallocate main_cursor

   select @UnitCount = count(*) FROM dbo.#TEMP_UNIT

   select @ProviderSystemName as PROVIDER_SYSTEM_NAME,
          @MemberName as MEMBER_NAME,
          @UnitTypeName as UNIT_TYPE,
          isnull(psv.provider_service_value, tpsv.provider_service_value) as SERVICE_VALUE,
          isnull(psv.provider_service_value_text,
          tpsv.provider_service_value_text) as SERVICE_VALUE_TEXT,
          count(csuv.provider_service_value_id) as SERVICE_VALUE_COUNT,
          @UnitCount as TOTAL_UNITS_SERVICED,
          @CustomerUnitName as TOP_PARENT_UNIT_NAME,
          @CustomerUnitTypeName as TOP_PARENT_UNIT_TYPE_NAME

   from com_service_unit_value csuv
   inner join com_service cs on csuv.com_service_id = cs.com_service_id and
   ( (cs.com_service_date >= @StartDate) and (cs.com_service_date <= @EndDate + 1) )
   inner join dbo.#TEMP_UNIT tu on csuv.customer_unit_id = tu.customer_unit_id
   right outer join provider_service_value psv on psv.provider_system_id = @ProviderSystemId and
                                  csuv.provider_service_value_id = psv.provider_service_value_id
   left outer join template_provider_service_value tpsv on psv.template_provider_service_value_id = tpsv.provider_service_value_id
   where psv.provider_system_id = @ProviderSystemId
   group by tu.unit_type_name,
            isnull(psv.provider_service_value, tpsv.provider_service_value),
            isnull(psv.provider_service_value_text,
            tpsv.provider_service_value_text)

   order by isnull(psv.provider_service_value, tpsv.provider_service_value)

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetSystemMessage' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetSystemMessage

   go

create procedure spGetSystemMessage( @ProviderSystemId integer ) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   -- new procedure
   execute @ReturnCode = spGetContactInfoForEntityByType @ProviderSystemId,
                                                         6,
                                                         14
   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetSystemUnits' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetSystemUnits

   go

create procedure spGetSystemUnits( @ProviderSystemId integer,
                                   @parentid         integer=-1 ) as

   CREATE TABLE #temp_unit (
   CUSTOMER_UNIT_TYPE_ID integer,
   UNIT_TYPE_PARENT_ID integer,
   UNIT_TYPE_TOP_PARENT_ID integer,
   CUSTOMER_UNIT_TYPE_NAME varchar(50),
   CUSTOMER_UNIT_NAME varchar(50),
   CUSTOMER_UNIT_NUMBER varchar(10))

   declare @unittypeid integer
   declare @unittypename varchar(50)
   declare @unitname varchar(50)
   declare @unitnumber varchar(10)

   declare UNIT_CURSOR cursor local for
   select c.CUSTOMER_UNIT_TYPE_ID,
          isnull( c.customer_unit_type_name, d.customer_unit_type_name ) as customer_unit_type_name,
          isnull( e.customer_unit_name, f.customer_unit_name ) as customer_unit_name,
          isnull( e.customer_unit_number, f.customer_unit_number ) as customer_unit_number
   from customer_unit_type c
   left outer join template_provider_customer_unit_type d on c.template_provider_customer_unit_type_id = d.customer_unit_type_id
   left outer join customer_unit_name e on c.customer_unit_type_id = e.customer_unit_type_id
   left outer join template_provider_customer_unit_name f on e.template_provider_customer_unit_name_id = f.customer_unit_name_id
   where c.provider_system_id = @ProviderSystemId
   and c.customer_unit_type_parent_id = @parentid

   OPEN UNIT_CURSOR
   FETCH NEXT FROM UNIT_CURSOR INTO
   @unittypeid,
   @unittypename,
   @unitname,
   @unitnumber

   WHILE ( @@FETCH_STATUS = 0 ) BEGIN

      insert into #temp_unit
      VALUES(
      @unittypeid,
      -1,
      -1,
      @unittypename,
      @unitname,
      @unitnumber)

      EXEC spGetSystemUnitsByParent @ProviderSystemId, @unittypeid, @unittypeid

      FETCH NEXT FROM UNIT_CURSOR INTO
      @unittypeid,
      @unittypename,
      @unitname,
      @unitnumber

   END

   CLOSE UNIT_CURSOR
   DEALLOCATE UNIT_CURSOR

   SELECT
   PROVIDER_SYSTEM_ID = @ProviderSystemId,
   CUSTOMER_UNIT_TYPE_ID,
   UNIT_TYPE_PARENT_ID,
   UNIT_TYPE_TOP_PARENT_ID,
   CUSTOMER_UNIT_TYPE_NAME,
   CUSTOMER_UNIT_NAME,
   CUSTOMER_UNIT_NUMBER
   FROM #temp_unit

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetSystemUnitsByParent' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetSystemUnitsByParent

   go

create procedure spGetSystemUnitsByParent( @ProviderSystemId  integer,
                                           @parentid          integer,
                                           @topparentid       integer ) as

   declare @unittypeid integer
   declare @unittypename varchar(50)
   declare @unitname varchar(50)
   declare @unitnumber varchar(10)

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */
   declare @ReturnCode   integer /* Result code returned by the execution of the stored procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   declare CHILD_CURSOR cursor local for
   select c.CUSTOMER_UNIT_TYPE_ID,
          isnull( c.customer_unit_type_name, d.customer_unit_type_name ) as customer_unit_type_name,
          isnull( e.customer_unit_name, f.customer_unit_name ) as customer_unit_name,
          isnull( e.customer_unit_number, f.customer_unit_number ) as customer_unit_number
   from customer_unit_type c
   left outer join template_provider_customer_unit_type d on c.template_provider_customer_unit_type_id = d.customer_unit_type_id
   left outer join customer_unit_name e on c.customer_unit_type_id = e.customer_unit_type_id
   left outer join template_provider_customer_unit_name f on e.template_provider_customer_unit_name_id = f.customer_unit_name_id
   where c.provider_system_id = @ProviderSystemId
   and c.customer_unit_type_parent_id = @parentid

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   OPEN CHILD_CURSOR
   FETCH NEXT FROM CHILD_CURSOR INTO
   @unittypeid,
   @unittypename,
   @unitname,
   @unitnumber

   WHILE ( @@FETCH_STATUS = 0 ) BEGIN

      insert into #temp_unit
      VALUES(
      @unittypeid,
      @parentid,
      @topparentid,
      @unittypename,
      @unitname,
      @unitnumber)

     execute @ReturnCode = spGetSystemUnitsByParent @ProviderSystemId, @unittypeid, @topparentid

    /* If there was an error... */
    if ( @ReturnCode <> 00 ) begin

       /* Return the failure. */
       return @ReturnCode

    end

     FETCH NEXT FROM CHILD_CURSOR INTO
     @unittypeid,
     @unittypename,
     @unitname,
     @unitnumber

   END

   CLOSE CHILD_CURSOR
   DEALLOCATE CHILD_CURSOR

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetTechnicianDailyActivityByTechnicianId' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetTechnicianDailyActivityByTechnicianId

   go

create procedure spGetTechnicianDailyActivityByTechnicianId( @TechnicianId integer,
                                                             @StartDate    datetime,
                                                             @EndDate      datetime ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   set nocount on

    /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Retrieve the daily activity for the technician within the passed date
      range ordered by the service data and the start time for the service. */
   select cs.COM_SERVICE_ID,
          convert( varchar(10), cs.COM_SERVICE_DATE, 01 ) as COM_SERVICE_DATE,
          cs.CUSTOMER_CONTACT,
          cs.COM_SERVICE_COMMENT,
          convert( varchar(10), cs.TIME_IN,  08 ) as TIME_IN,
          convert( varchar(10), cs.TIME_OUT, 08 ) as TIME_OUT,
          mu.MEMBER_USER_FNAME                 as TECHNICIAN_FNAME,
          mu.MEMBER_USER_LNAME                 as TECHNICIAN_LNAME,
          m.MEMBER_NAME                        as CUSTOMER_NAME,
          cs.CUSTOMER_UNIT_ID                  as LOCATION_ID,
          IsNull( pcut.CUSTOMER_UNIT_TYPE_NAME,   tpcut.CUSTOMER_UNIT_TYPE_NAME                               ) as LOCATION_TYPE_NAME,
          IsNull( puv.CUSTOMER_UNIT_NAME,         IsNull( pcun.CUSTOMER_UNIT_NAME, tpcun.CUSTOMER_UNIT_NAME ) ) as LOCATION_NAME,
          IsNull( pst.PROVIDER_SERVICE_TYPE_TEXT, tpst.PROVIDER_SERVICE_TYPE_TEXT                             ) as PROVIDER_SERVICE_TYPE,
          IsNull( ps.PROVIDER_SYSTEM_NAME,        tps.PROVIDER_SYSTEM_NAME                                    ) as PROVIDER_SYSTEM_NAME
   from COM_SERVICE cs
        inner join      PROVIDER_SERVICE_TYPE pst                   on ( cs.PROVIDER_SERVICE_TYPE_ID                  = pst.PROVIDER_SERVICE_TYPE_ID   )
        left outer join TEMPLATE_PROVIDER_SERVICE_TYPE tpst         on ( pst.TEMPLATE_PROVIDER_SERVICE_TYPE_ID        = tpst.PROVIDER_SERVICE_TYPE_ID  )
        left outer join MEMBER_USER mu                              on ( cs.TECHNICIAN_ID                             = mu.MEMBER_USER_ID              )
        left outer join PROVIDER_SYSTEM ps                          on ( ps.PROVIDER_SYSTEM_ID                        = pst.PROVIDER_SYSTEM_ID         )
        left outer join TEMPLATE_PROVIDER_SYSTEM tps                on ( tps.PROVIDER_SYSTEM_ID                       = ps.TEMPLATE_PROVIDER_SYSTEM_ID )
        left outer join CUSTOMER_UNIT puv                           on ( cs.CUSTOMER_UNIT_ID                          = puv.CUSTOMER_UNIT_ID           ) and
                                                                       ( puv.UNIT_PARENT_ID                           = -1                             )
        inner join      JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT pjcut on ( puv.CUSTOMER_UNIT_ID                         = pjcut.CUSTOMER_UNIT_ID         )
        left outer join CUSTOMER_UNIT_NAME pcun                     on ( pjcut.CUSTOMER_UNIT_NAME_ID                  = pcun.CUSTOMER_UNIT_NAME_ID     )
        left outer join TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME tpcun  on ( pcun.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME_ID = tpcun.CUSTOMER_UNIT_NAME_ID    )
        left outer join CUSTOMER_UNIT_TYPE pcut                     on ( pjcut.CUSTOMER_UNIT_TYPE_ID                  = pcut.CUSTOMER_UNIT_TYPE_ID     )
        left outer join TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE tpcut  on ( pcut.TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE_ID = tpcut.CUSTOMER_UNIT_TYPE_ID    )
        inner join      MEMBER m                                    on ( m.MEMBER_ID                                  = puv.CUSTOMER_ID                )
   where ( cs.TECHNICIAN_ID    =  @TechnicianId ) and
         ( cs.COM_SERVICE_DATE >= @StartDate    ) and
         ( cs.COM_SERVICE_DATE <= @EndDate      )
   order by cs.COM_SERVICE_DATE,
            cs.TIME_IN

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetTechnicianDailyActivityByTechnicianName' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetTechnicianDailyActivityByTechnicianName

   go

create procedure spGetTechnicianDailyActivityByTechnicianName( @TechnicianFName varchar(25),
                                                               @TechnicianLName varchar(25),
                                                               @ProviderId      integer,
                                                               @StartDate       datetime,
                                                               @EndDate         datetime ) as

   declare @TechnicianId integer /* Identifier for the technician in the member user table */
   declare @ReturnCode   integer /* Result code returned by the execution of the stored procedure */
   declare @RowsAffected integer /* Number of rows affected by the previously executed statement */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */
   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Find the row idenifier for the technician in the member user table that
      matches the name passed and is a tech for the passed provider. */
   select @TechnicianId = MEMBER_USER_ID
   from MEMBER_USER
   where ( ( MEMBER_USER_FNAME = @TechnicianFName ) and
           ( MEMBER_USER_LNAME = @TechnicianLName ) and
           ( MEMBER_ID         = @ProviderId    ) )

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) and ( @RowsAffected <> 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   execute @ReturnCode = spGetTechnicianDailyActivityByTechnicianId @TechnicianId,
                                                                    @StartDate,
                                                                    @EndDate

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

    end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetTechnicianDailyActivityDetailByTechnicianId' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetTechnicianDailyActivityDetailByTechnicianId

   go

create procedure spGetTechnicianDailyActivityDetailByTechnicianId( @TechnicianId     integer,
                                                                   @StartDate        datetime,
                                                                   @EndDate          datetime,
                                                                   @ShowServicedOnly bit ) as

   /*
      spGetTechnicianDailyActivityDetailByTechnicianId.sql

      Get the completed services with station detail for a particular
      technician based on a date range.

      If ShowServicedOnly then only records for units which were serviced are
      returned (i.e. in where clause csuv.TimeStamp is not null).

      Records are ordered by Com_Service_Date, Com_Service_ID, Time_In
      (for service), TimeStamp (for unit)

      Parameters: TechnicianID, StartDate, EndDate, ShowServicedOnly
   */

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */
   declare @ReturnCode   integer /* Result code returned by the execution of the stored procedure */

   set nocount on

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   if ( @ShowServicedOnly > 00 ) begin

      /* Retrieve the daily activity for the technician within the passed date
         range ordered by the service data and the start time for the service. */
      /* Retrieve the daily activity for the technician within the passed date
         range ordered by the service data and the start time for the service. */
      select cs.COM_SERVICE_ID,
             convert( varchar(10), cs.COM_SERVICE_DATE, 01 ) as COM_SERVICE_DATE,
             cs.CUSTOMER_CONTACT,
             cs.COM_SERVICE_COMMENT,
             convert( varchar(10), cs.TIME_IN,  08 ) as TIME_IN,
             convert( varchar(10), cs.TIME_OUT, 08 ) as TIME_OUT,
             mu.MEMBER_USER_FNAME                 as TECHNICIAN_FNAME,
             mu.MEMBER_USER_LNAME                 as TECHNICIAN_LNAME,
             m.MEMBER_NAME                        as CUSTOMER_NAME,
             cs.CUSTOMER_UNIT_ID                  as LOCATION_ID,
             IsNull( pcut.CUSTOMER_UNIT_TYPE_NAME,   tpcut.CUSTOMER_UNIT_TYPE_NAME                               ) as LOCATION_TYPE_NAME,
             IsNull( puv.CUSTOMER_UNIT_NAME,         IsNull( pcun.CUSTOMER_UNIT_NAME, tpcun.CUSTOMER_UNIT_NAME ) ) as LOCATION_NAME,
             IsNull( ccut.CUSTOMER_UNIT_TYPE_NAME, tccut.CUSTOMER_UNIT_TYPE_NAME ) + ' : ' +
             IsNull( cuv.CUSTOMER_UNIT_NAME,         IsNull( ccun.CUSTOMER_UNIT_NAME, tccun.CUSTOMER_UNIT_NAME ) ) as UNIT_NAME,
             IsNull( pst.PROVIDER_SERVICE_TYPE_TEXT, tpst.PROVIDER_SERVICE_TYPE_TEXT                             ) as PROVIDER_SERVICE_TYPE,
             IsNull( ps.PROVIDER_SYSTEM_NAME,        tps.PROVIDER_SYSTEM_NAME                                    ) as PROVIDER_SYSTEM_NAME,
             Time_Stamp = case
                             when csuv.TimeStamp is null
                                then 'No scan'
                             else convert( varchar, csuv.TimeStamp, 08 )
                          end,
             Ranking    = case
                             when ( csuv.PROVIDER_SERVICE_VALUE_ID is null )
                                then 'Unit not ranked'
                             else cast( IsNull(psv.PROVIDER_SERVICE_VALUE, tpsv.PROVIDER_SERVICE_VALUE) as varchar ) + ' ' + IsNull(psv.PROVIDER_SERVICE_VALUE_TEXT, tpsv.PROVIDER_SERVICE_VALUE_TEXT)
                          end,
             IsNull(IsNull( cpcut.CUSTOMER_UNIT_TYPE_NAME, tcpcut.CUSTOMER_UNIT_TYPE_NAME ) + ' : ' +
             IsNull( cu.CUSTOMER_UNIT_NAME, IsNull( cpcun.CUSTOMER_UNIT_NAME, tcpcun.CUSTOMER_UNIT_NAME ) ), 'Top Parent') as CUSTOMER_UNIT_NAME
      from COM_SERVICE cs
           inner join      PROVIDER_SERVICE_TYPE pst                    on ( cs.PROVIDER_SERVICE_TYPE_ID                   = pst.PROVIDER_SERVICE_TYPE_ID   )
           left outer join TEMPLATE_PROVIDER_SERVICE_TYPE tpst          on ( pst.TEMPLATE_PROVIDER_SERVICE_TYPE_ID         = tpst.PROVIDER_SERVICE_TYPE_ID  )
           inner join MEMBER_USER mu                                    on ( cs.TECHNICIAN_ID                              = mu.MEMBER_USER_ID              )
           inner join PROVIDER_SYSTEM ps                                on ( ps.PROVIDER_SYSTEM_ID                         = pst.PROVIDER_SYSTEM_ID         )
           left outer join TEMPLATE_PROVIDER_SYSTEM tps                 on ( tps.PROVIDER_SYSTEM_ID                        = ps.TEMPLATE_PROVIDER_SYSTEM_ID )
           inner join CUSTOMER_UNIT puv                                 on ( cs.CUSTOMER_UNIT_ID                           = puv.CUSTOMER_UNIT_ID           ) and
                                                                           ( puv.UNIT_PARENT_ID                            = -1                             )
           inner join      JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT pjcut  on ( puv.CUSTOMER_UNIT_ID                          = pjcut.CUSTOMER_UNIT_ID         )
           left outer join CUSTOMER_UNIT_NAME pcun                      on ( pjcut.CUSTOMER_UNIT_NAME_ID                   = pcun.CUSTOMER_UNIT_NAME_ID     )
           left outer join TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME tpcun   on ( pcun.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME_ID  = tpcun.CUSTOMER_UNIT_NAME_ID    )
           inner join CUSTOMER_UNIT_TYPE pcut                           on ( pjcut.CUSTOMER_UNIT_TYPE_ID                   = pcut.CUSTOMER_UNIT_TYPE_ID     ) and
                                                                           ( pcut.PROVIDER_SYSTEM_ID = ps.PROVIDER_SYSTEM_ID                                )
           left outer join TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE tpcut   on ( pcut.TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE_ID  = tpcut.CUSTOMER_UNIT_TYPE_ID    )
           inner join      MEMBER m                                     on ( m.MEMBER_ID                                   =  puv.CUSTOMER_ID               )
           left outer join COM_SERVICE_UNIT_VALUE csuv                  on ( csuv.Com_Service_ID                           = cs.Com_Service_ID              )
           inner join CUSTOMER_UNIT cuv                                 on ( csuv.CUSTOMER_UNIT_ID                         = cuv.CUSTOMER_UNIT_ID           )
           inner join      JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT cjcut  on ( cuv.CUSTOMER_UNIT_ID                          = cjcut.CUSTOMER_UNIT_ID         )
           left outer join CUSTOMER_UNIT_NAME ccun                      on ( cjcut.CUSTOMER_UNIT_NAME_ID                   = ccun.CUSTOMER_UNIT_NAME_ID     )
           left outer join TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME tccun   on ( ccun.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME_ID  = tccun.CUSTOMER_UNIT_NAME_ID    )
           inner join CUSTOMER_UNIT_TYPE ccut                           on ( cjcut.CUSTOMER_UNIT_TYPE_ID                   = ccut.CUSTOMER_UNIT_TYPE_ID     ) and
                                                                           ( ccut.PROVIDER_SYSTEM_ID = ps.PROVIDER_SYSTEM_ID                                )
           left outer join TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE tccut   on ( ccut.TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE_ID  = tccut.CUSTOMER_UNIT_TYPE_ID    )
           left outer join      PROVIDER_SERVICE_VALUE psv              on ( csuv.Provider_Service_Value_ID                = psv.Provider_Service_Value_ID  )
           left outer join TEMPLATE_PROVIDER_SERVICE_VALUE tpsv         on ( psv.Template_Provider_Service_Value_ID        = tpsv.Provider_Service_Value_ID )
           left outer join CUSTOMER_UNIT cu                             on ( cuv.Unit_Parent_ID                            = cu.Customer_Unit_ID            )
           inner join JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT cpjcut      on ( cu.CUSTOMER_UNIT_ID                           = cpjcut.CUSTOMER_UNIT_ID        )
           left outer join CUSTOMER_UNIT_NAME cpcun                     on ( cpjcut.CUSTOMER_UNIT_NAME_ID                  = cpcun.CUSTOMER_UNIT_NAME_ID    )
           left outer join TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME tcpcun  on ( cpcun.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME_ID = tcpcun.CUSTOMER_UNIT_NAME_ID   )
           inner join CUSTOMER_UNIT_TYPE cpcut                          on ( cpjcut.CUSTOMER_UNIT_TYPE_ID                  = cpcut.CUSTOMER_UNIT_TYPE_ID    ) and
                                                                           ( cpcut.PROVIDER_SYSTEM_ID = ps.PROVIDER_SYSTEM_ID                               )
           left outer join TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE tcpcut  on ( cpcut.TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE_ID = tcpcut.CUSTOMER_UNIT_TYPE_ID   )
      where ( cs.TECHNICIAN_ID    =  @TechnicianId ) and
            ( cs.COM_SERVICE_DATE >= @StartDate    ) and
            ( cs.COM_SERVICE_DATE <= @EndDate      )
      order by cs.COM_SERVICE_DATE,
               cs.COM_SERVICE_ID,
               cs.TIME_IN,
               csuv.TIMESTAMP,
               cuv.UNIT_PARENT_ID

      /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
      select @ErrorCode = @@Error

      /* If there was an error... */
      if ( @ErrorCode <> 00 ) begin

         /* Rollback the transaction. */
         rollback transaction

         /* Return the failure. */
         return 01

      end

   end

   else begin

      declare @Service table (
         COM_SERVICE_ID integer,
         COM_SERVICE_DATE varchar(10),
         CUSTOMER_CONTACT varchar(25),
         COM_SERVICE_COMMENT varchar(255),
         TIME_IN varchar(10),
         TIME_OUT varchar(10),
         TECHNICIAN_FNAME varchar(25),
         TECHNICIAN_LNAME varchar(25),
         CUSTOMER_NAME varchar(100),
         LOCATION_ID integer,
         LOCATION_TYPE_NAME varchar(50),
         LOCATION_NAME varchar(100),
         PROVIDER_SERVICE_TYPE varchar(50),
         PROVIDER_SYSTEM_ID integer,
         PROVIDER_SYSTEM_NAME varchar(50) )

      /* Retrieve the daily activity for the technician within the passed date
         range ordered by the service data and the start time for the service. */
      insert into @Service
      select cs.COM_SERVICE_ID,
             convert( varchar(10), cs.COM_SERVICE_DATE, 01 ) as COM_SERVICE_DATE,
             cs.CUSTOMER_CONTACT,
             cs.COM_SERVICE_COMMENT,
             convert( varchar(10), cs.TIME_IN,  08 ) as TIME_IN,
             convert( varchar(10), cs.TIME_OUT, 08 ) as TIME_OUT,
             mu.MEMBER_USER_FNAME                 as TECHNICIAN_FNAME,
             mu.MEMBER_USER_LNAME                 as TECHNICIAN_LNAME,
             m.MEMBER_NAME                        as CUSTOMER_NAME,
             cs.CUSTOMER_UNIT_ID                  as LOCATION_ID,
             IsNull( pcut.CUSTOMER_UNIT_TYPE_NAME,   tpcut.CUSTOMER_UNIT_TYPE_NAME                               ) as LOCATION_TYPE_NAME,
             IsNull( puv.CUSTOMER_UNIT_NAME,         IsNull( pcun.CUSTOMER_UNIT_NAME, tpcun.CUSTOMER_UNIT_NAME ) ) as LOCATION_NAME,
             IsNull( pst.PROVIDER_SERVICE_TYPE_TEXT, tpst.PROVIDER_SERVICE_TYPE_TEXT                             ) as PROVIDER_SERVICE_TYPE,
             ps.PROVIDER_SYSTEM_ID,
             IsNull( ps.PROVIDER_SYSTEM_NAME,        tps.PROVIDER_SYSTEM_NAME                                    ) as PROVIDER_SYSTEM_NAME
      from COM_SERVICE cs
           inner join      PROVIDER_SERVICE_TYPE pst                    on ( cs.PROVIDER_SERVICE_TYPE_ID                   = pst.PROVIDER_SERVICE_TYPE_ID   )
           left outer join TEMPLATE_PROVIDER_SERVICE_TYPE tpst          on ( pst.TEMPLATE_PROVIDER_SERVICE_TYPE_ID         = tpst.PROVIDER_SERVICE_TYPE_ID  )
           inner join MEMBER_USER mu                               on ( cs.TECHNICIAN_ID                              = mu.MEMBER_USER_ID              )
           inner join PROVIDER_SYSTEM ps                           on ( ps.PROVIDER_SYSTEM_ID                         = pst.PROVIDER_SYSTEM_ID         )
           left outer join TEMPLATE_PROVIDER_SYSTEM tps                 on ( tps.PROVIDER_SYSTEM_ID                        = ps.TEMPLATE_PROVIDER_SYSTEM_ID )
           inner join CUSTOMER_UNIT puv                            on ( cs.CUSTOMER_UNIT_ID                           = puv.CUSTOMER_UNIT_ID           ) and
                                                                           ( puv.UNIT_PARENT_ID                            = -1                             )
           inner join      JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT pjcut  on ( puv.CUSTOMER_UNIT_ID                          = pjcut.CUSTOMER_UNIT_ID         )
           left outer join CUSTOMER_UNIT_NAME pcun                      on ( pjcut.CUSTOMER_UNIT_NAME_ID                   = pcun.CUSTOMER_UNIT_NAME_ID     )
           left outer join TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME tpcun   on ( pcun.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME_ID  = tpcun.CUSTOMER_UNIT_NAME_ID    )
           inner join CUSTOMER_UNIT_TYPE pcut                      on ( pjcut.CUSTOMER_UNIT_TYPE_ID                   = pcut.CUSTOMER_UNIT_TYPE_ID     ) and
                                                                           ( pcut.PROVIDER_SYSTEM_ID                       = ps.PROVIDER_SYSTEM_ID          )
           left outer join TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE tpcut   on ( pcut.TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE_ID  = tpcut.CUSTOMER_UNIT_TYPE_ID    )
           inner join      MEMBER m                                     on ( m.MEMBER_ID                                   =  puv.CUSTOMER_ID               )
      where ( cs.TECHNICIAN_ID    =  @TechnicianId ) and
            ( cs.COM_SERVICE_DATE >= @StartDate    ) and
            ( cs.COM_SERVICE_DATE <= @EndDate      )
      order by cs.COM_SERVICE_DATE,
               cs.COM_SERVICE_ID

       /* Get the error code for the previous statement.
         Error checking MUST be done this way since any single statement executed
         will affect both of the global functions,  @@Error. */
      select @ErrorCode = @@Error

      /* If there was an error... */
      if ( @ErrorCode <> 00 ) begin

         /* Rollback the transaction. */
         rollback transaction

         /* Return the failure. */
         return 01

      end

      create table #TEMP_UNIT(
         CUSTOMER_UNIT_ID integer,
         CUSTOMER_ID integer,
         CUSTOMER_UNIT_TYPE_ID integer,
         PROVIDER_SYSTEM_ID integer,

         UNIT_PARENT_ID integer,
         UNIT_TOP_PARENT_ID integer,
         CUSTOMER_UNIT_NUMBER varchar(50),
         CUSTOMER_UNIT_NAME varchar(50),
         INSTALL_DATE datetime)

      declare
         @UnitId integer,
         @SystemId integer,
         @UnitName varchar(50),
         @RowCount integer

      declare UnitCursor cursor for
      select distinct
             LOCATION_ID,
             PROVIDER_SYSTEM_ID,
             LOCATION_NAME
      from @Service

      open UnitCursor
      fetch next from UnitCursor into
         @UnitId,
         @SystemId,
         @UnitName
      while ( @@fetch_status = 00 ) begin

         insert into #TEMP_UNIT (CUSTOMER_UNIT_ID, PROVIDER_SYSTEM_ID, UNIT_PARENT_ID, UNIT_TOP_PARENT_ID, CUSTOMER_UNIT_NAME )
         values ( @UnitId, @SystemId, -1, @UnitId, @UnitName )

         select @RowCount = count(*)
         from dbo.CUSTOMER_UNIT CU
         inner join dbo.JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT jcutcu on cu.CUSTOMER_UNIT_ID = jcutcu.CUSTOMER_UNIT_ID
         inner join dbo.CUSTOMER_UNIT_TYPE cut on jcutcu.CUSTOMER_UNIT_TYPE_ID = cut.CUSTOMER_UNIT_TYPE_ID
         where     cut.PROVIDER_SYSTEM_ID = @SystemId
           and     cu.UNIT_PARENT_ID = @UnitId

         if @RowCount > 0 begin

            execute @ReturnCode = spGetCustomerUnitsBySystemUserParent @SystemId, 0, @UnitId, @UnitId

            /* If there was an error... */
            if ( @ReturnCode <> 00 ) begin

               /* Return the failure. */
               return @ReturnCode

             end

         end

      fetch next from UnitCursor into
         @UnitId,
         @SystemId,
         @UnitName

      end

      close UnitCursor
      deallocate UnitCursor

      select svc.COM_SERVICE_ID,
             svc.COM_SERVICE_DATE,
             svc.CUSTOMER_CONTACT,
             svc.COM_SERVICE_COMMENT,
             svc.TIME_IN,
             svc.TIME_OUT,
             svc.TECHNICIAN_FNAME,
             svc.TECHNICIAN_LNAME,
             svc.CUSTOMER_NAME,
             svc.LOCATION_ID,
             svc.LOCATION_TYPE_NAME,
             svc.LOCATION_NAME,
             tu.CUSTOMER_UNIT_NAME as UNIT_NAME,
             svc.PROVIDER_SERVICE_TYPE,
             svc.PROVIDER_SYSTEM_NAME,
             TIME_STAMP = case
                             when csuv.COM_SERVICE_UNIT_VALUE_ID is null
                                then 'No detail'
                             else
                                case
                                   when csuv.TIMESTAMP is null
                                      then 'No scan'
                                   else convert( varchar(10), csuv.TIMESTAMP, 08 )
                                end
                          end,
             RANKING    = case
                             when csuv.COM_SERVICE_UNIT_VALUE_ID is null
                                then 'Unit not serviced'
                             else
                                case
                                   when ( csuv.PROVIDER_SERVICE_VALUE_ID is null )
                                      then 'Unit not ranked'
                                   else cast( IsNull(psv.PROVIDER_SERVICE_VALUE, tpsv.PROVIDER_SERVICE_VALUE) as varchar ) + ' ' + IsNull(psv.PROVIDER_SERVICE_VALUE_TEXT, tpsv.PROVIDER_SERVICE_VALUE_TEXT)
                                end
                          end,
             IsNull( cpcut.CUSTOMER_UNIT_TYPE_NAME, tcpcut.CUSTOMER_UNIT_TYPE_NAME ) + ' : ' +
             IsNull( cu.CUSTOMER_UNIT_NAME, IsNull( cpcun.CUSTOMER_UNIT_NAME, tcpcun.CUSTOMER_UNIT_NAME ) ) as CUSTOMER_UNIT_NAME
      from @Service svc
           inner join #TEMP_UNIT tu                                     on ( svc.LOCATION_ID                               = tu.UNIT_TOP_PARENT_ID         ) and
                                                                           ( tu.PROVIDER_SYSTEM_ID                         = svc.PROVIDER_SYSTEM_ID        )
           left outer join COM_SERVICE_UNIT_VALUE csuv                  on ( csuv.COM_SERVICE_ID                           = svc.COM_SERVICE_ID            ) and
                                                                           ( csuv.CUSTOMER_UNIT_ID                         = tu.CUSTOMER_UNIT_ID           )
           left outer join PROVIDER_SERVICE_VALUE psv                   on ( csuv.PROVIDER_SERVICE_VALUE_ID                = psv.PROVIDER_SERVICE_VALUE_ID )
           left outer join TEMPLATE_PROVIDER_SERVICE_VALUE tpsv         on ( psv.Template_Provider_Service_Value_ID        = tpsv.Provider_Service_Value_ID )
           left outer join CUSTOMER_UNIT cu                             on ( tu.UNIT_PARENT_ID                             = cu.CUSTOMER_UNIT_ID           ) or
                                                                           ( ( tu.CUSTOMER_UNIT_ID                         = cu.CUSTOMER_UNIT_ID       ) and
                                                                             ( cu.UNIT_PARENT_ID                           = -1                        )   )
           left outer join JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT cpjcut on ( cu.CUSTOMER_UNIT_ID                           = cpjcut.CUSTOMER_UNIT_ID       )
           left outer join CUSTOMER_UNIT_NAME cpcun                     on ( cpjcut.CUSTOMER_UNIT_NAME_ID                  = cpcun.CUSTOMER_UNIT_NAME_ID   )
           left outer join TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME tcpcun  on ( cpcun.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME_ID = tcpcun.CUSTOMER_UNIT_NAME_ID  )
           inner join CUSTOMER_UNIT_TYPE cpcut                          on ( cpjcut.CUSTOMER_UNIT_TYPE_ID                  = cpcut.CUSTOMER_UNIT_TYPE_ID   ) and
                                                                           ( cpcut.PROVIDER_SYSTEM_ID                      = tu.PROVIDER_SYSTEM_ID         )
           left outer join TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE tcpcut  on ( cpcut.TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE_ID = tcpcut.CUSTOMER_UNIT_TYPE_ID  )
      order by svc.COM_SERVICE_DATE,
               svc.COM_SERVICE_ID,
               svc.time_In,
               csuv.TimeStamp,
               tu.UNIT_PARENT_ID

       /* Get the error code for the previous statement.
          Error checking MUST be done this way since any single statement executed
          will affect both of the global functions,  @@Error. */
       select @ErrorCode = @@Error

       /* If there was an error... */
       if ( @ErrorCode <> 00 ) begin

         /* Rollback the transaction. */
         rollback transaction

         /* Return the failure. */
         return 01

      end

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetTechnicianDailyActivityDetailByUnitByTechnicianId' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetTechnicianDailyActivityDetailByUnitByTechnicianId

   go

create procedure spGetTechnicianDailyActivityDetailByUnitByTechnicianId( @TechnicianId     integer,
                                                                         @StartDate        datetime,
                                                                         @EndDate          datetime,
                                                                         @ShowServicedOnly bit ) as

   /*
      spGetTechnicianDailyActivityDetailByUnitByTechnicianId.sql

      Get the completed services with station detail for a particular
      technician based on a date range.

      If ShowServicedOnly then only records for units which were serviced are
      returned (i.e. in where clause csuv.TimeStamp is not null).

      Records are ordered by  Com_Service_Date,   (i.e. "Daily" )
                              Com_Service_ID,     ( for each service, in order )
                              Customer_Unit_Name  ( each customer area together,
                                                    no matter how many levels )

      Parameters: TechnicianID, StartDate, EndDate, ShowServicedOnly
   */

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */
   declare @ReturnCode   integer /* Result code returned by the execution of the stored procedure */

   set nocount on

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   if ( @ShowServicedOnly > 00 ) begin

      /* Retrieve the daily activity for the technician within the passed date
         range ordered by the service data and the start time for the service. */
      select cs.COM_SERVICE_ID,
             convert( varchar(10), cs.COM_SERVICE_DATE, 01 ) as COM_SERVICE_DATE,
             cs.CUSTOMER_CONTACT,
             cs.COM_SERVICE_COMMENT,
             convert( varchar(10), cs.TIME_IN,  08 ) as TIME_IN,
             convert( varchar(10), cs.TIME_OUT, 08 ) as TIME_OUT,
             mu.MEMBER_USER_FNAME                 as TECHNICIAN_FNAME,
             mu.MEMBER_USER_LNAME                 as TECHNICIAN_LNAME,
             m.MEMBER_NAME                        as CUSTOMER_NAME,
             cs.CUSTOMER_UNIT_ID                  as LOCATION_ID,
             IsNull( pcut.CUSTOMER_UNIT_TYPE_NAME,   tpcut.CUSTOMER_UNIT_TYPE_NAME                               ) as LOCATION_TYPE_NAME,
             IsNull( puv.CUSTOMER_UNIT_NAME,         IsNull( pcun.CUSTOMER_UNIT_NAME, tpcun.CUSTOMER_UNIT_NAME ) ) as LOCATION_NAME,
             IsNull( ccut.CUSTOMER_UNIT_TYPE_NAME, tccut.CUSTOMER_UNIT_TYPE_NAME ) + ' : ' +
             IsNull( cuv.CUSTOMER_UNIT_NAME,         IsNull( ccun.CUSTOMER_UNIT_NAME, tccun.CUSTOMER_UNIT_NAME ) ) as UNIT_NAME,
             IsNull( pst.PROVIDER_SERVICE_TYPE_TEXT, tpst.PROVIDER_SERVICE_TYPE_TEXT                             ) as PROVIDER_SERVICE_TYPE,
             IsNull( ps.PROVIDER_SYSTEM_NAME,        tps.PROVIDER_SYSTEM_NAME                                    ) as PROVIDER_SYSTEM_NAME,
             Time_Stamp = case
                             when csuv.TimeStamp is null
                                then 'No scan'
                             else convert( varchar, csuv.TimeStamp, 08 )
                          end,
             Ranking    = case
                             when ( csuv.PROVIDER_SERVICE_VALUE_ID is null )
                                then 'Unit not ranked'
                             else cast( IsNull(psv.PROVIDER_SERVICE_VALUE, tpsv.PROVIDER_SERVICE_VALUE) as varchar ) + ' ' + IsNull(psv.PROVIDER_SERVICE_VALUE_TEXT, tpsv.PROVIDER_SERVICE_VALUE_TEXT)
                          end,
             IsNull(IsNull( cpcut.CUSTOMER_UNIT_TYPE_NAME, tcpcut.CUSTOMER_UNIT_TYPE_NAME ) + ' : ' +
             IsNull( cu.CUSTOMER_UNIT_NAME, IsNull( cpcun.CUSTOMER_UNIT_NAME, tcpcun.CUSTOMER_UNIT_NAME ) ), 'Top Parent') as CUSTOMER_UNIT_NAME
      from COM_SERVICE cs
           inner join      PROVIDER_SERVICE_TYPE pst                    on ( cs.PROVIDER_SERVICE_TYPE_ID                   = pst.PROVIDER_SERVICE_TYPE_ID   )
           left outer join TEMPLATE_PROVIDER_SERVICE_TYPE tpst          on ( pst.TEMPLATE_PROVIDER_SERVICE_TYPE_ID         = tpst.PROVIDER_SERVICE_TYPE_ID  )
           inner join MEMBER_USER mu                                    on ( cs.TECHNICIAN_ID                              = mu.MEMBER_USER_ID              )
           inner join PROVIDER_SYSTEM ps                                on ( ps.PROVIDER_SYSTEM_ID                         = pst.PROVIDER_SYSTEM_ID         )
           left outer join TEMPLATE_PROVIDER_SYSTEM tps                 on ( tps.PROVIDER_SYSTEM_ID                        = ps.TEMPLATE_PROVIDER_SYSTEM_ID )
           inner join CUSTOMER_UNIT puv                                 on ( cs.CUSTOMER_UNIT_ID                           = puv.CUSTOMER_UNIT_ID           ) and
                                                                           ( puv.UNIT_PARENT_ID                            = -1                             )
           inner join      JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT pjcut  on ( puv.CUSTOMER_UNIT_ID                          = pjcut.CUSTOMER_UNIT_ID         )
           left outer join CUSTOMER_UNIT_NAME pcun                      on ( pjcut.CUSTOMER_UNIT_NAME_ID                   = pcun.CUSTOMER_UNIT_NAME_ID     )
           left outer join TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME tpcun   on ( pcun.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME_ID  = tpcun.CUSTOMER_UNIT_NAME_ID    )
           inner join CUSTOMER_UNIT_TYPE pcut                           on ( pjcut.CUSTOMER_UNIT_TYPE_ID                   = pcut.CUSTOMER_UNIT_TYPE_ID     ) and
                                                                           ( pcut.PROVIDER_SYSTEM_ID = ps.PROVIDER_SYSTEM_ID                                )
           left outer join TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE tpcut   on ( pcut.TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE_ID  = tpcut.CUSTOMER_UNIT_TYPE_ID    )
           inner join      MEMBER m                                     on ( m.MEMBER_ID                                   =  puv.CUSTOMER_ID               )
           left outer join COM_SERVICE_UNIT_VALUE csuv                  on ( csuv.Com_Service_ID                           = cs.Com_Service_ID              )
           inner join CUSTOMER_UNIT cuv                                 on ( csuv.CUSTOMER_UNIT_ID                         = cuv.CUSTOMER_UNIT_ID           )
           inner join      JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT cjcut  on ( cuv.CUSTOMER_UNIT_ID                          = cjcut.CUSTOMER_UNIT_ID         )
           left outer join CUSTOMER_UNIT_NAME ccun                      on ( cjcut.CUSTOMER_UNIT_NAME_ID                   = ccun.CUSTOMER_UNIT_NAME_ID     )
           left outer join TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME tccun   on ( ccun.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME_ID  = tccun.CUSTOMER_UNIT_NAME_ID    )
           inner join CUSTOMER_UNIT_TYPE ccut                           on ( cjcut.CUSTOMER_UNIT_TYPE_ID                   = ccut.CUSTOMER_UNIT_TYPE_ID     ) and
                                                                           ( ccut.PROVIDER_SYSTEM_ID = ps.PROVIDER_SYSTEM_ID                                )
           left outer join TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE tccut   on ( ccut.TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE_ID  = tccut.CUSTOMER_UNIT_TYPE_ID    )
           left outer join      PROVIDER_SERVICE_VALUE psv              on ( csuv.Provider_Service_Value_ID                = psv.Provider_Service_Value_ID  )
           left outer join TEMPLATE_PROVIDER_SERVICE_VALUE tpsv         on ( psv.Template_Provider_Service_Value_ID        = tpsv.Provider_Service_Value_ID )
           left outer join CUSTOMER_UNIT cu                             on ( cuv.Unit_Parent_ID                            = cu.Customer_Unit_ID            )
           inner join JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT cpjcut      on ( cu.CUSTOMER_UNIT_ID                           = cpjcut.CUSTOMER_UNIT_ID        )
           left outer join CUSTOMER_UNIT_NAME cpcun                     on ( cpjcut.CUSTOMER_UNIT_NAME_ID                  = cpcun.CUSTOMER_UNIT_NAME_ID    )
           left outer join TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME tcpcun  on ( cpcun.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME_ID = tcpcun.CUSTOMER_UNIT_NAME_ID   )
           inner join CUSTOMER_UNIT_TYPE cpcut                          on ( cpjcut.CUSTOMER_UNIT_TYPE_ID                  = cpcut.CUSTOMER_UNIT_TYPE_ID    ) and
                                                                           ( cpcut.PROVIDER_SYSTEM_ID = ps.PROVIDER_SYSTEM_ID                               )
           left outer join TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE tcpcut  on ( cpcut.TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE_ID = tcpcut.CUSTOMER_UNIT_TYPE_ID   )
      where ( cs.TECHNICIAN_ID    =  @TechnicianId ) and
            ( cs.COM_SERVICE_DATE >= @StartDate    ) and
            ( cs.COM_SERVICE_DATE <= @EndDate      )
      order by cs.COM_SERVICE_DATE,
               cs.COM_SERVICE_ID,
               cuv.unit_parent_id,
               cu.Customer_Unit_Name,
               csuv.TIMESTAMP

       /* Get the error code for the previous statement.
          Error checking MUST be done this way since any single statement executed
          will affect both of the global functions,  @@Error. */
      select @ErrorCode = @@Error

      /* If there was an error... */
      if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   end

   else begin

      declare @Service table (
         COM_SERVICE_ID integer,
         COM_SERVICE_DATE varchar(10),
         CUSTOMER_CONTACT varchar(25),
         COM_SERVICE_COMMENT varchar(255),
         TIME_IN varchar(10),
         TIME_OUT varchar(10),
         TECHNICIAN_FNAME varchar(25),
         TECHNICIAN_LNAME varchar(25),
         CUSTOMER_NAME varchar(100),
         LOCATION_ID integer,
         LOCATION_TYPE_NAME varchar(50),
         LOCATION_NAME varchar(100),
         PROVIDER_SERVICE_TYPE varchar(50),
         PROVIDER_SYSTEM_ID integer,
         PROVIDER_SYSTEM_NAME varchar(50) )

      /* Retrieve the daily activity for the technician within the passed date
         range ordered by the service data and the start time for the service. */
      insert into @Service
      select cs.COM_SERVICE_ID,
             convert( varchar(10), cs.COM_SERVICE_DATE, 01 ) as COM_SERVICE_DATE,
             cs.CUSTOMER_CONTACT,
             cs.COM_SERVICE_COMMENT,
             convert( varchar(10), cs.TIME_IN,  08 ) as TIME_IN,
             convert( varchar(10), cs.TIME_OUT, 08 ) as TIME_OUT,
             mu.MEMBER_USER_FNAME                 as TECHNICIAN_FNAME,
             mu.MEMBER_USER_LNAME                 as TECHNICIAN_LNAME,
             m.MEMBER_NAME                        as CUSTOMER_NAME,
             cs.CUSTOMER_UNIT_ID                  as LOCATION_ID,
             IsNull( pcut.CUSTOMER_UNIT_TYPE_NAME,   tpcut.CUSTOMER_UNIT_TYPE_NAME                               ) as LOCATION_TYPE_NAME,
             IsNull( puv.CUSTOMER_UNIT_NAME,         IsNull( pcun.CUSTOMER_UNIT_NAME, tpcun.CUSTOMER_UNIT_NAME ) ) as LOCATION_NAME,
             IsNull( pst.PROVIDER_SERVICE_TYPE_TEXT, tpst.PROVIDER_SERVICE_TYPE_TEXT                             ) as PROVIDER_SERVICE_TYPE,
             ps.PROVIDER_SYSTEM_ID,
             IsNull( ps.PROVIDER_SYSTEM_NAME,        tps.PROVIDER_SYSTEM_NAME                                    ) as PROVIDER_SYSTEM_NAME
      from COM_SERVICE cs
           inner join      PROVIDER_SERVICE_TYPE pst                    on ( cs.PROVIDER_SERVICE_TYPE_ID                   = pst.PROVIDER_SERVICE_TYPE_ID   )
           left outer join TEMPLATE_PROVIDER_SERVICE_TYPE tpst          on ( pst.TEMPLATE_PROVIDER_SERVICE_TYPE_ID         = tpst.PROVIDER_SERVICE_TYPE_ID  )
           inner join MEMBER_USER mu                               on ( cs.TECHNICIAN_ID                              = mu.MEMBER_USER_ID              )
           inner join PROVIDER_SYSTEM ps                           on ( ps.PROVIDER_SYSTEM_ID                         = pst.PROVIDER_SYSTEM_ID         )
           left outer join TEMPLATE_PROVIDER_SYSTEM tps                 on ( tps.PROVIDER_SYSTEM_ID                        = ps.TEMPLATE_PROVIDER_SYSTEM_ID )
           inner join CUSTOMER_UNIT puv                            on ( cs.CUSTOMER_UNIT_ID                           = puv.CUSTOMER_UNIT_ID           ) and
                                                                           ( puv.UNIT_PARENT_ID                            = -1                             )
           inner join      JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT pjcut  on ( puv.CUSTOMER_UNIT_ID                          = pjcut.CUSTOMER_UNIT_ID         )
           left outer join CUSTOMER_UNIT_NAME pcun                      on ( pjcut.CUSTOMER_UNIT_NAME_ID                   = pcun.CUSTOMER_UNIT_NAME_ID     )
           left outer join TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME tpcun   on ( pcun.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME_ID  = tpcun.CUSTOMER_UNIT_NAME_ID    )
           inner join CUSTOMER_UNIT_TYPE pcut                      on ( pjcut.CUSTOMER_UNIT_TYPE_ID                   = pcut.CUSTOMER_UNIT_TYPE_ID     ) and
                                                                           ( pcut.PROVIDER_SYSTEM_ID                       = ps.PROVIDER_SYSTEM_ID          )
           left outer join TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE tpcut   on ( pcut.TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE_ID  = tpcut.CUSTOMER_UNIT_TYPE_ID    )
           inner join      MEMBER m                                     on ( m.MEMBER_ID                                   =  puv.CUSTOMER_ID               )
      where ( cs.TECHNICIAN_ID    =  @TechnicianId ) and
            ( cs.COM_SERVICE_DATE >= @StartDate    ) and
            ( cs.COM_SERVICE_DATE <= @EndDate      )
      order by cs.COM_SERVICE_DATE,
               cs.COM_SERVICE_ID

       /* Get the error code for the previous statement.
          Error checking MUST be done this way since any single statement executed
          will affect both of the global functions,  @@Error. */
      select @ErrorCode = @@Error

      /* If there was an error... */
      if ( @ErrorCode <> 00 ) begin

         /* Rollback the transaction. */
         rollback transaction

         /* Return the failure. */
         return 01

      end

      create table #TEMP_UNIT(
         CUSTOMER_UNIT_ID integer,
         CUSTOMER_ID integer,
         CUSTOMER_UNIT_TYPE_ID integer,
         PROVIDER_SYSTEM_ID integer,
         UNIT_PARENT_ID integer,
         UNIT_TOP_PARENT_ID integer,
         CUSTOMER_UNIT_NUMBER varchar(50),
         CUSTOMER_UNIT_NAME varchar(50),
         INSTALL_DATE datetime)

      declare
         @UnitId integer,
         @SystemId integer,
         @UnitName varchar(50),
         @RowCount integer

      declare UnitCursor cursor for
      select distinct
             LOCATION_ID,
             PROVIDER_SYSTEM_ID,
             LOCATION_NAME
      from @Service
      open UnitCursor
      fetch next from UnitCursor into
         @UnitId,
         @SystemId,
         @UnitName
      while ( @@fetch_status = 00 ) begin

         insert into #TEMP_UNIT (CUSTOMER_UNIT_ID, PROVIDER_SYSTEM_ID, UNIT_PARENT_ID, UNIT_TOP_PARENT_ID, CUSTOMER_UNIT_NAME )
         values ( @UnitId, @SystemId, -1, @UnitId, @UnitName )

         select @RowCount = count(*)
         from dbo.CUSTOMER_UNIT CU
         inner join dbo.JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT jcutcu on cu.CUSTOMER_UNIT_ID = jcutcu.CUSTOMER_UNIT_ID
         inner join dbo.CUSTOMER_UNIT_TYPE cut on jcutcu.CUSTOMER_UNIT_TYPE_ID = cut.CUSTOMER_UNIT_TYPE_ID
         where     cut.PROVIDER_SYSTEM_ID = @SystemId
           and     cu.UNIT_PARENT_ID = @UnitId

          /* Get the error code for the previous statement.
             Error checking MUST be done this way since any single statement executed
             will affect both of the global functions,  @@Error. */
          select @ErrorCode = @@Error

          /* If there was an error... */
          if ( @ErrorCode <> 00 ) begin

             /* Rollback the transaction. */
             rollback transaction

             /* Return the failure. */
             return 01

          end

         if @RowCount > 0 begin

            execute @ReturnCode = spGetCustomerUnitsBySystemUserParent @SystemId, 0, @UnitId, @UnitId

            /* If there was an error... */
            if ( @ReturnCode <> 00 ) begin

               /* Return the failure. */
               return @ReturnCode

            end

         end

      fetch next from UnitCursor into
         @UnitId,
         @SystemId,
         @UnitName

      end

      close UnitCursor
      deallocate UnitCursor

      select svc.COM_SERVICE_ID,
             svc.COM_SERVICE_DATE,
             svc.CUSTOMER_CONTACT,
             svc.COM_SERVICE_COMMENT,
             svc.TIME_IN,
             svc.TIME_OUT,
             svc.TECHNICIAN_FNAME,
             svc.TECHNICIAN_LNAME,
             svc.CUSTOMER_NAME,
             svc.LOCATION_ID,
             svc.LOCATION_TYPE_NAME,
             svc.LOCATION_NAME,
             tu.CUSTOMER_UNIT_NAME as UNIT_NAME,
             svc.PROVIDER_SERVICE_TYPE,
             svc.PROVIDER_SYSTEM_NAME,
             TIME_STAMP = case
                             when csuv.COM_SERVICE_UNIT_VALUE_ID is null
                                then 'No detail'
                             else
                                case
                                   when csuv.TIMESTAMP is null
                                      then 'No scan'
                                   else convert( varchar(10), csuv.TIMESTAMP, 08 )
                                end
                          end,
             RANKING    = case
                             when csuv.COM_SERVICE_UNIT_VALUE_ID is null
                                then 'Unit not serviced'
                             else
                                case
                                   when ( csuv.PROVIDER_SERVICE_VALUE_ID is null )
                                      then 'Unit not ranked'
                                   else cast( IsNull(psv.PROVIDER_SERVICE_VALUE, tpsv.PROVIDER_SERVICE_VALUE) as varchar ) + ' ' + IsNull(psv.PROVIDER_SERVICE_VALUE_TEXT, tpsv.PROVIDER_SERVICE_VALUE_TEXT)
                                end
                          end,
             IsNull( cpcut.CUSTOMER_UNIT_TYPE_NAME, tcpcut.CUSTOMER_UNIT_TYPE_NAME ) + ' : ' +
             IsNull( cu.CUSTOMER_UNIT_NAME, IsNull( cpcun.CUSTOMER_UNIT_NAME, tcpcun.CUSTOMER_UNIT_NAME ) ) as CUSTOMER_UNIT_NAME
      from @Service svc
           inner join #TEMP_UNIT tu                                     on ( svc.LOCATION_ID                               = tu.UNIT_TOP_PARENT_ID         ) and
                                                                           ( tu.PROVIDER_SYSTEM_ID                         = svc.PROVIDER_SYSTEM_ID        )
           left outer join COM_SERVICE_UNIT_VALUE csuv                  on ( csuv.COM_SERVICE_ID                           = svc.COM_SERVICE_ID            ) and
                                                                           ( csuv.CUSTOMER_UNIT_ID                         = tu.CUSTOMER_UNIT_ID           )
           left outer join PROVIDER_SERVICE_VALUE psv                   on ( csuv.PROVIDER_SERVICE_VALUE_ID                = psv.PROVIDER_SERVICE_VALUE_ID )
           left outer join TEMPLATE_PROVIDER_SERVICE_VALUE tpsv         on ( psv.Template_Provider_Service_Value_ID        = tpsv.Provider_Service_Value_ID )
           left outer join CUSTOMER_UNIT cu                             on ( tu.UNIT_PARENT_ID                             = cu.CUSTOMER_UNIT_ID           ) or
                                                                           ( ( tu.CUSTOMER_UNIT_ID                         = cu.CUSTOMER_UNIT_ID       ) and
                                                                             ( cu.UNIT_PARENT_ID                           = -1                        )   )
           left outer join JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT cpjcut on ( cu.CUSTOMER_UNIT_ID                           = cpjcut.CUSTOMER_UNIT_ID       )
           left outer join CUSTOMER_UNIT_NAME cpcun                     on ( cpjcut.CUSTOMER_UNIT_NAME_ID                  = cpcun.CUSTOMER_UNIT_NAME_ID   )
           left outer join TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME tcpcun  on ( cpcun.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME_ID = tcpcun.CUSTOMER_UNIT_NAME_ID  )
           inner join CUSTOMER_UNIT_TYPE cpcut                          on ( cpjcut.CUSTOMER_UNIT_TYPE_ID                  = cpcut.CUSTOMER_UNIT_TYPE_ID   ) and
                                                                           ( cpcut.PROVIDER_SYSTEM_ID                      = tu.PROVIDER_SYSTEM_ID         )
           left outer join TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE tcpcut  on ( cpcut.TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE_ID = tcpcut.CUSTOMER_UNIT_TYPE_ID  )
      order by svc.COM_SERVICE_DATE,
               svc.COM_SERVICE_ID,
               tu.unit_parent_id,
               cu.Customer_Unit_Name,
               csuv.TIMESTAMP

      /* Get the error code for the previous statement.
         Error checking MUST be done this way since any single statement executed
         will affect both of the global functions,  @@Error. */
      select @ErrorCode = @@Error

      /* If there was an error... */
      if ( @ErrorCode <> 00 ) begin

         /* Rollback the transaction. */
         rollback transaction

         /* Return the failure. */
         return 01

      end

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetTemplateProviderSystemByTemplateProviderSystemId' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetTemplateProviderSystemByTemplateProviderSystemId

   go

create procedure spGetTemplateProviderSystemByTemplateProviderSystemId( @templateprovidersystemid integer ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   Select *
   from template_provider_system
   where provider_system_id = @templateprovidersystemid

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if (  @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */

   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetTemplateProviderSystems' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetTemplateProviderSystems

   go

create procedure spGetTemplateProviderSystems as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   SELECT *
   FROM TEMPLATE_PROVIDER_SYSTEM

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetTemplateProviderSystemsByProvider' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetTemplateProviderSystemsByProvider

   go

create procedure spGetTemplateProviderSystemsByProvider( @ProviderId integer ) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   execute @ReturnCode = spGetProviderTemplateProviderSystemsByProvider @ProviderId

    /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetTemplateServiceData' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetTemplateServiceData

   go

create procedure spGetTemplateServiceData as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   select b.template_service_data_type_id, template_service_data_id, template_service_data_mod, template_service_data
   from template_service_data a
   left outer join template_service_data_type b on a.template_service_data_type_id = b.template_service_data_type_id
   left outer join template_service_category c on b.template_service_category_id = c.template_service_category_id
   order by b.template_service_data_type_id

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetTemplateServiceDataByDataType' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetTemplateServiceDataByDataType

   go

create procedure spGetTemplateServiceDataByDataType( @servicedatatypeid integer ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   SELECT TEMPLATE_SERVICE_DATA_ID,
          TEMPLATE_SERVICE_DATA_MOD,
	  TEMPLATE_SERVICE_DATA,
	  TEMPLATE_SERVICE_DATA_TYPE_ID
   FROM TEMPLATE_SERVICE_DATA
   WHERE TEMPLATE_SERVICE_DATA_TYPE_ID = @servicedatatypeid

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetUnitCategoryDataCounts' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetUnitCategoryDataCounts

   go

create procedure spGetUnitCategoryDataCounts( @CustomerUnitTypeId   integer,
                                              @ParentUnitID         integer,
                                              @CategoryDataID       integer,
                                              @StartDate            datetime,
                                              @EndDate              datetime  ) as

   /*     spGetUnitCategoryDataCounts

           Stored proecedure to get counts for UnitDataCategoryCounts plugin

           jf 03/10/2005
   */

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   select  isnull( psc.PROVIDER_SERVICE_CATEGORY, tpsc.PROVIDER_SERVICE_CATEGORY ) as PROVIDER_SERVICE_CATEGORY,

           isnull( pu.CUSTOMER_UNIT_NAME, isnull( pcun.CUSTOMER_UNIT_NAME, ptcun.CUSTOMER_UNIT_NAME ) ) as PARENT_UNIT_NAME,

           isnull( scut.CUSTOMER_UNIT_TYPE_NAME, stcut.CUSTOMER_UNIT_TYPE_NAME ) as SERVICE_UNIT_TYPE_NAME,

           su.CUSTOMER_UNIT_ID as SERVICE_UNIT_ID,

           isnull( su.customer_unit_name, isnull( scun.customer_unit_name, stcun.customer_unit_name ) ) as SERVICE_UNIT_NAME,

           isnull( csd.COM_SERVICE_DATA_ALT_TEXT, isnull( psd.PROVIDER_SERVICE_DATA, tpsd.PROVIDER_SERVICE_DATA ) ) as COM_SERVICE_DATA,

           Count( cs.Com_Service_ID ) as  CategoryDataCount

   from COM_SERVICE cs
        left outer join COM_SERVICE_UNIT_VALUE             csuv on ( cs.COM_SERVICE_ID                 = csuv.COM_SERVICE_ID            )
        left outer join COM_SERVICE_DATA                   csd  on ( csuv.COM_SERVICE_UNIT_VALUE_ID    = csd.COM_SERVICE_UNIT_VALUE_ID       )
        left outer join PROVIDER_SERVICE_DATA              psd  on ( csd.PROVIDER_SERVICE_DATA_ID      = psd.PROVIDER_SERVICE_DATA_ID        )
        left outer join PROVIDER_SERVICE_DATA_TYPE         psdt on ( psd.PROVIDER_SERVICE_DATA_TYPE_ID = psdt.PROVIDER_SERVICE_DATA_TYPE_ID  )
        left outer join PROVIDER_SERVICE_CATEGORY          psc  on ( psdt.PROVIDER_SERVICE_CATEGORY_ID = psc.PROVIDER_SERVICE_CATEGORY_ID    )
        left outer join TEMPLATE_PROVIDER_SERVICE_CATEGORY tpsc on ( psc.TEMPLATE_PROVIDER_SERVICE_CATEGORY_ID = tpsc.PROVIDER_SERVICE_CATEGORY_ID   )
        left outer join TEMPLATE_PROVIDER_SERVICE_DATA     tpsd on ( psd.TEMPLATE_PROVIDER_SERVICE_DATA_ID     = tpsd.PROVIDER_SERVICE_DATA_ID       )

        left outer join CUSTOMER_UNIT    pu  on ( cs.CUSTOMER_UNIT_ID = pu.CUSTOMER_UNIT_ID )
        inner join PROVIDER_SERVICE_TYPE pst on ( cs.PROVIDER_SERVICE_TYPE_ID = pst.PROVIDER_SERVICE_TYPE_ID  )

        inner join JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT     pjcut on ( pu.CUSTOMER_UNIT_ID         = pjcut.CUSTOMER_UNIT_ID      )
        inner join CUSTOMER_UNIT_TYPE                        pcut  on ( pjcut.CUSTOMER_UNIT_TYPE_ID = pcut.CUSTOMER_UNIT_TYPE_ID  ) and
                                                                      ( pst.PROVIDER_SYSTEM_ID      = pcut.PROVIDER_SYSTEM_ID     )
        left outer join CUSTOMER_UNIT_NAME                   pcun  on ( pjcut.CUSTOMER_UNIT_NAME_ID = pcun.CUSTOMER_UNIT_NAME_ID  )
        left outer join TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME ptcun on ( pcun.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME_ID = ptcun.CUSTOMER_UNIT_NAME_ID )

        left outer join CUSTOMER_UNIT                         su    on ( csuv.CUSTOMER_UNIT_ID = su.CUSTOMER_UNIT_ID )
        left outer join JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT sjcut on ( su.CUSTOMER_UNIT_ID = sjcut.CUSTOMER_UNIT_ID      )
        left outer join CUSTOMER_UNIT_TYPE                    scut  on ( sjcut.CUSTOMER_UNIT_TYPE_ID = scut.CUSTOMER_UNIT_TYPE_ID  ) and
                                                                       ( pst.PROVIDER_SYSTEM_ID = scut.PROVIDER_SYSTEM_ID     )
        left outer join TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE  stcut on ( scut.TEMPLATE_PROVIDER_CUSTOMER_UNIT_TYPE_ID = stcut.CUSTOMER_UNIT_TYPE_ID )
        left outer join CUSTOMER_UNIT_NAME                    scun  on ( sjcut.CUSTOMER_UNIT_NAME_ID = scun.CUSTOMER_UNIT_NAME_ID  )
        left outer join TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME  stcun on ( scun.TEMPLATE_PROVIDER_CUSTOMER_UNIT_NAME_ID = stcun.CUSTOMER_UNIT_NAME_ID )

   where   ( psd.Provider_Service_Data_ID = @CategoryDataID ) and
           ( pu.Customer_Unit_ID          = @ParentUnitID )   and
           ( scut.Customer_Unit_Type_ID   = @CustomerUnitTypeId )     and

           ( cs.COM_SERVICE_DATE >= @StartDate    ) and
           ( cs.COM_SERVICE_DATE <= @EndDate      )

   group by isnull( psc.PROVIDER_SERVICE_CATEGORY, tpsc.PROVIDER_SERVICE_CATEGORY ),

            isnull( pu.CUSTOMER_UNIT_NAME, isnull( pcun.CUSTOMER_UNIT_NAME, ptcun.CUSTOMER_UNIT_NAME ) ),

            isnull( scut.CUSTOMER_UNIT_TYPE_NAME, stcut.CUSTOMER_UNIT_TYPE_NAME ),

            su.CUSTOMER_UNIT_ID,

            isnull( su.customer_unit_name, isnull( scun.customer_unit_name, stcun.customer_unit_name ) ),

            isnull( csd.COM_SERVICE_DATA_ALT_TEXT, isnull( psd.PROVIDER_SERVICE_DATA, tpsd.PROVIDER_SERVICE_DATA ) )

   having   ( Count( cs.Com_Service_ID ) > 0 )

   order by Count( cs.Com_Service_ID ) desc

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetUnitTypeChildrenUnitType' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetUnitTypeChildrenUnitType

   go

create procedure spGetUnitTypeChildrenUnitType( @CustomerUnitTypeId integer,
                                                @UnitTypeIds        varchar(100) out ) as

   declare @ChildTypeId integer

   declare unit_type_cursor cursor local fast_forward for

      select cut.customer_unit_type_id from
      customer_unit_type cut where
      cut.customer_unit_type_parent_id = @CustomerUnitTypeId

   open unit_type_cursor fetch next from unit_type_cursor into @ChildTypeId

   while ( @@Fetch_Status = 0 ) begin
      if @UnitTypeIds <> ''
         set @UnitTypeIds = @UnitTypeIds + ', '
      set @UnitTypeIds = @UnitTypeIds + cast( @ChildTypeId as varchar(10) )
      exec spGetUnitTypeChildrenUnitType @ChildTypeId, @UnitTypeIds out
      fetch next from unit_type_cursor into @ChildTypeId

   end

   close unit_type_cursor
   deallocate unit_type_cursor

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetUserByMemberUserId' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetUserByMemberUserId

   go

create procedure spGetUserByMemberUserId( @MemberUserId integer ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   SELECT MEMBER_USER.MEMBER_USER_ID,
          MEMBER_ID,
          MEMBER_USER_NAME,
          MEMBER_USER_PWD,
          MEMBER_USER_FNAME,
          MEMBER_USER_LNAME,
          MEMBER_USER_LAST_LOGIN,
          MEMBER_USER_EMAIL,
          SECURITY_GROUP.SECURITY_GROUP_ID,
          SECURITY_GROUP.SECURITY_GROUP_NAME
   FROM MEMBER_USER
   LEFT OUTER JOIN JOIN_MEMBER_USER_SECURITY_GROUP ON MEMBER_USER.MEMBER_USER_ID = JOIN_MEMBER_USER_SECURITY_GROUP.MEMBER_USER_ID
   LEFT OUTER JOIN SECURITY_GROUP ON JOIN_MEMBER_USER_SECURITY_GROUP.SECURITY_GROUP_ID = SECURITY_GROUP.SECURITY_GROUP_ID
   WHERE  MEMBER_USER.MEMBER_USER_ID = @MemberUserId
   ORDER BY MEMBER_USER_LNAME, MEMBER_USER_FNAME

   /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetUserEmailListForFrequency' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetUserEmailListForFrequency

   go

create procedure spGetUserEmailListForFrequency as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   set nocount on

    /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   select mues.member_user_email_id,
          mues.member_user_id,
          mues.provider_system_id,
          insull( psv.provider_service_value, tpsv.provider_service_value ) as provider_service_value,
          DATEADD( dd, 0, DATEDIFF( dd, 0, getdate() - mues.email_frequency_days ) ) as start_date,
          DATEADD( dd, 0, DATEDIFF( dd, 0, getdate() - 1 )) as end_date,
          sg.security_group_id,
          sg.security_group_type_id
   from member_user_email_settings mues
   inner join join_member_user_security_group jmusg on jmusg.member_user_id = mues.member_user_id
   inner join security_group sg on sg.security_group_id = jmusg.security_group_id
   left outer join PROVIDER_SERVICE_VALUE psv           on ( mues.PROVIDER_SERVICE_VALUE_ID         = psv.PROVIDER_SERVICE_VALUE_ID  )
   left outer join TEMPLATE_PROVIDER_SERVICE_VALUE tpsv on ( psv.TEMPLATE_PROVIDER_SERVICE_VALUE_ID = tpsv.PROVIDER_SERVICE_VALUE_ID )

   where DATEADD( dd, 0, DATEDIFF( dd, 0, mues.email_last_update + mues.email_frequency_days ))
      <= DATEADD( dd, 0, DATEDIFF( dd, 0, getdate() )) and
     /* don't return disabled users */
     ( ( sg.security_group_id <> 14  ) and ( sg.security_group_id <> 15 ) ) and
     ( mues.email_frequency_days > 0 ) and
     ( mues.email_disabled = 0 )

    /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

      /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetUserGroups' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetUserGroups

   go

create procedure spGetUserGroups( @MemberUserId      integer,
                                  @MemberGroupTypeId integer ) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   -- new procedure
   execute @ReturnCode = spGetMemberGroupsWithUserByType @MemberUserId, @MemberGroupTypeId

     /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetUsersByCustomer' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetUsersByCustomer

   go

create procedure spGetUsersByCustomer( @CustomerId integer ) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

    -- new procedure
   execute @ReturnCode = spGetMemberUsersByMemberId @CustomerId

     /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetUsersByProvider' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetUsersByProvider

   go

create procedure spGetUsersByProvider( @ProviderId integer ) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   execute @ReturnCode = spGetMemberUsersByMemberId @ProviderId

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetWorkOrdersBySystemUserDateRange' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetWorkOrdersBySystemUserDateRange

   go

create procedure spGetWorkOrdersBySystemUserDateRange( @ProviderSystemId  integer,
                                                       @MemberUserId      integer,
                                                       @StartDate         datetime,
                                                       @EndDate           datetime ) as

   declare @ErrorCode       integer /* Error code returned by the execution of the last statement   */
   declare @RowsAffected    integer /* Number of rows affected by the previously executed statement */
   declare @Transactions    integer /* Number of active transactions at the start of this procedure */
   declare @SecurityGroupId integer /* Identifier for the current user's security group             */
   declare @CustomerId      integer /* Identifier for the customer containing the current user      */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Get the identifier for the current user's security group. */
   select @SecurityGroupId = SECURITY_GROUP_ID
   from JOIN_MEMBER_USER_SECURITY_GROUP
   where MEMBER_USER_ID = @MemberUserId

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If the current user is NOT a super user... */
   if ( @SecurityGroupId < 06 ) or ( @SecurityGroupId > 06 ) begin

      /* Get the work orders that the current user has access to. */
      select pcss.PROVIDER_CUSTOMER_SERVICE_SCHEDULE_ID,
             pcss.CUSTOMER_UNIT_ID,
             pcss.PROVIDER_SERVICE_TYPE_ID,
             pcss.COM_SERVICE_ID,
             convert( varchar(10), pcss.PROVIDER_CUSTOMER_SERVICE_SCHEDULE_DATE, 01 ) as SERVICE_DATE,
             convert( varchar(08), pcss.PROVIDER_CUSTOMER_SERVICE_SCHEDULE_DATE, 08)  as SERVICE_START_TIME,
             pcss.WORK_ORDER_NUMBER
      from PROVIDER_CUSTOMER_SERVICE_SCHEDULE pcss
      inner join      PROVIDER_SERVICE_TYPE pst           on pcss.PROVIDER_SERVICE_TYPE_ID = pst.PROVIDER_SERVICE_TYPE_ID
      left outer join VW_CUSTOMER_UNITS_BY_SYSTEM_USER vw on pcss.CUSTOMER_UNIT_ID         = vw.CUSTOMER_UNIT_ID
      where ( vw.PROVIDER_SYSTEM_ID  = @ProviderSystemId ) and
            ( vw.MEMBER_USER_ID      = @MemberUserId   ) and
            ( pst.PROVIDER_SYSTEM_ID = @ProviderSystemId ) and
            ( pcss.PROVIDER_CUSTOMER_SERVICE_SCHEDULE_DATE >= @StartDate ) and
            ( pcss.PROVIDER_CUSTOMER_SERVICE_SCHEDULE_DATE <  DateAdd( d, 01, @EndDate ) )
      order by pcss.PROVIDER_CUSTOMER_SERVICE_SCHEDULE_DATE desc

      /* If there was an error... */
      if ( @@Error <> 00 ) begin

         /* Rollback the transaction. */
         rollback transaction

         /* Return the failure. */
         return 01

      end

   end

   else begin /* If the current user is a super user... */

      /* Get the identifier for the current user's customer. */
      select @CustomerId = MEMBER_ID
      from MEMBER_USER
      where MEMBER_USER_ID = @MemberUserId

      /* Get the rows affected and the error code for the previous statement.
         Error checking MUST be done this way since any single statement executed
         will affect both of the global functions, @@RowCount and @@Error. */
      select @RowsAffected = @@RowCount, @ErrorCode = @@Error

      /* If there was an error... */
      if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

         /* Rollback the transaction. */
         rollback transaction

         /* Return the failure. */
         return 01

      end

      /* Get the work orders that the current customer has access to. */
      select pcss.PROVIDER_CUSTOMER_SERVICE_SCHEDULE_ID,
             pcss.CUSTOMER_UNIT_ID,
             pcss.PROVIDER_SERVICE_TYPE_ID,
             pcss.COM_SERVICE_ID,
             convert( varchar(10), pcss.PROVIDER_CUSTOMER_SERVICE_SCHEDULE_DATE, 01 ) as SERVICE_DATE,
             convert( varchar(08), pcss.PROVIDER_CUSTOMER_SERVICE_SCHEDULE_DATE, 08 ) as SERVICE_START_TIME,
             pcss.WORK_ORDER_NUMBER
      from PROVIDER_CUSTOMER_SERVICE_SCHEDULE pcss
      inner join      PROVIDER_SERVICE_TYPE pst               on pcss.PROVIDER_SERVICE_TYPE_ID = pst.PROVIDER_SERVICE_TYPE_ID
      left outer join VW_CUSTOMER_UNITS_BY_SYSTEM_CUSTOMER vw on pcss.CUSTOMER_UNIT_ID         = vw.CUSTOMER_UNIT_ID
      where ( vw.PROVIDER_SYSTEM_ID  = @ProviderSystemId   ) and
            ( vw.CUSTOMER_ID         = @CustomerId ) and
            ( pst.PROVIDER_SYSTEM_ID = @ProviderSystemId   ) and
            ( pcss.PROVIDER_CUSTOMER_SERVICE_SCHEDULE_DATE >= @StartDate ) and
            ( pcss.PROVIDER_CUSTOMER_SERVICE_SCHEDULE_DATE <  DateAdd( d, 01, @EndDate ) )
      order by pcss.PROVIDER_CUSTOMER_SERVICE_SCHEDULE_DATE desc

      /* If there was an error... */
      if ( @@Error <> 00 ) begin

         /* Rollback the transaction. */
         rollback transaction

         /* Return the failure. */
         return 01

      end

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetWorkOrdersCompletedBySystemUnit' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetWorkOrdersCompletedBySystemUnit

   go

create procedure spGetWorkOrdersCompletedBySystemUnit( @ProviderSystemId integer,
                                                       @CustomerUnitId   integer ) as

   declare @ReturnCode integer /* Result code returned by the execution of the stored procedure */

   /* Get the completed work orders for the current service program and
      customer unit. */
   execute @ReturnCode = spGetProviderCustomerServiceScheduleBySystemUnit @ProviderSystemId,
                                                                          @CustomerUnitId,
                                                                          00

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetWorkOrdersPendingBySystemUnit' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetWorkOrdersPendingBySystemUnit

   go

create procedure spGetWorkOrdersPendingBySystemUnit( @ProviderSystemId integer,
                                                     @CustomerUnitId   integer ) as

   declare @ReturnCode integer /* Result code returned by the execution of the stored procedure */

   /* Get the pending work orders for the current service program and customer
      unit. */
   execute @ReturnCode = spGetProviderCustomerServiceScheduleBySystemUnit @ProviderSystemId,
                                                                          @CustomerUnitId,
                                                                          01

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spInsertApplicationHelp' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spInsertApplicationHelp

   go

create procedure spInsertApplicationHelp( @PhysicalPage integer,
                                          @LogicalPage  integer,
                                          @HelpAction   integer,
                                          @HelpText     text,
                                          @HelpId       integer output ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @RowsAffected integer /* Number of rows affected by the previously executed statement */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Insert the new row. */
   insert into APPLICATION_HELP
   ( PHYSICAL_PAGE,
     LOGICAL_PAGE,
     HELP_ACTION,
     HELP_TEXT )
   values
   ( @PhysicalPage,
     @LogicalPage,
     @HelpAction,
     @HelpText )

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* Set the value of the new primary key to return. */
   select @HelpId = @@Identity

   /* If there was an error... */
   if ( @@Error <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spInsertComServiceData' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure  spInsertComServiceData

   go

create procedure spInsertComServiceData( @ComServiceUnitValueId     integer,
                                         @ProviderServiceDataTypeId integer,
                                         @ProviderServiceDataId     integer,
                                         @ComServiceDataAltText     varchar(255),
                                         @RowId                     integer,
                                         @ComServiceDataId          integer output,
                                         @LogTransaction            integer = 1 ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @RowsAffected integer /* Number of rows affected by the previously executed statement */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
      set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was executed... */
      if ( @Transactions = 00 ) begin

   /* Start the transaction. */
         begin transaction

      end

   /* If @ProviderServiceDataTypeId is null then go get it */
   if ( @ProviderServiceDataTypeId is null ) and ( @ProviderServiceDataId is not null ) begin
      select @ProviderServiceDataTypeId = PROVIDER_SERVICE_DATA_TYPE_ID
      from PROVIDER_SERVICE_DATA
      where PROVIDER_SERVICE_DATA_ID = @ProviderServiceDataId

      /* Get the rows affected and the error code for the previous statement.
         Error checking MUST be done this way since any single statement executed
         will affect both of the global functions, @@RowCount and @@Error. */
      select @RowsAffected = @@RowCount, @ErrorCode = @@Error

      /* If there was an error... */
      if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

         /* Rollback the transaction. */
         rollback transaction

         /* Return the failure. */
         return 01

      end

   end

   if ( @ProviderServiceDataId = 00 ) set @ProviderServiceDataId = NULL

   /* Insert a new row in the XXXXXXXX table. */
      insert into COM_SERVICE_DATA (
         [COM_SERVICE_UNIT_VALUE_ID],
         [PROVIDER_SERVICE_DATA_TYPE_ID],
         [PROVIDER_SERVICE_DATA_ID],
         [COM_SERVICE_DATA_ALT_TEXT],
         [ROW_ID]
      )
      values (
         @ComServiceUnitValueId,
         @ProviderServiceDataTypeId,
         @ProviderServiceDataId,
         @ComServiceDataAltText,
         @RowId
      )

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* Set the value of the new primary key for the XXXXXXXX. */
   select @ComServiceDataId = @@Identity

   /* If there was an error... */
   if ( @@Error <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   if ( @LogTransaction = 1 ) begin

      declare @InterfaceId integer

      declare INTERFACE_CURSOR cursor for
      select jmiet.INTERFACE_ID
      from JOIN_MAPPING_INTERFACE_ENTITY_TYPE jmiet,
           MAPPING_INTERFACE mi,
           PROVIDER_SYSTEM ps,
           PROVIDER_SERVICE_TYPE pst,
           COM_SERVICE cs,
           COM_SERVICE_UNIT_VALUE csuv
      where jmiet.INTERFACE_ID = mi.INTERFACE_ID
        and mi.PROVIDER_ID = ps.PROVIDER_ID
        and ps.PROVIDER_SYSTEM_ID = pst.PROVIDER_SYSTEM_ID
        and pst.PROVIDER_SERVICE_TYPE_ID = cs.PROVIDER_SERVICE_TYPE_ID
        and cs.COM_SERVICE_ID = csuv.COM_SERVICE_ID
        and csuv.COM_SERVICE_UNIT_VALUE_ID = @ComServiceUnitValueId
        and jmiet.ENTITY_TYPE_ID = 13
        and jmiet.LOG_TRANSACTION = 1

      open INTERFACE_CURSOR

      fetch next from INTERFACE_CURSOR into
      @InterfaceId

      while ( @@fetch_status = 0 ) begin

         if not exists ( select * from TRANSACTION_LOG where ENTITY_ID = @ComServiceUnitValueId and ENTITY_TYPE_ID = 13 and INTERFACE_ID = @InterfaceId ) begin

            /* If there was an error... */
            if ( @@Error <> 00 ) begin

               /* Rollback the transaction. */
               rollback transaction

               /* Return the failure. */
               return 01

            end

            /* Insert into TRANSACTION_LOG using spInsertTransactionLog */
            exec spInsertTransactionLog @InterfaceId, @ComServiceUnitValueId, 13, 'U', 0, 0

            /* Get the rows affected and the error code for the previous statement.
               Error checking MUST be done this way since any single statement executed
               will affect both of the global functions, @@RowCount and @@Error. */
            select @RowsAffected = @@RowCount, @ErrorCode = @@Error

            /* If there was an error... */
            if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

               /* Rollback the transaction. */
               rollback transaction

               /* Return the failure. */
               return 01

            end

         end

      fetch next from INTERFACE_CURSOR into
      @InterfaceId

      end

      close INTERFACE_CURSOR
      deallocate INTERFACE_CURSOR

   end

   /* If there were no active transactions when this stored procedure was executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spInsertComServiceUnitValue' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spInsertComServiceUnitValue

   go

create procedure spInsertComServiceUnitValue( @ComServiceId           integer,
                                              @ProviderServiceValueId integer,
                                              @CustomerUnitId         integer,
                                              @Timestamp              datetime,
                                              @ComServiceUnitValueId  integer output,
                                              @LogTransaction         integer = 1 ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @RowsAffected integer /* Number of rows affected by the previously executed statement */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Insert a new row in the XXXXXXXX table. */
   insert into COM_SERVICE_UNIT_VALUE (
      [COM_SERVICE_ID],
      [PROVIDER_SERVICE_VALUE_ID],
      [CUSTOMER_UNIT_ID],
      [TIMESTAMP]
   )
   values (
      @ComServiceId,
      @ProviderServiceValueId,
      @CustomerUnitId,
      @Timestamp
   )

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* Set the value of the new primary key for the XXXXXXXX. */
   select @ComServiceUnitValueId = @@Identity

   /* If there was an error... */
   if ( @@Error <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If @LogTransaction = 1 then check if log entry exists */
   if ( @LogTransaction = 1 ) begin

      declare @InterfaceId integer

      declare INTERFACE_CURSOR cursor for
      select jmiet.INTERFACE_ID
      from JOIN_MAPPING_INTERFACE_ENTITY_TYPE jmiet,
           MAPPING_INTERFACE mi,
           PROVIDER_SYSTEM ps,
           PROVIDER_SERVICE_TYPE pst,
           COM_SERVICE cs,
           COM_SERVICE_UNIT_VALUE csuv
      where jmiet.INTERFACE_ID = mi.INTERFACE_ID
        and mi.PROVIDER_ID = ps.PROVIDER_ID
        and ps.PROVIDER_SYSTEM_ID = pst.PROVIDER_SYSTEM_ID
        and pst.PROVIDER_SERVICE_TYPE_ID = cs.PROVIDER_SERVICE_TYPE_ID
        and cs.COM_SERVICE_ID = csuv.COM_SERVICE_ID
        and csuv.COM_SERVICE_UNIT_VALUE_ID = @ComServiceUnitValueId
        and jmiet.ENTITY_TYPE_ID = 13
        and jmiet.LOG_TRANSACTION = 1

      open INTERFACE_CURSOR

      fetch next from INTERFACE_CURSOR into
      @InterfaceId

      while ( @@fetch_status = 0 ) begin

         if not exists ( select * from TRANSACTION_LOG where ENTITY_ID = @ComServiceUnitValueId and ENTITY_TYPE_ID = 13 and INTERFACE_ID = @InterfaceId ) begin

            /* If there was an error... */
            if ( @@Error <> 00 ) begin

               /* Rollback the transaction. */
               rollback transaction

               /* Return the failure. */
               return 01

            end

            /* Insert into TRANSACTION_LOG using spInsertTransactionLog */
            exec spInsertTransactionLog @InterfaceId, @ComServiceUnitValueId, 13, 'U', 0, 0

            /* Get the rows affected and the error code for the previous statement.
               Error checking MUST be done this way since any single statement executed
               will affect both of the global functions, @@RowCount and @@Error. */
            select @RowsAffected = @@RowCount, @ErrorCode = @@Error

            /* If there was an error... */
            if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

               /* Rollback the transaction. */
               rollback transaction

               /* Return the failure. */
               return 01

            end

         end

      fetch next from INTERFACE_CURSOR into
      @InterfaceId

      end

      close INTERFACE_CURSOR
      deallocate INTERFACE_CURSOR

   end

   /* If there were no active transactions when this stored procedure was executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spInsertCustomerSubUnit' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spInsertCustomerSubUnit

   go

create procedure spInsertCustomerSubUnit( @CustomerId         integer,
                                          @CustomerUnitName   varchar(100),
                                          @CustomerUnitNumber varchar(50),
                                          @UnitParentId       integer,
                                          @CustomerUnitTypeId integer,
                                          @CustomerUnitNameId integer,
                                          @CustomerUnitId     integer output) as

   declare @ErrorCode    integer      /* Error code returned by the execution of the last statement    */
   declare @RowsAffected integer      /* Number of rows affected by the previously executed statement  */
   declare @ReturnCode   integer      /* Result code returned by the execution of the stored procedure */
   declare @InstallDate  datetime /* Sets the INSTALL_DATE field of the CUSTOMER_UNIT record       */
   declare @Transactions integer      /* Number of active transactions at the start of this procedure  */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* If the customer unit does NOT already exist... */
   if ( not ( Exists( select customer_unit_id
                      from customer_unit
                      where customer_id = @CustomerId
                      and customer_unit_number = @CustomerUnitNumber
                      and unit_parent_id = @UnitParentId ) ) ) begin

      /* Get the current system date */
      set @InstallDate = GetDate()

      /* Insert the new customer sub-unit row. */
      execute @ReturnCode = spInsertCustomerUnit @CustomerId,
                                                 @CustomerUnitName,
                                                 @CustomerUnitNumber,
                                                 @UnitParentId,
                                                 @InstallDate,
                                                 @CustomerUnitId output, 00

      /* If there was an error... */
      if ( @ReturnCode <> 00 ) begin

         /* Return the failure. */
         return @ReturnCode

      end

   end

   /* If a customer unit with the same customer_id, unit_parent_id and customer_unit_number
      already exists. */
   else begin

      /* Get the identifier for the customer unit if it already exists.  This will
         occur if the user is adding an existing unit with a barcode to another
         service program. */
      select @CustomerUnitId = customer_unit_id
      from customer_unit
      where customer_id = @CustomerId
        and customer_unit_number = @CustomerUnitNumber
        and unit_parent_id = @UnitParentId

   end

   /* If the customer unit already exists but is NOT part of the currently
      specified service program as denoted by the specified customer unit type
      identifier... */
   if ( not ( Exists( select customer_unit_id
                      from customer_unit_type cut
                      inner join join_customer_unit_type_customer_unit jcutcu on cut.customer_unit_type_id = jcutcu.customer_unit_type_id
                      where jcutcu.customer_unit_id = @CustomerUnitId and cut.provider_system_id =
                      ( select provider_system_id
                        from customer_unit_type
                        where customer_unit_type_id = @CustomerUnitTypeId ) ) ) ) begin

      /* Insert the new customer sub-unit/customer unit type row in the join
         table to add the customer sub-unit to the service program. */
      execute @ReturnCode = spInsertJoinCustomerUnitTypeCustomerUnit @CustomerUnitTypeId,
                                                                     @CustomerUnitId,
                                                                     @CustomerUnitNameId

      /* If there was an error... */
      if ( @ReturnCode <> 00 ) begin

         /* Return the failure. */
         return @ReturnCode

      end

      /* Generate all of the default subunits defined for the specified customer
         unit type in the service program. */
      execute @ReturnCode = spCreateNewCustomerUnitsByParentType @CustomerUnitTypeId,
                                                                 @CustomerUnitId,
                                                                 @CustomerId

      /* If there was an error... */
      if ( @ReturnCode <> 00 ) begin

         /* Return the failure. */
         return @ReturnCode

      end

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spInsertCustomerUnit' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spInsertCustomerUnit

   go

create procedure spInsertCustomerUnit( @CustomerId         integer,
                                       @CustomerUnitName   varchar(100),
                                       @CustomerUnitNumber varchar(50),
                                       @UnitParentId       integer,
                                       @InstallDate        datetime,
                                       @CustomerUnitId     integer out,
                                       @LogTransaction     integer = 1 ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @RowsAffected integer /* Number of rows affected by the previously executed statement */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Get the current system date as the install date. */
   select @InstallDate = GetDate()

   /* Insert a new row in the customer unit table. */
   insert into CUSTOMER_UNIT (
      [CUSTOMER_ID],
      [CUSTOMER_UNIT_NAME],
      [CUSTOMER_UNIT_NUMBER],
      [UNIT_PARENT_ID],
      [INSTALL_DATE]
   )
   values (
      @CustomerId,
      @CustomerUnitName,
      @CustomerUnitNumber,
      @UnitParentId,
      @InstallDate
   )

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* Set the value of the new primary key for the customer unit. */
   select @CustomerUnitId = @@Identity

   /* If there was an error... */
   if ( @@Error <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If parameter @LogTransaction = 1 then check if log entry exists */
   if ( @LogTransaction = 1 ) begin

      if ( @UnitParentId = -1 ) begin

         declare @InterfaceId integer

         declare INTERFACE_CURSOR cursor for
         select jmiet.INTERFACE_ID
         from JOIN_MAPPING_INTERFACE_ENTITY_TYPE jmiet,
              MAPPING_INTERFACE mi,
              PROVIDER_CUSTOMER pc,
              CUSTOMER_UNIT cu
         where jmiet.INTERFACE_ID = mi.INTERFACE_ID
           and mi.PROVIDER_ID = pc.PROVIDER_ID
           and pc.CUSTOMER_ID = cu.CUSTOMER_ID
           and cu.CUSTOMER_UNIT_ID = @CustomerUnitId
           and jmiet.ENTITY_TYPE_ID = 5
           and jmiet.LOG_TRANSACTION = 1

         /* If there was an error... */
         if ( @@Error <> 00 ) begin

            /* Rollback the transaction. */
            rollback transaction

            /* Return the failure. */
            return 01

         end

         open INTERFACE_CURSOR

         /* If there was an error... */
         if ( @@Error <> 00 ) begin

            /* Rollback the transaction. */
            rollback transaction

            /* Return the failure. */
            return 01

         end

         fetch next from INTERFACE_CURSOR into
         @InterfaceId

         while ( @@fetch_status = 0 ) begin

            if not exists ( select * from TRANSACTION_LOG where ENTITY_ID = @CustomerUnitId and ENTITY_TYPE_ID = 5 and INTERFACE_ID = @InterfaceId ) begin

               /* If there was an error... */
               if ( @@Error <> 00 ) begin

                  /* Rollback the transaction. */
                  rollback transaction

                  /* Return the failure. */
                  return 01

               end

               /* Insert into TRANSACTION_LOG using spInsertTransactionLog */
               exec spInsertTransactionLog @InterfaceId, @CustomerUnitId, 5, 'U', 0, 0

               /* Get the rows affected and the error code for the previous statement.
                  Error checking MUST be done this way since any single statement executed
                  will affect both of the global functions, @@RowCount and @@Error. */
               select @RowsAffected = @@RowCount, @ErrorCode = @@Error

               /* If there was an error... */
               if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

                  /* Rollback the transaction. */
                  rollback transaction

                  /* Return the failure. */
                  return 01

               end

            end

         fetch next from INTERFACE_CURSOR into
         @InterfaceId

         end

         close INTERFACE_CURSOR
         deallocate INTERFACE_CURSOR

      end

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spInsertJoinCustomerUnitTypeCustomerUnit' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spInsertJoinCustomerUnitTypeCustomerUnit

   go

create procedure spInsertJoinCustomerUnitTypeCustomerUnit( @CustomerUnitTypeId   integer,
                                                           @CustomerUnitId       integer,
														   @CustomerUnitNameId   integer ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @RowsAffected integer /* Number of rows affected by the previously executed statement */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
      set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was executed... */
      if ( @Transactions = 00 ) begin

   /* Start the transaction. */
         begin transaction

      end

   /* Insert a new row in the JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT table. */
      insert into JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT (
         [CUSTOMER_UNIT_TYPE_ID],
         [CUSTOMER_UNIT_ID],
         [CUSTOMER_UNIT_NAME_ID]
      )
      values (
         @CustomerUnitTypeId,
         @CustomerUnitId,
         @CustomerUnitNameId
      )

   /* Get the rows affected and the error code for the previous statement.
   Error checking MUST be done this way since any single statement executed
   will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spInsertJoinMemberUserSecurityGroup' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spInsertJoinMemberUserSecurityGroup

   go

create procedure spInsertJoinMemberUserSecurityGroup( @MemberUserId    integer,
                                                      @SecurityGroupId integer ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @RowsAffected integer /* Number of rows affected by the previously executed statement */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Insert a new row in the XXXXXXXX table. */
   insert into JOIN_MEMBER_USER_SECURITY_GROUP
   ( MEMBER_USER_ID,
     SECURITY_GROUP_ID )
   values
   ( @MemberUserId,
     @SecurityGroupId )

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spInsertMappingEntity' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spInsertMappingEntity

   go

create procedure spInsertMappingEntity( @InterfaceId     integer,
                                        @EntityId        integer,
                                        @EntityTypeId    integer,
                                        @ForeignId       varchar(50),
                                        @ForeignType     varchar(50),
                                        @MappingEntityId integer output ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @RowsAffected integer /* Number of rows affected by the previously executed statement */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Insert a new row in the mapping entity table. */
   insert into MAPPING_ENTITY
   ( [INTERFACE_ID],
     [ENTITY_ID],
     [ENTITY_TYPE_ID],
     [FOREIGN_ID],
     [FOREIGN_TYPE] )
   values
   ( @InterfaceId,
     @EntityId,
     @EntityTypeId,
     @ForeignId,
     @ForeignType )

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* Set the value of the new primary key for the mapping entity. */
   select @MappingEntityId = @@Identity

   /* If there was an error... */
   if ( @@Error <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spInsertMember' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spInsertMember

   go

create procedure spInsertMember( @MemberTypeId   integer,
                                 @MemberName     varchar(100),
                                 @MemberId       integer output,
                                 @LogTransaction integer = 1 ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @RowsAffected integer /* Number of rows affected by the previously executed statement */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Insert a new row in the XXXXXXXX table. */
   insert into MEMBER (
      [MEMBER_TYPE_ID],
      [MEMBER_NAME]
   )
   values (
      @MemberTypeId,
      @MemberName
   )

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* Set the value of the new primary key for the XXXXXXXX. */
   select @MemberId = @@Identity

   /* If there was an error... */
   if ( @@Error <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If parameter @LogTransaction = 1 then check if log entry exists */
   if ( @LogTransaction = 1 ) begin

      if ( @MemberTypeId = 2 ) begin

         declare @InterfaceId integer

         declare INTERFACE_CURSOR cursor for
         select jmiet.INTERFACE_ID
         from JOIN_MAPPING_INTERFACE_ENTITY_TYPE jmiet,
              MAPPING_INTERFACE mi,
              PROVIDER_CUSTOMER pc
         where jmiet.INTERFACE_ID = mi.INTERFACE_ID
           and mi.PROVIDER_ID = pc.PROVIDER_ID
           and pc.CUSTOMER_ID = @MemberId
           and jmiet.ENTITY_TYPE_ID = 4
           and jmiet.LOG_TRANSACTION = 1

         open INTERFACE_CURSOR

         fetch next from INTERFACE_CURSOR into
         @InterfaceId

         while ( @@fetch_status = 0 ) begin

            if not exists ( select * from TRANSACTION_LOG where ENTITY_ID = @MemberId and ENTITY_TYPE_ID = 4 and INTERFACE_ID = @InterfaceId ) begin

               /* If there was an error... */
               if ( @@Error <> 00 ) begin

                  /* Rollback the transaction. */
                  rollback transaction

                  /* Return the failure. */
                  return 01

               end

               /* Insert into TRANSACTION_LOG using spInsertTransactionLog */
               exec spInsertTransactionLog @InterfaceId, @MemberId, 4, 'U', 0, 0

               /* Get the rows affected and the error code for the previous statement.
                  Error checking MUST be done this way since any single statement executed
                  will affect both of the global functions, @@RowCount and @@Error. */
               select @RowsAffected = @@RowCount, @ErrorCode = @@Error

               /* If there was an error... */
               if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

                  /* Rollback the transaction. */
                  rollback transaction

                  /* Return the failure. */
                  return 01

               end

            end

         fetch next from INTERFACE_CURSOR into
         @InterfaceId

         end

         close INTERFACE_CURSOR
         deallocate INTERFACE_CURSOR

      end

   end

   /* If there were no active transactions when this stored procedure was executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spInsertMemberGroup' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spInsertMemberGroup

   go

create procedure spInsertMemberGroup ( @MemberGroupTypeId integer,
                                       @MemberGroupName   varchar(50),
                                       @MemberGroupId     integer output,
                                       @LogTransaction    integer = 1 ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @RowsAffected integer /* Number of rows affected by the previously executed statement */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */
   declare @BranchorRoute varchar(15)
   declare @EntityTypeId integer

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Insert a new row in the XXXXXXXX table. */
   insert into MEMBER_GROUP (
      [MEMBER_GROUP_TYPE_ID],
      [MEMBER_GROUP_NAME]
   )
   values (
      @MemberGroupTypeId,
      @MemberGroupName
   )

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* Set the value of the new primary key for the XXXXXXXX. */
   select @MemberGroupId = @@Identity

   /* If there was an error... */
   if ( @@Error <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If parameter @LogTransaction = 1 then check if log entry exists */
   if ( @LogTransaction = 1 ) begin

      select @BranchorRoute = MEMBER_GROUP_TYPE_NAME from MEMBER_GROUP_TYPE where MEMBER_GROUP_TYPE_ID = @MemberGroupTypeId

      /* Get the rows affected and the error code for the previous statement.
         Error checking MUST be done this way since any single statement executed
         will affect both of the global functions, @@RowCount and @@Error. */
      select @RowsAffected = @@RowCount, @ErrorCode = @@Error

      /* If there was an error... */
      if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

         /* Rollback the transaction. */
         rollback transaction

         /* Return the failure. */
         return 01

      end

      if ( @BranchorRoute = 'Routes' ) set @EntityTypeId = 16 else if ( @BranchorRoute = 'Branches' ) set @EntityTypeId = 15

      declare @InterfaceId integer

      declare INTERFACE_CURSOR cursor for
      select jmiet.INTERFACE_ID
      from JOIN_MAPPING_INTERFACE_ENTITY_TYPE jmiet,
           MAPPING_INTERFACE mi,
           MEMBER_GROUP_TYPE mgt,
           MEMBER_GROUP mg
      where jmiet.INTERFACE_ID = mi.INTERFACE_ID
        and mi.PROVIDER_ID = mgt.MEMBER_ID
        and mgt.MEMBER_GROUP_TYPE_ID = mg.MEMBER_GROUP_TYPE_ID
        and mg.MEMBER_GROUP_ID = @MemberGroupId
        and jmiet.ENTITY_TYPE_ID = @EntityTypeId
        and jmiet.LOG_TRANSACTION = 1

      open INTERFACE_CURSOR

      fetch next from INTERFACE_CURSOR into
      @InterfaceId

      while ( @@fetch_status = 0 ) begin

         if not exists ( select * from TRANSACTION_LOG where ENTITY_ID = @MemberGroupId and ENTITY_TYPE_ID = @EntityTypeId and INTERFACE_ID = @InterfaceId ) begin

            /* If there was an error... */
            if ( @@Error <> 00 ) begin

               /* Rollback the transaction. */
               rollback transaction

              /* Return the failure. */
              return 01

            end

            /* Insert into TRANSACTION_LOG using spInsertTransactionLog */
            exec spInsertTransactionLog @InterfaceId, @MemberGroupId, @EntityTypeId, 'U', 0, 0

            /* Get the rows affected and the error code for the previous statement.
               Error checking MUST be done this way since any single statement executed
               will affect both of the global functions, @@RowCount and @@Error. */
            select @RowsAffected = @@RowCount, @ErrorCode = @@Error

            /* If there was an error... */
            if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

               /* Rollback the transaction. */
               rollback transaction

               /* Return the failure. */
               return 01

            end

         end

      fetch next from INTERFACE_CURSOR into
      @InterfaceId

      end

      close INTERFACE_CURSOR
      deallocate INTERFACE_CURSOR

   end

   /* If there were no active transactions when this stored procedure was executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spInsertMemberUser' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spInsertMemberUser

   go

create procedure spInsertMemberUser( @MemberId            integer,
                                     @MemberUserName      varchar(50),
                                     @MemberUserPwd       varchar(15),
                                     @MemberUserFname     varchar(25),
                                     @MemberUserLname     varchar(25),
                                     @MemberUserLastLogin datetime,
                                     @MemberUserEmail     varchar(50),
                                     @MemberUserId        integer output,
                                     @LogTransAction      integer = 1 ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @RowsAffected integer /* Number of rows affected by the previously executed statement */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */
   declare @MemberTypeId integer

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Insert a new row in the XXXXXXXX table. */
   insert into MEMBER_USER (
      [MEMBER_ID],
      [MEMBER_USER_NAME],
      [MEMBER_USER_PWD],
      [MEMBER_USER_FNAME],
      [MEMBER_USER_LNAME],
      [MEMBER_USER_LAST_LOGIN],
      [MEMBER_USER_EMAIL]
   )
   values (
      @MemberId,
      @MemberUserName,
      @MemberUserPwd,
      @MemberUserFname,
      @MemberUserLname,
      @MemberUserLastLogin,
      @MemberUserEmail
   )

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* Set the value of the new primary key for the XXXXXXXX. */
   select @MemberUserId = @@Identity

   /* If there was an error... */
   if ( @@Error <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If parameter @LogTransaction = 1 then check if log entry exists */
   if ( @LogTransaction = 1 ) begin

      select @MemberTypeId = MEMBER_TYPE_ID from MEMBER where MEMBER_ID = @MemberId

      /* If there was an error... */
      if ( @@Error <> 00 ) begin

         /* Rollback the transaction. */
         rollback transaction

         /* Return the failure. */
         return 01

      end

      /* If parameter @MemberTypeId = 1 then check if log entry exists */
      if ( @MemberTypeId = 1 ) begin

         declare @InterfaceId integer

         declare INTERFACE_CURSOR cursor for
         select jmiet.INTERFACE_ID
         from JOIN_MAPPING_INTERFACE_ENTITY_TYPE jmiet,
              MAPPING_INTERFACE mi,
              MEMBER_USER mu
         where jmiet.INTERFACE_ID = mi.INTERFACE_ID
           and mi.PROVIDER_ID = mu.MEMBER_ID
           and mu.MEMBER_USER_ID = @MemberUserId
           and jmiet.ENTITY_TYPE_ID = 1
           and jmiet.LOG_TRANSACTION = 1

         open INTERFACE_CURSOR

         fetch next from INTERFACE_CURSOR into
         @InterfaceId

         while ( @@fetch_status = 0 ) begin

            if not exists ( select * from TRANSACTION_LOG where ENTITY_ID = @MemberUserId and ENTITY_TYPE_ID = 1 and INTERFACE_ID = @InterfaceId ) begin

               /* If there was an error... */
               if ( @@Error <> 00 ) begin

                  /* Rollback the transaction. */
                  rollback transaction

                  /* Return the failure. */
                  return 01

               end

               /* Insert into TRANSACTION_LOG using spInsertTransactionLog */
               exec spInsertTransactionLog @InterfaceId, @MemberUserId, 1, 'U', 0, 0

               /* Get the rows affected and the error code for the previous statement.
                  Error checking MUST be done this way since any single statement executed
                  will affect both of the global functions, @@RowCount and @@Error. */
               select @RowsAffected = @@RowCount, @ErrorCode = @@Error

               /* If there was an error... */
               if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

                  /* Rollback the transaction. */
                  rollback transaction

                  /* Return the failure. */
                  return 01

               end

            end

         fetch next from INTERFACE_CURSOR into
         @InterfaceId

         end

         close INTERFACE_CURSOR
         deallocate INTERFACE_CURSOR

      end

   end

   /* If there were no active transactions when this stored procedure was executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spInsertProviderCustomerServiceFinancial' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spInsertProviderCustomerServiceFinancial

   go

create procedure spInsertProviderCustomerServiceFinancial( @ProviderCustomerServiceId           integer,
                                                           @ProviderServiceTypeId               integer,
                                                           @CustomerUnitId                      integer,
                                                           @ProviderCustomerServiceAmount       varchar(10),
                                                           @ProviderCustomerServiceFinancialId  integer output,
                                                           @LogTransaction                      integer = 01 ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement    */
   declare @RowsAffected integer /* Number of rows affected by the previously executed statement  */
   declare @Transactions integer /* Number of active transactions at the start of this procedure  */
   declare @ReturnCode   integer /* Result code returned by the execution of the stored procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* If the provider customer service identifier was not passed... */
   if (@ProviderCustomerServiceId is null ) begin

      /* Since this parameter is not required, we can used the service type
         and customer unit identifiers to find the value in the database. */
      select @ProviderCustomerServiceId = PROVIDER_CUSTOMER_SERVICE_ID
      from PROVIDER_CUSTOMER_SERVICE pcs
      inner join PROVIDER_CUSTOMER     pc  on pcs.PROVIDER_CUSTOMER_ID = pc.PROVIDER_CUSTOMER_ID
      inner join PROVIDER_SYSTEM       ps  on pc.PROVIDER_ID           = ps.PROVIDER_ID
      inner join PROVIDER_SERVICE_TYPE pst on ps.PROVIDER_SYSTEM_ID    = pst.PROVIDER_SYSTEM_ID
      inner join CUSTOMER_UNIT         cu  on pc.CUSTOMER_ID           = cu.CUSTOMER_ID
      where pst.PROVIDER_SERVICE_TYPE_ID = @ProviderServiceTypeId and
            cu.CUSTOMER_UNIT_ID          = @CustomerUnitId

      /* Get the rows affected and the error code for the previous statement.
         Error checking MUST be done this way since any single statement executed
         will affect both of the global functions, @@RowCount and @@Error. */
      select @RowsAffected = @@RowCount, @ErrorCode = @@Error

      /* If there was an error... */
      if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

         /* Rollback the transaction. */
         rollback transaction

         /* Return the failure. */
         return 01

      end

   end

   /* Insert a new row in the provider customer service table. */
   insert into PROVIDER_CUSTOMER_SERVICE_FINANCIAL
   ( PROVIDER_CUSTOMER_SERVICE_ID,
     PROVIDER_SERVICE_TYPE_ID,
     CUSTOMER_UNIT_ID,
     PROVIDER_CUSTOMER_SERVICE_AMOUNT )
   values
   ( @ProviderCustomerServiceId,
     @ProviderServiceTypeId,
     @CustomerUnitId,
     @ProviderCustomerServiceAmount )

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* Set the value of the new primary key for the customer service schedule. */
   select @ProviderCustomerServiceFinancialId = @@Identity

   /* If there was an error... */
   if ( @@Error <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If @LogTransaction = 01 then check if log entry exists. */
   if ( @LogTransaction = 01 ) begin

      declare @InterfaceId integer

      declare INTERFACE_CURSOR cursor for
      select jmiet.INTERFACE_ID
      from JOIN_MAPPING_INTERFACE_ENTITY_TYPE jmiet,
           MAPPING_INTERFACE mi,
           PROVIDER_SYSTEM ps,
           PROVIDER_SERVICE_TYPE pst,
           PROVIDER_CUSTOMER_SERVICE_FINANCIAL pcsf
      where jmiet.INTERFACE_ID                          = mi.INTERFACE_ID and
            mi.PROVIDER_ID                              = ps.PROVIDER_ID and
            ps.PROVIDER_SYSTEM_ID                       = pst.PROVIDER_SYSTEM_ID and
            pst.PROVIDER_SERVICE_TYPE_ID                = pcsf.PROVIDER_SERVICE_TYPE_ID and
            pcsf.PROVIDER_CUSTOMER_SERVICE_FINANCIAL_ID = @ProviderCustomerServiceFinancialId and
            jmiet.ENTITY_TYPE_ID                        = 14 and
            jmiet.LOG_TRANSACTION                       = 01

      /* If there was an error... */
      if ( @@Error <> 00 ) begin

         /* Rollback the transaction. */
         rollback transaction

         /* Return the failure. */
         return 01

      end

      open INTERFACE_CURSOR

      /* If there was an error... */
      if ( @@Error <> 00 ) begin

         /* Rollback the transaction. */
         rollback transaction

         /* Return the failure. */
         return 01

      end

      fetch next from INTERFACE_CURSOR into @InterfaceId

      while ( @@Fetch_Status = 00 ) begin

         if not exists ( select * from TRANSACTION_LOG
                         where ENTITY_ID      = @ProviderCustomerServiceFinancialId and
                               ENTITY_TYPE_ID = 14                                  and
                               INTERFACE_ID   = @InterfaceId ) begin

            /* If there was an error... */
            if ( @@Error <> 00 ) begin

               /* Rollback the transaction. */
               rollback transaction

               /* Return the failure. */
               return 01

            end

            /* Insert into TRANSACTION_LOG using spInsertTransactionLog */
            execute @ReturnCode = spInsertTransactionLog @InterfaceId,
                                                         @ProviderCustomerServiceFinancialId,
                                                         14, 'U', 00, 00

            /* If there was an error... */
            if ( @ReturnCode <> 00 ) begin

               /* Return the failure. */
               return @ReturnCode

            end

         end

         fetch next from INTERFACE_CURSOR into @InterfaceId

      end

      close INTERFACE_CURSOR

      deallocate INTERFACE_CURSOR

      /* If there was an error... */
      if ( @@Error <> 00 ) begin

         /* Rollback the transaction. */
         rollback transaction

         /* Return the failure. */
         return 01

      end

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spInsertProviderCustomerServiceSchedule' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spInsertProviderCustomerServiceSchedule

   go

create procedure spInsertProviderCustomerServiceSchedule( @ProviderCustomerServiceId           integer,
                                                          @ProviderServiceTypeId               integer,
                                                          @CustomerUnitId                      integer,
                                                          @ProviderCustomerServiceScheduleDate datetime,
                                                          @ComServiceId                        integer,
                                                          @WorkOrderNumber                     varchar(50),
                                                          @ProviderCustomerServiceScheduleId   integer output,
                                                          @LogTransaction                      integer = 01 ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement    */
   declare @RowsAffected integer /* Number of rows affected by the previously executed statement  */
   declare @Transactions integer /* Number of active transactions at the start of this procedure  */
   declare @ReturnCode   integer /* Result code returned by the execution of the stored procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* If the provider customer service identifier was not passed... */
   if (@ProviderCustomerServiceId is null ) begin

      /* Since this parameter is not required, we can used the service type
         and customer unit identifiers to find the value in the database. */
      select @ProviderCustomerServiceId = PROVIDER_CUSTOMER_SERVICE_ID
      from PROVIDER_CUSTOMER_SERVICE pcs
      inner join PROVIDER_CUSTOMER     pc  on pcs.PROVIDER_CUSTOMER_ID = pc.PROVIDER_CUSTOMER_ID
      inner join PROVIDER_SYSTEM       ps  on pc.PROVIDER_ID           = ps.PROVIDER_ID
      inner join PROVIDER_SERVICE_TYPE pst on ps.PROVIDER_SYSTEM_ID    = pst.PROVIDER_SYSTEM_ID
      inner join CUSTOMER_UNIT         cu  on pc.CUSTOMER_ID           = cu.CUSTOMER_ID
      where pst.PROVIDER_SERVICE_TYPE_ID = @ProviderServiceTypeId and
            cu.CUSTOMER_UNIT_ID          = @CustomerUnitId

      /* Get the rows affected and the error code for the previous statement.
         Error checking MUST be done this way since any single statement executed
         will affect both of the global functions, @@RowCount and @@Error. */
      select @RowsAffected = @@RowCount, @ErrorCode = @@Error

      /* If there was an error... */
      if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

         /* Rollback the transaction. */
         rollback transaction

         /* Return the failure. */
         return 01

      end

   end

   /* Insert a new row in the provider customer service table. */
   insert into PROVIDER_CUSTOMER_SERVICE_SCHEDULE
   ( PROVIDER_CUSTOMER_SERVICE_ID,
     PROVIDER_SERVICE_TYPE_ID,
     CUSTOMER_UNIT_ID,
     PROVIDER_CUSTOMER_SERVICE_SCHEDULE_DATE,
     COM_SERVICE_ID,
     WORK_ORDER_NUMBER )
   values
   ( @ProviderCustomerServiceId,
     @ProviderServiceTypeId,
     @CustomerUnitId,
     @ProviderCustomerServiceScheduleDate,
     @ComServiceId,
     @WorkOrderNumber )

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* Set the value of the new primary key for the customer service schedule. */
   select @ProviderCustomerServiceScheduleId = @@Identity

   /* If there was an error... */
   if ( @@Error <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If @LogTransaction = 01 then check if log entry exists. */
   if ( @LogTransaction = 01 ) begin

      declare @InterfaceId integer

      declare INTERFACE_CURSOR cursor for
      select jmiet.INTERFACE_ID
      from JOIN_MAPPING_INTERFACE_ENTITY_TYPE jmiet,
           MAPPING_INTERFACE mi,
           PROVIDER_SYSTEM ps,
           PROVIDER_SERVICE_TYPE pst,
           PROVIDER_CUSTOMER_SERVICE_SCHEDULE pcss
      where jmiet.INTERFACE_ID                         = mi.INTERFACE_ID and
            mi.PROVIDER_ID                             = ps.PROVIDER_ID and
            ps.PROVIDER_SYSTEM_ID                      = pst.PROVIDER_SYSTEM_ID and
            pst.PROVIDER_SERVICE_TYPE_ID               = pcss.PROVIDER_SERVICE_TYPE_ID and
            pcss.PROVIDER_CUSTOMER_SERVICE_SCHEDULE_ID = @ProviderCustomerServiceScheduleId and
            jmiet.ENTITY_TYPE_ID                       = 12 and
            jmiet.LOG_TRANSACTION                      = 01

      /* If there was an error... */
      if ( @@Error <> 00 ) begin

         /* Rollback the transaction. */
         rollback transaction

         /* Return the failure. */
         return 01

      end

      open INTERFACE_CURSOR

      /* If there was an error... */
      if ( @@Error <> 00 ) begin

         /* Rollback the transaction. */
         rollback transaction

         /* Return the failure. */
         return 01

      end

      fetch next from INTERFACE_CURSOR into @InterfaceId

      while ( @@Fetch_Status = 00 ) begin

         if not exists ( select * from TRANSACTION_LOG
                         where ENTITY_ID      = @ProviderCustomerServiceScheduleId and
                               ENTITY_TYPE_ID = 12                                 and
                               INTERFACE_ID   = @InterfaceId ) begin

            /* If there was an error... */
            if ( @@Error <> 00 ) begin

               /* Rollback the transaction. */
               rollback transaction

               /* Return the failure. */
               return 01

            end

            /* Insert into TRANSACTION_LOG using spInsertTransactionLog */
            execute @ReturnCode = spInsertTransactionLog @InterfaceId,
                                                         @ProviderCustomerServiceScheduleId,
                                                         12, 'U', 00, 00

            /* If there was an error... */
            if ( @ReturnCode <> 00 ) begin

               /* Return the failure. */
               return @ReturnCode

            end

         end

         fetch next from INTERFACE_CURSOR into @InterfaceId

      end

      close INTERFACE_CURSOR

      deallocate INTERFACE_CURSOR

      /* If there was an error... */
      if ( @@Error <> 00 ) begin

         /* Rollback the transaction. */
         rollback transaction

         /* Return the failure. */
         return 01

      end

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spInsertTransactionLog' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spInsertTransactionLog

   go

create procedure spInsertTransactionLog( @InterfaceId      integer,
                                         @EntityId         integer,
                                         @EntityTypeId     integer,
                                         @ChangeAction     char(1),
                                         @Transmitted      integer,
                                         @TransactionLogId integer out ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @RowsAffected integer /* Number of rows affected by the previously executed statement */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */
   declare @TransactionDate datetime /* Date of transaction, used for purging old records    */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Get current date/time and set @TransactionDate */
   set @TransactionDate = GetDate()

   /* Insert a new row in the XXXXXXXX table. */
   insert into TRANSACTION_LOG (
      [INTERFACE_ID],
      [ENTITY_ID],
      [ENTITY_TYPE_ID],
      [CHANGE_ACTION],
      [TRANSMITTED],
      [TRANSACTION_DATE]
   )
   values (
      @InterfaceId,
      @EntityId,
      @EntityTypeId,
      @ChangeAction,
      @Transmitted,
      @TransactionDate
   )

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* Set the value of the new primary key for the XXXXXXXX. */
   select @TransactionLogId = @@Identity

   /* If there was an error... */
   if ( @@Error <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spLogin' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spLogin

   go

create procedure spLogin( @UserName varchar(50),
                          @Password varchar(15) ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @RowsAffected integer /* Number of rows affected by the previously executed statement */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

    /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   SELECT a.MEMBER_USER_ID,
          a.MEMBER_USER_FNAME,
	  a.MEMBER_USER_LNAME,
	  a.MEMBER_USER_EMAIL,
	  a.MEMBER_USER_LAST_LOGIN,
	  a.MEMBER_ID,
	  b.MEMBER_TYPE_ID,
	  b.MEMBER_NAME,
	  c.SECURITY_GROUP_ID,
	  d.AGREEMENT_ID
   FROM MEMBER_USER a
   LEFT JOIN MEMBER b ON a.MEMBER_ID = b.MEMBER_ID
   LEFT OUTER JOIN JOIN_MEMBER_USER_SECURITY_GROUP c ON a.MEMBER_USER_ID = c.MEMBER_USER_ID
   LEFT OUTER JOIN vw_member_user_agreement d ON b.MEMBER_ID = d.MEMBER_ID
   WHERE a.MEMBER_USER_NAME = @UserName
   AND a.MEMBER_USER_PWD = @Password
   AND c.SECURITY_GROUP_ID not in ( 14, 15 )

    /* Get the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions,  @@Error. */
   select @ErrorCode = @@Error

   /* If there was an error... */
   if ( @ErrorCode <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   Update MEMBER_USER
      Set MEMBER_USER_LAST_LOGIN = getdate()
   WHERE MEMBER_USER_NAME = @UserName
   AND MEMBER_USER_PWD = @Password

   /* Get the rows affected and the error code for the previous
   statement.  Error checking MUST be done this way since any single
   statement executed will affect both of the global functions,
   @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

    /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spModifyTransactionLogByEntityIdEntityType' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spModifyTransactionLogByEntityIdEntityType

   go

create procedure spModifyTransactionLogByEntityIdEntityType( @InterfaceId integer,
                                                             @EntityId    integer,
                                                             @EntityType  varchar(50),
                                                             @Transmitted integer = 1 ) as

   declare @ErrorCode        integer     /* Error code returned by the execution of the last statement   */
   declare @RowsAffected     integer     /* Number of rows affected by the previously executed statement */
   declare @Transactions     integer     /* Number of active transactions at the start of this procedure */
   declare @ReturnCode       integer /* Result code returned by the execution of the stored procedure */
   declare @TransactionLogId integer     /* Current identifier for the transaction log                   */
   declare @ChangeAction     char(1) /* Type of transaction in the log                               */
   declare @EntityTypeId     integer     /* The Entity Type identifier for the @EnityType parameter */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was executed... */
   if ( @Transactions = 00 ) begin

   /* Start the transaction. */
      begin transaction

   end

   if exists (
      select *
      from ENTITY_TYPE
      where ENTITY_TYPE = @EntityType ) begin

      /* If there was an error... */
      if ( @@Error <> 00 ) begin

         /* Rollback the transaction. */
         rollback transaction

         /* Return the failure. */
         return 01

      end

      select @EntityTypeId = ENTITY_TYPE_ID
      from ENTITY_TYPE
      where ENTITY_TYPE = @EntityType

      /* Get the error code for the previous statement.
         Error checking MUST be done this way since any single statement executed
         will affect both of the global functions, @@Error. */
      select @ErrorCode = @@Error

      /* If there was an error... */
      if ( @ErrorCode <> 00 )  begin

         /* Rollback the transaction. */
         rollback transaction

         /* Return the failure. */
         return 01

      end

      if exists (
         select *
         from TRANSACTION_LOG
         where INTERFACE_ID = @InterfaceId
           and ENTITY_ID = @EntityId
           and ENTITY_TYPE_ID = @EntityTypeId ) begin

         /* If there was an error... */
         if ( @@Error <> 00 ) begin

            /* Rollback the transaction. */
            rollback transaction

            /* Return the failure. */
            return 01

         end

         select @TransactionLogId = TRANSACTION_LOG_ID, @ChangeAction = CHANGE_ACTION
         from TRANSACTION_LOG
         where INTERFACE_ID = @InterfaceId
           and ENTITY_ID = @EntityId
           and ENTITY_TYPE_ID = @EntityTypeId

         /* Get the rows affected and the error code for the previous statement.
            Error checking MUST be done this way since any single statement executed
            will affect both of the global functions, @@RowCount and @@Error. */
         select @RowsAffected = @@RowCount, @ErrorCode = @@Error

         /* If there was an error... */
         if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

            /* Rollback the transaction. */
            rollback transaction

            /* Return the failure. */
            return 01

         end

         execute @ReturnCode = spUpdateTransactionLog @TransactionLogId, @InterfaceId, @EntityId, @EntityTypeId, @ChangeAction, @Transmitted

         /* If there was an error... */
         if ( @ReturnCode <> 00 ) begin

            /* Return the failure. */
            return @ReturnCode

         end

      end

   end

   if ( @Transactions = 00 ) begin

   /* Commit the transaction. */
      commit transaction

   end

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spRandomPassword' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spRandomPassword

   go

create procedure spRandomPassword( @MinLength smallint = 5,
	                               @MaxLength smallint = 8,
	                               @Pwd_out varchar(15) OUTPUT ) as
   /*
   Description:
   Procedure made in order to generate a random password that is somewhat pronouncable and easy to remember.
   Assumptions:
   This procedure assumes your are expecting a password data type of nvarchar(16)
   Details:
   Password length can be defined by suggesting the minimum and maximum length. For fixed
   size passwords, you may suggest the same number for both minimum and maximum
   (i.e. - EXEC AccountUsers_RandomPassword 8, 8)
   Author:
   Created by Lewis Edward Moten III on Saturday, July 07, 2001
   email: lewis@moten.com
   url: http://www.lewismoten.com
   Copyright (c) 2001, Lewis Edward Moten III, All rights reserved.
   You may alter the text for your own database only to esure proper working conditions against your
   database (i.e. - Changing the location of the table where user names reside and the field name)
   If you redistribute the code, you must include the original content including copyright and contact
   information.
   */

   declare @Password nvarchar(16)
   declare @Length smallint
   declare @WriteConsonant bit
   declare @Position smallint
   declare @Vowels nchar(5)
   declare @Consonants nchar(16)
   declare @DoubleConsonants nchar(11)
   declare @Random smallint
   declare @LetterPosition integer
   declare @Letter nchar(1)

   select @Vowels = 'aeiou'
   select @Consonants = 'bcdfghjklmnprstv'
   select @DoubleConsonants = 'cdfglmnprst'
   select @Password = ''
   select @WriteConsonant = 1
   -- determine length
   Select @Length = @MinLength + Round(Rand() * (@MaxLength - @MinLength), 0, 0)
   Select @Position = 1
   while @Position <= @Length
   begin
    	select @Random = Round(Rand() * 100, 0, 0) + 1
    	-- 10% double consonants
    	if not @Password = '' and @WriteConsonant = 1 and @Random < 10
    	begin
    		select @LetterPosition = Convert(integer, Round((Rand() * (Len(@DoubleConsonants)-1)), 0, 0), 1) +1
    		select @Letter = SubString(@DoubleConsonants, @LetterPosition, 1)
    		select @Password = @Password + Replicate(@Letter, 2)
    		select @Position = @Position + 1 -- because we just took up 2 positions
    		select @WriteConsonant = 0
    	end
    	else
    	begin
    		-- 80% consonants
    		if @WriteConsonant = 1 and @Random < 90
    		begin
    			select @LetterPosition = Convert(integer, Round((Rand() * (Len(@Consonants)-1)), 0, 0), 1) + 1
    			select @Letter = SubString(@Consonants, @LetterPosition, 1)
    			select @Password = @Password + @Letter
    			select @WriteConsonant = 0
    		end
    		-- 10% vowels
    		else
    		begin
    			select @LetterPosition = Convert(integer, Round((Rand() * (Len(@Vowels)-1)), 0, 0), 1) + 1
    			select @Letter = SubString(@Vowels, @LetterPosition, 1)
    			select @Password = @Password + @Letter
    			select @WriteConsonant = 1
    		end
    	end
    	select @Position = @Position + 1 -- incriment counter
   end
   -- just in case that last character was a double consonant
   select @password = Left(@Password, @length)
   -- return password
   SELECT @pwd_out = @password

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spRemoveCustomerFromProviderSystem' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spRemoveCustomerFromProviderSystem

   go

create procedure spRemoveCustomerFromProviderSystem( @ProviderCustomerServiceId integer ) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

      /* Remove all references to services that were completed for this service program */
      update provider_customer_service_schedule
      set com_service_id = NULL
      where provider_customer_service_schedule_id in (
      select provider_customer_service_schedule_id
      from provider_customer_service_schedule pcss
      inner join com_service cs on pcss.com_service_id = cs.com_service_id
      inner join provider_service_type pst on cs.provider_service_type_id = pst.provider_service_type_id
      inner join customer_unit cu on cs.customer_unit_id = cu.customer_unit_id
      inner join provider_customer pc on cu.customer_id = pc.customer_id
      inner join provider_customer_service pcs on pc.provider_customer_id = pcs.provider_customer_id
	          								      and pcs.provider_system_id = pst.provider_system_id
      where pcs.provider_customer_service_id = @ProviderCustomerServiceId )

      /* If there was an error... */
      if ( @@Error <> 00 ) begin

         /* Return the failure. */
         return 01

      end

      /* delete the sub-units that are dependent on this provider system relationship */
      delete join_customer_unit_type_customer_unit
	  from join_customer_unit_type_customer_unit
      inner join customer_unit cu on join_customer_unit_type_customer_unit.customer_unit_id = cu.customer_unit_id
      inner join provider_customer pc on cu.customer_id = pc.customer_id
      inner join customer_unit_type cut on join_customer_unit_type_customer_unit.customer_unit_type_id = cut.customer_unit_type_id
      inner join provider_customer_service pcs on cut.provider_system_id = pcs.provider_system_id
	   										  and pcs.provider_customer_id = pc.provider_customer_id
      where pcs.provider_customer_service_id = @ProviderCustomerServiceId

      /* If there was an error... */
      if ( @@Error <> 00 ) begin

         /* Return the failure. */
         return 01

      end

   /* delete the PROVIDER_CUSTOMER_SERVICE record */
   execute @ReturnCode = spDeleteProviderCustomerService @ProviderCustomerServiceId

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spRemoveCustomerUnitFromProviderGroup' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spRemoveCustomerUnitFromProviderGroup

   go

create procedure spRemoveCustomerUnitFromProviderGroup( @MemberGroupId  integer,
                                                        @CustomerUnitid 
integer ) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   execute @ReturnCode = spDeleteJoinMemberGroupCustomerUnit @MemberGroupId, @CustomerUnitId

     /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spRemoveCustomerUserFromCustomerGroup' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spRemoveCustomerUserFromCustomerGroup

   go

create procedure spRemoveCustomerUserFromCustomerGroup( @MemberUserId  integer,
                                                        @MemberGroupId integer ) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   execute @ReturnCode = spDeleteJoinMemberGroupUser @MemberGroupId, @MemberUserId

     /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spRemoveParentUnitFromSystem' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spRemoveParentUnitFromSystem

   go

create procedure spRemoveParentUnitFromSystem( @CustomerUnitTypeId integer,
                                               @CustomerUnitId     integer ) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   execute @ReturnCode = spDeleteJoinCustomerUnitTypeCustomerUnit @CustomerUnitTypeId,
                                                                  @CustomerUnitId

    /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spRemoveProviderGroupFromProviderUser' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spRemoveProviderGroupFromProviderUser

   go

create procedure spRemoveProviderGroupFromProviderUser( @MemberUserId  integer,
                                                        @MemberGroupId integer ) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   -- new procedure
   execute @ReturnCode = spDeleteJoinMemberGroupUser @MemberGroupId,
                                                     @MemberUserId

    /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spSQLConnector' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spSQLConnector

   go

create procedure spSQLConnector( @stmt nvarchar(4000) ) as

   /* spSQLConnector.sql

   Execute any SQL statement passed in as the parameter stmt.
   Intended to be used for complex dynamic select statements used for reports.
   Returns 01 if there is an error.

   Jim Fauntleroy 4/27/2004

   */

   execute sp_executesql @stmt

   if ( @@Error <> 00 ) begin

      return 01

   end

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spUpdateApplicationHelpByHelpId' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spUpdateApplicationHelpByHelpId

   go

create procedure spUpdateApplicationHelpByHelpId( @HelpId       integer,
                                                  @PhysicalPage integer,
                                                  @LogicalPage  integer,
                                                  @HelpAction   integer,
                                                  @HelpText     text ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @RowsAffected integer /* Number of rows affected by the previously executed statement */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Update the target row. */
   update APPLICATION_HELP
   set PHYSICAL_PAGE = @PhysicalPage,
       LOGICAL_PAGE  = @LogicalPage,
       HELP_ACTION   = @HelpAction,
       HELP_TEXT     = @HelpText
   where HELP_ID = @HelpId

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spUpdateApplicationHelpTextByHelpId' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spUpdateApplicationHelpTextByHelpId

   go

create procedure spUpdateApplicationHelpTextByHelpId( @HelpId   integer,
                                                      @HelpText text ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @RowsAffected integer /* Number of rows affected by the previously executed statement */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Update the target row. */
   update APPLICATION_HELP
   set HELP_TEXT = @HelpText
   where HELP_ID = @HelpId

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spUpdateApplicationHelpTextByPage' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spUpdateApplicationHelpTextByPage

   go

create procedure spUpdateApplicationHelpTextByPage( @PhysicalPage integer,
                                                    @LogicalPage  integer,
                                                    @HelpAction   integer,
                                                    @HelpText     text ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @RowsAffected integer /* Number of rows affected by the previously executed statement */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Update the target row. */
   update APPLICATION_HELP
   set HELP_TEXT = @HelpText
   where PHYSICAL_PAGE = @PhysicalPage and
         LOGICAL_PAGE  = @LogicalPage  and
         HELP_ACTION   = @HelpAction

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spUpdateComServiceData' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spUpdateComServiceData

   go

create procedure spUpdateComServiceData( @ComServiceDataId          integer,
                                         @ComServiceUnitValueId     integer,
										 @ProviderServiceDataTypeId integer,
										 @ProviderServiceDataId     integer,
										 @ComServiceDataAltText     varchar(255),
										 @RowId                     integer,
										 @LogTransaction            integer = 1 ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @RowsAffected integer /* Number of rows affected by the previously executed statement */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
      set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was executed... */
      if ( @Transactions = 00 ) begin

   /* Start the transaction. */
         begin transaction

      end

   /* If @ProviderServiceDataTypeId is null then go get it */
   if ( @ProviderServiceDataTypeId is null ) and ( @ProviderServiceDataId is not null ) begin
      select @ProviderServiceDataTypeId = PROVIDER_SERVICE_DATA_TYPE_ID
      from PROVIDER_SERVICE_DATA
      where PROVIDER_SERVICE_DATA_ID = @ProviderServiceDataId

      /* Get the rows affected and the error code for the previous statement.
         Error checking MUST be done this way since any single statement executed
         will affect both of the global functions, @@RowCount and @@Error. */
      select @RowsAffected = @@RowCount, @ErrorCode = @@Error

      /* If there was an error... */
      if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

         /* Rollback the transaction. */
         rollback transaction

         /* Return the failure. */
         return 01

      end

   end

   /* Update a row in the provider customer service table. */
      update COM_SERVICE_DATA
      set
         [COM_SERVICE_UNIT_VALUE_ID] = @ComServiceUnitValueId,
         [PROVIDER_SERVICE_DATA_TYPE_ID] = @ProviderServiceDataTypeId,
         [PROVIDER_SERVICE_DATA_ID] = @ProviderServiceDataId,
         [COM_SERVICE_DATA_ALT_TEXT] = @ComServiceDataAltText,
         [ROW_ID] = @RowId
      where
         [COM_SERVICE_DATA_ID] = @ComServiceDataId

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   if ( @LogTransaction = 1 ) begin

      declare @InterfaceId integer

      declare INTERFACE_CURSOR cursor for
      select jmiet.INTERFACE_ID
      from JOIN_MAPPING_INTERFACE_ENTITY_TYPE jmiet,
           MAPPING_INTERFACE mi,
           PROVIDER_SYSTEM ps,
           PROVIDER_SERVICE_TYPE pst,
           COM_SERVICE cs,
           COM_SERVICE_UNIT_VALUE csuv
      where jmiet.INTERFACE_ID = mi.INTERFACE_ID
        and mi.PROVIDER_ID = ps.PROVIDER_ID
        and ps.PROVIDER_SYSTEM_ID = pst.PROVIDER_SYSTEM_ID
        and pst.PROVIDER_SERVICE_TYPE_ID = cs.PROVIDER_SERVICE_TYPE_ID
        and cs.COM_SERVICE_ID = csuv.COM_SERVICE_ID
        and csuv.COM_SERVICE_UNIT_VALUE_ID = @ComServiceUnitValueId
        and jmiet.ENTITY_TYPE_ID = 13
        and jmiet.LOG_TRANSACTION = 1

      open INTERFACE_CURSOR

      fetch next from INTERFACE_CURSOR into
      @InterfaceId

      while ( @@fetch_status = 0 ) begin

         if not exists ( select * from TRANSACTION_LOG where ENTITY_ID = @ComServiceUnitValueId and ENTITY_TYPE_ID = 13 and INTERFACE_ID = @InterfaceId ) begin

            /* If there was an error... */
            if ( @@Error <> 00 ) begin

               /* Rollback the transaction. */
               rollback transaction

               /* Return the failure. */
               return 01

            end

            /* Insert into TRANSACTION_LOG using spInsertTransactionLog */
            exec spInsertTransactionLog @InterfaceId, @ComServiceUnitValueId, 13, 'U', 0, 0

            /* Get the rows affected and the error code for the previous statement.
               Error checking MUST be done this way since any single statement executed
               will affect both of the global functions, @@RowCount and @@Error. */
            select @RowsAffected = @@RowCount, @ErrorCode = @@Error

            /* If there was an error... */
            if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

               /* Rollback the transaction. */
               rollback transaction

               /* Return the failure. */
               return 01

            end

         end

      fetch next from INTERFACE_CURSOR into
      @InterfaceId

      end

      close INTERFACE_CURSOR
      deallocate INTERFACE_CURSOR

   end

   /* If there were no active transactions when this stored procedure was executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spUpdateComServiceUnitValue' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spUpdateComServiceUnitValue

   go

create procedure spUpdateComServiceUnitValue( @ComServiceUnitValueId  integer,
                                              @ComServiceId           integer,
                                              @ProviderServiceValueId integer,
                                              @CustomerUnitId         integer,
                                              @Timestamp              datetime,
                                              @LogTransaction         integer = 1 ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @RowsAffected integer /* Number of rows affected by the previously executed statement */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Update a row in the provider customer service table. */
   update COM_SERVICE_UNIT_VALUE
   set
      [COM_SERVICE_ID] = @ComServiceId,
      [PROVIDER_SERVICE_VALUE_ID] = @ProviderServiceValueId,
      [CUSTOMER_UNIT_ID] = @CustomerUnitId,
      [TIMESTAMP] = @Timestamp
   where
      [COM_SERVICE_UNIT_VALUE_ID] = @ComServiceUnitValueId

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If @LogTransaction = 1 then check if log entry exists */
   if ( @LogTransaction = 1 ) begin

      declare @InterfaceId integer

      declare INTERFACE_CURSOR cursor for
      select jmiet.INTERFACE_ID
      from JOIN_MAPPING_INTERFACE_ENTITY_TYPE jmiet,
           MAPPING_INTERFACE mi,
           PROVIDER_SYSTEM ps,
           PROVIDER_SERVICE_TYPE pst,
           COM_SERVICE cs,
           COM_SERVICE_UNIT_VALUE csuv
      where jmiet.INTERFACE_ID = mi.INTERFACE_ID
        and mi.PROVIDER_ID = ps.PROVIDER_ID
        and ps.PROVIDER_SYSTEM_ID = pst.PROVIDER_SYSTEM_ID
        and pst.PROVIDER_SERVICE_TYPE_ID = cs.PROVIDER_SERVICE_TYPE_ID
        and cs.COM_SERVICE_ID = csuv.COM_SERVICE_ID
        and csuv.COM_SERVICE_UNIT_VALUE_ID = @ComServiceUnitValueId
        and jmiet.ENTITY_TYPE_ID = 13
        and jmiet.LOG_TRANSACTION = 1

      open INTERFACE_CURSOR

      fetch next from INTERFACE_CURSOR into
      @InterfaceId

      while ( @@fetch_status = 0 ) begin

         if not exists ( select * from TRANSACTION_LOG where ENTITY_ID = @ComServiceUnitValueId and ENTITY_TYPE_ID = 13 and INTERFACE_ID = @InterfaceId ) begin

            /* If there was an error... */
            if ( @@Error <> 00 ) begin

               /* Rollback the transaction. */
               rollback transaction

               /* Return the failure. */
               return 01

            end

            /* Insert into TRANSACTION_LOG using spInsertTransactionLog */
            exec spInsertTransactionLog @InterfaceId, @ComServiceUnitValueId, 13, 'U', 0, 0

            /* Get the rows affected and the error code for the previous statement.
               Error checking MUST be done this way since any single statement executed
               will affect both of the global functions, @@RowCount and @@Error. */
            select @RowsAffected = @@RowCount, @ErrorCode = @@Error

            /* If there was an error... */
            if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

               /* Rollback the transaction. */
               rollback transaction

               /* Return the failure. */
               return 01

            end

         end

      fetch next from INTERFACE_CURSOR into
      @InterfaceId

      end

      close INTERFACE_CURSOR
      deallocate INTERFACE_CURSOR

   end

   /* If there were no active transactions when this stored procedure was executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spUpdateCustomer' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spUpdateCustomer

   go

create procedure spUpdateCustomer( @CustomerId   integer,
                                   @CustomerName varchar(100) ) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   execute @ReturnCode = spUpdateMember @CustomerId,
                                        2,
                                        @CustomerName

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spUpdateCustomerContactInfo' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spUpdateCustomerContactInfo

   go

create procedure spUpdateCustomerContactInfo( @ContactId     integer,
                                              @CustomerId    integer,
                                              @ContactTypeId integer,
                                              @ContactInfo   varchar(255) ) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   execute @ReturnCode = spUpdateContact @ContactId,
                                         @ContactTypeId,
                                         @ContactInfo

     /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spUpdateCustomerGroup' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spUpdateCustomerGroup

   go

create procedure spUpdateCustomerGroup( @CustomerGroupId     integer,
                                        @CustomerGroupTypeId integer,
                                        @CustomerGroupName   varchar(50) ) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   execute @ReturnCode = spUpdateMemberGroup @CustomerGroupId,
                                             @CustomerGroupTypeId,
                                             @CustomerGroupName

      /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spUpdateCustomerGroupType' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spUpdateCustomerGroupType

   go

create procedure spUpdateCustomerGroupType( @CustomerGroupTypeId   integer,
                                            @CustomerId            integer,
                                            @CustomerGroupTypeName varchar(50) ) as
   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   -- new procedure
   execute @ReturnCode = spUpdateMemberGroupType @CustomerGroupTypeId,
                                                 @CustomerGroupTypeName,
                                                 @CustomerId

      /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spUpdateCustomerSubUnit' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spUpdateCustomerSubUnit

   go

create procedure spUpdateCustomerSubUnit( @CustomerUnitId     integer,
                                          @CustomerId         integer,
                                          @CustomerUnitName   varchar(100),
                                          @CustomerUnitNumber varchar(50),
                                          @UnitParentId       integer,
                                          @CustomerUnitTypeId integer,
                                          @CustomerUnitNameId integer,
                                          @OldUnitTypeId      integer ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @RowsAffected integer /* Number of rows affected by the previously executed statement */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Update the specified customer sub-unit row. */
   update CUSTOMER_UNIT
   set CUSTOMER_ID          = @CustomerId,
       CUSTOMER_UNIT_NAME   = @CustomerUnitName,
       CUSTOMER_UNIT_NUMBER = @CustomerUnitNumber,
       UNIT_PARENT_ID       = @UnitParentId
   where CUSTOMER_UNIT_ID = @CustomerUnitId

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* Update the customer sub-unit/customer unit type row in the join table. */
   update JOIN_CUSTOMER_UNIT_TYPE_CUSTOMER_UNIT
   set CUSTOMER_UNIT_TYPE_ID = @CustomerUnitTypeId,
       CUSTOMER_UNIT_ID      = @CustomerUnitId,
       CUSTOMER_UNIT_NAME_ID = @CustomerUnitNameId
   where CUSTOMER_UNIT_TYPE_ID = @OldUnitTypeId and
         CUSTOMER_UNIT_ID      = @CustomerUnitId

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spUpdateCustomerUnit' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spUpdateCustomerUnit

   go

create procedure spUpdateCustomerUnit( @CustomerUnitId     integer,
                                       @CustomerId         integer,
                                       @CustomerUnitName   varchar(100),
                                       @CustomerUnitNumber varchar(50),
                                       @UnitParentId       integer,
                                       @UpdateDate         datetime,
                                       @LogTransaction     integer = 1 ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @RowsAffected integer /* Number of rows affected by the previously executed statement */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Get the current system date as the update date. */
   select @UpdateDate = GetDate()

   /* Update a row in the provider customer service table. */
   update CUSTOMER_UNIT
   set [CUSTOMER_ID]          = @CustomerId,
       [CUSTOMER_UNIT_NAME]   = @CustomerUnitName,
       [CUSTOMER_UNIT_NUMBER] = @CustomerUnitNumber,
       [UNIT_PARENT_ID]       = @UnitParentId,
       [UPDATE_DATE]          = @UpdateDate
   where
      [CUSTOMER_UNIT_ID] = @CustomerUnitId

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If parameter @LogTransaction = 1 then check if log entry exists */
   if ( @LogTransaction = 1 ) begin

      if ( @UnitParentId = -1 ) begin

         declare @InterfaceId integer

         declare INTERFACE_CURSOR cursor for
         select jmiet.INTERFACE_ID
         from JOIN_MAPPING_INTERFACE_ENTITY_TYPE jmiet,
              MAPPING_INTERFACE mi,
              PROVIDER_CUSTOMER pc,
              CUSTOMER_UNIT cu
         where jmiet.INTERFACE_ID = mi.INTERFACE_ID
           and mi.PROVIDER_ID = pc.PROVIDER_ID
           and pc.CUSTOMER_ID = cu.CUSTOMER_ID
           and cu.CUSTOMER_UNIT_ID = @CustomerUnitId
           and jmiet.ENTITY_TYPE_ID = 5
           and jmiet.LOG_TRANSACTION = 1

           /* If there was an error... */
           if ( @@Error <> 00 ) begin

              /* Rollback the transaction. */
              rollback transaction

              /* Return the failure. */
              return 01

           end

         open INTERFACE_CURSOR

         /* If there was an error... */
         if ( @@Error <> 00 ) begin

            /* Rollback the transaction. */
            rollback transaction

            /* Return the failure. */
            return 01

         end

         fetch next from INTERFACE_CURSOR into
         @InterfaceId

         while ( @@fetch_status = 0 ) begin

            if not exists ( select * from TRANSACTION_LOG where ENTITY_ID = @CustomerUnitId and ENTITY_TYPE_ID = 5 and INTERFACE_ID = @InterfaceId ) begin

               /* If there was an error... */
               if ( @@Error <> 00 ) begin

                  /* Rollback the transaction. */
                  rollback transaction

                  /* Return the failure. */
                  return 01

               end

               /* Insert into TRANSACTION_LOG using spInsertTransactionLog */
               exec spInsertTransactionLog @InterfaceId, @CustomerUnitId, 5, 'U', 0, 0

               /* Get the rows affected and the error code for the previous statement.
                  Error checking MUST be done this way since any single statement executed
                  will affect both of the global functions, @@RowCount and @@Error. */
               select @RowsAffected = @@RowCount, @ErrorCode = @@Error

               /* If there was an error... */
               if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

                  /* Rollback the transaction. */
                  rollback transaction

                  /* Return the failure. */
                  return 01

               end

            end

         fetch next from INTERFACE_CURSOR into
         @InterfaceId

         end

         close INTERFACE_CURSOR
         deallocate INTERFACE_CURSOR

      end

   end

   /* If there were no active transactions when this stored procedure was executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spUpdateCustomerUnitContactInfo' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spUpdateCustomerUnitContactInfo

   go

create procedure spUpdateCustomerUnitContactInfo( @ContactId      integer,
                                                  @CustomerUnitId integer,
                                                  @ContactTypeId  integer,
                                                  @ContactInfo    varchar(255) ) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   execute @ReturnCode = spUpdateContact @ContactId,
                                         @ContactTypeId,
                                         @ContactInfo

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spUpdateCustomerUser' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spUpdateCustomerUser

   go

create procedure spUpdateCustomerUser(  @CustomerUserId  integer,
                                        @CustomerId      integer,
                                        @UserName        varchar(50),
                                        @Password        varchar(15),
                                        @FirstName       varchar(25),
                                        @LastName        varchar(25),
                                        @Email           varchar(50),
                                        @LastLogin       datetime,
                                        @SecurityGroupId integer ) as

   declare @Transactions       integer /* Number of active transactions at the start of this procedure */
   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   execute @ReturnCode = spUpdateMemberUser @CustomerUserId,
                                            @CustomerId,
                                            @UserName,
                                            @Password,
                                            @FirstName,
                                            @LastName,
                                            @LastLogin,
                                            @Email

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   if @SecurityGroupId > 00 begin
      execute @ReturnCode = spDeleteJoinMemberUserSecurityGroup @CustomerUserId

      /* If there was an error... */
      if ( @ReturnCode <> 00 ) begin

         /* Return the failure. */
         return @ReturnCode

      end

      execute @ReturnCode = spInsertJoinMemberUserSecurityGroup @CustomerUserId,
                                                                @SecurityGroupId

      /* If there was an error... */
      if ( @ReturnCode <> 00 ) begin

         /* Return the failure. */
         return @ReturnCode

      end

   end

    /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

go

-- could not find in remote method
/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spGetCustomerContactInfo' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spGetCustomerContactInfo

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spUpdateCustomerUserContactInfo' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spUpdateCustomerUserContactInfo

   go

create procedure spUpdateCustomerUserContactInfo( @ContactId      integer,
                                                  @CustomerUserId integer,
                                                  @ContactTypeId  integer,
                                                  @ContactInfo    varchar(255) ) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   execute @ReturnCode = spUpdateContact @ContactId,
                                         @ContactTypeId,
                                         @ContactInfo

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spUpdateMappingEntity' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spUpdateMappingEntity

   go

create procedure spUpdateMappingEntity( @MappingEntityId integer,
                                        @InterfaceId     integer,
                                        @EntityId        integer,
                                        @EntityTypeId    integer,
                                        @ForeignId       varchar(50),
                                        @ForeignType     varchar(50) ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @RowsAffected integer /* Number of rows affected by the previously executed statement */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Update a row in the mapping entity table. */
   update MAPPING_ENTITY
   set [INTERFACE_ID]   = @InterfaceId,
       [ENTITY_ID]      = @EntityId,
       [ENTITY_TYPE_ID] = @EntityTypeId,
       [FOREIGN_ID]     = @ForeignId,
       [FOREIGN_TYPE]   = @ForeignType
   where [MAPPING_ENTITY_ID] = @MappingEntityId

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spUpdateMember' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spUpdateMember

   go

create procedure spUpdateMember( @MemberId       integer,
                                 @MemberTypeId   integer,
                                 @MemberName     varchar(100),
                                 @LogTransaction integer = 1 ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @RowsAffected integer /* Number of rows affected by the previously executed statement */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Update a row in the provider customer service table. */
   update MEMBER
   set
      [MEMBER_TYPE_ID] = @MemberTypeId,
      [MEMBER_NAME] = @MemberName
   where
      [MEMBER_ID] = @MemberId

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If parameter @LogTransaction = 1 then check if log entry exists */
   if ( @LogTransaction = 1 ) begin

      if ( @MemberTypeId = 2 ) begin

         declare @InterfaceId integer

         declare INTERFACE_CURSOR cursor for
         select jmiet.INTERFACE_ID
         from JOIN_MAPPING_INTERFACE_ENTITY_TYPE jmiet,
              MAPPING_INTERFACE mi,
              PROVIDER_CUSTOMER pc
         where jmiet.INTERFACE_ID = mi.INTERFACE_ID
           and mi.PROVIDER_ID = pc.PROVIDER_ID
           and pc.CUSTOMER_ID = @MemberId
           and jmiet.ENTITY_TYPE_ID = 4
           and jmiet.LOG_TRANSACTION = 1

         open INTERFACE_CURSOR

         fetch next from INTERFACE_CURSOR into
         @InterfaceId

         while ( @@fetch_status = 0 ) begin

            if not exists ( select * from TRANSACTION_LOG where ENTITY_ID = @MemberId and ENTITY_TYPE_ID = 4 and INTERFACE_ID = @InterfaceId ) begin

               /* If there was an error... */
               if ( @@Error <> 00 ) begin

                  /* Rollback the transaction. */
                  rollback transaction

                  /* Return the failure. */
                  return 01

               end

               /* Insert into TRANSACTION_LOG using spInsertTransactionLog */
               exec spInsertTransactionLog @InterfaceId, @MemberId, 4, 'U', 0, 0

               /* Get the rows affected and the error code for the previous statement.
                  Error checking MUST be done this way since any single statement executed
                  will affect both of the global functions, @@RowCount and @@Error. */
               select @RowsAffected = @@RowCount, @ErrorCode = @@Error

               /* If there was an error... */
               if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

                  /* Rollback the transaction. */
                  rollback transaction

                  /* Return the failure. */
                  return 01

               end

            end

         fetch next from INTERFACE_CURSOR into
         @InterfaceId

         end

         close INTERFACE_CURSOR
         deallocate INTERFACE_CURSOR

      end

   end

   /* If there were no active transactions when this stored procedure was executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spUpdateMemberGroup' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spUpdateMemberGroup

   go

create procedure spUpdateMemberGroup( @MemberGroupId     integer,
                                      @MemberGroupTypeId integer,
                                      @MemberGroupName   varchar(50),
                                      @LogTransaction    integer = 1 ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @RowsAffected integer /* Number of rows affected by the previously executed statement */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */
   declare @BranchorRoute varchar(15)
   declare @EntityTypeId integer

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Update a row in the provider customer service table. */
   update MEMBER_GROUP
   set
      [MEMBER_GROUP_TYPE_ID] = @MemberGroupTypeId,
      [MEMBER_GROUP_NAME] = @MemberGroupName
   where
      [MEMBER_GROUP_ID] = @MemberGroupId

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If parameter @LogTransaction = 1 then check if log entry exists */
   if ( @LogTransaction = 1 ) begin

      select @BranchorRoute = MEMBER_GROUP_TYPE_NAME from MEMBER_GROUP_TYPE where MEMBER_GROUP_TYPE_ID = @MemberGroupTypeId

      /* Get the rows affected and the error code for the previous statement.
         Error checking MUST be done this way since any single statement executed
         will affect both of the global functions, @@RowCount and @@Error. */
      select @RowsAffected = @@RowCount, @ErrorCode = @@Error

      /* If there was an error... */
      if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

         /* Rollback the transaction. */
         rollback transaction

         /* Return the failure. */
         return 01

      end

      if ( @BranchorRoute = 'Routes' ) set @EntityTypeId = 16 else if ( @BranchorRoute = 'Branches' ) set @EntityTypeId = 15

      declare @InterfaceId integer

      declare INTERFACE_CURSOR cursor for
      select jmiet.INTERFACE_ID
      from JOIN_MAPPING_INTERFACE_ENTITY_TYPE jmiet,
           MAPPING_INTERFACE mi,
           MEMBER_GROUP_TYPE mgt,
           MEMBER_GROUP mg
      where jmiet.INTERFACE_ID = mi.INTERFACE_ID
        and mi.PROVIDER_ID = mgt.MEMBER_ID
        and mgt.MEMBER_GROUP_TYPE_ID = mg.MEMBER_GROUP_TYPE_ID
        and mg.MEMBER_GROUP_ID = @MemberGroupId
        and jmiet.ENTITY_TYPE_ID = @EntityTypeId
        and jmiet.LOG_TRANSACTION = 1

      open INTERFACE_CURSOR

      fetch next from INTERFACE_CURSOR into
      @InterfaceId

      while ( @@fetch_status = 0 ) begin

         if not exists ( select * from TRANSACTION_LOG where ENTITY_ID = @MemberGroupId and ENTITY_TYPE_ID = @EntityTypeId and INTERFACE_ID = @InterfaceId ) begin

            /* If there was an error... */

            if ( @@Error <> 00 ) begin

               /* Rollback the transaction. */
               rollback transaction

              /* Return the failure. */
              return 01

            end

            /* Insert into TRANSACTION_LOG using spInsertTransactionLog */
            exec spInsertTransactionLog @InterfaceId, @MemberGroupId, @EntityTypeId, 'U', 0, 0

            /* Get the rows affected and the error code for the previous statement.
               Error checking MUST be done this way since any single statement executed
               will affect both of the global functions, @@RowCount and @@Error. */
            select @RowsAffected = @@RowCount, @ErrorCode = @@Error

            /* If there was an error... */
            if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

               /* Rollback the transaction. */
               rollback transaction

               /* Return the failure. */
               return 01

            end

         end

      fetch next from INTERFACE_CURSOR into
      @InterfaceId

      end

      close INTERFACE_CURSOR
      deallocate INTERFACE_CURSOR

   end

   /* If there was an error... */
   if ( @@Error <> 00 ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spUpdateMemberUser' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spUpdateMemberUser

   go

create procedure spUpdateMemberUser( @MemberUserId        integer,
                                     @MemberId            integer,
                                     @MemberUserName      varchar(50),
                                     @MemberUserPwd       varchar(15),
                                     @MemberUserFname     varchar(25),
                                     @MemberUserLname     varchar(25),
                                     @MemberUserLastLogin datetime,
                                     @MemberUserEmail     varchar(50),
                                     @LogTransAction      integer = 1 ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @RowsAffected integer /* Number of rows affected by the previously executed statement */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */
   declare @MemberTypeId integer

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Update a row in the provider customer service table. */
   update MEMBER_USER
   set
      [MEMBER_ID] = @MemberId,
      [MEMBER_USER_NAME] = @MemberUserName,
      [MEMBER_USER_PWD] = @MemberUserPwd,
      [MEMBER_USER_FNAME] = @MemberUserFname,
      [MEMBER_USER_LNAME] = @MemberUserLname,
      [MEMBER_USER_LAST_LOGIN] = @MemberUserLastLogin,
      [MEMBER_USER_EMAIL] = @MemberUserEmail
   where
      [MEMBER_USER_ID] = @MemberUserId

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If parameter @LogTransaction = 1 then check if log entry exists */
   if ( @LogTransaction = 1 ) begin

      select @MemberTypeId = MEMBER_TYPE_ID from MEMBER where MEMBER_ID = @MemberId

      /* If there was an error... */
      if ( @@Error <> 00 ) begin

         /* Rollback the transaction. */
         rollback transaction

         /* Return the failure. */
         return 01

      end

      /* If parameter @MemberTypeId = 1 then check if log entry exists */
      if ( @MemberTypeId = 1 ) begin

         declare @InterfaceId integer

         declare INTERFACE_CURSOR cursor for
         select jmiet.INTERFACE_ID
         from JOIN_MAPPING_INTERFACE_ENTITY_TYPE jmiet,
              MAPPING_INTERFACE mi,
              MEMBER_USER mu
         where jmiet.INTERFACE_ID = mi.INTERFACE_ID
           and mi.PROVIDER_ID = mu.MEMBER_ID
           and mu.MEMBER_USER_ID = @MemberUserId
           and jmiet.ENTITY_TYPE_ID = 1
           and jmiet.LOG_TRANSACTION = 1

         open INTERFACE_CURSOR

         fetch next from INTERFACE_CURSOR into
         @InterfaceId

         while ( @@fetch_status = 0 ) begin

            if not exists ( select * from TRANSACTION_LOG where ENTITY_ID = @MemberUserId and ENTITY_TYPE_ID = 1 and INTERFACE_ID = @InterfaceId ) begin

               /* If there was an error... */
               if ( @@Error <> 00 ) begin

                  /* Rollback the transaction. */
                  rollback transaction

                  /* Return the failure. */
                  return 01

               end

               /* Insert into TRANSACTION_LOG using spInsertTransactionLog */
               exec spInsertTransactionLog @InterfaceId, @MemberUserId, 1, 'U', 0, 0

               /* Get the rows affected and the error code for the previous statement.
                  Error checking MUST be done this way since any single statement executed
                  will affect both of the global functions, @@RowCount and @@Error. */
               select @RowsAffected = @@RowCount, @ErrorCode = @@Error

               /* If there was an error... */
               if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

                  /* Rollback the transaction. */
                  rollback transaction

                  /* Return the failure. */
                  return 01


               end

            end

         fetch next from INTERFACE_CURSOR into
         @InterfaceId

         end

         close INTERFACE_CURSOR
         deallocate INTERFACE_CURSOR

      end

   end

   /* If there were no active transactions when this stored procedure was executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spUpdateMemberUserEmailSettingsLastUpdateDate' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spUpdateMemberUserEmailSettingsLastUpdateDate

   go

create procedure spUpdateMemberUserEmailSettingsLastUpdateDate( @MemberUserEmailId integer ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @RowsAffected integer /* Number of rows affected by the previously executed statement */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
      set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was executed... */
      if ( @Transactions = 00 ) begin

   /* Start the transaction. */
         begin transaction

      end

   /* Update a row in the provider customer service table. */
      update MEMBER_USER_EMAIL_SETTINGS
      set

         [EMAIL_LAST_UPDATE] = GetDate()
      where
         [MEMBER_USER_EMAIL_ID] = @MemberUserEmailId

   /* Get the rows affected and the error code for the previous statement.
   Error checking MUST be done this way since any single statement executed
   will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spUpdateProvider' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spUpdateProvider

   go

create procedure spUpdateProvider( @ProviderId   integer,
                                   @ProviderName varchar(100) ) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   execute @ReturnCode = spUpdateMember @ProviderId,
                                        1,
                                        @ProviderName

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spUpdateProviderContactInfo' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spUpdateProviderContactInfo

   go

create procedure spUpdateProviderContactInfo( @ContactId     integer,
                                              @ProviderId    integer,
                                              @ContactTypeId integer,
                                              @ContactInfo   varchar(255) ) as
   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   execute @ReturnCode = spUpdateContact @ContactId,
                                         @ContactTypeId,
                                         @ContactInfo

    /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spUpdateProviderCustomerServiceFinancial' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spUpdateProviderCustomerServiceFinancial

   go

create procedure spUpdateProviderCustomerServiceFinancial( @ProviderCustomerServiceFinancialId  integer,
                                                           @ProviderCustomerServiceId           integer,
                                                           @ProviderServiceTypeId               integer,
                                                           @CustomerUnitId                      integer,
                                                           @ProviderCustomerServiceAmount       varchar(10),
                                                           @LogTransaction                      integer = 01 ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement    */
   declare @RowsAffected integer /* Number of rows affected by the previously executed statement  */
   declare @Transactions integer /* Number of active transactions at the start of this procedure  */
   declare @ReturnCode   integer /* Result code returned by the execution of the stored procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* If the provider customer service identifier was not passed... */
   if (@ProviderCustomerServiceId is null ) begin

      /* Since this parameter is not required, we can used the service type
         and customer unit identifiers to find the value in the database. */
      select @ProviderCustomerServiceId = PROVIDER_CUSTOMER_SERVICE_ID
      from PROVIDER_CUSTOMER_SERVICE pcs
      inner join PROVIDER_CUSTOMER     pc  on pcs.PROVIDER_CUSTOMER_ID = pc.PROVIDER_CUSTOMER_ID
      inner join PROVIDER_SYSTEM       ps  on pc.PROVIDER_ID           = ps.PROVIDER_ID
      inner join PROVIDER_SERVICE_TYPE pst on ps.PROVIDER_SYSTEM_ID    = pst.PROVIDER_SYSTEM_ID
      inner join CUSTOMER_UNIT         cu  on pc.CUSTOMER_ID           = cu.CUSTOMER_ID
      where pst.PROVIDER_SERVICE_TYPE_ID = @ProviderServiceTypeId and
            cu.CUSTOMER_UNIT_ID          = @CustomerUnitId

      /* Get the rows affected and the error code for the previous statement.
         Error checking MUST be done this way since any single statement executed
         will affect both of the global functions, @@RowCount and @@Error. */
      select @RowsAffected = @@RowCount, @ErrorCode = @@Error

      /* If there was an error... */
      if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

         /* Rollback the transaction. */
         rollback transaction

         /* Return the failure. */
         return 01

      end

   end

   /* Update a row in the provider customer service table. */
   update PROVIDER_CUSTOMER_SERVICE_FINANCIAL
   set [PROVIDER_CUSTOMER_SERVICE_ID]             = @ProviderCustomerServiceId,
       [PROVIDER_SERVICE_TYPE_ID]                 = @ProviderServiceTypeId,
       [CUSTOMER_UNIT_ID]                         = @CustomerUnitId,
       [PROVIDER_CUSTOMER_SERVICE_AMOUNT]         = @ProviderCustomerServiceAmount
   where [PROVIDER_CUSTOMER_SERVICE_FINANCIAL_ID] = @ProviderCustomerServiceFinancialId

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If @LogTransaction = 01 then check if log entry exists */
   if ( @LogTransaction = 01 ) begin

      declare @InterfaceId integer

      declare INTERFACE_CURSOR cursor for
      select jmiet.INTERFACE_ID
      from JOIN_MAPPING_INTERFACE_ENTITY_TYPE jmiet,
           MAPPING_INTERFACE mi,
           PROVIDER_SYSTEM ps,
           PROVIDER_SERVICE_TYPE pst,
           PROVIDER_CUSTOMER_SERVICE_FINANCIAL pcsf
      where jmiet.INTERFACE_ID = mi.INTERFACE_ID
        and mi.PROVIDER_ID = ps.PROVIDER_ID
        and ps.PROVIDER_SYSTEM_ID = pst.PROVIDER_SYSTEM_ID
        and pst.PROVIDER_SERVICE_TYPE_ID = pcsf.PROVIDER_SERVICE_TYPE_ID
        and pcsf.PROVIDER_CUSTOMER_SERVICE_FINANCIAL_ID = @ProviderCustomerServiceFinancialId
        and jmiet.ENTITY_TYPE_ID = 14
        and jmiet.LOG_TRANSACTION = 1

      /* If there was an error... */
      if ( @@Error <> 00 ) begin

         /* Rollback the transaction. */
         rollback transaction

         /* Return the failure. */
         return 01

      end

      open INTERFACE_CURSOR

      /* If there was an error... */
      if ( @@Error <> 00 ) begin

         /* Rollback the transaction. */
         rollback transaction

         /* Return the failure. */
         return 01

      end

      fetch next from INTERFACE_CURSOR into @InterfaceId

      while ( @@fetch_status = 0 ) begin

         if not exists ( select *
                         from TRANSACTION_LOG
                         where ENTITY_ID      = @ProviderCustomerServiceFinancialId and
                               ENTITY_TYPE_ID = 14                                  and
                               INTERFACE_ID = @InterfaceId ) begin

            /* If there was an error... */
            if ( @@Error <> 00 ) begin

               /* Rollback the transaction. */
               rollback transaction

               /* Return the failure. */
               return 01

            end

            /* Insert into TRANSACTION_LOG using spInsertTransactionLog */
            execute @ReturnCode = spInsertTransactionLog @InterfaceId,
                                                         @ProviderCustomerServiceFinancialId,
                                                         14, 'U', 00, 00

            /* If there was an error... */
            if ( @ReturnCode <> 00 ) begin

               /* Return the failure. */
               return @ReturnCode

            end

         end

         fetch next from INTERFACE_CURSOR into @InterfaceId

      end

      close INTERFACE_CURSOR

      deallocate INTERFACE_CURSOR

      /* If there was an error... */
      if ( @@Error <> 00 ) begin

         /* Rollback the transaction. */
         rollback transaction

         /* Return the failure. */
         return 01

      end

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spUpdateProviderCustomerServiceSchedule' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spUpdateProviderCustomerServiceSchedule

   go

create procedure spUpdateProviderCustomerServiceSchedule( @ProviderCustomerServiceScheduleId   integer,
                                                          @ProviderCustomerServiceId           integer,
                                                          @ProviderServiceTypeId               integer,
                                                          @CustomerUnitId                      integer,
                                                          @ProviderCustomerServiceScheduleDate datetime,
                                                          @ComServiceId                        integer,
                                                          @WorkOrderNumber                     varchar(50),
                                                          @LogTransaction                      integer = 01 ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement    */
   declare @RowsAffected integer /* Number of rows affected by the previously executed statement  */
   declare @Transactions integer /* Number of active transactions at the start of this procedure  */
   declare @ReturnCode   integer /* Result code returned by the execution of the stored procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* If the provider customer service identifier was not passed... */
   if (@ProviderCustomerServiceId is null ) begin

      /* Since this parameter is not required, we can used the service type
         and customer unit identifiers to find the value in the database. */
      select @ProviderCustomerServiceId = PROVIDER_CUSTOMER_SERVICE_ID
      from PROVIDER_CUSTOMER_SERVICE pcs
      inner join PROVIDER_CUSTOMER     pc  on pcs.PROVIDER_CUSTOMER_ID = pc.PROVIDER_CUSTOMER_ID
      inner join PROVIDER_SYSTEM       ps  on pc.PROVIDER_ID           = ps.PROVIDER_ID
      inner join PROVIDER_SERVICE_TYPE pst on ps.PROVIDER_SYSTEM_ID    = pst.PROVIDER_SYSTEM_ID
      inner join CUSTOMER_UNIT         cu  on pc.CUSTOMER_ID           = cu.CUSTOMER_ID
      where pst.PROVIDER_SERVICE_TYPE_ID = @ProviderServiceTypeId and
            cu.CUSTOMER_UNIT_ID          = @CustomerUnitId

      /* Get the rows affected and the error code for the previous statement.
         Error checking MUST be done this way since any single statement executed
         will affect both of the global functions, @@RowCount and @@Error. */
      select @RowsAffected = @@RowCount, @ErrorCode = @@Error

      /* If there was an error... */
      if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

         /* Rollback the transaction. */
         rollback transaction

         /* Return the failure. */
         return 01

      end

   end

   /* Update a row in the provider customer service table. */
   update PROVIDER_CUSTOMER_SERVICE_SCHEDULE
   set [PROVIDER_CUSTOMER_SERVICE_ID]            = @ProviderCustomerServiceId,
       [PROVIDER_SERVICE_TYPE_ID]                = @ProviderServiceTypeId,
       [CUSTOMER_UNIT_ID]                        = @CustomerUnitId,
       [PROVIDER_CUSTOMER_SERVICE_SCHEDULE_DATE] = @ProviderCustomerServiceScheduleDate,
       [COM_SERVICE_ID]                          = @ComServiceId,
       [WORK_ORDER_NUMBER]                       = @WorkOrderNumber
   where [PROVIDER_CUSTOMER_SERVICE_SCHEDULE_ID] = @ProviderCustomerServiceScheduleId

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If @LogTransaction = 01 then check if log entry exists */
   if ( @LogTransaction = 01 ) begin

      declare @InterfaceId integer

      declare INTERFACE_CURSOR cursor for
      select jmiet.INTERFACE_ID
      from JOIN_MAPPING_INTERFACE_ENTITY_TYPE jmiet,
           MAPPING_INTERFACE mi,
           PROVIDER_SYSTEM ps,
           PROVIDER_SERVICE_TYPE pst,
           PROVIDER_CUSTOMER_SERVICE_SCHEDULE pcss
      where jmiet.INTERFACE_ID = mi.INTERFACE_ID
        and mi.PROVIDER_ID = ps.PROVIDER_ID
        and ps.PROVIDER_SYSTEM_ID = pst.PROVIDER_SYSTEM_ID
        and pst.PROVIDER_SERVICE_TYPE_ID = pcss.PROVIDER_SERVICE_TYPE_ID
        and pcss.PROVIDER_CUSTOMER_SERVICE_SCHEDULE_ID = @ProviderCustomerServiceScheduleId
        and jmiet.ENTITY_TYPE_ID = 12
        and jmiet.LOG_TRANSACTION = 1

      /* If there was an error... */
      if ( @@Error <> 00 ) begin

         /* Rollback the transaction. */
         rollback transaction

         /* Return the failure. */
         return 01

      end

      open INTERFACE_CURSOR

      /* If there was an error... */
      if ( @@Error <> 00 ) begin

         /* Rollback the transaction. */
         rollback transaction

         /* Return the failure. */
         return 01

      end

      fetch next from INTERFACE_CURSOR into @InterfaceId

      while ( @@fetch_status = 0 ) begin

         if not exists ( select *
                         from TRANSACTION_LOG
                         where ENTITY_ID      = @ProviderCustomerServiceScheduleId and
                               ENTITY_TYPE_ID = 12                                 and
                               INTERFACE_ID = @InterfaceId ) begin

            /* If there was an error... */
            if ( @@Error <> 00 ) begin

               /* Rollback the transaction. */
               rollback transaction

               /* Return the failure. */
               return 01

            end

            /* Insert into TRANSACTION_LOG using spInsertTransactionLog */
            execute @ReturnCode = spInsertTransactionLog @InterfaceId,
                                                         @ProviderCustomerServiceScheduleId,
                                                         12, 'U', 00, 00

            /* If there was an error... */
            if ( @ReturnCode <> 00 ) begin

               /* Return the failure. */
               return @ReturnCode

            end

         end

         fetch next from INTERFACE_CURSOR into @InterfaceId

      end


      close INTERFACE_CURSOR

      deallocate INTERFACE_CURSOR

      /* If there was an error... */
      if ( @@Error <> 00 ) begin

         /* Rollback the transaction. */
         rollback transaction

         /* Return the failure. */
         return 01

      end

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spUpdateProviderGroup' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spUpdateProviderGroup

   go

create procedure spUpdateProviderGroup( @ProviderGroupId     integer,
                                        @ProviderGroupTypeId integer,
                                        @ProviderGroupName   varchar(50) ) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   execute @ReturnCode = spUpdateMemberGroup @ProviderGroupId,
                                             @ProviderGroupTypeId,
                                             @ProviderGroupName

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin


      /* Return the failure. */
      return @ReturnCode

   end

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spUpdateProviderGroupType' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spUpdateProviderGroupType

   go

create procedure spUpdateProviderGroupType( @ProviderGroupTypeId   integer,
                                            @ProviderId            integer,
                                            @ProviderGroupTypeName varchar(50) ) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   -- new procedure
   execute @ReturnCode = spUpdateMemberGroupType @ProviderGroupTypeId,
                                                 @ProviderGroupTypeName,
                                                 @ProviderId

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spUpdateProviderSystemContactInfo' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spUpdateProviderSystemContactInfo

   go

create procedure spUpdateProviderSystemContactInfo( @ContactId        integer,
                                                    @ProviderSystemId integer,
                                                    @ContactTypeId    integer,
                                                    @ContactInfo      varchar(255) ) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   execute @ReturnCode = spUpdateContact @ContactId,
                                         @ContactTypeId,
                                         @ContactInfo

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spUpdateProviderUser' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spUpdateProviderUser

   go

create procedure spUpdateProviderUser( @ProviderUserId  integer,
                                       @ProviderId      integer,
                                       @UserName        varchar(50),
                                       @Password        varchar(15),
                                       @FirstName       varchar(25),
                                       @LastName        varchar(25),
                                       @Email           varchar(50),
                                       @LastLogin       datetime,
                                       @SecurityGroupId integer ) as

   declare @Transactions       integer /* Number of active transactions at the start of this procedure */
   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   execute @ReturnCode = spUpdateMemberUser  @ProviderUserId,
                                             @ProviderId,
                                             @UserName,
                                             @Password,
                                             @FirstName,
                                             @LastName,
                                             @LastLogin,
                                             @Email

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   if @SecurityGroupId > 00 begin
      execute @ReturnCode = spDeleteJoinMemberUserSecurityGroup @ProviderUserId

      /* If there was an error... */
      if ( @ReturnCode <> 00 ) begin

         /* Return the failure. */
         return @ReturnCode

      end

      execute @ReturnCode = spInsertJoinMemberUserSecurityGroup @ProviderUserId,
                                                                @SecurityGroupId
      /* If there was an error... */
      if ( @ReturnCode <> 00 ) begin

         /* Return the failure. */
         return @ReturnCode

      end

   end

   /* If there were no active transactions when this stored procedure was
      executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spUpdateProviderUserContactInfo' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spUpdateProviderUserContactInfo

   go

create procedure spUpdateProviderUserContactInfo( @ContactId        integer,
                                                  @ProviderUserId   integer,
                                                  @ContactTypeId    integer,
                                                  @ContactInfo      varchar(255) ) as

   declare @ReturnCode         integer /* Result code returned by the execution of the stored procedure */

   execute @ReturnCode = spUpdateContact @ContactId,
                                         @ContactTypeId,
                                         @ContactInfo

   /* If there was an error... */
   if ( @ReturnCode <> 00 ) begin

      /* Return the failure. */
      return @ReturnCode

   end

   return 00

   go

/* If the procedure exists in the database... */
if ( Exists( select name
             from sysobjects
             where name = 'spUpdateTransactionLog' and xtype = 'P' ) )

   /* Remove it. */
   drop procedure spUpdateTransactionLog

   go

create procedure spUpdateTransactionLog( @TransactionLogId integer,
                                         @InterfaceId      integer,
                                         @EntityId         integer,
                                         @EntityTypeId     integer,
                                         @ChangeAction     char(1),
                                         @Transmitted      integer ) as

   declare @ErrorCode    integer /* Error code returned by the execution of the last statement   */
   declare @RowsAffected integer /* Number of rows affected by the previously executed statement */
   declare @Transactions integer /* Number of active transactions at the start of this procedure */

   /* Get the number of active transactions at the start of this procedure. */
   set @Transactions = @@TranCount

   /* If there were no active transactions when this stored procedure was executed... */
   if ( @Transactions = 00 ) begin

      /* Start the transaction. */
      begin transaction

   end

   /* Update a row in the provider customer service table. */
   update TRANSACTION_LOG
   set
      [INTERFACE_ID] = @InterfaceId,
      [ENTITY_ID] = @EntityId,
      [ENTITY_TYPE_ID] = @EntityTypeId,
      [CHANGE_ACTION] = @ChangeAction,
      [TRANSMITTED] = @Transmitted
   where
      [TRANSACTION_LOG_ID] = @TransactionLogId

   /* Get the rows affected and the error code for the previous statement.
      Error checking MUST be done this way since any single statement executed
      will affect both of the global functions, @@RowCount and @@Error. */
   select @RowsAffected = @@RowCount, @ErrorCode = @@Error

   /* If there was an error... */
   if ( ( @ErrorCode <> 00 ) or ( @RowsAffected = 00 ) ) begin

      /* Rollback the transaction. */
      rollback transaction

      /* Return the failure. */
      return 01

   end

   /* If there were no active transactions when this stored procedure was executed... */
   if ( @Transactions = 00 ) begin

      /* Commit the transaction. */
      commit transaction

   end

   /* Return the success. */
   return 00

   go

